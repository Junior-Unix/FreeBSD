                                FreeBSD Handbook

  Projeto de Documentac,ao do FreeBSD

   Revisao: 53984

   Copyright (c) 1995-2020 The FreeBSD Documentation Project

   Copyright

   Redistribution and use in source (XML DocBook) and 'compiled' forms (XML,
   HTML, PDF, PostScript, RTF and so forth) with or without modification, are
   permitted provided that the following conditions are met:

    1. Redistributions of source code (XML DocBook) must retain the above
       copyright notice, this list of conditions and the following disclaimer
       as the first lines of this file unmodified.

    2. Redistributions in compiled form (transformed to other DTDs, converted
       to PDF, PostScript, RTF and other formats) must reproduce the above
       copyright notice, this list of conditions and the following disclaimer
       in the documentation and/or other materials provided with the
       distribution.

  Importante:

   THIS DOCUMENTATION IS PROVIDED BY THE FREEBSD DOCUMENTATION PROJECT "AS
   IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE FREEBSD DOCUMENTATION
   PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   DOCUMENTATION, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   FreeBSD is a registered trademark of the FreeBSD Foundation.

   3Com and HomeConnect are registered trademarks of 3Com Corporation.

   3ware is a registered trademark of 3ware Inc.

   ARM is a registered trademark of ARM Limited.

   Adaptec is a registered trademark of Adaptec, Inc.

   Adobe, Acrobat, Acrobat Reader, Flash and PostScript are either registered
   trademarks or trademarks of Adobe Systems Incorporated in the United
   States and/or other countries.

   Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS,
   Quicktime, and TrueType are trademarks of Apple Inc., registered in the
   U.S. and other countries.

   Android is a trademark of Google Inc.

   Heidelberg, Helvetica, Palatino, and Times Roman are either registered
   trademarks or trademarks of Heidelberger Druckmaschinen AG in the U.S. and
   other countries.

   IBM, AIX, OS/2, PowerPC, PS/2, S/390, and ThinkPad are trademarks of
   International Business Machines Corporation in the United States, other
   countries, or both.

   IEEE, POSIX, and 802 are registered trademarks of Institute of Electrical
   and Electronics Engineers, Inc. in the United States.

   Intel, Celeron, Centrino, Core, EtherExpress, i386, i486, Itanium,
   Pentium, and Xeon are trademarks or registered trademarks of Intel
   Corporation or its subsidiaries in the United States and other countries.

   Intuit and Quicken are registered trademarks and/or registered service
   marks of Intuit Inc., or one of its subsidiaries, in the United States and
   other countries.

   Linux is a registered trademark of Linus Torvalds.

   LSI Logic, AcceleRAID, eXtremeRAID, MegaRAID and Mylex are trademarks or
   registered trademarks of LSI Logic Corp.

   Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media and
   Windows NT are either registered trademarks or trademarks of Microsoft
   Corporation in the United States and/or other countries.

   Motif, OSF/1, and UNIX are registered trademarks and IT DialTone and The
   Open Group are trademarks of The Open Group in the United States and other
   countries.

   Oracle is a registered trademark of Oracle Corporation.

   RealNetworks, RealPlayer, and RealAudio are the registered trademarks of
   RealNetworks, Inc.

   Red Hat, RPM, are trademarks or registered trademarks of Red Hat, Inc. in
   the United States and other countries.

   Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JRE, JSP, JVM,
   Netra, OpenJDK, Solaris, StarOffice, SunOS and VirtualBox are trademarks
   or registered trademarks of Sun Microsystems, Inc. in the United States
   and other countries.

   MATLAB is a registered trademark of The MathWorks, Inc.

   SpeedTouch is a trademark of Thomson.

   VMware is a trademark of VMware, Inc.

   Mathematica is a registered trademark of Wolfram Research, Inc.

   XFree86 is a trademark of The XFree86 Project, Inc.

   Ogg Vorbis and Xiph.Org are trademarks of Xiph.Org.

   Many of the designations used by manufacturers and sellers to distinguish
   their products are claimed as trademarks. Where those designations appear
   in this document, and the FreeBSD Project was aware of the trademark
   claim, the designations have been followed by the "(TM)" or the "(R)"
   symbol.

   2020-03-15 16:03:31 por dbaio.
   Resumo

   Bem vindo ao FreeBSD! Este manual cobre a instalac,ao e o uso diario do
   FreeBSD 12.1-RELEASE e do FreeBSD 11.3-RELEASE. Este livro e o resultado
   do trabalho continuo de muitas pessoas. Algumas sec,oes podem estar
   desatualizadas. Os interessados em ajudar a atualizar e expandir este
   documento devem enviar e-mails para a lista de discussao do projeto de
   documentac,ao do FreeBSD.

   A ultima versao deste livro esta disponivel no site do FreeBSD. Versoes
   anteriores podem ser obtidas em https://docs.FreeBSD.org/doc/. O livro
   pode ser baixado em uma variedade de formatos e opc,oes de compressao do
   servidor FTP do FreeBSD ou de um dos inumeros sites espelho. Copias
   impressas podem ser adquiridas da FreeBSD Mall. As pesquisas podem ser
   realizadas no manual e em outros documentos na pagina de busca.

   [ Documento HTML em partes / Documento HTML completo ]

     ----------------------------------------------------------------------

   Indice

   Prefacio

   I. Primeiros Passos

                1. Introduc,ao

                             1.1. Sinopse

                             1.2. Bem vindo ao FreeBSD!

                             1.3. Sobre o Projeto FreeBSD

                2. Instalando o FreeBSD

                             2.1. Sinopse

                             2.2. Requisitos minimos de hardware

                             2.3. Tarefas de Pre-instalac,ao

                             2.4. Iniciando a instalac,ao

                             2.5. Usando o bsdinstall

                             2.6. Alocando o espac,o em disco

                             2.7. Fazendo o download dos arquivos de
                             distribuic,ao

                             2.8. Pos-instalac,ao

                             2.9. Soluc,ao de problemas

                             2.10. Usando o Live CD

                3. Fundamentos do FreeBSD

                             3.1. Sinopse

                             3.2. Consoles e Terminais Virtuais

                             3.3. Usuarios e Gerenciamento Basico de Contas

                             3.4. Permissoes

                             3.5. Estrutura de Diretorios

                             3.6. Organizac,ao dos Discos

                             3.7. Montando e Desmontando Sistemas de Arquivos

                             3.8. Processos e Daemons

                             3.9. Shells

                             3.10. Editores de Texto

                             3.11. Dispositivos e nos de dispositivos

                             3.12. Paginas de Manual

                4. Instalando Aplicativos: Pacotes e Ports

                             4.1. Sinopse

                             4.2. Visao geral sobre a Instalac,ao de Software

                             4.3. Encontrando Software

                             4.4. Usando o pkg para o gerenciamento de
                             pacotes binarios

                             4.5. Usando a Colec,ao de Ports

                             4.6. Compilando Pacotes com o Poudriere

                             4.7. Considerac,oes pos-instalac,ao

                             4.8. Lidando com ports quebrados

                5. O sistema X Window

                             5.1. Sinopse

                             5.2. Terminologia

                             5.3. Instalando o Xorg

                             5.4. Configurac,ao do Xorg

                             5.5. Usando fontes no Xorg

                             5.6. O Gerenciador de Display X

                             5.7. Ambientes de desktop

                             5.8. Instalando o Compiz Fusion

                             5.9. Soluc,ao de problemas

   II. Tarefas comuns

                6. Aplicac,oes de Desktop

                             6.1. Sinopse

                             6.2. Navegadores

                             6.3. Produtividade

                             6.4. Visualizadores de Documentos

                             6.5. Financ,as

                7. Multimidia

                             7.1. Sinopse

                             7.2. Configurando a Placa de Som

                             7.3. Audio MP3

                             7.4. Reproduc,ao de Video

                             7.5. Placas de TV

                             7.6. MythTV

                             7.7. Scanners de Imagem

                8. Configurando o kernel do FreeBSD

                             8.1. Sinopse

                             8.2. Por que compilar um kernel personalizado?

                             8.3. Encontrando o hardware do sistema

                             8.4. O Arquivo de Configurac,ao

                             8.5. Criando e Instalando um Kernel Customizado

                             8.6. Se algo der errado

                9. Impressao

                             9.1. Inicio Rapido

                             9.2. Conexoes de Impressora

                             9.3. Linguagens de Descric,ao de Pagina Comuns

                             9.4. Impressao Direta

                             9.5. LPD (Daemon de impressora de linha)

                             9.6. Outros sistemas de impressao

                10. Compatibilidade binaria com o Linux(R)

                             10.1. Sinopse

                             10.2. Configurando a compatibilidade binaria com
                             o Linux(R)

                             10.3. Topicos Avanc,ados

   III. Administrac,ao do Sistema

                11. Configurac,ao e Ajuste

                             11.1. Sinopse

                             11.2. Inicializac,ao de Servic,os

                             11.3. Configurando o cron(8)

                             11.4. Gerenciando Servic,os no FreeBSD

                             11.5. Configurando Placas de Interface de Rede

                             11.6. Hosts Virtuais

                             11.7. Configurando o log do sistema

                             11.8. Arquivos de Configurac,ao

                             11.9. Efetuando ajustes com o sysctl(8)

                             11.10. Otimizac,ao de Discos

                             11.11. Ajustando os Limites do Kernel

                             11.12. Adicionando Espac,o de Swap

                             11.13. Gerenciamento de energia e recursos

                12. O processo de inicializac,ao do FreeBSD

                             12.1. Sinopse

                             12.2. Processo de Inicializac,ao do FreeBSD

                             12.3. Configurando telas iniciais de
                             inicializac,ao

                             12.4. Sugestoes de dispositivos

                             12.5. Sequencia de Desligamento

                13. Seguranc,a

                             13.1. Sinopse

                             13.2. Introduc,ao

                             13.3. Senhas de Uso Unico

                             13.4. TCP Wrapper

                             13.5. Kerberos

                             13.6. OpenSSL

                             13.7. VPN Sobre IPsec

                             13.8. OpenSSH

                             13.9. Listas de Controle de Acesso

                             13.10. Monitorando Problemas de Seguranc,a de
                             Terceiros

                             13.11. Avisos de Seguranc,a do FreeBSD

                             13.12. Auditoria de Processo

                             13.13. Limites de Recursos

                             13.14. Administrac,ao Compartilhada com Sudo

                14. Jails

                             14.1. Sinopse

                             14.2. Termos Relacionados `a Jails

                             14.3. Criando e Controlando Jails

                             14.4. Tuning e Administrac,ao

                             14.5. Atualizando Multiplas Jails

                             14.6. Gerenciando Jails com o ezjail

                15. Controle de acesso obrigatorio

                             15.1. Sinopse

                             15.2. Termos chave

                             15.3. Entendendo os rotulos MAC

                             15.4. Planejando a configurac,ao de seguranc,a

                             15.5. Politicas MAC Disponiveis

                             15.6. Bloqueio do Usuario

                             15.7. Nagios em Jail MAC

                             15.8. Soluc,ao de problemas do framework MAC

                16. Auditoria de Evento de Seguranc,a

                             16.1. Sinopse

                             16.2. Termos chave

                             16.3. Configurac,ao de Auditoria

                             16.4. Trabalhando com Trilhas de Auditoria

                17. Armazenamento

                             17.1. Sinopse

                             17.2. Adicionando Discos

                             17.3. Redimensionando e Ampliando Discos

                             17.4. Dispositivos de Armazenamento USB

                             17.5. Criando e Usando Midia em CD

                             17.6. Criando e Usando Midia de DVD

                             17.7. Criando e Usando Disquetes

                             17.8. Noc,oes Basicas de Backup

                             17.9. Discos de Memoria

                             17.10. Snapshots de Sistemas de Arquivos

                             17.11. Cotas de Disco

                             17.12. Criptografando Partic,oes de Disco

                             17.13. Criptografando Swap

                             17.14. Alta Disponibilidade de Armazenamento
                             (HAST)

                18. GEOM: Framework de Transformac,ao de Disco Modular

                             18.1. Sinopse

                             18.2. RAID0 - Striping

                             18.3. RAID1 - Espelhamento

                             18.4. RAID3 - Distribuic,ao em Nivel de Byte com
                             Paridade Dedicada

                             18.5. Dispositivos RAID por Software

                             18.6. GEOM Network Gate

                             18.7. Rotulando Dispositivos de Disco

                             18.8. Journaling UFS atraves do GEOM

                19. O sistema de arquivos Z (ZFS)

                             19.1. O que torna o ZFS diferente

                             19.2. Guia de Inicio Rapido

                             19.3. Administrac,ao zpool

                             19.4. Administrac,ao do zfs

                             19.5. Administrac,ao Delegada

                             19.6. Topicos Avanc,ados

                             19.7. Recursos adicionais

                             19.8. Recursos e terminologia do ZFS

                20. Outros Sistemas de Arquivos

                             20.1. Sinopse

                             20.2. Sistemas de arquivos do Linux(R)

                21. Virtualizac,ao

                             21.1. Sinopse

                             21.2. FreeBSD como Sistema Operacional Convidado
                             no Parallels para Mac OS(R) X

                             21.3. FreeBSD como sistema convidado no Virtual
                             PC para Windows(R)

                             21.4. FreeBSD como Sistema Operacional Convidado
                             no VMware Fusion para Mac OS(R)

                             21.5. FreeBSD como Sistema Operacional Convidado
                             no VirtualBox(TM)

                             21.6. FreeBSD como Host com VirtualBox(TM)

                             21.7. FreeBSD como um Host bhyve

                             21.8. FreeBSD como Host Xen(TM)

                22. Localizac,ao - Uso e Configurac,ao do i18n/L10n

                             22.1. Sinopse

                             22.2. Usando Localizac,ao

                             22.3. Encontrando Aplicac,oes i18n

                             22.4. Configurac,ao de Localizac,ao para Idiomas
                             Especificos

                23. Atualizac,ao e Upgrade do FreeBSD

                             23.1. Sinopse

                             23.2. Atualizac,ao do FreeBSD

                             23.3. Atualizando o Conjunto de Documentac,ao

                             23.4. Acompanhando um ramo de desenvolvimento

                             23.5. Atualizando o FreeBSD a partir do codigo
                             fonte

                             23.6. Atualizac,ao de varias maquinas

                24. DTrace

                             24.1. Sinopse

                             24.2. Diferenc,as de Implementac,ao

                             24.3. Ativando o Suporte do DTrace

                             24.4. Usando o DTrace

                25. Modo de dispositivo USB/USB OTG

                             25.1. Sinopse

                             25.2. Portas Seriais Virtuais USB

                             25.3. Interfaces de rede do modo de dispositivo
                             USB

                             25.4. Dispositivo de armazenamento virtual USB

   IV. Comunicac,ao de rede

                26. Comunicac,oes Seriais

                             26.1. Sinopse

                             26.2. Terminologia serial e hardware

                             26.3. Terminais

                             26.4. Servic,o Dial-in

                             26.5. Servic,o de Dial-in

                             26.6. Configurando o Console Serial

                27. PPP

                             27.1. Sinopse

                             27.2. Configurando o PPP

                             27.3. Soluc,ao de problemas de conexoes PPP

                             27.4. Usando o PPP sobre Ethernet (PPPoE)

                             27.5. Usando PPP sobre ATM (PPPoA)

                28. Correio Eletronico

                             28.1. Sinopse

                             28.2. Componentes de Email

                             28.3. Arquivos de Configurac,ao do Sendmail

                             28.4. Alterando o Mail Transfer Agent

                             28.5. Soluc,ao de problemas

                             28.6. Topicos Avanc,ados

                             28.7. Configurando Apenas Envio

                             28.8. Usando Email com uma Conexao Dialup

                             28.9. Autenticac,ao SMTP

                             28.10. Mail User Agents

                             28.11. Usando o fetchmail

                             28.12. Usando o procmail

                29. Servidores de Rede

                             29.1. Sinopse

                             29.2. O super-servidor inetd

                             29.3. Network File System (NFS)

                             29.4. Sistema de Informac,ao de Rede (NIS)

                             29.5. Protocolo leve de acesso de diretorio (
                             LDAP )

                             29.6. Protocolo de configurac,ao dinamica de
                             hosts (DHCP)

                             29.7. Sistema de Nomes de Dominio (DNS)

                             29.8. Servidor HTTP Apache

                             29.9. Protocolo de Transferencia de Arquivos
                             (FTP)

                             29.10. Servic,os de arquivos e impressao para
                             clientes Microsoft(R) Windows(R) Clients (Samba)

                             29.11. Sincronizac,ao de Relogio com NTP

                             29.12. Inicializador iSCSI e Configurac,ao Alvo

                30. Firewalls

                             30.1. Sinopse

                             30.2. Conceitos de Firewall

                             30.3. PF

                             30.4. IPFW

                             30.5. IPFILTER (IPF)

                             30.6. Blacklistd

                31. Rede Avanc,ada

                             31.1. Sinopse

                             31.2. Gateways e Rotas

                             31.3. Rede sem fio

                             31.4. USB Tethering

                             31.5. Bluetooth

                             31.6. Bridging

                             31.7. Agregac,ao de links e failover

                             31.8. Operac,ao Diskless com PXE

                             31.9. IPv6

                             31.10. Protocolo Comum de Redundancia de
                             Enderec,os (CARP)

                             31.11. VLANs

   V. Apendices

                A. Obtendo o FreeBSD

                             A.1. CD and DVD Sets

                             A.2. Sites de FTP

                             A.3. Usando o Subversion

                             A.4. Usando o rsync

                B. Bibliografia

                             B.1. Livros especificos para o FreeBSD

                             B.2. Guias de usuarios

                             B.3. Guias de Administradores

                             B.4. Guias de programadores

                             B.5. Internals do sistema operacional

                             B.6. Referencias de seguranc,a

                             B.7. Referencias de Hardware

                             B.8. Historia do UNIX(R)

                             B.9. Periodicos, Jornais e Revistas

                C. Recursos na Internet

                             C.1. Websites

                             C.2. Listas de Discussao

                             C.3. Grupos de Noticias Usenet

                             C.4. Espelhos Oficiais

                D. Chaves OpenPGP

                             D.1. Administradores

   Glossario do FreeBSD

   Indice Remissivo

   Lista de Figuras

   2.1. Menu do FreeBSD Boot Loader

   2.2. Menu de Opc,oes de Inicializac,ao do FreeBSD

   2.3. Menu de boas-vindas

   2.4. Carregamento de Keymap

   2.5. Menu de Selec,ao do Keymap

   2.6. Menu de Teste do Keymap

   2.7. Configurando o nome do host

   2.8. Selecionando Componentes para Instalar

   2.9. Instalando a partir da rede

   2.10. Escolhendo um Site Espelho

   2.11. Opc,oes de Particionamento

   2.12. Selecionando a partir de varios discos

   2.13. Selecionando todo o disco ou partic,ao

   2.14. Confirmac,ao

   2.15. Selecionar Esquema de Particionamento

   2.16. Revise as partic,oes criadas

   2.17. Confirmac,ao final

   2.18. Criar partic,oes manualmente

   2.19. Criar partic,oes manualmente

   2.20. Criar partic,oes manualmente

   2.21. Menu de particionamento do ZFS

   2.22. Tipo de pool ZFS

   2.23. Selec,ao de disco

   2.24. Selec,ao invalida

   2.25. Analisando um disco

   2.26. Senha de criptografia de disco

   2.27. Ultima chance

   2.28. Fazendo o download dos arquivos de distribuic,ao

   2.29. Verificando arquivos de distribuic,ao

   2.30. Extraindo arquivos de distribuic,ao

   2.31. Definindo a Senha de root

   2.32. Escolha uma interface de rede

   2.33. Buscando por pontos de acesso sem fio

   2.34. Escolhendo uma rede sem fio

   2.35. Configurac,ao WPA2

   2.36. Escolha a rede IPv4

   2.37. Escolha a configurac,ao IPv4 DHCP

   2.38. Configurac,ao IPv4 estatica

   2.39. Escolha a rede IPv6

   2.40. Escolha a configurac,ao do SLAAC do IPv6

   2.41. Configurac,ao Estatica do IPv6

   2.42. Configurac,ao do DNS

   2.43. Selecione uma regiao

   2.44. Selecione um pais

   2.45. Selecione um fuso horario

   2.46. Confirme o fuso horario

   2.47. Selecionar Data

   2.48. Selecionar Hora

   2.49. Selecionando Servic,os Adicionais para Ativar

   2.50. Selecionando Opc,oes de Seguranc,a (Hardening)

   2.51. Adicione contas de usuario

   2.52. Insira as informac,oes do usuario

   2.53. Saia do gerenciamento de usuarios e grupos

   2.54. Configurac,ao final

   2.55. Configurac,ao manual

   2.56. Conclua a instalac,ao

   31.1. Processo de inicializac,ao PXE com o sistema de arquivos raiz
   montado por NFS

   Lista de Tabelas

   2.1. Esquemas de Particionamento

   3.1. Utilitarios para gerenciar contas de usuarios

   3.2. Permissoes UNIX(R)

   3.3. Nomes de dispositivos de disco

   3.4. Variaveis de Ambiente Comuns

   5.1. Arquivos de Configurac,ao do XDM

   7.1. Mensagens de Erros Comuns

   9.1. Saida PDLs

   12.1. Comandos Internos do Loader

   12.2. Interac,ao do Kernel durante o Boot

   13.1. Limites de Recursos de Classe de Login

   16.1. Classes de Eventos de Auditoria Padrao

   16.2. Prefixos para Classes de Eventos de Auditoria

   22.1. Idiomas Comum e Codigos de Pais

   22.2. Tipos de Terminal Definidos para Conjuntos de Caracteres

   22.3. Consoles Disponiveis pela Colec,ao de Ports

   22.4. Metodos de Entrada Disponiveis

   23.1. Versoes do FreeBSD e Caminhos do Repositorio

   26.1. RS-232C Nomes dos Sinais

   26.2. Cabo Null-Modem DB-25 para DB-25

   26.3. Cabo DB-9 para DB-9 Null-Modem

   26.4. Cabo DB-9 para DB-25 Null-Modem

   29.1. Terminologia do NIS

   29.2. Usuarios Adicionais

   29.3. Sistemas Adicionais

   29.4. Terminologia DNS

   30.1. Opc,oes Uteis do pfctl

   31.1. Flags da Tabela de Roteamento Frequentemente Observados

   31.2. Codigos de capacidade da estac,ao

   31.3. Enderec,os IPv6 reservados

   Lista de Exemplos

   2.1. Criando partic,oes tradicionais para um sistema de arquivos dividido

   3.1. Instalar um programa como superusuario

   3.2. Adicionando um usuario no FreeBSD

   3.3. Remoc,ao de contas interativas com o rmuser

   3.4. Usando o chpass como superusuario

   3.5. Usando o chpass como usuario regular

   3.6. Alterando Sua Senha

   3.7. Mudando a senha de outro usuario como superusuario

   3.8. Adicionando um grupo usando o pw(8)

   3.9. Adicionando contas de usuarios a um novo grupo usando o pw(8)

   3.10. Adicionando um novo membro a um grupo usando o pw(8)

   3.11. Usando o id(1) para determinar a associac,ao ao grupo

   3.12. Exemplo de Nomes de Disco, Slice e Partic,ao

   3.13. Modelo conceitual de um disco

   5.1. Selecione o driver de video Intel(R) em um arquivo

   5.2. Selecione o driver de video Radeon em um arquivo

   5.3. Selecione o driver de video VESA em um arquivo

   5.4. Selecione o driver de video scfb em um arquivo

   5.5. Defina a resoluc,ao de tela em um arquivo

   5.6. Configurando Manualmente as Frequencias do Monitor

   5.7. Definindo um layout de teclado

   5.8. Definindo varios layouts de teclado

   5.9. Ativando o fechamento de X pelo teclado

   5.10. Definindo o numero de botoes do mouse

   11.1. Configurac,ao do servidor de log de exemplo

   11.2. Criando um arquivo de swap

   12.1. Captura de tela do boot0

   12.2. Captura de tela do boot2

   12.3. Configurando um Console Inseguro em /etc/ttys

   13.1. Criar um Tunel Seguro para SMTP

   13.2. Acesso Seguro de um Servidor POP3

   13.3. Ignorando um Firewall

   14.1. mergemaster(8) em Jail Nao Confiavel

   14.2. mergemaster(8) em Jail Confiavel

   14.3. Executando o BIND em uma Jail

   17.1. Usando dump sobre ssh

   17.2. Usando o dump sobre ssh com o RSH configurado

   17.3. Fazendo Backup do Diretorio Atual com o tar

   17.4. Restaurando o Diretorio Atual com o tar

   17.5. Usando ls e cpio para Criar um Backup Recursivo do Diretorio Atual

   17.6. Fazendo Backup do Diretorio Atual com pax

   18.1. Rotulando Partic,oes no Disco de Inicializac,ao

   23.1. Aumentando o numero de jobs de compilac,ao

   26.1. Configurando Entradas de Terminal

   29.1. Recarregando o Arquivo de Configurac,ao do inetd

   29.2. Montando uma Exportac,ao com autofs(5)

   29.3. Exemplo de /etc/ntp.conf

   31.1. Agregac,ao LACP com um switch Cisco(R)

   31.2. Modo de Failover

   31.3. Modo de failover entre interfaces Ethernet e sem fio

                                    Prefacio

Audiencia Pretendida

   O novato no FreeBSD descobrira que a primeira sec,ao deste livro guia o
   usuario atraves do processo de instalac,ao do FreeBSD e gentilmente
   apresenta os conceitos e convenc,oes que sustentam o UNIX(R). Trabalhar
   atraves desta sec,ao exige pouco mais do que o desejo de explorar, e a
   capacidade de incorporar novos conceitos `a medida que eles sao
   introduzidos.

   Uma vez que voce chegou ate aqui, a segunda sec,ao do Handbook, muito
   maior, e uma referencia abrangente a todos os topicos de interesse para
   administradores de sistemas FreeBSD. Alguns destes capitulos podem
   recomendar que voce fac,a alguma leitura previa, e isto e destacado na
   sinopse no inicio de cada capitulo.

   Para uma lista de fontes adicionais de informac,ao, por favor veja o
   Apendice B, Bibliografia.

Mudanc,as desde a Terceira Edic,ao

   A versao online atual do Handbook representa o esforc,o cumulativo de
   muitas centenas de contribuidores nos ultimos 10 anos. A seguir estao
   algumas das mudanc,as significativas desde a publicac,ao da terceira
   edic,ao do volume em 2004:

     * Capitulo 24, DTrace foi adicionado com informac,oes sobre a poderosa
       ferramenta de analise de desempenho DTrace.

     * Capitulo 20, Outros Sistemas de Arquivos foi adicionado com
       informac,oes sobre sistemas de arquivos nao-nativos no FreeBSD, como o
       ZFS da Sun(TM).

     * Capitulo 16, Auditoria de Evento de Seguranc,a foi adicionado para
       cobrir os novos recursos de auditoria no FreeBSD e explicar seu uso.

     * Capitulo 21, Virtualizac,ao foi adicionado com informac,oes sobre a
       instalac,ao do FreeBSD em ambientes virtualizados.

     * Capitulo 2, Instalando o FreeBSD foi adicionado para cobrir a
       instalac,ao do FreeBSD usando o novo utilitario de instalac,ao,
       bsdinstall.

Mudanc,as desde a Segunda Edic,ao (2004)

   A terceira edic,ao foi o culminar de mais de dois anos de trabalho pelos
   membros dedicados do Projeto de Documentac,ao do FreeBSD. A edic,ao
   impressa cresceu a tal tamanho que foi necessario publicar como dois
   volumes separados. A seguir estao as principais mudanc,as nesta nova
   edic,ao:

     * Capitulo 11, Configurac,ao e Ajuste foi expandido com novas
       informac,oes sobre o gerenciamento de recursos e energia da ACPI, o
       utilitario de sistema cron e mais opc,oes para ajuste do kernel.

     * Capitulo 13, Seguranc,a foi expandido com novas informac,oes sobre
       redes virtuais privadas (VPNs), listas de controle de acesso (ACLs) do
       sistema de arquivos e avisos de seguranc,a.

     * Capitulo 15, Controle de acesso obrigatorio e um novo capitulo desta
       edic,ao. Ele explica o que e MAC e como esse mecanismo pode ser usado
       para proteger um sistema FreeBSD.

     * Capitulo 17, Armazenamento foi expandido com novas informac,oes sobre
       dispositivos de armazenamento USB, snapshots do sistema de arquivos,
       cotas do sistema de arquivos, arquivos e sistemas de arquivos com
       suporte de rede e partic,oes de disco criptografadas.

     * Uma sec,ao de soluc,ao de problemas foi adicionada ao Capitulo 27,
       PPP.

     * Capitulo 28, Correio Eletronico foi expandido com novas informac,oes
       sobre o uso de agentes de transporte alternativos, autenticac,ao SMTP,
       UUCP, fetchmail, procmail e outros topicos avanc,ados.

     * Capitulo 29, Servidores de Rede e novidade nesta edic,ao. Este
       capitulo inclui informac,oes sobre a configurac,ao do Servidor HTTP
       Apache, ftpd e a configurac,ao de um servidor para clientes
       Microsoft(R) Windows(R) com Samba. Algumas sec,oes do Capitulo 31,
       Rede Avanc,ada foram movidas para ca para melhorar a apresentac,ao.

     * Capitulo 31, Rede Avanc,ada foi expandido com novas informac,oes sobre
       o uso de dispositivos Bluetooth(R) com o FreeBSD, configurac,ao de
       redes sem fio e redes ATM (Asynchronous Transfer Mode).

     * Um glossario foi adicionado para fornecer um local central para as
       definic,oes de termos tecnicos utilizados ao longo do livro.

     * Uma serie de melhorias esteticas foram feitas nas tabelas e figuras ao
       longo do livro.

Mudanc,as desde a Primeira Edic,ao (2001)

   A segunda edic,ao foi o culminar de mais de dois anos de trabalho pelos
   membros dedicados do Projeto de Documentac,ao do FreeBSD. A seguir, as
   principais mudanc,as nesta edic,ao:

     * Um indice completo foi adicionado.

     * Todas as figuras ASCII foram substituidas por diagramas graficos.

     * Uma sinopse padrao foi adicionada a cada capitulo para fornecer um
       resumo rapido de quais informac,oes o capitulo contem e o que se
       espera que o leitor saiba.

     * O conteudo foi logicamente reorganizado em tres partes: "Introduc,ao",
       "Administrac,ao do Sistema" e "Apendices".

     * Capitulo 3, Fundamentos do FreeBSD foi expandido para conter
       informac,oes adicionais sobre processos, daemons e sinais.

     * Capitulo 4, Instalando Aplicativos: Pacotes e Ports foi expandido para
       conter informac,oes adicionais sobre o gerenciamento de pacotes
       binarios.

     * Capitulo 5, O sistema X Window foi completamente reescrito com enfase
       no uso de tecnologias de desktop modernas como KDE e GNOME sobre o
       XFree86(TM) 4.X.

     * Capitulo 12, O processo de inicializac,ao do FreeBSD foi expandido.

     * Capitulo 17, Armazenamento foi escrito a partir do que costumava ser
       dois capitulos separados em "Discos" e "Backups". Sentimos que os
       topicos sao mais faceis de compreender quando apresentados como um
       unico capitulo. Uma sec,ao sobre RAID (hardware e software) tambem foi
       adicionada.

     * Capitulo 26, Comunicac,oes Seriais foi completamente reorganizado e
       atualizado para o FreeBSD 4.X/5.X.

     * Capitulo 27, PPP foi substancialmente atualizado.

     * Muitas novas sec,oes foram adicionadas ao Capitulo 31, Rede Avanc,ada.

     * Capitulo 28, Correio Eletronico foi expandido para incluir mais
       informac,oes sobre a configurac,ao do sendmail.

     * Capitulo 10, Compatibilidade binaria com o Linux(R) foi expandido para
       incluir informac,oes sobre como instalar o Oracle(R) e o SAP(R)
       R/3(R).

     * Os novos topicos a seguir sao abordados nesta segunda edic,ao:

          * Capitulo 11, Configurac,ao e Ajuste.

          * Capitulo 7, Multimidia.

Organizac,ao deste Livro

   Este livro e dividido em cinco sec,oes logicamente distintas. A primeira
   sec,ao, Introduc,ao, cobre a instalac,ao e o uso basico do FreeBSD.
   Espera-se que o leitor siga estes capitulos em sequencia, possivelmente
   ignorando capitulos que abordam topicos familiares. A segunda sec,ao,
   Tarefas Comuns, cobre alguns dos recursos mais usados do FreeBSD. Esta
   sec,ao e todas as sec,oes subsequentes podem ser lidas fora de ordem. Cada
   capitulo comec,a com uma sinopse sucinta que descreve o que o capitulo
   cobre e o que se espera que o leitor ja conhec,a. Isso permite que o
   leitor casual pule para encontrar capitulos de interesse. A terceira
   sec,ao, Administrac,ao do Sistema, cobre topicos de administrac,ao. A
   quarta sec,ao, Comunicac,ao de Rede, aborda topicos sobre redes e
   servidores. A quinta sec,ao contem apendices de informac,oes de
   referencia.

   Capitulo 1, Introduc,ao

           Introduz o FreeBSD para um novo usuario. Descreve a historia do
           projeto FreeBSD, seus objetivos e modelo de desenvolvimento.

   Capitulo 2, Instalando o FreeBSD

           Guia o usuario durante todo o processo de instalac,ao do FreeBSD
           9.x usando o bsdinstall.

   Capitulo 3, Fundamentos do FreeBSD

           Cobre os comandos basicos e a funcionalidade do sistema
           operacional FreeBSD. Se voce esta familiarizado com Linux(R) ou
           outro tipo de UNIX(R), provavelmente voce pode pular este
           capitulo.

   Capitulo 4, Instalando Aplicativos: Pacotes e Ports

           Cobre a instalac,ao de softwares de terceiros com a inovadora
           "Colec,ao de Ports" do FreeBSD, e com pacotes binarios
           tradicionais.

   Capitulo 5, O sistema X Window

           Descreve o Sistema X Window em geral e usa o X11 no FreeBSD em
           particular. Tambem descreve ambientes comuns de desktop, como o
           KDE e GNOME.

   Capitulo 6, Aplicac,oes de Desktop

           Lista alguns aplicativos comuns de desktop, como navegadores web e
           pacotes de produtividade, e descreve como instala-los no FreeBSD.

   Capitulo 7, Multimidia

           Mostra como configurar o suporte a reproduc,ao de som e video para
           o seu sistema. Tambem descreve alguns exemplos de aplicativos de
           audio e video.

   Capitulo 8, Configurando o kernel do FreeBSD

           Explica o porque que voce pode precisar configurar um novo kernel
           e fornece instruc,oes detalhadas para configurar, compilar e
           instalar um kernel personalizado.

   Capitulo 9, Impressao

           Descreve o gerenciamento de impressoras no FreeBSD, incluindo
           informac,oes sobre paginas de banner, contabilidade de impressoras
           e configurac,ao inicial.

   Capitulo 10, Compatibilidade binaria com o Linux(R)

           Descreve os recursos de compatibilidade Linux(R) do FreeBSD.
           Tambem fornece instruc,oes detalhadas de instalac,ao para muitos
           aplicativos Linux(R) populares, como o Oracle(R) e o
           Mathematica(R).

   Capitulo 11, Configurac,ao e Ajuste

           Descreve os parametros disponiveis para os administradores do
           sistema ajustarem um sistema FreeBSD para um otimo desempenho.
           Tambem descreve os varios arquivos de configurac,ao usados no
           FreeBSD e onde encontra-los.

   Capitulo 12, O processo de inicializac,ao do FreeBSD

           Descreve o processo de inicializac,ao do FreeBSD e explica como
           controlar este processo com opc,oes de configurac,ao.

   Capitulo 13, Seguranc,a

           Descreve muitas ferramentas diferentes disponiveis para ajudar a
           manter seu sistema FreeBSD seguro, incluindo Kerberos, IPsec e
           OpenSSH.

   Capitulo 14, Jails

           Descreve o framework do jail e as suas vantagens sobre o chroot
           tradicional do FreeBSD.

   Capitulo 15, Controle de acesso obrigatorio

           Explica o que e o Mandatory Access Control (MAC) e como esse
           mecanismo pode ser usado para proteger um sistema FreeBSD.

   Capitulo 16, Auditoria de Evento de Seguranc,a

           Descreve o que e a Auditoria de Eventos do FreeBSD, como ela pode
           ser instalada, configurada e como as trilhas de auditoria podem
           ser inspecionadas ou monitoradas.

   Capitulo 17, Armazenamento

           Descreve como gerenciar midias de armazenamento e sistemas de
           arquivos com o FreeBSD. Isto inclui discos fisicos, matrizes RAID,
           midias oticas e de fita, discos com suporte de memoria e sistemas
           de arquivos de rede.

   Capitulo 18, GEOM: Framework de Transformac,ao de Disco Modular

           Descreve o que e o framework GEOM do FreeBSD e como configurar os
           varios niveis suportados de RAID.

   Capitulo 20, Outros Sistemas de Arquivos

           Examina o suporte a sistemas de arquivos nao-nativos no FreeBSD,
           como o Z File System da Sun(TM).

   Capitulo 21, Virtualizac,ao

           Descreve o que os sistemas de virtualizac,ao oferecem e como eles
           podem ser usados com o FreeBSD.

   Capitulo 22, Localizac,ao - Uso e Configurac,ao do i18n/L10n

           Descreve como usar o FreeBSD em outros idiomas alem do ingles.
           Abrange a localizac,ao tanto em nivel de sistema como em nivel de
           aplicativo.

   Capitulo 23, Atualizac,ao e Upgrade do FreeBSD

           Explica as diferenc,as entre FreeBSD-STABLE, FreeBSD-CURRENT e
           FreeBSD releases. Descreve quais usuarios se beneficiariam do uso
           de um sistema em desenvolvimento e descreve este processo. Cobre
           os metodos que os usuarios podem usar para atualizar seu sistema
           para a ultima release de seguranc,a.

   Capitulo 24, DTrace

           Descreve como configurar e usar a ferramenta DTrace da Sun(TM) no
           FreeBSD. O rastreamento dinamico pode ajudar a localizar problemas
           de desempenho, realizando a analise do sistema em tempo real.

   Capitulo 26, Comunicac,oes Seriais

           Explica como conectar terminais e modems ao seu sistema FreeBSD
           para conexoes de discagem de entrada e de saida.

   Capitulo 27, PPP

           Descreve como usar o PPP para se conectar a sistemas remotos com o
           FreeBSD.

   Capitulo 28, Correio Eletronico

           Explica os diferentes componentes de um servidor de e-mail e
           mergulha em topicos simples de configurac,ao do software mais
           popular de servidor de e-mails: o sendmail.

   Capitulo 29, Servidores de Rede

           Fornece instruc,oes detalhadas e exemplos de arquivos de
           configurac,ao para configurar sua maquina FreeBSD como um servidor
           de sistema de arquivos de rede, servidor de nome de dominio,
           servidor de sistema de informac,oes de rede ou servidor de
           sincronizac,ao de horario.

   Capitulo 30, Firewalls

           Explica a filosofia por tras dos firewalls baseados em software e
           fornece informac,oes detalhadas sobre a configurac,ao dos
           diferentes firewalls disponiveis para o FreeBSD.

   Capitulo 31, Rede Avanc,ada

           Descreve muitos topicos de rede, incluindo o compartilhamento de
           uma conexao `a Internet com outros computadores em sua LAN,
           topicos avanc,ados de roteamento, rede sem fio, Bluetooth(R), ATM,
           IPv6 e muito mais.

   Apendice A, Obtendo o FreeBSD

           Lista diferentes fontes para obter a midia de instalac,ao do
           FreeBSD em CD-ROM ou DVD, bem como diferentes sites na Internet
           que permitem que voce baixe e instale o FreeBSD.

   Apendice B, Bibliografia

           Este livro aborda muitos assuntos diferentes que podem deixa-lo
           com a curiosidade de uma explicac,ao mais detalhada. A
           bibliografia lista muitos livros excelentes que sao referenciados
           no texto.

   Apendice C, Recursos na Internet

           Descreve os muitos foruns disponiveis para usuarios do FreeBSD
           postarem perguntas e se engajarem em conversas tecnicas sobre o
           FreeBSD.

   Apendice D, Chaves OpenPGP

           Lista as fingerprints PGP de varios desenvolvedores do FreeBSD.

Convenc,oes utilizadas neste livro

   Para fornecer um texto consistente e facil de ler, varias convenc,oes sao
   seguidas ao longo do livro.

  Convenc,oes Tipograficas

   Italico

           Uma fonte italica e usada para nomes de arquivos, URLs, textos
           enfatizados e o primeiro uso de termos tecnicos.

   Monospace

           Uma fonte monoespac,ada e usada para mensagens de erro, comandos,
           variaveis de ambiente, nomes de ports, nomes de host, nomes de
           usuarios, nomes de grupos, nomes de dispositivos, variaveis e
           fragmentos de codigo.

   Negrito

           Uma fonte negrita e usada para aplicativos, comandos e chaves.

  Entrada do Usuario

   As teclas sao mostradas em negrito para se destacar do restante do texto.
   As combinac,oes de teclas que devem ser digitadas simultaneamente sao
   mostradas com `+' entre as teclas, como:

   Ctrl+Alt+Del

   Isso significa que o usuario deve digitar as teclas Ctrl, Alt e Del ao
   mesmo tempo.

   As teclas que devem ser digitadas em sequencia serao separadas por
   virgulas, por exemplo:

   Ctrl+X, Ctrl+S

   Significaria que o usuario deve digitar as teclas Ctrl e X simultaneamente
   e, em seguida, digitar as teclas Ctrl e S simultaneamente.

  Exemplos

   Exemplos comec,ando com C:\> indicam um comando MS-DOS(R). Salvo
   indicac,ao em contrario, estes comandos podem ser executados a partir de
   uma janela de "Prompt de Comando" em um ambiente Microsoft(R) Windows(R).

 E:\> tools\fdimage floppies\kern.flp A:

   Exemplos comec,ando com # indicam um comando que deve ser executado como
   superusuario no FreeBSD. Voce pode logar como root para digitar o comando,
   ou logar como sua conta normal e usar o comando su(1) para obter
   privilegios de superusuario.

 # dd if=kern.flp of=/dev/fd0

   Exemplos comec,ando com % indicam um comando que deve ser chamado a partir
   de uma conta de usuario normal. Salvo indicac,ao em contrario, a sintaxe
   C-shell e usada para definir variaveis de ambiente e outros comandos do
   shell.

 % top

Agradecimentos

   O livro que voce esta segurando representa os esforc,os de muitas centenas
   de pessoas em todo o mundo. Nao importa se eles enviaram correc,oes para
   erros de digitac,ao ou submeteram capitulos completos, todas as
   contribuic,oes foram uteis.

   Varias empresas tem apoiado o desenvolvimento deste documento, pagando aos
   autores para trabalhar em tempo integral, pagando pela publicac,ao, etc.
   Em particular, a BSDi (posteriormente adquirida pela Wind River Systems)
   pagou membros do Projeto de Documentac,ao do FreeBSD para trabalhar na
   melhoria deste livro em tempo integral, levando `a publicac,ao da primeira
   edic,ao impressa em marc,o de 2000 (ISBN 1-57176-241-8). A Wind River
   Systems pagou varios autores adicionais para fazer uma serie de melhorias
   na infraestrutura de impressao e adicionar capitulos adicionais ao texto.
   Este trabalho culminou com a publicac,ao da segunda edic,ao impressa em
   novembro de 2001 (ISBN 1-57176-303-1). Em 2003-2004, a FreeBSD Mall, Inc.
   pagou a varios contribuidores para melhorar o Handbook em preparac,ao para
   a terceira edic,ao impressa.

                           Parte I. Primeiros Passos

   Esta parte do handbook e destinada aos usuarios e administradores que sao
   novos no FreeBSD. Estes capitulos:

     * Apresentam o FreeBSD.

     * Guiam os leitores atraves do processo de instalac,ao.

     * Ensinam conceitos basicos e fundamentais do UNIX(R).

     * Mostram como instalar a grande variedade de aplicativos de terceiros
       disponiveis para o FreeBSD.

     * Apresenta o X, o sistema de janelas UNIX(R) e detalha como configurar
       um ambiente de desktop para tornar os usuarios mais produtivos.

   O numero de referencias a topicos futuros no texto foi mantido no minimo,
   para que uma sec,ao possa ser lida do comec,o ao fim com o minimo de
   avanc,o desnecessario de paginas.

   Indice

   1. Introduc,ao

                1.1. Sinopse

                1.2. Bem vindo ao FreeBSD!

                1.3. Sobre o Projeto FreeBSD

   2. Instalando o FreeBSD

                2.1. Sinopse

                2.2. Requisitos minimos de hardware

                2.3. Tarefas de Pre-instalac,ao

                2.4. Iniciando a instalac,ao

                2.5. Usando o bsdinstall

                2.6. Alocando o espac,o em disco

                2.7. Fazendo o download dos arquivos de distribuic,ao

                2.8. Pos-instalac,ao

                2.9. Soluc,ao de problemas

                2.10. Usando o Live CD

   3. Fundamentos do FreeBSD

                3.1. Sinopse

                3.2. Consoles e Terminais Virtuais

                3.3. Usuarios e Gerenciamento Basico de Contas

                3.4. Permissoes

                3.5. Estrutura de Diretorios

                3.6. Organizac,ao dos Discos

                3.7. Montando e Desmontando Sistemas de Arquivos

                3.8. Processos e Daemons

                3.9. Shells

                3.10. Editores de Texto

                3.11. Dispositivos e nos de dispositivos

                3.12. Paginas de Manual

   4. Instalando Aplicativos: Pacotes e Ports

                4.1. Sinopse

                4.2. Visao geral sobre a Instalac,ao de Software

                4.3. Encontrando Software

                4.4. Usando o pkg para o gerenciamento de pacotes binarios

                4.5. Usando a Colec,ao de Ports

                4.6. Compilando Pacotes com o Poudriere

                4.7. Considerac,oes pos-instalac,ao

                4.8. Lidando com ports quebrados

   5. O sistema X Window

                5.1. Sinopse

                5.2. Terminologia

                5.3. Instalando o Xorg

                5.4. Configurac,ao do Xorg

                5.5. Usando fontes no Xorg

                5.6. O Gerenciador de Display X

                5.7. Ambientes de desktop

                5.8. Instalando o Compiz Fusion

                5.9. Soluc,ao de problemas

Capitulo 1. Introduc,ao

   Reestruturado, reorganizado e com partes reescritas por Jim Mock.
   Indice

   1.1. Sinopse

   1.2. Bem vindo ao FreeBSD!

   1.3. Sobre o Projeto FreeBSD

1.1. Sinopse

   Obrigado pelo seu interesse no FreeBSD! O capitulo seguinte cobre varios
   aspectos do Projeto FreeBSD, como seu historico, objetivos, modelo de
   desenvolvimento e assim por diante.

   Depois de ler este capitulo, voce sabera:

     * Como o FreeBSD se relaciona com outros sistemas operacionais de
       computadores.

     * A historia do projeto FreeBSD.

     * Os objetivos do projeto FreeBSD.

     * O basico do modelo de desenvolvimento de codigo aberto do FreeBSD.

     * E claro: de onde o nome "FreeBSD" vem.

1.2. Bem vindo ao FreeBSD!

   O FreeBSD e um Sistema Operacional de codigo aberto nos padroes Unix-Like
   para computadores de arquitetura x86 (32 and 64 bits), ARM(R), AArch64,
   RISC-V(R), MIPS(R), POWER(R), PowerPC(R), and Sun UltraSPARC(R). Ele
   fornece todos os recursos que sao considerados comuns hoje em dia, como
   multitarefa preemptiva, protec,ao de memoria, memoria virtual, recursos
   para multiplos usuarios, suporte a SMP, todas as ferramentas de
   desenvolvimento de codigo aberto para diferentes linguagens e estruturas e
   recursos de area de trabalho centralizados no Sistema X Window, KDE ou
   GNOME. Seus pontos fortes sao:

     * Licenc,a Liberal Open Source, que concede a voce o direito de
       modificar e estender livremente seu codigo-fonte e incorpora-lo em
       projetos Open Source e produtos fechados, sem impor restric,oes
       tipicas `as licenc,as copyleft, bem como evita potenciais problemas de
       incompatibilidade de licenc,a.

     * Rede TCP/IP forte - O FreeBSD implementa protocolos padroes da
       industria com desempenho e escalabilidade crescentes. Isso faz com que
       seja uma boa combinac,ao tanto em func,oes de servidor quanto de
       roteamento/firewall - e, de fato, muitas empresas e fornecedores o
       utilizam precisamente para essa finalidade.

     * Suporte totalmente integrado ao OpenZFS, incluindo root-on-ZFS, ZFS
       Boot Environments, gerenciamento de falhas, delegac,ao administrativa,
       suporte a jails, documentac,ao especifica ao FreeBSD e suporte ao
       instalador do sistema.

     * Extensivos recursos de seguranc,a, do Mandatory Access Control ao
       Capsicum e mecanismos de sandbox.

     * Mais de 30 mil pacotes pre-compilados para todas as arquiteturas
       suportadas, e a Colec,ao de Ports, que facilita a compilac,ao de seus
       proprios pacotes personalizados.

     * Documentac,ao - alem do Handbook e livros de diferentes autores que
       cobrem topicos que vao da administrac,ao do sistema aos internals do
       kernel, ha tambem as paginas man(), nao apenas para daemons do
       userspace, utilitarios e arquivos de configurac,ao, mas tambem para
       APIs do driver do kernel (sec,ao 9) e drivers individuais (sec,ao 4).

     * Estrutura de repositorio simples e consistente e sistema de
       compilac,ao - O FreeBSD usa um unico repositorio para todos os seus
       componentes, tanto para o kernel quanto para o userspace. Isso,
       juntamente com um sistema de compilac,ao unificado, facil de
       personalizar e um processo de desenvolvimento bem pensado, facilita a
       integrac,ao do FreeBSD com a infraestrutura de compilac,ao do seu
       proprio produto.

     * Mantem-se fiel `a filosofia do Unix, preferindo heterogeneidade ao
       inves de deamons monoliticos "all in one" com comportamento codificado
       (hardcoded).

     * Compatibilidade binaria com o Linux, o que torna possivel executar
       muitos binarios do Linux sem a necessidade de virtualizac,ao.

   O FreeBSD e baseado na release 4.4BSD-Lite do Computer Systems Research
   Group (CSRG) da Universidade da California em Berkeley, e mantem a
   tradic,ao distinta do desenvolvimento de sistemas BSD. Alem do bom
   trabalho fornecido pelo CSRG, o Projeto FreeBSD colocou milhares de
   horas-homem para estender a funcionalidade e ajustar o sistema para o
   maximo desempenho e confiabilidade em situac,oes de carga reais. O FreeBSD
   oferece desempenho e confiabilidade a altura de outras ofertas de codigo
   aberto e comerciais, combinadas com recursos de ponta nao disponiveis em
   nenhum outro lugar.

  1.2.1. O que o FreeBSD Pode Fazer?

   As aplicac,oes para as quais o FreeBSD pode ser colocado sao
   verdadeiramente limitadas apenas pela sua propria imaginac,ao. Do
   desenvolvimento de software `a automac,ao de fabrica, do controle de
   estoque `a correc,ao de azimute de antenas de satelite remotas; Se isso
   puder ser feito com um produto comercial UNIX(R), e mais do que provavel
   que voce tambem possa faze-lo com o FreeBSD! O FreeBSD tambem se beneficia
   significativamente de milhares de aplicativos de alta qualidade
   desenvolvidos por centros de pesquisa e universidades em todo o mundo,
   muitas vezes disponiveis com pouco ou nenhum custo.

   Como o codigo-fonte do FreeBSD esta disponivel gratuitamente, o sistema
   tambem pode ser customizado em um grau quase inedito para aplicac,oes ou
   projetos especiais, e de maneiras que geralmente nao sao possiveis com a
   maioria do sistemas operacionais dos principais fornecedores comerciais.
   Aqui esta apenas uma amostra de algumas das aplicac,oes em que as pessoas
   estao atualmente usando o FreeBSD:

     * Servic,os de Internet: A robusta rede TCP/IP incorporada ao FreeBSD
       torna-o uma plataforma ideal para uma variedade de servic,os de
       Internet, tais como:

          * Servidores WEB

          * Roteamento IPv4 e IPv6

          * Firewalls e Gateways NAT ("IP masquerading")

          * Servidores FTP

          * Servidores de Email

          * E mais...

     * Educac,ao: Voce e estudante de ciencias da computac,ao ou de
       engenharia relacionada? Nao ha melhor maneira de aprender sobre
       sistemas operacionais, arquitetura de computadores e redes do que
       colocar as maos no sistema, uma experiencia que o FreeBSD pode
       oferecer. Os varios pacotes CAD, matematicos e de design grafico
       disponiveis gratuitamente tambem o tornam altamente util para aqueles
       cujo principal interesse em um computador e fazer com que outro
       trabalho seja feito!

     * Pesquisa: Com o codigo-fonte de todo o sistema disponivel, o FreeBSD e
       uma excelente plataforma para pesquisa em sistemas operacionais, assim
       como em outros ramos da ciencia da computac,ao. A natureza livremente
       disponivel do FreeBSD tambem possibilita que grupos remotos colaborem
       em ideias ou desenvolvimento compartilhado sem ter que se preocupar
       com acordos de licenciamento especiais ou limitac,oes sobre o que pode
       ser discutido em foruns abertos.

     * Rede: Precisa de um novo roteador? Um servidor de nomes (DNS)? Um
       firewall para manter as pessoas fora de sua rede interna? O FreeBSD
       pode facilmente transformar esse PC nao utilizado que esta encostado
       em algum canto em um roteador avanc,ado com recursos sofisticados de
       filtragem de pacotes.

     * Embarcado: O FreeBSD e uma excelente plataforma para construir
       sistemas embarcados. Com suporte para plataformas ARM(R), MIPS(R) e
       PowerPC(R), juntamente com uma pilha de rede robusta, recursos de
       ponta e a permissiva Licenc,a BSD o FreeBSD e uma excelente base para
       a criac,ao de roteadores embarcados, firewalls e outros dispositivos.

     * Desktop: O FreeBSD e uma otima opc,ao para uma soluc,ao de desktop
       barata usando o servidor X11 disponivel gratuitamente. O FreeBSD
       oferece varias opc,oes de ambientes de desktop de codigo aberto,
       incluindo as interfaces graficas de usuario padrao do GNOME e do KDE.
       O FreeBSD pode ate inicializar "diskless" a partir de um servidor
       central, tornando as estac,oes de trabalho individuais ainda mais
       baratas e faceis de administrar.

     * Desenvolvimento de Software: O sistema basico do FreeBSD vem com um
       conjunto completo de ferramentas de desenvolvimento, incluindo um
       completo compilador e depurador C/C++ . O suporte para muitas outras
       linguagens tambem esta disponivel por meio da colec,ao de ports e dos
       pacotes.

   O FreeBSD esta disponivel para download gratuito, ou pode ser obtido em
   CD-ROM ou DVD. Por favor, consulte Apendice A, Obtendo o FreeBSD para
   maiores informac,oes sobre como obter o FreeBSD.

  1.2.2. Quem Usa o FreeBSD?

   O FreeBSD e conhecido por seus recursos de servic,o web - sites que rodam
   no FreeBSD incluem Hacker News, Netcraft, NetEase, Netflix, Sina, Sony
   Japan, Rambler, Yahoo!, e Yandex.

   Os recursos avanc,ados do FreeBSD, a seguranc,a comprovada, o ciclo de
   release previsivel e a licenc,a permissiva levaram `a sua utilizac,ao como
   plataforma para a construc,ao de muitos appliances, dispositivos e
   produtos tanto comerciais quanto de codigo aberto. Muitas das maiores
   empresas de TI do mundo usam o FreeBSD:

     * Apache - A Apache Software Foundation executa a maior parte de sua
       infraestrutura voltada para o publico, incluindo possivelmente um dos
       maiores repositorios SVN do mundo, com mais de 1.4 milhoes de commits,
       no FreeBSD.

     * Apple - OS X utiliza muito do FreeBSD na sua pilha de rede, no seu
       sistema de arquivos virtuais e em muitos componentes userland. O Apple
       iOS tambem contem elementos emprestados do FreeBSD.

     * Cisco - Os appliances de seguranc,a de rede e anti-spam IronPort
       executam um kernel modificado do FreeBSD.

     * Citrix - A linha NetScaler de dispositivos de seguranc,a fornece
       balanceamento de carga nas camadas 4-7, cache de conteudo, firewall de
       aplicativos, VPN segura e acesso movel `a rede em nuvem, juntamente
       com o poder de um shell do FreeBSD.

     * Dell EMC Isilon - Os dispositivos de armazenamento corporativo da
       Isilon sao baseados no FreeBSD. A licenc,a extremamente liberal do
       FreeBSD permitiu que a Isilon integrasse sua propriedade intelectual
       ao kernel e se concentrasse em construir seu produto ao inves de um
       sistema operacional.

     * Quest KACE - Os appliances de gerenciamento de sistemas KACE executam
       o FreeBSD devido `a sua confiabilidade, escalabilidade e a comunidade
       que apoia seu desenvolvimento continuo.

     * iXsystems - A linha TrueNAS de dispositivos de armazenamento unificado
       e baseada no FreeBSD. Alem de seus produtos comerciais, a iXsystems
       tambem gerencia o desenvolvimento dos projetos de codigo aberto TrueOS
       e FreeNAS.

     * Juniper - O sistema operacional JunOS que roda em todos os
       equipamentos de rede da Juniper (incluindo roteadores, switches,
       firewalls e dispositivos de rede) e baseado no FreeBSD. A Juniper e um
       dos muitos fornecedores que mostra a relac,ao simbiotica entre o
       projeto e os fornecedores de produtos comerciais. Melhorias geradas na
       Juniper sao enviadas para o FreeBSD para reduzir a complexidade de
       integrar novos recursos do FreeBSD ao JunOS no futuro.

     * McAfee - O SecurOS, a base dos produtos de firewall corporativo da
       McAfee, incluindo o Sidewinder, e baseado no FreeBSD.

     * NetApp - A linha de dispositivos de armazenamento Data ONTAP GX e
       baseada no FreeBSD. Alem disso, a NetApp contribuiu com muitos
       recursos, incluindo o novo hipervisor licenciado pelo BSD, bhyve.

     * Netflix - O appliance OpenConnect que a Netflix usa para transmitir
       filmes para seus clientes e baseado no FreeBSD. A Netflix fez extensas
       contribuic,oes para a base de codigo e trabalha para manter um delta
       zero a partir do FreeBSD mainline. Os appliances Netflix OpenConnect
       sao responsaveis por entregar mais de 32% de todo o trafego de
       Internet na America do Norte.

     * Sandvine - A Sandvine usa o FreeBSD como base de suas plataformas de
       processamento de rede em tempo real de alto desempenho que compoem
       seus produtos inteligentes de controle de politica de rede.

     * Sony - O console de videogame PlayStation 4 executa uma versao
       modificada do FreeBSD.

     * Sophos - O produto Sophos Email Appliance e baseado em uma versao
       modificada (hardened) do FreeBSD e varre as mensagens de entrada em
       busca por spam e virus, ao mesmo tempo em que monitora as mensagens de
       saida quanto a malware, bem como a perda acidental de informac,oes
       confidenciais.

     * Spectra Logic - A linha nTier de dispositivos de armazenamento de
       dados de arquivamento executa o FreeBSD e o OpenZFS.

     * Stormshield - Os dispositivos Stormshield Network Security sao
       baseados em uma versao modificada do FreeBSD. A licenc,a BSD permite
       que eles integrem sua propria propriedade intelectual ao sistema
       enquanto retornam uma grande quantidade de desenvolvimento
       interessante para a comunidade.

     * The Weather Channel - O appliance IntelliStar que e instalado na
       central de cada provedor de cabo local e e responsavel por injetar
       previsoes meteorologicas locais na programac,ao da rede de TV a cabo,
       executa o FreeBSD.

     * Verisign - A Verisign e responsavel por operar os registros de dominio
       raiz .com e .net, bem como a infra-estrutura de DNS que a acompanha.
       Eles contam com diversos sistemas operacionais de rede, incluindo o
       FreeBSD, para garantir que nao haja um ponto comum de falha em sua
       infraestrutura.

     * Voxer - A Voxer suporta sua plataforma de mensagem de voz movel com o
       ZFS no FreeBSD. A Voxer mudou de um derivativo do Solaris para o
       FreeBSD por causa da sua documentac,ao superior, comunidade maior e
       mais ativa e ao ambiente mais favoravel ao desenvolvedor. Alem de
       recursos criticos como o ZFS e o DTrace, o FreeBSD tambem oferece
       suporte a TRIM no ZFS.

     * Fudo Security - O dispositivo de seguranc,a FUDO permite que as
       empresas monitorem, controlem, registrem e fac,am auditoria de
       contratados e administradores que trabalham em seus sistemas. Baseado
       em todos os melhores recursos de seguranc,a do FreeBSD, incluindo ZFS,
       GELI, Capsicum, HAST e auditdistd.

   O FreeBSD tambem gerou varios projetos de codigo aberto relacionados:

     * BSD Router - Um substituto baseado em FreeBSD para grandes roteadores
       corporativos projetados para rodar em hardware PC padrao.

     * FreeNAS - Um FreeBSD personalizado projetado para ser usado como um
       dispositivo de servidor de arquivos de rede. Fornece uma interface web
       baseada em Python para simplificar o gerenciamento dos sistemas de
       arquivos UFS e ZFS. Inclui suporte para NFS, SMB/CIFS, AFP, FTP e
       iSCSI. Inclui um sistema extensivel de plugins baseado em jails do
       FreeBSD.

     * GhostBSD - e derivado do FreeBSD, usa o ambiente GTK para fornecer uma
       aparencia bonita e uma experiencia confortavel na moderna plataforma
       BSD, oferecendo um ambiente de trabalho natural e nativo UNIX(R).

     * mfsBSD - Um kit de ferramentas para compilar uma imagem do sistema
       FreeBSD que roda inteiramente da memoria.

     * NAS4Free - Uma distribuic,ao de servidor de arquivos baseada no
       FreeBSD com uma interface web PHP.

     * OPNSense - OPNsense e um firewall e uma plataforma de roteamento open
       source, baseado em FreeBSD, facil-de-usar e facil-de-compilar. O
       OPNsense inclui a maioria dos recursos disponiveis em firewalls
       comerciais caros e, em muitos casos, muito mais. Ele traz o rico
       conjunto de recursos de ofertas comerciais com os beneficios de
       codigos fonte abertos e verificaveis.

     * TrueOS - O TrueOS e baseado na lendaria seguranc,a e estabilidade do
       FreeBSD. O TrueOS segue o FreeBSD-CURRENT, com os drivers,
       atualizac,oes de seguranc,a e pacotes mais recentes disponiveis.

     * FuryBSD - e um desktop FreeBSD de codigo aberto novinho em folha. O
       FuryBSD presta homenagem aos projetos de BSD de desktop do passado,
       como PC-BSD e TrueOS com sua interface grafica e adiciona ferramentas
       adicionais, como uma imagem live USB/DVD hibrida. O FuryBSD e
       totalmente gratuito para uso e distribuido sob a licenc,a BSD.

     * MidnightBSD - e um sistema operacional derivado do FreeBSD
       desenvolvido com usuarios de desktop em mente. Inclui todo o software
       que voce esperaria para suas tarefas diarias: email, navegac,ao web,
       processamento de texto, jogos e muito mais.

     * pfSense - Uma distribuic,ao de firewall baseada no FreeBSD com uma
       enorme variedade de recursos e amplo suporte a IPv6.

     * ZRouter - Um firmware alternativo de codigo aberto para dispositivos
       embarcados baseado no FreeBSD. Projetado para substituir o firmware
       proprietario em roteadores prontos para uso.

   Uma lista de depoimentos de empresas que baseiam seus produtos e servic,os
   no FreeBSD pode ser encontrada no site da Fundac,ao FreeBSD. A Wikipedia
   tambem mantem uma lista de produtos baseados no FreeBSD.

1.3. Sobre o Projeto FreeBSD

   A sec,ao a seguir fornece algumas informac,oes basicas sobre o projeto,
   incluindo um breve historico, metas do projeto e o modelo de
   desenvolvimento do projeto.

  1.3.1. Uma Breve Historia do FreeBSD

   O Projeto FreeBSD teve sua genese no inicio de 1993, parcialmente como uma
   evoluc,ao natural do Unofficial 386BSD Patchkit por parte dos tres ultimos
   coordenadores: Nate Williams, Rod Grimes e Jordan Hubbard.

   O objetivo original era produzir um snapshot intermediario do 386BSD, a
   fim de corrigir um grande numero de problemas que o mecanismo do patchkit
   simplesmente nao era capaz de resolver. O titulo inicial do projeto foi
   386BSD 0.5 ou 386BSD Interim em referencia a esse fato.

   O 386BSD era o sistema operacional do Bill Jolitz, que havia ate entao
   sofrido bastante com quase um ano de negligencia. Como o patchkit inchava
   cada vez mais desconfortavelmente a cada dia que passava, eles decidiram
   ajudar o Bill fornecendo este snapshot "limpo". Esses planos foram
   interrompidos quando, de repente, Bill Jolitz decidiu retirar sua sanc,ao
   do projeto sem qualquer indicac,ao clara do que seria feito em seu lugar.

   O trio achou que a meta continuava valendo a pena, mesmo sem o apoio de
   Bill, e entao adotaram o nome "FreeBSD" cunhado por David Greenman. Os
   objetivos iniciais foram definidos apos consultar os usuarios atuais do
   sistema e, uma vez que ficou claro que o projeto estava em vias de se
   tornar realidade, Jordan entrou em contato com a Walnut Creek CDROM com o
   objetivo de melhorar os canais de distribuic,ao do FreeBSD para aqueles
   desafortunados sem acesso facil `a Internet. O Walnut Creek CDROM nao
   apenas apoiou a ideia de distribuir o FreeBSD em CD, mas tambem chegou a
   fornecer ao projeto uma maquina para trabalhar e uma conexao rapida `a
   Internet. Sem o grau de fe quase sem precedentes da Walnut Creek CDROM no
   que era, na epoca, um projeto completamente desconhecido, e bastante
   improvavel que o FreeBSD tivesse chegado tao longe, tao rapido, como hoje.

   A primeira distribuic,ao em CD-ROM (e amplo pela rede) foi o FreeBSD 1.0,
   lanc,ado em dezembro de 1993. Isto foi baseado na fita 4.3BSD-Lite
   ("Net/2") da U.C. Berkeley, com muitos componentes tambem fornecidos pelo
   386BSD e pela Free Software Foundation. Foi um sucesso bastante razoavel
   para uma primeira oferta, e e eles seguiram com o bem-sucedido FreeBSD 1.1
   em maio de 1994.

   Por esta altura, algumas nuvens de tempestade inesperadas formaram-se no
   horizonte, como a Novell e U.C. Berkeley resolveram seu longo processo
   judicial sobre o status legal da fita do Berkeley Net/2. Uma condic,ao
   desse acordo foi a concessao da U.C. Berkeley de que grande parte do
   codigo Net/2 foi "onerado" e era de propriedade da Novell, que por sua vez
   o adquiriu da AT&T algum tempo antes. O que a Berkeley recebeu em troca
   foi a "benc,ao" da Novell de que o lanc,amento do 4.4BSD-Lite, quando
   finalmente fosse lanc,ado, seria declarado livre e todos os atuais
   usuarios do Net/2 seriam fortemente encorajados a mudar. Isso incluiu o
   FreeBSD, e foi dado ao projeto o tempo para interromper o envio de seu
   proprio produto baseado em Net/2 ate o final de julho de 1994. Sob os
   termos desse acordo, o projeto recebeu um ultimo lanc,amento antes do
   prazo final, sendo esse lanc,amento o FreeBSD 1.1.5.1.

   O FreeBSD entao comec,ou a tarefa ardua de literalmente se reinventar de
   um conjunto completamente novo e incompleto de bits do 4.4BSD-Lite. As
   versoes "Lite" foram leves em parte porque o CSRG da Berkeley removeu
   grandes pedac,os de codigo necessarios para realmente compilar um sistema
   inicializavel (devido a varios requisitos legais) e o fato de que a port
   Intel do 4.4 era altamente incompleto. O projeto levou ate novembro de
   1994 para fazer essa transic,ao, e em dezembro lanc,ou o FreeBSD 2.0 para
   o mundo. Apesar de ainda ser um pouco mais dificil, o lanc,amento foi um
   sucesso significativo e foi seguido pela versao mais robusta e facil de
   instalar o FreeBSD 2.0.5 em junho de 1995.

   Desde aquela epoca, o FreeBSD fez uma serie de lanc,amentos cada vez
   melhorando a estabilidade, a velocidade e o conjunto de recursos da versao
   anterior.

   Por enquanto, os projetos de desenvolvimento de longo prazo continuam a
   ocorrer no ramo 10.X-CURRENT (trunk), e os snapshots de release 10.X sao
   continuamente disponibilizados a partir do servidor de snapshots `a medida
   que o trabalho progride.

  1.3.2. Objetivos do Projeto FreeBSD

   Contribuido porJordan Hubbard .

   Os objetivos do Projeto FreeBSD sao fornecer software que possa ser usado
   para qualquer proposito e sem amarras. Muitos de nos temos um investimento
   significativo no codigo (e projeto) e certamente nao nos importariamos com
   uma pequena compensac,ao financeira de vez em quando, mas definitivamente
   nao estamos preparados para insistir nisso. Acreditamos que a nossa
   primeira e principal "missao" e fornecer codigo a todos os participantes,
   e para qualquer finalidade, para que o codigo obtenha o maior uso possivel
   e fornec,a o maior beneficio possivel. Este e, acredito, um dos objetivos
   mais fundamentais do Software Livre e um dos que apoiamos
   entusiasticamente.

   O codigo em nossa arvore de codigo-fonte que se enquadra na GNU General
   Public License (GPL) ou na Library General Public License (LGPL) vem com
   um pouco mais de amarras, embora pelo menos do lado do acesso imposto, em
   vez do oposto usual. Devido `as complexidades adicionais que podem evoluir
   no uso comercial de software GPL, no entanto, preferimos software
   submetido sob licenc,a BSD quando e uma opc,ao razoavel faze-lo.

  1.3.3. O Modelo de Desenvolvimento do FreeBSD

   Contribuido por Satoshi Asami.

   O desenvolvimento do FreeBSD e um processo muito aberto e flexivel, sendo
   construido literalmente a partir das contribuic,oes de milhares de pessoas
   ao redor do mundo, como pode ser visto na nossa lista de contribuidores. A
   infraestrutura de desenvolvimento do FreeBSD permite que milhares de
   colaboradores colaborem pela Internet. Estamos constantemente `a procura
   de novos desenvolvedores e ideias, e os interessados em se envolver mais
   estreitamente com o projeto precisam simplesmente entrar em contato
   conosco pelas lista de discussoes tecnicas do FreeBSD. A lista de
   discussao de anuncios do FreeBSD tambem esta disponivel para aqueles que
   desejam fazer com que outros usuarios do FreeBSD conhec,am as principais
   areas de trabalho.

   Coisas uteis para saber sobre o Projeto FreeBSD e seu processo de
   desenvolvimento, seja trabalhando independentemente ou em estreita
   cooperac,ao:

   Os repositorios SVN

           Por varios anos, a arvore de codigo-fonte central do FreeBSD foi
           mantida pelo CVS (Concurrent Versions Systems), uma ferramenta de
           controle de codigo-fonte disponivel gratuitamente. Em junho de
           2008, o Projeto mudou para o SVN (Subversion). A troca foi
           considerada necessaria, pois as limitac,oes tecnicas impostas pelo
           CVS estavam se tornando obvias devido `a rapida expansao da arvore
           de codigo-fonte e `a quantidade de historico ja armazenada. Os
           repositorios do Projeto de Documentac,ao e da Colec,ao de Ports
           tambem foram movidos do CVS para o SVN em maio de 2012 e julho de
           2012, respectivamente. Por favor, consulte a sec,ao Atualizando o
           codigo fonte para maiores informac,oes sobre como obter o
           repositorio src/ do FreeBSD e Usando a Colec,ao de Ports para
           detalhes sobre como obter a colec,ao de ports do FreeBSD.

   A lista de committers

           Os committers sao as pessoas que tem acesso de escrita na arvore
           do Subversion, e estao autorizados a fazer modificac,oes no codigo
           fonte do FreeBSD (o termo "committer" vem de commit, o comando de
           controle de codigo-fonte que e usado para trazer novas mudanc,as
           para o repositorio). Qualquer um pode enviar um relatorio de bug
           para o Banco de Dados de Bugs. Antes de enviar um relatorio de
           bug, as listas de discussao, canais de IRC ou foruns do FreeBSD
           podem ser usados para ajudar a verificar se um problema e
           realmente um bug.

   O FreeBSD core team

           O FreeBSD core team seria equivalente a um conselho de diretores
           se o Projeto FreeBSD fosse uma empresa. A principal tarefa do core
           team e garantir que o projeto, como um todo, esteja saudavel e
           seguindo na direc,ao certa. Convidar desenvolvedores dedicados e
           responsaveis a ingressar em nosso grupo de committers e uma das
           func,oes do core team, assim como o recrutamento de novos membros
           do core team `a medida que os outros saiam. O core team atual foi
           eleito a partir de um grupo de committers candidatos em julho de
           2018. As eleic,oes sao realizadas a cada dois anos.

  Nota:

           Como a maioria dos desenvolvedores, a maioria dos membros do core
           team tambem sao voluntarios quando se trata de desenvolvimento do
           FreeBSD e nao se beneficiam financeiramente do projeto, entao o
           "compromisso" tambem nao deve ser interpretado erroneamente como
           significando "suporte garantido". A analogia do "quadro de
           diretores" da diretriz acima nao e muito precisa, e pode ser mais
           apropriado dizer que estas sao as pessoas que deram suas vidas em
           favor do FreeBSD contra o seu melhor julgamento!

   Contribuidores externos

           Por ultimo, mas definitivamente nao menos importante, o maior
           grupo de desenvolvedores sao os proprios usuarios que fornecem
           feedback e correc,oes de bugs para nos em uma base quase
           constante. A principal maneira de manter contato com o
           desenvolvimento nao-centralizado do FreeBSD e inscrever-se nas
           listas de discussoes tecnicas sobre o FreeBSD onde essas coisas
           sao discutidas. Veja Apendice C, Recursos na Internet para maiores
           informac,oes sobre as varias listas de discussao do FreeBSD.

           A Lista de Colaboradores do FreeBSD e extensa e crescente, entao
           por que nao se juntar a ela contribuindo com algo para o FreeBSD
           hoje?

           Fornecer codigo nao e a unica maneira de contribuir para o
           projeto; para uma lista mais completa de coisas que precisam ser
           feitas, por favor consulte o web site do Projeto FreeBSD.

   Em resumo, nosso modelo de desenvolvimento e organizado como um conjunto
   solto de circulos concentricos. O modelo centralizado e projetado para a
   conveniencia dos usuarios do FreeBSD, que sao providos com uma maneira
   facil de rastrear uma base de codigo central, e nao para manter potenciais
   colaboradores fora! Nosso desejo e apresentar um sistema operacional
   estavel com um grande conjunto de aplicac,oes coerentes que os usuarios
   possam facilmente instalar e usar - este modelo funciona muito bem em
   realizar isso.

   Tudo o que pedimos para aqueles que se juntarem a nos como desenvolvedores
   do FreeBSD e a mesma dedicac,ao que o pessoal atual tem para o seu sucesso
   continuo!

  1.3.4. Programas de Terceiros

   Alem das distribuic,oes basicas, o FreeBSD oferece uma colec,ao de
   software portada com milhares de programas comumente procurados. No
   momento da redac,ao deste texto, havia mais de 24.000 ports! A lista de
   ports varia de servidores http, a jogos, linguagens, editores e quase tudo
   no meio. Toda a colec,ao de ports requer aproximadamente 500 MB. Para
   compilar um port, simplesmente mude para o diretorio do programa que voce
   deseja instalar, digite make install e deixe o sistema fazer o resto. A
   distribuic,ao original completa para cada port que voce cria e baixada
   dinamicamente, para que voce precise apenas de espac,o em disco suficiente
   para compilar os ports desejados. Quase todos os ports tambem sao
   fornecidos como um pacote "pre-compilado", que pode ser instalado com um
   comando simples (pkg install) por aqueles que nao desejam compilar seus
   proprios ports pelo codigo fonte. Maiores informac,oes sobre pacotes e
   ports podem ser encontradas em Capitulo 4, Instalando Aplicativos: Pacotes
   e Ports.

  1.3.5. Documentac,ao Adicional

   Todas as versoes suportadas do FreeBSD fornecem uma opc,ao no instalador
   para instalar documentac,ao adicional em /usr/local/shar/doc/freebsd
   durante a configurac,ao inicial do sistema. A documentac,ao tambem pode
   ser instalada posteriormente, usando os pacotes descritos em
   Sec,ao 23.3.2, "Atualizando a documentac,ao a partir do ports". Voce pode
   ver os manuais instalados localmente com qualquer navegador compativel com
   HTML usando as seguintes URLs:

   O Handbook do FreeBSD

           /usr/local/share/doc/freebsd/handbook/index.html

   O FAQ do FreeBSD

           /usr/local/share/doc/freebsd/faq/index.html

   Voce tambem pode visualizar as copias principais (e atualizadas com mais
   frequencia) em https://www.FreeBSD.org/.

Capitulo 2. Instalando o FreeBSD

   Reestruturado, reorganizado e com partes reescritas por Jim Mock.
   Atualizado para o bsdinstall por Gavin Atkinson e Warren Block.
   Atualizado para root-on-ZFS por Allan Jude.
   Indice

   2.1. Sinopse

   2.2. Requisitos minimos de hardware

   2.3. Tarefas de Pre-instalac,ao

   2.4. Iniciando a instalac,ao

   2.5. Usando o bsdinstall

   2.6. Alocando o espac,o em disco

   2.7. Fazendo o download dos arquivos de distribuic,ao

   2.8. Pos-instalac,ao

   2.9. Soluc,ao de problemas

   2.10. Usando o Live CD

2.1. Sinopse

   Existem diversos modos diferentes de colocar o FreeBSD para rodar,
   dependendo do ambiente. Sao eles:

     * Imagens de Maquinas Virtuais, para baixar e importar em um ambiente
       virtual da sua escolha. Elas podem ser baixadas da pagina de Download
       do FreeBSD. Existem imagens para KVM ("qcow2"), VMWare ("vmdk"),
       Hyper-V ("vhd") e imagens de dispositivos brutos (raw device) que sao
       universalmente suportadas . Estas nao sao imagens de instalac,ao, mas
       sim as instancias pre-configuradas ("ja instaladas"), prontas para
       executar e realizar tarefas de pos-instalac,ao.

     * Imagens de maquinas virtuais disponiveis no AWS Marketplace, no
       Microsoft Azure Marketplace, e na Plataforma Google Cloud, para
       executar em seus respectivos servic,os de hospedagem. Para obter
       maiores informac,oes sobre como implantar o FreeBSD no Azure, consulte
       o capitulo relevante na Documentac,ao do Azure.

     * Imagens de cartao SD, para sistemas embarcados, como Raspberry Pi ou
       BeagleBone Black. Eles podem ser baixados da pagina de Download do
       FreeBSD. Esses arquivos devem ser descompactados e gravados como uma
       imagem bruta para um cartao SD, a partir do qual a placa sera
       inicializada.

     * Imagens de instalac,ao, para instalar o FreeBSD no disco rigido de um
       desktop padrao, laptop ou servidor.

   O resto deste capitulo descreve o quarto caso, explicando como instalar o
   FreeBSD usando o programa de instalac,ao baseado em texto chamado
   bsdinstall.

   Em geral, as instruc,oes de instalac,ao neste capitulo foram escritas para
   as arquiteturas i386(TM) e AMD64. Onde aplicavel, instruc,oes especificas
   para outras plataformas serao listadas. Pode haver pequenas diferenc,as
   entre o instalador e o que e mostrado aqui, portanto, use este capitulo
   como um guia geral, e nao como um conjunto de instruc,oes literais.

  Nota:

   Usuarios que preferem instalar o FreeBSD usando um instalador grafico
   podem estar interessados no pc-sysinstall , o instalador usado pelo
   Projeto TrueOS. Ele pode ser usado para instalar um desktop grafico
   (TrueOS) ou uma versao de linha de comando do FreeBSD. Consulte o Manual
   do Usuario do TrueOS para obter detalhes
   (https://www.trueos.org/handbook/trueos.html).

   Depois de ler este capitulo, voce sabera:

     * Quais os requisitos minimos de hardware e as arquiteturas suportadas
       pelo FreeBSD.

     * Como criar a midia de instalac,ao do FreeBSD.

     * Como iniciar o bsdinstall.

     * As perguntas que o bsdinstall fara, o que elas significam e como
       responde-las.

     * Como solucionar problemas de uma instalac,ao com falha.

     * Como acessar uma versao live do FreeBSD antes de se comprometer com
       uma instalac,ao.

   Antes de ler este capitulo, voce deve:

     * Ler a lista de hardware suportado que acompanha a versao do FreeBSD
       que sera instalada e verificar se o hardware do sistema e suportado.

2.2. Requisitos minimos de hardware

   Os requisitos de hardware para instalar o FreeBSD variam por arquitetura.
   Arquiteturas de hardware e dispositivos suportados por uma release do
   FreeBSD estao listados na pagina Informac,ao de Release do FreeBSD. A
   pagina de download do FreeBSD tambem tem recomendac,oes para escolha a
   imagem correta para as diferentes arquiteturas.

   Uma instalac,ao do FreeBSD requer um minimo de 96 MB de RAM e 1,5 GB de
   espac,o livre no disco rigido. No entanto, essas pequenas quantidades de
   memoria e espac,o em disco sao realmente adequadas apenas para aplicativos
   personalizados, como dispositivos embarcados. Os sistemas de desktop de
   uso geral precisam de mais recursos. De 2 a 4 GB de RAM e pelo menos 8 GB
   de espac,o no disco rigido e um bom ponto de partida.

   Estes sao os requisitos do processador para cada arquitetura:

   amd64

           Esse e o tipo de processador de desktop e laptop mais comum, usado
           na maioria dos sistemas modernos. A Intel (R) chama ele de
           Intel64. Outros fabricantes `as vezes o chamam de x86-64.

           Exemplos de processadores compativeis com AMD64 incluem: AMD
           Athlon(TM) 64, AMD Opteron(TM), multi-core Intel(R) Xeon(TM) e
           processadores Intel(R) Core(TM) 2 e posteriores.

   i386

           Desktops e laptops mais antigos geralmente usam essa arquitetura
           x86 de 32 bits.

           Quase todos os processadores compativeis com i386 com uma unidade
           de ponto flutuante sao suportados. Todos os processadores Intel(R)
           486 ou superior sao suportados.

           O FreeBSD ira aproveitar o suporte a Extensoes de Enderec,os
           Fisicos (PAE) em CPUs com este recurso. Um kernel com o recurso
           PAE ativado detectara memoria acima de 4 GB e permitira que ela
           seja usada pelo sistema. No entanto, o uso do PAE coloca
           restric,oes em drivers de dispositivos e outros recursos do
           FreeBSD.

   powerpc

           Todos os sistemas New World ROM Apple(R) Mac(R) com USB
           incorporados sao suportados. O SMP e suportado em maquinas com
           varios CPUs.

           Um kernel de 32 bits so pode usar os primeiros 2 GB de RAM.

   sparc64

           Os sistemas suportados pelo FreeBSD/sparc64 estao listados no
           Projeto FreeBSD/sparc64.

           O SMP e suportado em todos os sistemas com mais de 1 processador.
           Um disco dedicado e necessario, pois nao e possivel compartilhar
           um disco com outro sistema operacional neste momento.

2.3. Tarefas de Pre-instalac,ao

   Uma vez determinado que o sistema atende aos requisitos minimos de
   hardware para instalar o FreeBSD, o arquivo de instalac,ao deve ser
   baixado e a midia de instalac,ao preparada. Antes de fazer isso, verifique
   se o sistema esta pronto para uma instalac,ao, verificando os itens nesta
   lista de controle:

    1. Fac,a backup dos dados importantes

       Antes de instalar qualquer sistema operacional, sempre fac,a backup de
       todos os dados importantes primeiro. Nao armazene o backup no sistema
       que esta sendo instalado. Em vez disso, salve os dados em um disco
       removivel, como uma unidade USB, outro sistema na rede ou um servic,o
       de backup online. Teste o backup antes de iniciar a instalac,ao para
       garantir que ele contenha todos os arquivos necessarios. Depois que o
       instalador formatar o disco do sistema, todos os dados armazenados
       nesse disco serao perdidos.

    2. Decida onde instalar o FreeBSD

       Se o FreeBSD for o unico sistema operacional instalado, esta etapa
       pode ser ignorada. Mas se o FreeBSD compartilhar o disco com outro
       sistema operacional, decida qual disco ou partic,ao sera usado para o
       FreeBSD.

       Nas arquiteturas i386 e amd64, os discos podem ser divididos em varias
       partic,oes usando um dos dois esquemas de particionamento. Um registro
       de inicializac,ao mestre tradicional (MBR) contem uma tabela de
       partic,ao que define ate quatro partic,oes primarias. Por razoes
       historicas, o FreeBSD chama essas partic,oes primarias de slices. Uma
       dessas partic,oes primarias pode ser transformada em uma partic,ao
       estendida contendo varias partic,oes logicas. A Tabela de Partic,ao
       GUID (GPT) e um metodo mais novo e mais simples de particionar um
       disco. Implementac,oes comuns de GPT permitem ate 128 partic,oes por
       disco, eliminando a necessidade de partic,oes logicas.

       O boot loader do FreeBSD requer uma partic,ao primaria ou GPT. Se
       todas as partic,oes primarias ou GPT ja estiverem em uso, uma deve ser
       liberada para o FreeBSD. Para criar uma partic,ao sem excluir dados
       existentes, use uma ferramenta de redimensionamento de partic,ao para
       reduzir uma partic,ao existente e criar uma nova partic,ao usando o
       espac,o liberado.

       Uma variedade de ferramentas de redimensionamento de partic,oes
       comerciais e gratuitas estao listadas em
       http://en.wikipedia.org/wiki/List_of_disk_partitioning_software. O
       GParted Live (http://gparted.sourceforge.net/livecd.php) e um live CD
       que inclui o editor de partic,oes GParted. O GParted tambem esta
       incluido em muitas outras distribuic,oes live CD do Linux.

  Atenc,ao:

       Quando usados corretamente, os utilitarios de encolhimento de disco
       podem criar espac,o com seguranc,a para criar uma nova partic,ao. Como
       existe a possibilidade de selecionar a partic,ao errada, sempre fac,a
       backup de todos os dados importantes e verifique a integridade do
       backup antes de modificar as partic,oes do disco.

       Partic,oes de disco contendo diferentes sistemas operacionais tornam
       possivel instalar varios sistemas operacionais em um computador. Uma
       alternativa e usar virtualizac,ao (Capitulo 21, Virtualizac,ao) o que
       permite que varios sistemas operacionais sejam executados ao mesmo
       tempo sem modificar nenhuma partic,ao de disco.

    3. Colete informac,oes de rede

       Alguns metodos de instalac,ao do FreeBSD requerem uma conexao de rede
       para baixar os arquivos de instalac,ao. Apos qualquer instalac,ao, o
       instalador oferecera a configurac,ao das interfaces de rede do
       sistema.

       Se a rede tiver um servidor DHCP, ele podera ser usado para fornecer
       configurac,ao de rede automatica. Se o DHCP nao estiver disponivel, as
       seguintes informac,oes de rede para o sistema devem ser obtidas com o
       administrador de rede local ou com o provedor de servic,os de
       Internet:

       Informac,oes de rede necessarias
         1. Enderec,o IP

         2. Mascara de sub-rede

         3. Enderec,o do IP do gateway padrao

         4. Nome de dominio da rede

         5. Enderec,os IP dos servidores DNS da rede

    4. Verifique a Errata do FreeBSD

       Embora o Projeto FreeBSD se esforce para garantir que cada versao do
       FreeBSD seja o mais estavel possivel, ocasionalmente, os bugs aparecem
       no processo. Em raras ocasioes, esses erros afetam o processo de
       instalac,ao. A medida que esses problemas sao descobertos e
       corrigidos, eles sao anotados na Errata do FreeBSD
       (https://www.freebsd.org/releases/12.1R/errata.html) no site do
       FreeBSD. Verifique a errata antes de instalar para certificar-se de
       que nao existem problemas que possam afetar a instalac,ao.

       Informac,oes e erratas para todos os releases podem ser encontradas na
       sec,ao de informac,oes de release do site do FreeBSD
       (https://www.freebsd.org /releases/index.html).

  2.3.1. Prepare a midia de instalac,ao

   O instalador do FreeBSD nao e um aplicativo que pode ser executado dentro
   de outro sistema operacional. Em vez disso, baixe um arquivo de
   instalac,ao do FreeBSD, grave-o na midia associada ao seu tipo e tamanho
   (CD, DVD, ou USB), e inicialize o sistema para instalar a partir da midia
   inserida.

   Os arquivos de instalac,ao do FreeBSD estao disponiveis em
   www.freebsd.org/where.html#download. O nome de cada arquivo de instalac,ao
   inclui a versao de Release do FreeBSD, a arquitetura e o tipo de arquivo.
   Por exemplo, para instalar o FreeBSD 12.1 em um sistema amd64 de um DVD,
   baixe o FreeBSD-12.1-RELEASE-amd64-dvd1.iso, grave este arquivo em um DVD,
   e inicialize o sistema com o DVD inserido.

   Os arquivos de instalac,ao estao disponiveis em varios formatos. Os
   formatos variam dependendo da arquitetura do computador e do tipo de
   midia.

   Arquivos de instalac,ao adicionais sao incluidos para computadores que
   inicializam com UEFI (Interface de Firmware Extensivel Unificada). Os
   nomes desses arquivos incluem a string uefi.

   Tipos de arquivo:

     * -bootonly.iso: Este e o menor arquivo de instalac,ao, pois contem
       apenas o instalador. E necessaria uma conexao de Internet em
       funcionamento durante a instalac,ao, pois o instalador fara o download
       dos arquivos necessarios para concluir a instalac,ao do FreeBSD. Este
       arquivo deve ser gravado em um CD usando um aplicativo de gravac,ao
       CD.

     * -disc1.iso: Este arquivo contem todos os arquivos necessarios para
       instalar o FreeBSD, seu codigo-fonte e a colec,ao de ports. Ele deve
       ser gravado em um CD usando um aplicativo de gravac,ao CD.

     * -dvd1.iso: Este arquivo contem todos os arquivos necessarios para
       instalar o FreeBSD, seu codigo-fonte e a colec,ao de ports. Ele tambem
       contem um conjunto de pacotes binarios populares para instalar um
       gerenciador de janelas e alguns aplicativos para que um sistema
       completo possa ser instalado a partir da midia sem a necessidade de
       uma conexao com a Internet. Este arquivo deve ser gravado em um DVD
       usando um aplicativo de gravac,ao DVD.

     * -memstick.img: Este arquivo contem todos os arquivos necessarios para
       instalar o FreeBSD, seu codigo-fonte e a colec,ao de ports. Ele deve
       ser gravado em um pendrive USB usando as instruc,oes abaixo.

     * -mini-memstick.img: Como -bootonly.iso , nao inclui arquivos de
       instalac,ao, mas faz o download conforme necessario. E necessaria uma
       conexao de internet em funcionamento durante a instalac,ao. Grave este
       arquivo para um pendrive USB como mostrado em Sec,ao 2.3.1.1,
       "Gravando um arquivo de imagem para um pendrive USB".

   Depois de baixar o arquivo de imagem, baixe o CHECKSUM.SHA256 do mesmo
   diretorio. Calcule o checksum para o arquivo de imagem. O FreeBSD fornece
   o sha256(1) para isso, usado como sha256 imagefilename. Outros sistemas
   operacionais possuem programas semelhantes.

   Compare o checksum calculado com a mostrado em CHECKSUM.SHA256. Os
   checksum devem corresponder exatamente. Se os checksums nao
   corresponderem, o arquivo de imagem esta corrompido e deve ser baixado
   novamente.

    2.3.1.1. Gravando um arquivo de imagem para um pendrive USB

   O arquivo *. Img e uma imagem do conteudo completo de um cartao de
   memoria. Ele nao pode ser copiado para o dispositivo de destino como um
   arquivo. Varias aplicac,oes estao disponiveis para escrever o *. Img para
   um pendrive USB. Esta sec,ao descreve dois destes utilitarios.

  Importante:

   Antes de continuar, fac,a backup de todos os dados importantes do pendrive
   USB. Este procedimento ira apagar todos os dados existentes no mesmo.

   Procedimento 2.1. Usando o dd para gravar a imagem

  Atenc,ao:

   Este exemplo usa /dev/da0 como o dispositivo de destino em que a imagem
   sera gravada. Seja muito cuidadoso para que o dispositivo correto seja
   usado, pois esse comando destruira os dados existentes no dispositivo de
   destino especificado.

     * O utilitario de linha de comando dd(1) esta disponivel no BSD, no
       Linux(R) e no Mac OS(R). Para gravar a imagem usando o dd, insira o
       pendrive USB e determine o nome do dispositivo. Em seguida,
       especifique o nome do arquivo de instalac,ao baixado e o nome do
       dispositivo para o pendrive USB. Este exemplo grava a imagem de
       instalac,ao amd64 no primeiro dispositivo USB em um sistema FreeBSD
       existente.

 # dd if=FreeBSD-12.1-RELEASE-amd64-memstick.img of=/dev/da0 bs=1M conv=sync

       Se este comando falhar, verifique se o pendrive USB nao esta montado e
       se o nome do dispositivo aponta para o disco, nao para uma partic,ao.
       Alguns sistemas operacionais podem requerer que este comando seja
       executado com o sudo(8). A sintaxe do dd(1) varia ligeiramente em
       diferentes plataformas; por exemplo, o Mac OS(R) requer um bs=1m em
       minusculas. Sistemas como o Linux(R) podem gravar em buffer. Para
       forc,ar todas as gravac,oes a serem concluidas, use o comando sync(8).

   Procedimento 2.2. Usando o Windows(R) para gravar a imagem

  Atenc,ao:

   Certifique-se de fornecer a letra da unidade correta, pois os dados
   existentes na unidade especificada serao sobrescritos e destruidos.

    1. Obtendo o Image Writer para Windows(R)

       O Image Writer para Windows(R) e um aplicativo gratuito que pode
       gravar corretamente um arquivo de imagem em um cartao de memoria.
       Fac,a o download a partir de
       https://sourceforge.net/projects/win32diskimager/ e extraia-o em uma
       pasta.

    2. Escrevendo a imagem com o Image Writer

       Clique duas vezes no icone Win32DiskImager para iniciar o programa.
       Verifique se a letra da unidade mostrada em Device e a unidade com o
       cartao de memoria. Clique no icone da pasta e selecione a imagem a ser
       gravada no cartao de memoria. Clique em [ Save ] para aceitar o nome
       do arquivo de imagem. Verifique se tudo esta correto e se nenhuma
       pasta do cartao de memoria esta aberta em outras janelas. Quando tudo
       estiver pronto, clique em [Write] para gravar o arquivo de imagem no
       cartao de memoria.

   Agora voce esta pronto para comec,ar a instalar o FreeBSD.

2.4. Iniciando a instalac,ao

  Importante:

   Por padrao, a instalac,ao nao fara alterac,oes no(s) disco(s) antes da
   seguinte mensagem:

 Your changes will now be written to disk. If you
 have chosen to overwrite existing data, it will
 be PERMANENTLY ERASED. Are you sure you want to
 commit your changes?

   A instalac,ao pode ser encerrada a qualquer momento antes deste aviso. Se
   houver uma preocupac,ao de que algo esteja configurado incorretamente,
   basta desligar o computador antes desse ponto e nenhuma alterac,ao sera
   feita nos discos do sistema.

   Esta sec,ao descreve como inicializar o sistema a partir da midia de
   instalac,ao que foi preparada usando as instruc,oes em Sec,ao 2.3.1,
   "Prepare a midia de instalac,ao". Ao usar um dispositivo USB
   inicializavel, conecte o dispositivo USB antes de ligar o computador. Ao
   inicializar a partir do CD ou do DVD, ligue o computador e insira a midia
   na primeira oportunidade. O procedimento para configurar o sistema para
   inicializar a partir da midia inserida depende da arquitetura.

  2.4.1. Inicializando em i386(TM) e amd64

   Estas arquiteturas fornecem um menu BIOS para selecionar o dispositivo de
   inicializac,ao. Dependendo da midia de instalac,ao usada, selecione o
   dispositivo de CD/DVD ou o USB como o primeiro dispositivo de
   inicializac,ao. A maioria dos sistemas tambem fornece uma chave para
   selecionar o dispositivo durante a inicializac,ao sem ter que entrar no
   BIOS. Normalmente, a chave e F10, F11, F12 ou Escape.

   Se o computador carregar o sistema operacional existente em vez do
   instalador do FreeBSD, entao:

    1. A midia de instalac,ao nao foi inserida cedo o suficiente no processo
       de inicializac,ao. Deixe a midia inserida e tente reiniciar o
       computador.

    2. As alterac,oes do BIOS estavam incorretas ou nao foram salvas.
       Verifique novamente se o dispositivo de inicializac,ao correto esta
       selecionado como o primeiro dispositivo de inicializac,ao.

    3. Este sistema e muito antigo para suportar a inicializac,ao a partir da
       midia escolhida. Neste caso, o Plop Boot Manager
       (http://www.plop.at/en/bootmanagers.html) pode ser usado para
       inicializar o sistema a partir da midia selecionada.

  2.4.2. Inicializando no PowerPC(R)

   Na maioria das maquinas, manter pressionado o C no teclado durante a
   inicializac,ao ira inicializar a partir do CD. Caso contrario, mantenha
   pressionados Command+Option+O+F, ou Windows+Alt+O+F em teclados
   nao-Apple(R). No prompt 0 >, digite

 boot cd:,\ppc\loader cd:0

  2.4.3. Inicializando no SPARC64 (R)

   A maioria dos sistemas SPARC64(R) sao configurados para inicializar
   automaticamente a partir do disco. Para instalar o FreeBSD de um CD,
   requer uma pausa no PROM.

   Para fazer isso, reinicialize o sistema e aguarde ate que a mensagem de
   inicializac,ao aparec,a. A mensagem depende do modelo, mas deve ser algo
   como isto:

 Sun Blade 100 (UltraSPARC-IIe), Keyboard Present
 Copyright 1998-2001 Sun Microsystems, Inc.  All rights reserved.
 OpenBoot 4.2, 128 MB memory installed, Serial #51090132.
 Ethernet address 0:3:ba:b:92:d4, Host ID: 830b92d4.

   Se o sistema passar a inicializar a partir do disco neste ponto, pressione
   L1+A ou Stop+A no teclado, ou envie um BREAK pelo console serial. Ao usar
   o tip ou o cu, ~# ira emitir um BREAK. O prompt PROM sera ok em sistemas
   com uma CPU e ok {0} em sistemas SMP, onde o digito indica o numero da CPU
   ativa.

   Neste ponto, coloque o CD na unidade e digite boot cdrom no prompt PROM.

  2.4.4. Menu de inicializac,ao do FreeBSD

   Quando o sistema inicializar a partir da midia de instalac,ao, um menu
   semelhante ao seguinte sera exibido:

   Figura 2.1. Menu do FreeBSD Boot Loader
   Menu do FreeBSD Boot Loader

   Por padrao, o menu ira esperar dez segundos por uma ac,ao do usuario antes
   de inicializar no instalador do FreeBSD ou, se o FreeBSD ja estiver
   instalado, antes de inicializar no FreeBSD. Para pausar o cronometro de
   inicializac,ao para rever as selec,oes, pressione Espac,o. Para selecionar
   uma opc,ao, pressione seu numero, caractere ou tecla destacada. As
   seguintes opc,oes estao disponiveis.

     * Boot Multi User: Isto ira continuar o processo de inicializac,ao do
       FreeBSD. Se o temporizador de boot tiver sido pausado, pressione 1, B
       maiusculo ou minusculo ou Enter.

     * Boot Single User: Este modo pode ser usado para corrigir uma
       instalac,ao existente do FreeBSD como descrito em Sec,ao 12.2.4.1,
       "Modo Single-User". Pressione 2 ou S maiusculo ou minusculo para
       entrar neste modo.

     * Escape to loader prompt: Isso inicializara o sistema em um prompt de
       reparo que contem um numero limitado de comandos de baixo nivel. Este
       prompt e descrito em Sec,ao 12.2.3, "Estagio tres". Pressione 3 ou Esc
       para inicializar neste prompt.

     * Reboot: Reinicia o sistema.

     * Kernel: Carrega um kernel diferente.

     * Configure Boot Options: Abre o menu mostrado e descrito em Figura 2.2,
       "Menu de Opc,oes de Inicializac,ao do FreeBSD".

   Figura 2.2. Menu de Opc,oes de Inicializac,ao do FreeBSD
   Menu de Opc,oes de Inicializac,ao do FreeBSD

   O menu de opc,oes de inicializac,ao e dividido em duas sec,oes. A primeira
   sec,ao pode ser usada para retornar ao menu de inicializac,ao principal ou
   para redefinir quaisquer opc,oes que tenham sido alteradas de volta para
   seus valores padroes.

   A proxima sec,ao e usada para alternar as opc,oes disponiveis para On ou
   Off pressionando o numero ou caractere realc,ado da opc,ao. O sistema
   sempre inicializara usando as configurac,oes dessas opc,oes ate serem
   modificadas. Varias opc,oes podem ser alternadas usando este menu:

     * ACPI Support: Se o sistema travar durante a inicializac,ao, tente
       alternar essa opc,ao para Off.

     * Safe Mode: Se o sistema ainda travar durante a inicializac,ao, mesmo
       com Suporte a ACPI definido como Off, tente definir esta opc,ao como
       On.

     * Single User: Alterne esta opc,ao para On para corrigir uma instalac,ao
       existente do FreeBSD como descrito em Sec,ao 12.2.4.1, "Modo
       Single-User". Depois que o problema for corrigido, configure-o de
       volta para Off.

     * Verbose: Alterne esta opc,ao para On para ver mensagens mais
       detalhadas durante o processo de inicializac,ao. Isso pode ser util ao
       solucionar problemas de hardware.

   Depois de fazer as selec,oes necessarias, pressione 1 ou Backspace para
   retornar ao menu de boot principal, entao pressione Enter para continuar a
   inicializac,ao no FreeBSD. Uma serie de mensagens de inicializac,ao irao
   aparecer enquanto o FreeBSD executa seus testes de dispositivos de
   hardware e carrega o programa de instalac,ao. Quando a inicializac,ao
   estiver concluida, o menu de boas-vindas mostrado em Figura 2.3, "Menu de
   boas-vindas" sera exibido.

   Figura 2.3. Menu de boas-vindas
   Menu de boas-vindas

   Pressione Enter para selecionar o padrao de [Install] para entrar no
   instalador. O restante deste capitulo descreve como usar este instalador.
   Caso contrario, use as setas para a direita ou para a esquerda ou a letra
   colorida para selecionar o item de menu desejado. A opc,ao [Shell] pode
   ser usada para acessar um shell do FreeBSD, a fim de usar utilitarios de
   linha de comando para preparar os discos antes da instalac,ao. A opc,ao
   [Live CD] pode ser usada para testar o FreeBSD antes de instala-lo. A
   versao live e descrita em Sec,ao 2.10, "Usando o Live CD".

  Dica:

   Para revisar as mensagens de inicializac,ao, incluindo o probe do
   dispositivo de hardware, pressione a tecla S maiuscula ou minuscula e, em
   seguida, Enter para acessar um shell. No prompt do shell, digite more
   /var/run/dmesg.boot e use a barra de espac,o para rolar pelas mensagens.
   Quando terminar, digite exit para retornar ao menu de boas-vindas.

2.5. Usando o bsdinstall

   Esta sec,ao mostra a ordem dos menus do bsdinstall e o tipo de informac,ao
   que sera solicitada antes que o sistema seja instalado. Use as teclas de
   seta para realc,ar uma opc,ao de menu e, em seguida, a barra de Espac,o
   para selecionar ou desmarcar esse item de menu. Quando terminar, pressione
   Enter para salvar a selec,ao e passar para a proxima tela.

  2.5.1. Selecionando o menu do Keymap (Mapa de teclas)

   Antes de iniciar o processo, o bsdinstall carregara os arquivos de keymap
   como mostrado em Figura 2.4, "Carregamento de Keymap".

   Figura 2.4. Carregamento de Keymap
   Carregamento de Keymap

   Apos o carregamento dos keymaps, o bsdinstall exibe o menu mostrado em
   Figura 2.5, "Menu de Selec,ao do Keymap". Use as setas para cima e para
   baixo para selecionar o mapa de teclas que mais representa o mapeamento do
   teclado conectado ao sistema. Pressione Enter para salvar a selec,ao.

   Figura 2.5. Menu de Selec,ao do Keymap
   Menu de Selec,ao do Keymap

  Nota:

   Pressionar Esc saira deste menu e usara o mapa de teclas padrao. Se a
   escolha do mapa de teclado nao for clara, a opc,ao United States of
   America ISO-8859-1 e uma opc,ao segura.

   Alem disso, ao selecionar um keymap diferente, o usuario pode testar o
   keymap e garantir que esteja correto antes de continuar, conforme mostrado
   em Figura 2.6, "Menu de Teste do Keymap".

   Figura 2.6. Menu de Teste do Keymap
   Menu de Teste do Keymap

  2.5.2. Configurando o nome do host

   O proximo menu do bsdinstall e usado para definir o nome do host para o
   sistema recem-instalado.

   Figura 2.7. Configurando o nome do host
   Configurando o nome do host

   Digite um nome de host exclusivo para a rede. Ele deve ser um nome de host
   totalmente qualificado, como machine3.example.com.

  2.5.3. Selecionando Componentes para Instalar

   Em seguida, o bsdinstall solicitara a selec,ao de componentes opcionais
   para instalac,ao.

   Figura 2.8. Selecionando Componentes para Instalar
   Selecionando Componentes para Instalar

   Decidir quais componentes instalar dependera em grande parte do uso
   pretendido para o sistema e da quantidade de espac,o em disco disponivel.
   O kernel do FreeBSD e o userland, coletivamente conhecidos como o sistema
   base, sao sempre instalados. Dependendo da arquitetura, alguns desses
   componentes podem nao aparecer:

     * base-dbg - Ferramentas basicas como cat, ls entre outras com simbolos
       de depurac,ao ativados.

     * kernel-dbg - Kernel e modulos com simbolos de depurac,ao ativados.

     * lib32-dbg - Bibliotecas de compatibilidade para executar aplicativos
       de 32 bits em uma versao de 64 bits do FreeBSD com simbolos de
       depurac,ao ativados.

     * lib32 - Bibliotecas de compatibilidade para executar aplicativos de 32
       bits em uma versao de 64 bits do FreeBSD.

     * ports - A Colec,ao de Ports do FreeBSD e uma colec,ao de arquivos que
       automatiza o download, a compilac,ao e a instalac,ao de pacotes de
       software de terceiros. Capitulo 4, Instalando Aplicativos: Pacotes e
       Ports discute como usar a colec,ao de ports.

  Atenc,ao:

       O programa de instalac,ao nao verifica o espac,o em disco adequado.
       Selecione esta opc,ao apenas se houver espac,o suficiente no disco
       rigido. A Colec,ao de Ports do FreeBSD ocupa cerca de 500 MB de
       espac,o em disco.

     * src - O codigo-fonte completo do FreeBSD para o kernel e para o
       userland. Embora nao seja necessario para a maioria dos aplicativos,
       pode ser necessario para compilar drivers de dispositivo, modulos do
       kernel ou alguns aplicativos da Colec,ao de Ports. Ele tambem e usado
       para desenvolver o proprio FreeBSD. A arvore de codigo-fonte completa
       requer 1 GB de espac,o em disco e a recompilac,ao de todo o sistema
       FreeBSD requer 5 GB adicionais de espac,o.

     * tests - FreeBSD Test Suite.

  2.5.4. Instalando a partir da rede

   O menu mostrado em Figura 2.9, "Instalando a partir da rede" so aparece ao
   instalar a partir de um CD -bootonly.iso pois esta midia de instalac,ao
   nao possui uma copias dos arquivos de instalac,ao. Como os arquivos de
   instalac,ao devem ser recuperados atraves de uma conexao de rede, esse
   menu indica que a interface de rede deve ser configurada primeiro.

   Figura 2.9. Instalando a partir da rede
   Instalando a partir da rede

   Para configurar a conexao de rede, pressione Enter e siga as instruc,oes
   em Sec,ao 2.8.2, "Configurando as Interfaces de Rede". Quando a interface
   estiver configurada, selecione um site espelho localizado na mesma regiao
   do mundo que o computador no qual o FreeBSD esta sendo instalado. Os
   arquivos podem ser recuperados mais rapidamente quando o espelho esta
   proximo ao computador de destino, reduzindo o tempo de instalac,ao.

   Figura 2.10. Escolhendo um Site Espelho
   Escolhendo um Site Espelho

   A instalac,ao continuara como se os arquivos de instalac,ao estivessem
   localizados na midia de instalac,ao local.

2.6. Alocando o espac,o em disco

   O proximo menu e usado para determinar o metodo de alocac,ao de espac,o em
   disco. As opc,oes disponiveis no menu dependem da versao do FreeBSD sendo
   instalada.

   Figura 2.11. Opc,oes de Particionamento
   Opc,oes de Particionamento

   bsdinstall fornece ao usuario quatro metodos para alocar espac,o em disco:

     * O particionamento Auto (UFS) configura automaticamente as partic,oes
       do disco usando o sistema de arquivos UFS.

     * O particionamento Manual permite que usuarios avanc,ados criem
       partic,oes personalizadas a partir das opc,oes de menu.

     * Shell abre um prompt de shell no qual usuarios avanc,ados podem criar
       partic,oes personalizadas usando utilitarios de linha de comando como
       gpart(8), fdisk(8), e bsdlabel(8).

     * O particionamento Auto (ZFS) cria um sistema root-on-ZFS com suporte
       opcional `a criptografia GELI para boot environments.

   Esta sec,ao descreve o que considerar ao definir as partic,oes de disco.
   Em seguida, demonstra como usar os diferentes metodos de particionamento.

  2.6.1. Criando o layout da partic,ao

   Ao criar os sistemas de arquivos, lembre-se de que os discos rigidos
   transferem dados mais rapidamente das trilhas externas para as internas.
   Assim, sistemas de arquivos menores e mais acessados devem estar mais
   proximos da parte externa da unidade, enquanto partic,oes maiores, como
   /usr, devem ser colocadas em direc,ao `as partes internas do disco. E uma
   boa ideia criar partic,oes em uma ordem similar a: /, swap, /var e /usr.

   O tamanho da partic,ao /var reflete o uso pretendido para a maquina. Esta
   partic,ao e usada para armazenar caixas de correio, arquivos de log e
   spools de impressora. Caixas de correio e arquivos de log podem crescer
   ate tamanhos inesperados, dependendo do numero de usuarios e de quanto
   tempo os arquivos de log sao mantidos. Na media, a maioria dos usuarios
   raramente precisa de mais do que cerca de um gigabyte de espac,o livre em
   disco no /var.

  Nota:

   As vezes, e necessario muito espac,o em disco no /var/tmp. Quando um novo
   software e instalado, as ferramentas de empacotamento extraem uma copia
   temporaria dos pacotes no /var/tmp. Grandes pacotes de software, como o
   Firefox ou LibreOffice podem ser dificeis de instalar se nao houver
   espac,o em disco suficiente no /var/tmp.

   A partic,ao /usr contem muitos dos arquivos que suportam o sistema,
   incluindo o a Colec,ao de Ports do FreeBSD e o codigo-fonte do sistema.
   Pelo menos 2 gigabytes de espac,o sao recomendados para esta partic,ao.

   Ao selecionar os tamanhos das partic,oes, lembre-se dos requisitos de
   espac,o. Ficar sem espac,o em uma partic,ao enquanto mal usa outra pode
   ser um aborrecimento.

   Como regra geral, a partic,ao swap deve ter o dobro do tamanho da memoria
   fisica (RAM). Sistemas com pouca memoria RAM podem ter um melhor
   desempenho com mais swap. Configurar um swap pequeno pode levar a
   ineficiencias no codigo de verificac,ao de pagina da VM e pode criar
   problemas mais tarde, se mais memoria for adicionada.

   Em sistemas maiores com varios discos SCSI ou varios discos IDE operando
   em diferentes controladoras, e recomendavel que uma area de swap seja
   configurada em cada unidade, ate quatro unidades. As partic,oes de swap
   devem ter aproximadamente o mesmo tamanho. O kernel pode manipular
   tamanhos arbitrarios, mas as estruturas internas de dados podem ser
   dimensionadas para 4 vezes a maior partic,ao de swap. Manter as partic,oes
   de swap proximas do mesmo tamanho permitira que o kernel otimize o espac,o
   de swap entre discos. Partic,oes grandes de swap sao uma coisa boa, mesmo
   se o swap nao for muito usado. Pode ser mais facil de se recuperar de um
   programa devorador de memoria antes de ser forc,ado a reinicializar.

   Ao particionar adequadamente um sistema, a fragmentac,ao introduzida nas
   partic,oes menores e intensas em gravac,ao nao vai prejudicar as
   partic,oes que sao maioritariamente de leitura. Manter as partic,oes com
   maior carga de gravac,ao mais proximas da borda do disco aumentara o
   desempenho de I/O nas partic,oes onde ela e mais necessaria. Embora o
   desempenho de I/O nas partic,oes maiores possa ser necessario, muda-las
   mais para a borda do disco nao levara a uma melhoria de desempenho
   significativa em relac,ao `a movimentac,ao de /var para a borda.

  2.6.2. Particionamento Guiado Usando UFS

   Quando este metodo e selecionado, um menu exibira o(s) disco(s)
   disponivel(s). Se varios discos estiverem conectados, escolha aquele em
   que o FreeBSD deve ser instalado.

   Figura 2.12. Selecionando a partir de varios discos
   Selecionando a partir de varios discos

   Depois que o disco e selecionado, o proximo menu solicita a instalac,ao no
   disco inteiro ou a criac,ao de uma partic,ao usando o espac,o livre. Se [
   Entire Disk ] for escolhido, um layout de partic,ao geral que preenche
   todo o disco e criado automaticamente. Selecionar [Partition] cria um
   layout de partic,ao do espac,o nao utilizado no disco.

   Figura 2.13. Selecionando todo o disco ou partic,ao
   Selecionando todo o disco ou partic,ao

   Apos [ Entire Disk ] ser escolhido, bsdinstall exibe uma caixa de dialogo
   indicando que o disco sera apagado.

   Figura 2.14. Confirmac,ao
   Confirmac,ao

   O proximo menu mostra uma lista com os tipos de esquema de partic,ao. O
   GPT e geralmente a opc,ao mais apropriada para computadores amd64.
   Computadores mais antigos que nao sao compativeis com o GPT devem usar o
   MBR. Os outros esquemas de partic,ao sao geralmente usados para
   computadores incomuns ou antigos. Mais informac,oes estao disponiveis em
   Tabela 2.1, "Esquemas de Particionamento".

   Figura 2.15. Selecionar Esquema de Particionamento
   Selecionar Esquema de Particionamento

   Depois que o layout da partic,ao tiver sido criado, revise-o para garantir
   que ele atenda `as necessidades da instalac,ao. Selecionar [ Revert ]
   redefinira as partic,oes para seus valores originais e pressionar [Auto]
   recriara as partic,oes automaticas do FreeBSD. As partic,oes tambem podem
   ser criadas, modificadas ou excluidas manualmente. Quando o
   particionamento estiver correto, selecione [Finish] para continuar com a
   instalac,ao.

   Figura 2.16. Revise as partic,oes criadas
   Revise as partic,oes criadas

   Depois que os discos sao configurados, o proximo menu fornece a ultima
   chance de fazer alterac,oes antes que os discos selecionados sejam
   formatados. Se for necessario fazer alterac,oes, selecione [Back] para
   retornar ao menu principal de particionamento. [ Revert & Exit ] saira do
   instalador sem fazer alterac,oes no disco. Selecione [ Commit ] para
   iniciar o processo de instalac,ao.

   Figura 2.17. Confirmac,ao final
   Confirmac,ao final

   Para continuar com o processo de instalac,ao, va para Sec,ao 2.7, "Fazendo
   o download dos arquivos de distribuic,ao".

  2.6.3. Particionamento Manual

   Selecionar este metodo abre o editor de partic,oes:

   Figura 2.18. Criar partic,oes manualmente
   Criar partic,oes manualmente

   Realce a unidade de instalac,ao (ada0 neste exemplo) e selecione [ Create
   ] para exibir um menu dos esquemas de partic,ao disponiveis:

   Figura 2.19. Criar partic,oes manualmente
   Criar partic,oes manualmente

   O GPT e geralmente a opc,ao mais apropriada para computadores amd64.
   Computadores mais antigos que nao sao compativeis com o GPT devem usar o
   MBR. Os outros esquemas de partic,ao sao geralmente usados para
   computadores incomuns ou antigos.

   Tabela 2.1. Esquemas de Particionamento

   Abreviac,ao Descric,ao                                                     
   APM         Apple Partition Map, usado no PowerPC(R).                      
               O Label BSD sem um MBR, `as vezes chamado de modo              
   BSD         perigosamente dedicado porque os utilitarios de discos nao BSD 
               podem nao reconhece-lo.                                        
   GPT         Tabela de Partic,ao GUID (                                     
               http://en.wikipedia.org/wiki/GUID_Partition_Table ).           
   MBR         Registro mestre de inicializac,ao ou MBR (                     
               http://en.wikipedia.org/wiki/Master_boot_record ).             
   VTOC8       Tabela de Volume do Conteudo usado pelos computadores Sun      
               SPARC64 e UltraSPARC.                                          

   Depois que o esquema de particionamento for selecionado e criado,
   selecione [Create] novamente para criar as partic,oes.A tecla Tab e
   utilizada para navegac,ao entre os campos.

   Figura 2.20. Criar partic,oes manualmente
   Criar partic,oes manualmente

   Uma instalac,ao padrao do FreeBSD GPT usa pelo menos tres partic,oes:

     * freebsd-boot - Mantem o codigo de inicializac,ao do FreeBSD.

     * freebsd-ufs - Um sistema de arquivos UFS do FreeBSD.

     * freebsd-zfs - Um sistema de arquivos ZFS do FreeBSD. Mais informac,oes
       sobre o ZFS estao disponiveis em Capitulo 19, O sistema de arquivos Z
       (ZFS).

     * freebsd-swap - Espac,o de swap do FreeBSD.

   Consulte gpart(8) para obter informac,oes de todos os tipos de partic,oes
   GPT disponiveis.

   Varias partic,oes do sistema de arquivos podem ser criadas e algumas
   pessoas preferem um layout tradicional com partic,oes separadas para /,
   /var, /tmp e /usr. Veja Exemplo 2.1, "Criando partic,oes tradicionais para
   um sistema de arquivos dividido" para um exemplo.

   O tamanho pode ser digitado com abreviac,oes comuns: K para kilobytes, M
   para megabytes, ou G para gigabytes.

  Dica:

   O alinhamento adequado do setor fornece o melhor desempenho, e ao definir
   os tamanhos das partic,oes em multiplos de 4K bytes ajuda a garantir o
   alinhamento em discos com setores de 512 ou 4 bytes. Geralmente, usar
   tamanhos de partic,oes que sao multiplos de 1M ou 1G e a maneira mais
   facil de garantir que cada partic,ao comece em um multiplo par de 4K. Ha
   uma excec,ao: a partic,ao freebsd-boot nao deve ser maior que 512K devido
   `as limitac,oes atuais do codigo de inicializac,ao.

   Um Mountpoint e necessario se a partic,ao contiver um sistema de arquivos.
   Se apenas uma unica partic,ao UFS for criada, o ponto de montagem deve ser
   /.

   O Label e um nome pelo qual a partic,ao sera conhecida. Nomes ou numeros
   de unidades podem mudar se a unidade estiver conectada a um controlador ou
   porta diferente, mas a etiqueta da partic,ao nao muda. Referir-se a
   rotulos em vez de nomes de unidade e numeros de partic,ao em arquivos como
   o /etc/fstab torna o sistema mais tolerante a alterac,oes de hardware. Os
   rotulos GPT aparecem em /dev/gpt/ quando um disco e anexado. Outros
   esquemas de particionamento tem diferentes capacidades de rotulos e seus
   rotulos aparecem em diferentes diretorios no /dev/.

  Dica:

   Use um rotulo unico e exclusivo para cada uma das partic,oes para evitar
   conflitos de rotulos identicos. Algumas letras do nome, uso ou
   localizac,ao do computador podem ser adicionadas ao rotulo. Por exemplo,
   use labroot ou rootfslab para a partic,ao raiz UFS no computador chamado
   lab.

   Exemplo 2.1. Criando partic,oes tradicionais para um sistema de arquivos
   dividido

   Para um layout de partic,ao tradicional em que os diretorios /, /var, /tmp
   e /usr sao sistemas de arquivos separados em suas proprias partic,oes,
   crie um esquema de particionamento GPT e crie as partic,oes conforme
   mostrado. Os tamanhos de partic,ao mostrados sao tipicos para um disco de
   destino de 20G. Se houver mais espac,o disponivel no disco de destino,
   partic,oes maiores de swap ou /var podem ser uteis. Os rotulos mostrados
   aqui sao prefixados com ex para "exemplo", mas os leitores devem usar
   outros valores de rotulo exclusivos, conforme descrito acima.

   Por padrao, o gptboot do FreeBSD espera que a primeira partic,ao UFS seja
   a partic,ao /.

   Tipo de Partic,ao            Tamanho            Ponto de montagem  Rotulo  
   freebsd-boot      512K                                                     
   freebsd-ufs       2G                            /                 exrootfs 
   freebsd-swap      4G                                              exswap   
   freebsd-ufs       2G                            /var              exvarfs  
   freebsd-ufs       1G                            /tmp              extmpfs  
   freebsd-ufs       aceite o padrao (restante do  /usr              exusrfs  
                     disco)                        

   Depois que as partic,oes personalizadas forem criadas, selecione [Finish]
   para continuar com a instalac,ao e va para Sec,ao 2.7, "Fazendo o download
   dos arquivos de distribuic,ao".

  2.6.4. Particionamento Guiado Usando Root-on-ZFS

   O suporte para criac,ao automatica de instalac,oes root-on-ZFS foi
   adicionado no FreeBSD 10.0-RELEASE. Este modo de particionamento so
   funciona com discos inteiros e apaga o conteudo de todo o disco. O
   instalador criara automaticamente partic,oes alinhadas a limites de 4k e
   forc,ara o ZFS a usar setores 4k. Isso e seguro mesmo com discos de setor
   de 512 bytes e tem o beneficio adicional de garantir que os pools criados
   em discos de 512 bytes possam ter discos de setor de 4k adicionados no
   futuro, como espac,o de armazenamento adicional ou como substitutos para
   discos com falha. O instalador tambem pode opcionalmente empregar a
   criptografia de disco GELI conforme descrito em Sec,ao 17.12.2,
   "Criptografia de Disco com geli". Se a criptografia estiver ativada, um
   conjunto de inicializac,ao nao criptografado de 2 GB contendo o diretorio
   /boot sera criado. Ele contem o kernel e outros arquivos necessarios para
   inicializar o sistema. Uma partic,ao swap de um tamanho selecionavel pelo
   usuario tambem e criada, e todo o espac,o restante e usado para o pool do
   ZFS.

   O menu de configurac,ao principal do ZFS oferece varias opc,oes para
   controlar a criac,ao do pool.

   Figura 2.21. Menu de particionamento do ZFS
   Menu de particionamento do ZFS

   Selecione T para configurar o Pool Type e o(s) disco(s) que constituirao o
   pool. O instalador automatico do ZFS atualmente suporta apenas a criac,ao
   de um unico vdev de nivel superior, exceto no modo de stripe. Para criar
   conjuntos mais complexos, use as instruc,oes em Sec,ao 2.6.5,
   "Particionamento do modo shell" para criar o pool. O instalador suporta a
   criac,ao de varios tipos de conjuntos, incluindo stripe (nao recomendada,
   sem redundancia), mirror (melhor desempenho, menos espac,o utilizavel) e
   RAID-Z 1, 2 e 3 (com capacidade para suportar a falha simultanea de 1, 2 e
   3 discos, respectivamente). Ao selecionar o tipo de pool, uma dica e
   exibida na parte inferior da tela com conselhos sobre o numero de discos
   necessarios e, no caso de RAID-Z, o numero ideal de discos para cada
   configurac,ao.

   Figura 2.22. Tipo de pool ZFS
   Tipo de pool ZFS

   Quando um Tipo de pool tiver sido selecionado, uma lista de discos
   disponiveis sera exibida e o usuario sera solicitado a selecionar um ou
   mais discos para compor o pool. A configurac,ao e validada para garantir
   que discos suficientes sejam selecionados. Caso contrario, selecione
   <Change Selection> para retornar `a lista de discos ou <Cancel> para
   alterar o tipo de conjunto.

   Figura 2.23. Selec,ao de disco
   Selec,ao de disco
   Figura 2.24. Selec,ao invalida
   Selec,ao invalida

   Se um ou mais discos estiverem faltando na lista, ou se os discos foram
   anexados depois que o instalador foi iniciado, selecione - Rescan Devices
   para preencher novamente a lista de discos disponiveis. Para evitar apagar
   acidentalmente o disco errado, o menu - Disk Info pode ser usado para
   inspecionar cada disco, incluindo sua tabela de partic,ao e varias outras
   informac,oes, como o numero do modelo do dispositivo e o numero de serie,
   se disponiveis.

   Figura 2.25. Analisando um disco
   Analisando um disco

   O principal menu de configurac,ao do ZFS tambem permite que o usuario
   insira um nome de pool, desabilite a opc,ao que forc,a setores 4k,
   habilite ou desabilite a criptografia, alterne entre os tipos de tabela de
   partic,oesGPT (recomendado) ou MBR e selecione a quantidade de espac,o de
   swap. Quando todas as opc,oes tiverem sido definidas para os valores
   desejados, selecione o >>> Install no topo do menu.

   Se a criptografia de disco GELI foi ativada, o instalador solicitara duas
   vezes que a frase secreta seja usada para criptografar os discos.

   Figura 2.26. Senha de criptografia de disco
   Senha de criptografia de disco

   O instalador oferece uma ultima chance de cancelar antes que o conteudo
   das unidades selecionadas seja destruido para criar o pool do ZFS.

   Figura 2.27. Ultima chance
   Ultima chance

   A instalac,ao prossegue normalmente.

  2.6.5. Particionamento do modo shell

   Ao criar instalac,oes avanc,adas, os menus de particionamento do
   bsdinstall podem nao fornecer o nivel de flexibilidade necessario.
   Usuarios avanc,ados podem selecionar a opc,ao Shell no menu de
   particionamento para particionar manualmente as unidades, criar o(s)
   sistema(s) de arquivos, preencher o /tmp/bsdinstall_etc/fstab e montar os
   sistemas de arquivos em /mnt. Feito isso, digite exit para retornar ao
   bsdinstall e continue com a instalac,ao.

2.7. Fazendo o download dos arquivos de distribuic,ao

   O tempo de instalac,ao ira variar dependendo das distribuic,oes
   escolhidas, midia de instalac,ao e velocidade do computador. Uma serie de
   mensagens indicara o progresso.

   Primeiro, o instalador formata o(s) disco(s) selecionado(s) e inicializa
   as partic,oes. Em seguida, no caso de uma bootonly media ou mini memstick,
   ele faz o download dos componentes selecionados:

   Figura 2.28. Fazendo o download dos arquivos de distribuic,ao
   Fazendo o download dos arquivos de distribuic,ao

   Em seguida, a integridade dos arquivos de distribuic,ao e verificada para
   garantir que eles nao tenham sido corrompidos durante o download ou mal
   interpretados da midia de instalac,ao:

   Figura 2.29. Verificando arquivos de distribuic,ao
   Verificando arquivos de distribuic,ao

   Finalmente, os arquivos de distribuic,ao verificados sao extraidos para o
   disco:

   Figura 2.30. Extraindo arquivos de distribuic,ao
   Extraindo arquivos de distribuic,ao

   Depois que todos os arquivos de distribuic,ao solicitados tiverem sido
   extraidos, o bsdinstall exibira a primeira tela de configurac,ao
   pos-instalac,ao. As opc,oes de configurac,ao pos-instalac,ao disponiveis
   estao descritas na proxima sec,ao.

2.8. Pos-instalac,ao

   Uma vez instalado o FreeBSD, o bsdinstall solicitara a configurac,ao de
   varias opc,oes antes de inicializar o sistema recem-instalado. Esta sec,ao
   descreve essas opc,oes de configurac,ao.

  Dica:

   Depois que o sistema inicializa, o bsdconfig fornece um metodo orientado
   por menus para configurar o sistema usando essas e outras opc,oes.

  2.8.1. Definindo a Senha de root

   Primeiro, a senha do root deve ser definida. Ao digitar a senha, os
   caracteres digitados nao sao exibidos na tela. Depois que a senha for
   digitada, ela deve ser digitada novamente. Isso ajuda a evitar erros de
   digitac,ao.

   Figura 2.31. Definindo a Senha de root
   Definindo a Senha de root

  2.8.2. Configurando as Interfaces de Rede

   Em seguida, e mostrada uma lista das interfaces de rede encontradas no
   computador. Selecione a interface para configurar.

  Nota:

   Os menus de configurac,ao de rede serao ignorados se a rede tiver sido
   previamente configurada como parte de uma instalac,ao bootonly.

   Figura 2.32. Escolha uma interface de rede
   Escolha uma interface de rede

   Se uma interface Ethernet for selecionada, o instalador ira pular para o
   menu mostrado em Figura 2.36, "Escolha a rede IPv4". Se uma interface de
   rede sem fio for escolhida, o sistema procurara pontos de acesso sem fio:

   Figura 2.33. Buscando por pontos de acesso sem fio
   Buscando por pontos de acesso sem fio

   As redes sem fio sao identificadas por um identificador de conjunto de
   servic,os (SSID), um nome curto e exclusivo dado a cada rede. Os SSIDs
   encontrados durante a busca serao listados, seguidos por uma descric,ao
   dos tipos de criptografia disponiveis para essa rede. Se o SSID desejado
   nao aparecer na lista, selecione [Rescan] para buscar novamente. Se a rede
   desejada ainda nao aparecer, verifique se ha problemas com as conexoes da
   antena ou tente mover o computador para mais perto do ponto de acesso.
   refac,a a busca apos cada alterac,ao ser feita.

   Figura 2.34. Escolhendo uma rede sem fio
   Escolhendo uma rede sem fio

   Em seguida, insira as informac,oes de criptografia para se conectar `a
   rede sem fio selecionada. A encriptac,ao WPA2 e fortemente recomendada,
   pois os tipos de encriptac,ao mais antigos, como o WEP, oferecem pouca
   seguranc,a. Se a rede usar WPA2, insira a senha, tambem conhecida como
   Chave Pre-Compartilhada (PSK). Por motivos de seguranc,a, os caracteres
   digitados na caixa de entrada sao exibidos como asteriscos.

   Figura 2.35. Configurac,ao WPA2
   Configurac,ao WPA2

   Em seguida, escolha se um enderec,o IPv4 deve ou nao ser configurado na
   interface Ethernet ou na interface sem fio:

   Figura 2.36. Escolha a rede IPv4
   Escolha a rede IPv4

   Existem dois metodos de configurac,ao de IPv4. O DHCP configurara
   automaticamente a interface de rede da forma correta e devera ser usado se
   a rede fornecer um servidor DHCP. Caso contrario, as informac,oes de
   enderec,amento precisam ser inseridas manualmente como em uma
   configurac,ao estatica.

  Nota:

   Nao insira informac,oes de rede aleatorias, pois isso nao funcionara. Se
   um servidor DHCP nao estiver disponivel, obtenha as informac,oes listadas
   em Informac,oes de rede necessarias do administrador da rede ou do
   provedor de servic,os de Internet.

   Se um servidor DHCP estiver disponivel, selecione [Yes] no proximo menu
   para configurar automaticamente a interface de rede. O instalador parecera
   pausar por um minuto ou mais enquanto encontra o servidor DHCP e obtem as
   informac,oes de enderec,amento do sistema.

   Figura 2.37. Escolha a configurac,ao IPv4 DHCP
   Escolha a configurac,ao IPv4 DHCP

   Se um servidor DHCP nao estiver disponivel, selecione [No] e insira as
   seguintes informac,oes de enderec,amento neste menu:

   Figura 2.38. Configurac,ao IPv4 estatica
   Configurac,ao IPv4 estatica
     * Enderec,o IP - O enderec,o IPv4 atribuido a este computador. O
       enderec,o deve ser unico e nao estar em uso por outro equipamento na
       rede local.

     * Subnet Mask - A mascara de sub-rede da rede.

     * Default Router - O enderec,o IP do gateway padrao da rede.

   A proxima tela perguntara se a interface deve ser configurada para IPv6.
   Se IPv6 estiver disponivel e for desejado, escolha [Yes] para
   seleciona-lo.

   Figura 2.39. Escolha a rede IPv6
   Escolha a rede IPv6

   O IPv6 tambem possui dois metodos de configurac,ao. A configurac,ao
   automatica de enderec,os sem estado (SLAAC) solicitara automaticamente as
   informac,oes de configurac,ao corretas de um roteador local. Consulte
   http://tools.ietf.org/html/rfc4862 para maiores informac,oes. A
   configurac,ao estatica requer entrada manual das informac,oes da rede.

   Se um roteador IPv6 estiver disponivel, selecione [Yes] no proximo menu
   para configurar automaticamente a interface de rede. O instalador parecera
   pausar por um minuto ou mais enquanto localiza o roteador e obtem as
   informac,oes de enderec,amento do sistema.

   Figura 2.40. Escolha a configurac,ao do SLAAC do IPv6
   Escolha a configurac,ao do SLAAC do IPv6

   Se um roteador IPv6 nao estiver disponivel, selecione [No] e insira as
   seguintes informac,oes de enderec,amento neste menu:

   Figura 2.41. Configurac,ao Estatica do IPv6
   Configurac,ao Estatica do IPv6
     * Enderec,o IPv6 - O enderec,o IPv6 atribuido a este computador. O
       enderec,o deve ser unico e nao estar em uso por outro equipamento na
       rede local.

     * Default Router - O enderec,o IPv6 do gateway padrao da rede.

   O ultimo menu de configurac,ao de rede e usado para configurar o
   resolvedor do Sistema de Nomes de Dominio (DNS), que converte nomes de
   host de e para enderec,os de rede. Se o DHCP ou SLAAC foi usado para
   autoconfigurar a interface de rede, os valores do Resolver Configuration
   podem ja estar preenchidos. Caso contrario, insira o dominio da rede local
   nome no campo Search. DNS # 1 e DNS # 2 sao os enderec,os IPv4 e/ou IPv6
   dos servidores de DNS. Pelo menos um servidor DNS e necessario.

   Figura 2.42. Configurac,ao do DNS
   Configurac,ao do DNS

  2.8.3. Defina o fuso horario

   A proxima serie de menus e usada para determinar a hora local correta,
   selecionando a regiao geografica, o pais e o fuso horario. Definir o fuso
   horario permite que o sistema corrija automaticamente as alterac,oes de
   horario regionais, como horario de verao, e execute outras func,oes
   relacionadas ao fuso horario corretamente.

   O exemplo mostrado aqui e para uma maquina localizada no fuso horario do
   continente da Espanha, Europa. As selec,oes variam de acordo com a
   localizac,ao geografica.

   Figura 2.43. Selecione uma regiao
   Selecione uma regiao

   A regiao apropriada e selecionada usando as teclas de seta e depois
   pressionando Enter.

   Figura 2.44. Selecione um pais
   Selecione um pais

   Selecione o pais apropriado usando as teclas de seta e pressione Enter.

   Figura 2.45. Selecione um fuso horario
   Selecione um fuso horario

   O fuso horario apropriado e selecionado usando as teclas de seta e
   pressionando Enter.

   Figura 2.46. Confirme o fuso horario
   Confirme o fuso horario

   Confirme se a abreviac,ao do fuso horario esta correta.

   Figura 2.47. Selecionar Data
   Selecionar Data

   A data apropriada e selecionada usando as teclas de seta e pressionando [
   Set Date ]. Caso contrario, a selec,ao de data pode ser pulada
   pressionando [ Skip ].

   Figura 2.48. Selecionar Hora
   Selecionar Hora

   O horario apropriado e selecionado usando as teclas de seta e, em seguida,
   pressionando [ Set Time ]. Caso contrario, a selec,ao da hora pode ser
   pulada pressionando [ Skip ].

  2.8.4. Ativando Servic,os

   O proximo menu e usado para configurar quais servic,os do sistema serao
   iniciados sempre que o sistema for inicializado. Todos esses servic,os sao
   opcionais. Inicie apenas os servic,os necessarios para o funcionamento do
   sistema.

   Figura 2.49. Selecionando Servic,os Adicionais para Ativar
   Selecionando Servic,os Adicionais para Ativar

   Aqui esta um resumo dos servic,os que podem ser ativados neste menu:

     * local_unbound -Ative o DNS local unbound. E necessario ter em mente
       que esse e o unbound do sistema base e deve ser usado apenas como um
       cache local de consultas DNS. Se o objetivo e configurar um resolvedor
       para toda a rede, instale dns/unbound.

     * sshd - O daemon Secure Shell (SSH) e usado para acessar remotamente um
       sistema atraves de uma conexao criptografada. Ative este servic,o
       somente se o sistema estiver disponivel para logins remotos.

     * moused - Ative este servic,o se o mouse for usado a partir do console
       do sistema de linha de comando.

     * ntpdate - Ative a sincronizac,ao automatica do relogio no momento do
       boot. A funcionalidade deste programa agora esta disponivel no daemon
       ntpd(8). Apos um periodo consideravel de luto, o utilitario ntpdate(8)
       sera aposentado.

     * ntpd - O daemon do Network Time Protocol (NTP) para sincronizac,ao
       automatica do relogio. Ative este servic,o se houver um servidor
       Windows(R), Kerberos ou LDAP na rede.

     * powerd - Utilitario de controle de energia do sistema para controle de
       energia e economia de energia.

     * dumpdev - A habilitac,ao de despejos de memoria e util na depurac,ao
       de problemas com o sistema; portanto, os usuarios sao incentivados a
       habilitar despejos de memoria.

  2.8.5. Ativando Opc,oes de Seguranc,a (Hardening)

   O proximo menu e usado para configurar quais opc,oes de seguranc,a serao
   ativadas. Todas essas opc,oes sao opcionais. Mas seu uso e incentivado.

   Figura 2.50. Selecionando Opc,oes de Seguranc,a (Hardening)
   Selecionando Opc,oes de Seguranc,a (Hardening)

   Aqui esta um resumo das opc,oes que podem ser ativadas neste menu:

     * hide_uids - Oculta processos em execuc,ao de outros usuarios para
       impedir que usuarios sem privilegios vejam processos em execuc,ao de
       outros usuarios (UID), impedindo o vazamento de informac,oes.

     * hide_gids - Oculta processos em execuc,ao de outros grupos para
       impedir que usuarios sem privilegios vejam processos em execuc,ao de
       outros grupos (GID), impedindo o vazamento de informac,oes.

     * hide_jail - Oculta processos em execuc,ao em jails para impedir que
       usuarios sem privilegios vejam processos em execuc,ao dentro das
       jails.

     * read_msgbuf - Desativando a leitura do buffer de mensagens do kernel
       para usuarios sem privilegios, impede o uso do dmesg(8) para exibir
       mensagens do log do kernel em buffer.

     * proc_debug - Desativar os recursos de depurac,ao de processo para
       usuarios sem privilegios desativa uma variedade de servic,os de
       depurac,ao entre processos sem privilegios, incluindo algumas
       funcionalidades procfs, ptrace() e ktrace(). Observe que isso tambem
       ira bloquear ferramentas de depurac,ao, como por exemplo, lldb(1),
       truss(1), procstat(1), bem como alguns recursos de depurac,ao
       integrados em certas linguagens de script como PHP, etc., de funcionar
       para usuarios sem privilegios.

     * random_pid - Randomize o PID dos processos recem-criados.

     * clear_tmp - Limpar o /tmp na inicializac,ao do sistema.

     * disable_syslogd - Desative a criac,ao de socket de rede do syslogd.
       Por padrao, o FreeBSD executa o syslogd de maneira segura com -s. Isso
       impede que o daemon atenda solicitac,oes UDP recebidas na porta 514.
       Com esta opc,ao ativada, o syslogd sera executado com o sinalizador
       -ss, que impede o syslogd de abrir qualquer porta. Para obter mais
       informac,oes, consulte syslogd(8).

     * disable_sendmail - Desative o agente de transporte de email sendmail.

     * secure_console - Quando esta opc,ao esta ativada, o prompt solicita a
       senha de root ao entrar em modo single.

     * disable_ddtrace - O DTrace pode ser executado em um modo que realmente
       afetara o kernel em execuc,ao. Ac,oes destrutivas nao podem ser
       usadas, a menos que tenham sido explicitamente ativadas. Para
       habilitar esta opc,ao ao usar o DTrace, use -w. Para obter mais
       informac,oes, consulte dtrace(1).

  2.8.6. Adicione usuarios

   O proximo menu pede para criar pelo menos uma conta de usuario.
   Recomenda-se fazer login no sistema usando uma conta de usuario em vez de
   utilizar diretamente o root. Quando logado como root, essencialmente nao
   ha limites ou protec,ao sobre o que pode ser feito. Fazer o login como um
   usuario normal e mais seguro.

   Selecione [Yes] para adicionar novos usuarios.

   Figura 2.51. Adicione contas de usuario
   Adicione contas de usuario

   Siga os prompts e insira as informac,oes solicitadas para a conta do
   usuario. O exemplo mostrado em Figura 2.52, "Insira as informac,oes do
   usuario" cria a conta de usuario asample.

   Figura 2.52. Insira as informac,oes do usuario
   Insira as informac,oes do usuario

   Aqui esta um resumo das informac,oes para solicitadas:

     * Username - O nome que o usuario digitara para efetuar login. Uma
       convenc,ao comum e usar a primeira letra do primeiro nome combinada
       com o sobrenome, desde que cada nome de usuario seja exclusivo para o
       sistema. O nome de usuario faz distinc,ao entre maiusculas e
       minusculas e nao deve conter espac,os.

     * Username - O nome completo do usuario. Este campo pode conter espac,os
       e e usado como uma descric,ao para a conta do usuario.

     * Uid - ID do Usuario. Normalmente, isso e deixado em branco para que o
       sistema atribua um valor.

     * Login group - O grupo do usuario. Normalmente, isso e deixado em
       branco para aceitar o padrao.

     * Invite user into other groups? - Grupos adicionais aos quais o usuario
       sera adicionado como membro. Se o usuario precisar de acesso
       administrativo, digite wheel aqui.

     * Login class - normalmente deixado em branco para seguir com o padrao.

     * Shell - Digite um dos valores listados para definir o shell interativo
       para o usuario. Consulte Sec,ao 3.9, "Shells" para maiores
       informac,oes sobre shells.

     * Home directory - O diretorio inicial do usuario. O padrao geralmente
       esta correto.

     * Home directory permissions - Permissoes no diretorio inicial do
       usuario. O padrao geralmente esta correto.

     * Use password-based authentication? A resposta deve ser Yes para que o
       usuario seja solicitado a inserir sua senha no login.

     * Use an empty password? - Normalmente a resposta sera No, pois e
       inseguro ter uma senha em branco.

     * Use a random password? - Normalmente a resposta sera No para que o
       usuario possa definir sua propria senha no proximo prompt.

     * Enter password - Escolha a senha para este usuario. Caracteres
       digitados nao serao exibidos na tela.

     * Enter password again - A senha deve ser digitada novamente para
       verificac,ao.

     * Lock out the account after creation? - A reposta normalmente sera No
       para que o usuario possa fazer o login.

   Depois de inserir tudo, um resumo sera exibido para revisao. Se algum erro
   foi cometido, digite no e tente novamente. Se tudo estiver correto, digite
   yes para criar o novo usuario.

   Figura 2.53. Saia do gerenciamento de usuarios e grupos
   Saia do gerenciamento de usuarios e grupos

   Se houver mais usuarios para adicionar, responda a pergunta Add another
   user? com yes. Digite no para concluir a adic,ao de usuarios e continuar a
   instalac,ao.

   Para obter maiores informac,oes sobre como adicionar usuarios e sobre como
   gerencia-los de usuarios, consulte Sec,ao 3.3, "Usuarios e Gerenciamento
   Basico de Contas".

  2.8.7. Configurac,ao final

   Depois que tudo tiver sido instalado e configurado, voce tera uma chance
   final para modificar as configurac,oes.

   Figura 2.54. Configurac,ao final
   Configurac,ao final

   Use este menu para fazer alterac,oes ou fazer qualquer configurac,ao
   adicional antes de concluir a instalac,ao.

     * Add User - Descrito em Sec,ao 2.8.6, "Adicione usuarios".

     * Root Password - Descrito em Sec,ao 2.8.1, "Definindo a Senha de root".

     * Hostname - Descrito em Sec,ao 2.5.2, "Configurando o nome do host".

     * Network - Descrito em Sec,ao 2.8.2, "Configurando as Interfaces de
       Rede".

     * Services - Descrito em Sec,ao 2.8.4, "Ativando Servic,os".

     * System Hardening - Descrito em Sec,ao 2.8.5, "Ativando Opc,oes de
       Seguranc,a (Hardening)".

     * Time Zone - Descrito em Sec,ao 2.8.3, "Defina o fuso horario".

     * Handbook - Fac,a o download e instale o FreeBSD Handbook.

   Depois que completar qualquer configurac,ao final que tenha faltado,
   selecione Exit.

   Figura 2.55. Configurac,ao manual
   Configurac,ao manual

   O bsdinstall perguntara se ha alguma configurac,ao adicional que precise
   ser feita antes de reinicializar o novo sistema. Selecione [Yes] para sair
   para um shell dentro do novo sistema ou [No] para prosseguir para a ultima
   etapa da instalac,ao.

   Figura 2.56. Conclua a instalac,ao
   Conclua a instalac,ao

   Se outras configurac,oes ou configurac,oes especiais forem necessarias,
   selecione [Live CD] para inicializar a midia de instalac,ao no modo Live
   CD.

   Se a instalac,ao estiver completa, selecione [Reboot] para reiniciar o
   computador e iniciar o novo sistema FreeBSD. Nao se esquec,a de remover a
   midia de instalac,ao do FreeBSD ou o computador podera inicializar
   novamente a partir dela.

   Quando o FreeBSD inicializa, mensagens informativas sao exibidas. Depois
   que o sistema concluir a inicializac,ao, um prompt de login sera exibido.
   No login:, insira o nome de usuario adicionado durante a instalac,ao.
   Evite efetuar login como root. Consulte Sec,ao 3.3.1.3, "A conta de
   superusuario" para instruc,oes sobre como se tornar o superusuario quando
   o acesso administrativo for necessario.

   As mensagens que apareceram durante a inicializac,ao podem ser revisadas
   pressionando Scroll-Lock para ativar o buffer de rolagem para tras. As
   teclas PgUp, PgDn e setas podem ser usadas para rolar pelas mensagens.
   Quando terminar, pressione Scroll-Lock novamente para desbloquear o visor
   e retornar ao console. Para revisar essas mensagens depois que o sistema
   estiver ativo por algum tempo, digite less /var/run/dmesg.boot em um
   prompt de comando. Pressione q para retornar `a linha de comando apos a
   visualizac,ao.

   Se o sshd foi habilitado em Figura 2.49, "Selecionando Servic,os
   Adicionais para Ativar", a primeira inicializac,ao pode ser um pouco mais
   lenta, pois o sistema gerara as chaves RSA e DSA. As inicializac,oes
   subsequ:entes serao mais rapidas. As impressoes digitais das chaves serao
   exibidas, conforme mostrado neste exemplo:

 Generating public/private rsa1 key pair.
 Your identification has been saved in /etc/ssh/ssh_host_key.
 Your public key has been saved in /etc/ssh/ssh_host_key.pub.
 The key fingerprint is:
 10:a0:f5:af:93:ae:a3:1a:b2:bb:3c:35:d9:5a:b3:f3 root@machine3.example.com
 The key's randomart image is:
 +--[RSA1 1024]----+
 |    o..          |
 |   o . .         |
 |  .   o          |
 |       o         |
 |    o   S        |
 |   + + o         |
 |o . + *          |
 |o+ ..+ .         |
 |==o..o+E         |
 +-----------------+
 Generating public/private dsa key pair.
 Your identification has been saved in /etc/ssh/ssh_host_dsa_key.
 Your public key has been saved in /etc/ssh/ssh_host_dsa_key.pub.
 The key fingerprint is:
 7e:1c:ce:dc:8a:3a:18:13:5b:34:b5:cf:d9:d1:47:b2 root@machine3.example.com
 The key's randomart image is:
 +--[ DSA 1024]----+
 |       ..     . .|
 |      o  .   . + |
 |     . ..   . E .|
 |    . .  o o . . |
 |     +  S = .    |
 |    +  . = o     |
 |     +  . * .    |
 |    . .  o .     |
 |      .o. .      |
 +-----------------+
 Starting sshd.

   Consulte Sec,ao 13.8, "OpenSSH" para maiores informac,oes sobre
   fingerprints e o SSH.

   O FreeBSD nao instala um ambiente grafico por padrao. Consulte Capitulo 5,
   O sistema X Window para maiores informac,oes sobre como instalar e
   configurar um gerenciador grafico de janelas.

   O desligamento adequado de um computador FreeBSD ajuda a proteger os dados
   e o hardware contra danos. Nao desligue a energia antes do sistema ter
   sido desligado corretamente! Se o usuario for membro do grupo wheel,
   torne-se o superusuario digitando su na linha de comando e inserindo a
   senha do usuario root. Em seguida, digite shutdown -p now e o sistema sera
   desligado corretamente e, se o hardware suportar, ira se desliga-se.

2.9. Soluc,ao de problemas

   Esta sec,ao aborda a soluc,ao de problemas basicos de instalac,ao, tais
   como problemas comuns que as pessoas relataram.

   Verifique o documento Notas de Hardware
   (https://www.freebsd.org/releases/index.html) para a versao do FreeBSD
   para garantir que o hardware e suportado. Se o hardware for suportado e
   houver travamentos ou outros problemas, compile um kernel personalizado
   usando as instruc,oes em Capitulo 8, Configurando o kernel do FreeBSD para
   adicionar suporte a dispositivos que nao estao presentes no kernel
   GENERIC. O kernel padrao assume que a maioria dos dispositivos de hardware
   esta na configurac,ao padrao de fabrica em termos de IRQs, enderec,os de
   I/O e canais DMA. Se o hardware foi reconfigurado, um arquivo de
   configurac,ao personalizado do kernel pode dizer ao FreeBSD onde encontrar
   os dispositivos.

  Nota:

   Alguns problemas de instalac,ao podem ser evitados ou aliviados com a
   atualizac,ao do firmware em varios componentes de hardware, principalmente
   na placa-mae. O firmware da placa-mae e geralmente chamado de BIOS. A
   maioria dos fabricantes de placas-mae e computadores tem um site para
   atualizac,oes e para informac,oes sobre as atualizac,oes.

   Os fabricantes geralmente desaconselham a atualizac,ao da BIOS da
   placa-mae, a menos que haja uma boa razao para isso, como uma atualizac,ao
   critica. O processo de atualizac,ao pode dar errado, deixando o BIOS
   incompleto e o computador inoperante.

   Se o sistema trava enquanto verifica o hardware durante a inicializac,ao
   ou se comporta de maneira estranha durante a instalac,ao, o ACPI pode ser
   o culpado. O FreeBSD faz uso extensivo do sistema ACPI nas plataformas
   i386 e amd64 para ajudar na configurac,ao do sistema, caso seja detectado
   durante a inicializac,ao. Infelizmente, alguns bugs ainda existem tanto no
   driver ACPI como nas placas-mae do sistema e no firmware BIOS. O ACPI pode
   ser desativado configurando a opc,ao hint.acpi.0.disabled no terceiro
   estagio do boot loader:

 set hint.acpi.0.disabled="1"

   Isso e redefinido toda vez que o sistema e inicializado, portanto e
   necessario adicionar hint.acpi.0.disabled="1" ao arquivo /boot/loader.conf
   . Maiores informac,oes sobre o boot loader podem ser encontradas em
   Sec,ao 12.1, "Sinopse".

2.10. Usando o Live CD

   O menu de boas-vindas do bsdinstall, mostrado em Figura 2.3, "Menu de
   boas-vindas", fornece uma opc,ao [Live CD]. Isto e util para aqueles que
   ainda estao se perguntando se o FreeBSD e o sistema operacional correto
   para eles e quer testar alguns dos recursos antes de instalar.

   Os seguintes pontos devem ser observados antes de usar o [Live CD]:

     * Para obter acesso ao sistema, a autenticac,ao e necessaria. O nome de
       usuario e root e a senha esta em branco.

     * Como o sistema e executado diretamente da midia de instalac,ao, o
       desempenho sera significativamente mais lento do que o de um sistema
       instalado em um disco rigido.

     * Essa opc,ao fornece apenas um prompt de comando e nao uma interface
       grafica.

Capitulo 3. Fundamentos do FreeBSD

   Indice

   3.1. Sinopse

   3.2. Consoles e Terminais Virtuais

   3.3. Usuarios e Gerenciamento Basico de Contas

   3.4. Permissoes

   3.5. Estrutura de Diretorios

   3.6. Organizac,ao dos Discos

   3.7. Montando e Desmontando Sistemas de Arquivos

   3.8. Processos e Daemons

   3.9. Shells

   3.10. Editores de Texto

   3.11. Dispositivos e nos de dispositivos

   3.12. Paginas de Manual

3.1. Sinopse

   Este capitulo cobre os comandos basicos e as funcionalidades do sistema
   operacional FreeBSD. Grande parte deste material e relevante para qualquer
   sistema operacional do tipo UNIX(R). Novos usuarios do FreeBSD sao
   encorajados a ler este capitulo cuidadosamente.

   Depois de ler este capitulo, voce sabera:

     * Como usar e configurar consoles virtuais.

     * Como criar e gerenciar usuarios e grupos no FreeBSD.

     * Como funcionam as permissoes de arquivo UNIX(R) e as flags de arquivos
       do FreeBSD.

     * O layout padrao do sistema de arquivos do FreeBSD.

     * A organizac,ao do disco no FreeBSD.

     * Como montar e desmontar sistemas de arquivos.

     * O que sao processos, daemons e sinais.

     * O que e um shell e como alterar o ambiente de login padrao.

     * Como usar editores de texto basicos.

     * O que sao devices e device nodes.

     * Como ler paginas de manual para obter maiores informac,oes.

3.2. Consoles e Terminais Virtuais

   A menos que o FreeBSD tenha sido configurado para iniciar automaticamente
   um ambiente grafico durante a inicializac,ao, o sistema inicializara em um
   prompt de login da linha de comando, como visto neste exemplo:

 FreeBSD/amd64 (pc3.example.org) (ttyv0)

 login:

   A primeira linha contem algumas informac,oes sobre o sistema. O amd64
   indica que o sistema neste exemplo esta executando uma versao de 64 bits
   do FreeBSD. O nome do host e pc3.example.org, e ttyv0 indica que este e o
   "console do sistema". A segunda linha e o prompt de login.

   Como o FreeBSD e um sistema multiusuario, ele precisa de alguma maneira
   distinguir entre usuarios diferentes. Isso e feito exigindo que todos os
   usuarios fac,am login no sistema antes de obter acesso aos programas no
   sistema. Cada usuario tem um "nome de usuario" unico e uma "senha"
   pessoal.

   Para efetuar login no console do sistema, digite o nome de usuario que foi
   configurado durante a instalac,ao do sistema, conforme descrito em
   Sec,ao 2.8.6, "Adicione usuarios" e pressione Enter. Em seguida, insira a
   senha associada ao nome de usuario e pressione Enter. A senha nao e ecoada
   por razoes de seguranc,a.

   Uma vez que a senha correta e inserida, a mensagem do dia (MOTD) sera
   exibida, seguida de um prompt de comando. Dependendo do shell que foi
   selecionado quando o usuario foi criado, este prompt sera um caractere #,
   $ ou %. O prompt indica que o usuario esta logado no console do sistema
   FreeBSD e pronto para testar os comandos disponiveis.

  3.2.1. Consoles Virtuais

   Enquanto o console do sistema pode ser usado para interagir com o sistema,
   um usuario trabalhando a partir da linha de comando no teclado de um
   sistema FreeBSD normalmente ira efetuar login em um console virtual. Isso
   ocorre porque as mensagens do sistema sao configuradas por padrao para
   serem exibidas no console do sistema. Essas mensagens serao exibidas por
   cima do comando ou arquivo em que o usuario estiver trabalhando,
   dificultando a concentrac,ao no trabalho em questao.

   Por padrao, o FreeBSD e configurado para fornecer varios consoles virtuais
   para a entrada de comandos. Cada console virtual tem seu proprio prompt de
   login e shell e e facil alternar entre os consoles virtuais. Isso
   essencialmente fornece a linha de comando equivalente a ter varias janelas
   abertas ao mesmo tempo em um ambiente grafico.

   As combinac,oes de teclas Alt+F1 ate a Alt+F8 foram reservadas pelo
   FreeBSD para alternar entre os consoles virtuais. Use Alt+F1 para alternar
   para o console do sistema (ttyv0), Alt+F2 para acessar o primeiro console
   virtual (ttyv1), Alt+F3 para acessar o segundo console virtual (ttyv2) e
   assim por diante. Ao usar o Xorg como um console grafico, a combinac,ao
   Ctrl+Alt+F1 e utilizada para retornar para um console virtual baseado em
   texto.

   Ao mudar de um console para o proximo, o FreeBSD gerencia a saida da tela.
   O resultado e uma ilusao de ter varias telas virtuais e teclados que podem
   ser usados para digitar comandos para o FreeBSD rodar. Os programas
   executados em um console virtual nao param de ser executados quando o
   usuario alterna para um console virtual diferente.

   Consulte kbdcontrol(1), vidcontrol(1), atkbd(4), syscons(4), e vt(4) para
   uma descric,ao mais tecnica do console do FreeBSD e seus drivers de
   teclado.

   No FreeBSD, o numero de consoles virtuais disponiveis e configurado nesta
   sec,ao do /etc/ttys:

 # name    getty                         type  status comments
 #
 ttyv0   "/usr/libexec/getty Pc"         xterm   on  secure
 # Virtual terminals
 ttyv1   "/usr/libexec/getty Pc"         xterm   on  secure
 ttyv2   "/usr/libexec/getty Pc"         xterm   on  secure
 ttyv3   "/usr/libexec/getty Pc"         xterm   on  secure
 ttyv4   "/usr/libexec/getty Pc"         xterm   on  secure
 ttyv5   "/usr/libexec/getty Pc"         xterm   on  secure
 ttyv6   "/usr/libexec/getty Pc"         xterm   on  secure
 ttyv7   "/usr/libexec/getty Pc"         xterm   on  secure
 ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure

   Para desativar um console virtual, coloque um simbolo de comentario (#) no
   inicio da linha que representa esse console virtual. Por exemplo, para
   reduzir o numero de consoles virtuais disponiveis de oito para quatro,
   coloque um # na frente das ultimas quatro linhas que representam os
   consoles virtuais de ttyv5 ate ttyv8. Nao comente a linha do console do
   sistema ttyv0. Note que o ultimo console virtual (ttyv8) e usado para
   acessar o ambiente grafico se o Xorg tiver sido instalado e configurado
   conforme descrito em Capitulo 5, O sistema X Window.

   Para uma descric,ao detalhada de cada coluna neste arquivo e as opc,oes
   disponiveis para os consoles virtuais, consulte ttys(5).

  3.2.2. Modo "Single User"

   O menu de inicializac,ao do FreeBSD fornece uma opc,ao chamada "Boot
   Single User". Se esta opc,ao for selecionada, o sistema inicializara em um
   modo especial conhecido como "single user mode". Esse modo e normalmente
   usado para reparar um sistema que nao inicializa ou para redefinir a senha
   de root quando ela e desconhecida. Quando em modo single user, a rede e
   outros consoles virtuais nao estao disponiveis. No entanto, havera acesso
   completo de root ao sistema e, por padrao, a senha de root nao e
   necessaria. Por estas razoes, o acesso fisico ao teclado e necessario para
   iniciar neste modo e determinar quem tem acesso fisico ao teclado e algo a
   considerar ao proteger um sistema FreeBSD.

   As configurac,oes que controlam o modo de single user sao encontradas
   nesta sec,ao do /etc/ttys:

 # name  getty                           type  status  comments
 #
 # If console is marked "insecure", then init will ask for the root password
 # when going to single-user mode.
 console none                            unknown  off  secure

   Por padrao, o status e definido como secure. Isso pressupoe que quem tem
   acesso fisico ao teclado nao e importante ou e controlado por uma politica
   de seguranc,a fisica. Se essa configurac,ao for alterada para insecure, a
   suposic,ao e que o ambiente em si e inseguro porque qualquer pessoa pode
   acessar o teclado. Quando esta linha e alterada para insecure, o FreeBSD
   ira solicitar a senha do root quando um usuario selecionar inicializar no
   modo single user.

  Nota:

   Tenha cuidado ao alterar esta configurac,ao para inseguro! Se a senha do
   root for esquecida, a inicializac,ao no modo single user ainda e possivel,
   mas pode ser dificil para alguem que nao esteja familiarizado com o
   processo de inicializac,ao do FreeBSD.

  3.2.3. Alterar os modos de video do console

   O modo de video padrao do console do FreeBSD pode ser ajustado para
   1024x768, 1280x1024 ou qualquer outro tamanho suportado pelo chip grafico
   e monitor. Para usar um modo de video diferente, carregue o modulo VESA:

 # kldload vesa

   Para determinar quais modos de video sao suportados pelo hardware, use
   vidcontrol(1). Para obter uma lista de modos de video suportados, execute
   o seguinte:

 # vidcontrol -i mode

   A saida deste comando lista os modos de video suportados pelo hardware.
   Para selecionar um novo modo de video, especifique o modo usando
   vidcontrol(1) como o usuario root :

 # vidcontrol MODE_279

   Se o novo modo de video for aceitavel, ele pode ser definido
   permanentemente na inicializac,ao, adicionando-o ao /etc/rc.conf:

 allscreens_flags="MODE_279"

3.3. Usuarios e Gerenciamento Basico de Contas

   O FreeBSD permite que multiplos usuarios usem o computador ao mesmo tempo.
   Enquanto apenas um usuario pode se sentar em frente `a tela e usar o
   teclado a qualquer momento, qualquer numero de usuarios pode efetuar o
   login no sistema atraves da rede. Para usar o sistema, cada usuario deve
   ter sua propria conta de usuario.

   Este capitulo descreve:

     * Os diferentes tipos de contas de usuarios em um sistema FreeBSD.

     * Como adicionar, remover e modificar contas de usuarios.

     * Como definir limites para controlar os recursos que usuarios e grupos
       podem acessar.

     * Como criar grupos e adicionar usuarios como membros de um grupo.

  3.3.1. Tipos de conta

   Como todo acesso ao sistema FreeBSD e obtido usando contas e todos os
   processos sao executados por usuarios, o gerenciamento de usuarios e
   contas e importante.

   Existem tres tipos principais de contas: contas do sistema, contas de
   usuario e a conta de superusuario.

    3.3.1.1. Contas do sistema

   As contas do sistema sao usadas para executar servic,os como DNS, correio
   e servidores web. A razao para isso e a seguranc,a; se todos os servic,os
   fossem executados como superusuario, eles poderiam agir sem restric,oes.

   Exemplos de contas do sistema sao daemon, operador, bind, news, e www.

  Atenc,ao:

   E necessario ter cuidado ao usar o grupo operator, pois privilegios de
   acesso como o de superusuario podem ser concedidos, incluindo e nao
   limitado a, desligamento, reinicializac,ao e acesso a todos os itens em
   /dev para o grupo.

   A nobody e uma conta generica sem privilegios do sistema. No entanto,
   quanto mais servic,os usarem nobody, a mais arquivos e processos esse
   usuario sera associado e, portanto, mais privilegiado esse usuario se
   tornara.

    3.3.1.2. Contas de usuario

   As contas de usuarios sao atribuidas a pessoas reais e sao usadas para
   efetuar login e usar o sistema. Todas as pessoas que acessam o sistema
   devem ter uma conta de usuario exclusiva. Isso permite que o administrador
   descubra quem esta fazendo o que e impede que usuarios alterem as
   configurac,oes de outros usuarios.

   Cada usuario pode configurar seu proprio ambiente para adequar o sistema
   ao seu uso, utilizando suas opc,oes padrao para o shell, editor, atalhos
   de teclado e idioma.

   Cada conta de usuario em um sistema FreeBSD tem certas informac,oes
   associadas:

   Nome de usuario

           O nome do usuario e digitado no prompt login:. Cada usuario deve
           ter um nome de usuario exclusivo. Existem diversas regras para
           criar nomes de usuario validos que estao documentadas em
           passwd(5). Recomenda-se usar nomes de usuario que tenham oito ou
           menos caracteres, todos os caracteres devem ser minusculos para
           manter a compatibilidade com aplicativos legados.

   Senha

           Cada conta tem uma senha associada.

   ID do usuario (UID)

           O ID do Usuario (UID) e um numero usado para identificar
           unicamente o usuario no sistema FreeBSD. Comandos que permitem que
           um nome de usuario seja especificado o converterao para o UID.
           Recomenda-se usar um UID menor que 65535, ja que valores mais
           altos podem causar problemas de compatibilidade com alguns
           softwares.

   ID do grupo (GID)

           O ID do grupo (GID) e um numero usado para identificar unicamente
           o grupo principal ao qual o usuario pertence. Os grupos sao um
           mecanismo para controlar o acesso a recursos com base no GID de um
           usuario, em vez de no seu UID. Isso pode reduzir
           significativamente o tamanho de alguns arquivos de configurac,ao e
           permite que os usuarios sejam membros de mais de um grupo.
           Recomenda-se usar um GID de 65535 ou inferior, pois GIDs mais
           altos podem nao funcionar com alguns softwares.

   Classe de login

           As classes de login sao uma extensao do mecanismo de grupo que
           fornece flexibilidade adicional ao configurar o sistema para
           diferentes usuarios. As classes de login sao discutidas em
           Sec,ao 13.13.1, "Configurando Classes de Login".

   Tempo para mudanc,a de senha

           Por padrao as senhas nao expiram. No entanto, a expirac,ao de
           senha pode ser ativada por usuario, forc,ando alguns ou todos os
           usuarios a alterar suas senhas apos um determinado periodo de
           tempo.

   Tempo de expirac,ao da conta

           Por padrao o FreeBSD nao expira contas. Ao criar contas que
           precisam de uma vida util limitada, como contas de alunos em uma
           escola, especifique a data de expirac,ao da conta usando o pw(8).
           Apos o tempo de expirac,ao, a conta nao podera ser usada para
           efetuar login no sistema, embora os diretorios e arquivos da conta
           permanec,am no servidor.

   Nome completo do usuario

           O nome de usuario identifica a conta de forma unica para o
           FreeBSD, mas nao reflete necessariamente o nome real do usuario.
           Semelhante a um comentario, essas informac,oes podem conter
           espac,os, caracteres maiusculos e ter mais de oito caracteres.

   Diretorio Inicial (home)

           O diretorio "home" e um caminho completo para um diretorio no
           sistema. Este e o diretorio inicial do usuario quando o usuario
           faz o login. Uma convenc,ao comum e colocar todos os diretorios
           home dos usuarios em /home/username ou /usr/home/username. Cada
           usuario armazena seus arquivos e subdiretorios pessoais em seu
           proprio diretorio home.

   Shell do usuario

           O shell fornece o ambiente padrao do usuario para interagir com o
           sistema. Existem muitos tipos diferentes de shells e usuarios
           experientes terao suas proprias preferencias, que podem ser
           refletidas nas suas configurac,oes da conta.

    3.3.1.3. A conta de superusuario

   A conta de superusuario, geralmente chamada de root, e usada para
   gerenciar o sistema sem limitac,oes de privilegios. Por este motivo, nao
   deve ser usado para tarefas do dia-a-dia, como enviar e receber e-mail,
   explorac,ao geral do sistema ou programac,ao.

   O superusuario, ao contrario de outras contas de usuario, pode operar sem
   limites, e o uso indevido da conta de superusuario pode resultar em
   desastres espetaculares. As contas de usuario nao podem destruir o sistema
   operacional por engano, por isso e recomendavel fazer o login como uma
   conta de usuario e se tornar o superusuario somente quando um comando
   exigir privilegios extras.

   Sempre cheque duas ou tres vezes todos os comandos emitidos como
   superusuario, pois um espac,o extra ou um caractere ausente pode causar
   uma perda de dados irreparavel.

   Existem varias maneiras de obter privilegios de superusuario. Embora seja
   possivel efetuar login como root, isso e altamente desencorajado.

   Em vez disso, use su(1) para se tornar o superusuario. Se - for
   especificado ao executar este comando, o usuario tambem herdara o ambiente
   do usuario root. O usuario que executa este comando deve estar no grupo
   wheel ou o comando falhara. O usuario tambem deve saber a senha da conta
   de usuario root.

   Neste exemplo, o usuario so se torna superusuario para executar make
   install, pois isso requer privilegios de superusuario. Quando o comando e
   concluido, o usuario digita exit para deixar a conta de superusuario e
   retornar `a sua conta de usuario.

   Exemplo 3.1. Instalar um programa como superusuario

 % configure
 % make
 % su -
 Password:
 # make install
 # exit
 %

   O framework integrado su(1) funciona bem para sistemas isolados ou redes
   pequenas com apenas um administrador. Uma alternativa e instalar o pacote
   ou port security/sudo. Este software fornece registro de atividades e
   permite ao administrador configurar quais usuarios podem executar quais
   comandos como superusuario.

  3.3.2. Gerenciando Contas

   O FreeBSD fornece uma variedade de diferentes comandos para gerenciar
   contas de usuarios. Os comandos mais comuns sao descritos em Tabela 3.1,
   "Utilitarios para gerenciar contas de usuarios", seguidos por alguns
   exemplos de seu uso. Veja a pagina de manual para cada utilitario para
   maiores detalhes e exemplos de uso.

   Tabela 3.1. Utilitarios para gerenciar contas de usuarios

    Comando                               Resumo                              
   adduser(8) Aplicativo de linha de comando recomendado para adicionar novos 
              usuarios.                                                       
   rmuser(8)  Aplicativo de linha de comando recomendado para remover         
              usuarios.                                                       
   chpass(1)  Uma ferramenta flexivel para alterar as informac,oes do         
              usuario.                                                        
   passwd(1)  Ferramenta de linha de comando para alterar senhas de usuarios. 
   pw(8)      Uma ferramenta poderosa e flexivel para modificar todos os      
              aspectos das contas de usuario.                                 

    3.3.2.1. adduser

   O programa recomendado para adicionar novos usuarios e o adduser(8).
   Quando um novo usuario e adicionado, este programa atualiza
   automaticamente o /etc/passwd e o /etc/group. Ele tambem cria um diretorio
   inicial para o novo usuario, copia os arquivos de configurac,ao padrao de
   /usr/share/skel e pode, opcionalmente, enviar uma nova mensagem de
   boas-vindas ao novo usuario. Este utilitario deve ser executado como o
   superusuario.

   O utilitario adduser(8) e interativo e percorre as etapas para criar uma
   nova conta de usuario. Como visto em Exemplo 3.2, "Adicionando um usuario
   no FreeBSD", insira as informac,oes necessarias ou pressione Enter para
   aceitar o valor padrao mostrado entre colchetes. Neste exemplo, o usuario
   foi convidado para o grupo wheel, permitindo que ele se tornasse o
   superusuario com o uso do su(1). Quando terminar, o utilitario perguntara
   se deseja criar outro usuario ou finalizar o comando.

   Exemplo 3.2. Adicionando um usuario no FreeBSD

 # adduser
 Username: jru
 Full name: J. Random User
 Uid (Leave empty for default):
 Login group [jru]:
 Login group is jru. Invite jru into other groups? []: wheel
 Login class [default]:
 Shell (sh csh tcsh zsh nologin) [sh]: zsh
 Home directory [/home/jru]:
 Home directory permissions (Leave empty for default):
 Use password-based authentication? [yes]:
 Use an empty password? (yes/no) [no]:
 Use a random password? (yes/no) [no]:
 Enter password:
 Enter password again:
 Lock out the account after creation? [no]:
 Username   : jru
 Password   : ****
 Full Name  : J. Random User
 Uid        : 1001
 Class      :
 Groups     : jru wheel
 Home       : /home/jru
 Shell      : /usr/local/bin/zsh
 Locked     : no
 OK? (yes/no): yes
 adduser: INFO: Successfully added (jru) to the user database.
 Add another user? (yes/no): no
 Goodbye!
 #

  Nota:

   Como a senha nao e mostrada quando digitada, tenha cuidado para nao
   digitar a senha incorretamente ao criar a conta do usuario.

    3.3.2.2. rmuser

   Para remover completamente um usuario do sistema, execute o rmuser(8) como
   o superusuario. Este comando executa as seguintes etapas:

    1. Remove a entrada crontab(1) do usuario, se existir.

    2. Remove todas as tarefas at(1) pertencentes ao usuario.

    3. Elimina todos os processos pertencentes ao usuario.

    4. Remove o usuario do arquivo de senhas do sistema.

    5. Opcionalmente, remove o diretorio pessoal do usuario, se ele for de
       propriedade do usuario.

    6. Remove os arquivos de mensagens recebidas pertencentes ao usuario de
       /var/mail.

    7. Remove todos os arquivos pertencentes ao usuario das areas de
       armazenamento de arquivos temporarios, como /tmp.

    8. Finalmente, remove o nome de usuario de todos os grupos aos quais ele
       pertence em /etc/group. Se um grupo ficar vazio e o nome do grupo for
       o mesmo que o nome de usuario, o grupo sera removido. Isso complementa
       os grupos exclusivos por usuario criados por adduser(8).

   O rmuser(8) nao pode ser usado para remover contas de superusuario, pois
   isso quase sempre ocasiona uma de destruic,ao em massa.

   Por padrao, um modo interativo e usado, conforme mostrado no exemplo a
   seguir.

   Exemplo 3.3. Remoc,ao de contas interativas com o rmuser

 # rmuser jru
 Matching password entry:
 jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
 Is this the entry you wish to remove? y
 Remove user's home directory (/home/jru)? y
 Removing user (jru): mailspool home passwd.
 #

    3.3.2.3. chpass

   Qualquer usuario pode usar o chpass(1) para alterar seu shell padrao e
   informac,oes pessoais associadas `a sua conta de usuario. O superusuario
   pode usar esse utilitario para alterar informac,oes adicionais da conta de
   qualquer usuario.

   Quando nao ha opc,oes, alem de um nome de usuario opcional, o chpass(1)
   exibe um editor contendo informac,oes do usuario. Quando o usuario sai do
   editor, o banco de dados do usuario e atualizado com as novas
   informac,oes.

  Nota:

   Este utilitario solicitara a senha do usuario ao sair do editor, a menos
   que o utilitario seja executado como superusuario.

   Em Exemplo 3.4, "Usando o chpass como superusuario", o superusuario
   digitou chpass jru e agora esta visualizando os campos que podem ser
   alterados para este usuario. Se jru executar este comando, apenas os
   ultimos seis campos serao exibidos e estarao disponiveis para edic,ao.
   Isso e mostrado em Exemplo 3.5, "Usando o chpass como usuario regular".

   Exemplo 3.4. Usando o chpass como superusuario

 #Changing user database information for jru.
 Login: jru
 Password: *
 Uid [#]: 1001
 Gid [# or name]: 1001
 Change [month day year]:
 Expire [month day year]:
 Class:
 Home directory: /home/jru
 Shell: /usr/local/bin/zsh
 Full Name: J. Random User
 Office Location:
 Office Phone:
 Home Phone:
 Other information:

   Exemplo 3.5. Usando o chpass como usuario regular

 #Changing user database information for jru.
 Shell: /usr/local/bin/zsh
 Full Name: J. Random User
 Office Location:
 Office Phone:
 Home Phone:
 Other information:

  Nota:

   Os comandos chfn(1) e chsh(1) sao links para chpass(1), como sao
   ypchpass(1), ypchfn(1)eypchsh(1). Ja que o suporte ao NIS e automatico,
   colocar o yp antes do comando nao e necessario. Os procedimentos para
   configurar o NIS esta documentado em Capitulo 29, Servidores de Rede.

    3.3.2.4. passwd

   Qualquer usuario pode alterar facilmente sua senha usando o passwd(1).
   Para prevenir alterac,oes acidentais ou nao autorizadas, este comando ira
   solicitar a senha atual ao usuario antes de configurar uma nova senha:

   Exemplo 3.6. Alterando Sua Senha

 % passwd
 Changing local password for jru.
 Old password:
 New password:
 Retype new password:
 passwd: updating the database...
 passwd: done

   O superusuario pode alterar a senha de qualquer usuario especificando o
   nome de usuario ao executar o passwd(1). Quando este utilitario e
   executado como superusuario, ele nao solicita a senha atual do usuario.
   Isso permite que a senha seja alterada quando um usuario nao consegue
   lembrar a senha original.

   Exemplo 3.7. Mudando a senha de outro usuario como superusuario

 # passwd jru
 Changing local password for jru.
 New password:
 Retype new password:
 passwd: updating the database...
 passwd: done

  Nota:

   Como com o chpass(1), o yppasswd(1) e um link para passwd(1), entao o NIS
   funciona com ambos os comandos.

    3.3.2.5. pw

   O utilitario pw(8) pode criar, remover, modificar e exibir usuarios e
   grupos. Funciona como um front-end para o usuario do sistema e para os
   arquivos de grupo. O pw(8) tem um conjunto muito poderoso de opc,oes de
   linha de comando que o torna adequado para uso em shell scripts, mas novos
   usuarios podem achar isso mais complicado que os outros comandos
   apresentados nesta sec,ao.

  3.3.3. Gerenciando Grupos

   Um grupo e uma lista de usuarios. Um grupo e identificado pelo nome do
   grupo e pelo GID. No FreeBSD, o kernel usa o UID de um processo, e a lista
   de grupos a que pertence, para determinar o que o processo pode fazer. Na
   maioria das vezes, o GID de um usuario ou processo geralmente significa o
   primeiro grupo na lista.

   O mapeamento do nome do grupo para o GID esta listado em /etc/group. Este
   e um arquivo de texto simples com quatro campos delimitados por dois
   pontos. O primeiro campo e o nome do grupo, o segundo e a senha
   criptografada, o terceiro e o GID e o quarto e a lista de membros
   delimitados por virgulas. Para uma descric,ao mais completa da sintaxe,
   consulte group(5).

   O superusuario pode modificar o /etc/group usando um editor de texto.
   Alternativamente, o pw(8) pode ser usado para adicionar e editar grupos.
   Por exemplo, para adicionar um grupo chamado teamtwo e confirmar se ele
   existe:

   Exemplo 3.8. Adicionando um grupo usando o pw(8)

 # pw groupadd teamtwo
 # pw groupshow teamtwo
 teamtwo:*:1100:

   Neste exemplo, 1100 e o GID de teamtwo. No momento, teamtwo nao possui
   membros. Este comando adicionara jru como um membro de teamtwo.

   Exemplo 3.9. Adicionando contas de usuarios a um novo grupo usando o pw(8)

 # pw groupmod teamtwo -M jru
 # pw groupshow teamtwo
 teamtwo:*:1100:jru

   O argumento para a opc,ao -M e uma lista de usuarios, delimitada por
   virgulas, a serem adicionados a um novo grupo (vazio) ou para substituir
   os membros de um grupo existente. Para o usuario, essa associac,ao ao
   grupo e diferente (e adicional ao) do grupo principal do usuario listado
   no arquivo de senha. Isso significa que o usuario nao aparecera como
   membro ao usar a opc,ao groupshow com o pw(8), mas mostrara quando a
   informac,ao e consultada via id(1) ou uma ferramenta similar. Quando o
   pw(8) e usado para adicionar um usuario a um grupo, ele apenas manipula o
   /etc/group e nao tenta ler dados adicionais do /etc/passwd.

   Exemplo 3.10. Adicionando um novo membro a um grupo usando o pw(8)

 # pw groupmod teamtwo -m db
 # pw groupshow teamtwo
 teamtwo:*:1100:jru,db

   Neste exemplo, o argumento para -m e uma lista delimitada por virgulas de
   usuarios que devem ser adicionados ao grupo. Ao contrario do exemplo
   anterior, esses usuarios sao adicionados ao grupo e nao substituem
   usuarios existentes no grupo.

   Exemplo 3.11. Usando o id(1) para determinar a associac,ao ao grupo

 % id jru
 uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)

   Neste exemplo, jru e um membro dos grupos jru e teamtwo.

   Para obter mais informac,oes sobre este comando e o formato do /etc/group,
   consulte pw(8) e group(5).

3.4. Permissoes

   No FreeBSD, todo arquivo e diretorio tem um conjunto associado de
   permissoes e varios utilitarios estao disponiveis para visualizar e
   modificar essas permissoes. E necessario entender como as permissoes
   funcionam para garantir que os usuarios consigam acessar os arquivos que
   precisam e nao consigam acessar os arquivos usados pelo sistema
   operacional ou de propriedade de outros usuarios.

   Esta sec,ao discute as permissoes UNIX(R) tradicionais usadas no FreeBSD.
   Para um controle de acesso ao sistema de arquivos mais refinado, consulte
   Sec,ao 13.9, "Listas de Controle de Acesso".

   No UNIX(R), as permissoes basicas sao atribuidas usando tres tipos de
   acesso: ler, escrever e executar. Esses tipos de acesso sao usados para
   determinar o acesso do arquivo ao proprietario, ao grupo e a outros
   usuarios do arquivo (todos os outros). As permissoes de leitura, gravac,ao
   e execuc,ao podem ser representadas como as letras r, w e x. Elas tambem
   podem ser representados como numeros binarios, pois cada permissao esta
   ativada ou desativada (0). Quando representada como um numero, a ordem e
   sempre lida como rwx, onde r e ativado com o valor 4, w e ativado com o
   valor 2 e x e ativado com o valor 1.

   A Tabela 4.1 resume as possiveis possibilidades numericas e alfabeticas.
   Ao ler a coluna "Listagem do Diretorio", um - e usado para representar uma
   permissao que esta desativada.

   Tabela 3.2. Permissoes UNIX(R)

    Valor                   Permissao                  Listagem de diretorio  
   0        Sem leitura, sem escrita, sem execuc,ao   ---                     
   1        Sem leitura, sem escrita, execuc,ao       --x                     
   2        Sem leitura, escrita, sem execuc,ao       -w-                     
   3        Sem leitura, escrita, execuc,ao           -wx                     
   4        Leitura, sem escrita, sem execuc,ao       r--                     
   5        Leitura, sem escrita, execuc,ao           r-x                     
   6        Leitura, escrita, sem execuc,ao           rw-                     
   7        Leitura, escrita, execuc,ao               rwx                     

   Use o argumento -l com o ls(1) para exibir uma lista longa de diretorios
   que inclua uma coluna de informac,oes sobre um permissoes do arquivo para
   o proprietario, grupo e outros. Por exemplo, um ls -l em um diretorio
   arbitrario pode mostrar:

 % ls -l
 total 530
 -rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
 -rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
 -rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt

   O primeiro caractere (mais `a esquerda) da primeira coluna indica se esse
   arquivo e um arquivo normal, um diretorio, um dispositivo de caractere
   especial, um soquete ou qualquer outro dispositivo especial de
   pseudo-arquivo. Neste exemplo, o - indica um arquivo regular. Os proximos
   tres caracteres, rw- neste exemplo, fornecem as permissoes para o
   proprietario do arquivo. Os proximos tres caracteres, r--, fornecem as
   permissoes para o grupo ao qual o arquivo pertence. Os tres ultimos
   caracteres, r--, dao as permissoes para o resto do mundo. Um trac,o
   significa que a permissao esta desativada. Neste exemplo, as permissoes
   sao definidas para que o proprietario possa ler e gravar no arquivo, o
   grupo possa ler o arquivo e o resto do mundo so possa ler o arquivo. De
   acordo com a tabela acima, as permissoes para este arquivo seriam 644,
   onde cada digito representa uma das tres partes da permissao do arquivo.

   Como o sistema controla as permissoes nos dispositivos? O FreeBSD trata a
   maioria dos dispositivos de hardware como um arquivo nos quais os
   programas podem abrir, ler e gravar dados. Esses arquivos de dispositivos
   especiais sao armazenados em /dev/.

   Diretorios tambem sao tratados como arquivos. Eles tem permissoes de
   leitura, gravac,ao e execuc,ao. O bit executavel de um diretorio tem um
   significado ligeiramente diferente que nos arquivos. Quando um diretorio e
   marcado como executavel, isso significa que e possivel mudar para esse
   diretorio usando cd(1). Isso tambem significa que e possivel acessar os
   arquivos dentro desse diretorio, sujeito `as permissoes dos proprios
   arquivos.

   Para executar uma listagem de diretorios, a permissao de leitura deve
   estar ativada no diretorio. Para deletar um arquivo que se conhece o nome,
   e necessario ter permissoes de escrita e execuc,ao no diretorio que contem
   o arquivo.

   Ha mais bits de permissao, mas eles sao usados principalmente em
   circunstancias especiais, como binarios setuid e diretorios fixos. Para
   obter mais informac,oes sobre permissoes de arquivos e como configura-las,
   consulte chmod(1).

  3.4.1. Permissoes simbolicas

   Contribuido por Tom Rhodes.

   Permissoes simbolicas usam caracteres em vez de valores octais para
   atribuir permissoes a arquivos ou diretorios. Permissoes simbolicas usam a
   sintaxe de (quem) (ac,ao) (permissoes), onde os seguintes valores estao
   disponiveis:

         Opc,ao           Letra                    Representa                 
   (quem)              u            Usuario                                   
   (quem)              g            Grupo                                     
   (quem)              o            Outros                                    
   (quem)              a            Todos ("resto do mundo")                  
   (ac,ao)             +            Adiciona permissoes                       
   (ac,ao)             -            Remove permissoes                         
   (ac,ao)             =            Permissoes definidas explicitamente       
   (permissoes)        r            Leitura                                   
   (permissoes)        w            Escrita                                   
   (permissoes)        x            Execuc,ao                                 
   (permissoes)        t            bit fixador                               
   (permissoes)        s            Set UID ou GID                            

   Esses valores sao usados com o chmod(1), mas com letras em vez de numeros.
   Por exemplo, o comando a seguir impediria que outros usuarios acessassem
   FILE:

 % chmod go= FILE

   Uma lista separada por virgula pode ser fornecida quando mais de um
   conjunto de alterac,oes em um arquivo precisar ser feito. Por exemplo, o
   comando a seguir remove as permissoes de gravac,ao do grupo e "resto do
   mundo" no FILE e adiciona as permissoes de execuc,ao para todos:

 % chmod go-w,a+x FILE

  3.4.2. Flags de arquivos no FreeBSD

   Contribuido por Tom Rhodes.

   Alem das permissoes de arquivo, o FreeBSD suporta o uso de "flags de
   arquivo". Esses sinalizadores adicionam um nivel a mais de seguranc,a e
   controle sobre os arquivos, mas nao nos diretorios. Com flags de arquivos,
   mesmo o root pode ser impedido de remover ou alterar arquivos.

   Os sinalizadores de arquivo sao modificados usando o chflags(1). Por
   exemplo, para ativar o sinalizador undeletable do sistema no arquivo
   file1, use o seguinte comando:

 # chflags sunlink file1

   Para desabilitar o sinalizador undeletable do sistema, coloque um "no" na
   frente do sunlink:

 # chflags nosunlink file1

   Para visualizar os sinalizadores de um arquivo, use -lo com o ls(1):

 # ls -lo file1

 -rw-r--r-- 1 trhodes trhodes sunlnk 0 Mar 1 05:54 file1

   Varios flags de arquivo so podem ser adicionados ou removidos pelo usuario
   root. Em outros casos, o proprietario do arquivo pode definir seus
   sinalizadores. Consulte chflags(1) e chflags(2) para maiores informac,oes.

  3.4.3. As permissoes setuid, setgid e sticky

   Contribuido por Tom Rhodes.

   Alem das permissoes ja discutidas, existem tres outras configurac,oes
   especificas que todos os administradores devem conhecer. Eles sao as
   permissoes setuid, setgid e sticky.

   Essas configurac,oes sao importantes para algumas operac,oes UNIX(R), pois
   fornecem funcionalidades normalmente nao concedidas a usuarios normais.
   Para compreende-los, a diferenc,a entre o ID real de usuario e o ID
   efetivo de usuario deve ser explicada.

   O ID de usuario real e o UID que inicia ou e o dono do processo. O ID de
   usuario efetivo e o UID do usuario com o qual o processo e executado. Por
   exemplo, o passwd(1) e executado com o ID do usuario real quando um
   usuario altera sua senha. No entanto, para atualizar o banco de dados de
   senhas, o comando e executado como o ID efetivo do usuario root. Isso
   permite que os usuarios alterem suas senhas sem ver um erro Permission
   Denied.

   A permissao setuid pode ser definida prefixando um conjunto de permissoes
   com o numero quatro (4), conforme mostrado no exemplo a seguir:

 # chmod 4755 suidexample.sh

   As permissoes em suidexample.sh agora se parecem com o seguinte:

 -rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh

   Observe que um s agora faz parte do conjunto de permissoes designado para
   o proprietario do arquivo, substituindo o bit executavel. Isso viabiliza
   utilitarios que precisam de permissoes elevadas, como o passwd(1).

  Nota:

   A opc,ao nosuid mount(8) fara com que esses binarios falhem
   silenciosamente sem alertar o usuario. Essa opc,ao nao e totalmente
   confiavel, ja que um wrapper nosuid pode contorna-la.

   Para ver isso em tempo real, abra dois terminais. Em um deles, digite
   passwd como um usuario normal. Enquanto aguarda uma nova senha, verifique
   a tabela de processos e observe as informac,oes de usuario do passwd(1):

   No terminal A:

 Changing local password for trhodes
 Old Password:

   No terminal B:

 # ps aux | grep passwd

 trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
 root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd

   Embora passwd(1) seja executado como um usuario normal, ele esta usando o
   UID do root.

   A permissao setgid executa a mesma func,ao que a permissao setuid; exceto
   que altera as configurac,oes do grupo. Quando um aplicativo ou utilitario
   e executado com essa configurac,ao, ele recebe as permissoes com base no
   grupo do arquivo, nao no usuario que iniciou o processo.

   Para definir a permissao setgid em um arquivo, execute o chmod(1) com dois
   (2) no inicio:

 # chmod 2755 sgidexample.sh

   Na listagem a seguir, observe que o s esta agora no campo designado para
   as configurac,oes de permissao do grupo:

 -rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh

  Nota:

   Nestes exemplos, mesmo que o shell script em questao seja um arquivo
   executavel, ele nao sera executado com um EUID diferente ou um ID de
   usuario efetivo. Isso ocorre porque os shell scripts podem nao acessar as
   chamadas de sistema setuid(2).

   Os bits de permissao setuid e setgid podem diminuir a seguranc,a do
   sistema, permitindo permissoes elevadas. A terceira permissao especial, o
   sticky bit, pode fortalecer a seguranc,a de um sistema.

   Quando o sticky bit e definido em um diretorio, ele permite a exclusao de
   arquivos apenas pelo proprietario do arquivo. Isso e util para impedir a
   exclusao de arquivos em diretorios publicos, como /tmp, por usuarios que
   nao possuem o arquivo. Para utilizar essa permissao, use o um (1) no
   inicio das permissoes:

 # chmod 1777 /tmp

   A permissao sticky bit sera exibida como um t no final do conjunto de
   permissoes:

 # ls -al / | grep tmp

 drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp

3.5. Estrutura de Diretorios

   Entender a hierarquia de diretorios do FreeBSD e fundamental para obter
   uma compreensao geral do sistema. O diretorio mais importante e o root ou
   raiz ou "/". Esse diretorio e o primeiro montado no momento da
   inicializac,ao e contem a base do sistema necessaria para preparar o
   sistema operacional para a operac,ao multi-usuario. O diretorio raiz
   tambem contem pontos de montagem para outros sistemas de arquivos que sao
   montados durante a transic,ao para a operac,ao multi-usuario.

   Um ponto de montagem e um diretorio no qual sistemas de arquivos
   adicionais podem ser disponibilizados em um sistema de arquivos principal
   (geralmente o sistema de arquivos raiz). Isso e descrito em Sec,ao 3.6,
   "Organizac,ao dos Discos". Os pontos de montagem padrao incluem /usr/,
   /var/, /tmp/, /mnt/ e /cdrom/. Esses diretorios sao geralmente associados
   a entradas em /etc/fstab. Este arquivo e uma tabela de varios sistemas de
   arquivos e pontos de montagem e e lido pelo sistema. A maioria dos
   sistemas de arquivos em /etc/fstab e montada automaticamente no momento da
   inicializac,ao do script rc(8) a nao ser que haja a opc,ao noauto. Maiores
   detalhes em Sec,ao 3.7.1, "O arquivo fstab".

   Uma descric,ao completa da hierarquia do sistema de arquivos esta
   disponivel em hier(7). A tabela a seguir fornece uma visao geral dos
   diretorios mais comuns.

      Diretorio                            Descric,ao                         
   /               Diretorio raiz do sistema de arquivos.                     
   /bin/           Utilitarios de usuario fundamentais para ambientes mono e  
                   multi-usuario.                                             
   /boot/          Programas e arquivos de configurac,ao usados durante o     
                   bootstrap do sistema operacional.                          
   /boot/defaults/ Arquivos de configurac,ao de inicializac,ao padrao.        
                   Consulte loader.conf(5) para maiores detalhes.             
   /dev/           Nos de dispositivo (device nodes). Consulte intro(4) para  
                   detalhes.                                                  
   /etc/           Arquivos de configurac,ao do sistema e scripts.            
   /etc/defaults/  Arquivos padrao de configurac,ao do sistema. Consulte      
                   rc(8) para maiores detalhes.                               
   /etc/mail/      Arquivos de configurac,ao para agentes de transporte de    
                   mensagens, como o sendmail(8).                             
   /etc/periodic/  Scripts que sao executados diariamente, semanalmente e     
                   mensalmente, por meio do cron(8). Consulte periodic(8)     
                   para maiores detalhes.                                     
   /etc/ppp/       Arquivos de configurac,ao do ppp(8).                       
   /mnt/           Diretorio vazio comumente usado pelos administradores do   
                   sistema como um ponto de montagem temporario.              
   /proc/          Sistema de arquivos de processos. Consulte procfs(5),      
                   mount_procfs(8) para detalhes.                             
   /rescue/        Programas vinculados estaticamente para recuperac,ao de    
                   emergencia, conforme descrito em rescue(8).                
   /root/          Diretorio da conta root.                                   
   /sbin/          Programas do sistema e utilitarios de administrac,ao       
                   fundamentais para ambientes mono e multi-usuario.          
   /tmp/           Arquivos temporarios que normalmente nao sao preservados   
                   em uma reinicializac,ao do sistema. Um sistema de arquivos 
                   baseado em memoria e frequentemente montado em /tmp. Isso  
                   pode ser automatizado usando as variaveis relacionadas ao  
                   tmpmfs do rc.conf(5) ou com uma entrada em /etc/fstab;     
                   consulte mdmfs(8) para maiores detalhes.                   
   /usr/           A maioria dos utilitarios e aplicativos do usuario.        
   /usr/bin/       Utilitarios comuns, ferramentas de programac,ao e          
                   aplicativos.                                               
   /usr/include/   Arquivos para "include" do C padrao.                       
   /usr/lib/       Arquivos de biblioteca.                                    
   /usr/libdata/   Diversos arquivos de dados de utilitarios.                 
   /usr/libexec/   Daemons do sistema e utilitarios do sistema executados por 
                   outros programas.                                          
   /usr/local/     Executaveis e bibliotecas locais. Tambem e usado como o    
                   destino padrao para o framework do ports do FreeBSD.       
                   Dentro do /usr/local, o layout geral esboc,ado por hier(7) 
                   para /usr deve ser usado. Excec,oes sao o diretorio man,   
                   que esta diretamente sob /usr/local em vez de sob          
                   /usr/local/share, e a documentac,ao do ports esta em       
                   share/doc/port.                                            
   /usr/obj/       Arvore de destino especifica da arquitetura produzida pela 
                   construc,ao da arvore /usr/src.                            
   /usr/ports/     A Colec,ao de Ports do FreeBSD (opcional).                 
   /usr/sbin/      Daemons do sistema e utilitarios do sistema executados     
                   pelos usuarios.                                            
   /usr/share/     Arquivos independentes de arquitetura.                     
   /usr/src/       Arquivos do codigo-fonte do BSD.                           
   /var/           Arquivos de log de multiplos propositos, temporarios,      
                   transientes e de spool. Um sistema de arquivos baseado em  
                   memoria `as vezes e montado em /var. Isso pode ser         
                   automatizado usando as variaveis relacionadas ao varmfs em 
                   rc.conf(5) ou com uma entrada em /etc/fstab; consulte      
                   mdmfs(8) para maiores detalhes.                            
   /var/log/       Diversos arquivos de log do sistema.                       
   /var/mail/      Arquivos de caixa de correio do usuario.                   
   /var/spool/     Diretorios de spooling de impressoras e sistemas de email. 
   /var/tmp/       Arquivos temporarios que geralmente sao preservados em uma 
                   reinicializac,ao do sistema, a menos que /var seja um      
                   sistema de arquivos baseado em memoria.                    
   /var/yp/        Mapas de NIS.                                              

3.6. Organizac,ao dos Discos

   A menor unidade de organizac,ao que o FreeBSD usa para encontrar arquivos
   e o nome do arquivo. Os nomes dos arquivos diferenciam maiusculas de
   minusculas, o que significa que readme.txt e README.TXT sao dois arquivos
   distintos. O FreeBSD nao usa a extensao de um arquivo para determinar se e
   um programa, documento ou alguma outra forma de dados.

   Os arquivos sao armazenados em diretorios. Um diretorio pode nao conter
   arquivos ou pode conter centenas deles. Um diretorio tambem pode conter
   outros diretorios, permitindo uma hierarquia de diretorios entre si para
   organizar os dados.

   Arquivos e diretorios sao referenciados por meio de um nome, seguido por
   uma barra, /, seguido por qualquer outro nome de diretorio que seja
   necessario. Por exemplo, se o diretorio foo contiver um diretorio bar que
   contenha o arquivo readme.txt, o nome completo ou caminho, para o arquivo
   e foo/bar/readme.txt. Observe que isso e diferente do Windows(R) que usa \
   para separar nomes de arquivos e diretorios. O FreeBSD nao usa letras de
   unidades ou outros nomes de unidades no caminho. Por exemplo, nao se deve
   digitar c:\foo\bar\readme.txt no FreeBSD.

   Diretorios e arquivos sao armazenados em um sistema de arquivos. Cada
   sistema de arquivos contem exatamente um diretorio no nivel superior,
   chamado de diretorio raiz para esse sistema de arquivos. Este diretorio
   raiz pode conter outros diretorios. Um sistema de arquivos e designado
   como sistema de arquivos raiz ou /. Todos os outros sistemas de arquivos
   sao montados no sistema de arquivos raiz. Nao importa quantos discos
   estejam no sistema FreeBSD, cada diretorio parece fazer parte do mesmo
   disco.

   Considere tres sistemas de arquivos, chamados A, B e C. Cada sistema de
   arquivos tem um diretorio raiz, que contem dois outros diretorios,
   chamados A1, A2 (e da mesma forma B1, B2 e C1, C2).

   Chame A de sistema de arquivos raiz. Se ls(1) for usado para visualizar o
   conteudo deste diretorio, ele mostrara dois subdiretorios, A1 e A2. A
   arvore de diretorios tem esta aparencia:

   Um sistema de arquivos deve ser montado em um diretorio em outro sistema
   de arquivos. Ao montar o sistema de arquivos B no diretorio A1, o
   diretorio raiz de B substitui A1 e os diretorios em B aparecem de acordo:

   Todos os arquivos que estao nos diretorios B1 ou B2 podem ser alcanc,ados
   com o caminho /A1/B1 ou /A1/B2, conforme necessario. Todos os arquivos que
   estavam em /A1 foram temporariamente ocultados. Eles reaparecerao se B for
   desmontado de A.

   Se B tivesse sido montado em A2, o diagrama ficaria assim:

   e os caminhos seriam /A2/B1 e /A2/B2 respectivamente.

   Os sistemas de arquivos podem ser montados uns em cima dos outros.
   Continuando o ultimo exemplo, o sistema de arquivos C pode ser montado no
   topo do diretorio B1 no sistema de arquivos B, levando a esta disposic,ao:

   Ou C poderia ser montado diretamente no sistema de arquivos A, sob o
   diretorio A1:

   E perfeitamente possivel ter um sistema de arquivos raiz grande e nao
   precisar criar nenhum outro. Existem algumas desvantagens nessa abordagem
   e uma vantagem.

   Beneficios de varios sistemas de arquivos
     * Sistemas de arquivos diferentes podem ter diferentes opc,oes de
       montagem. Por exemplo, o sistema de arquivos raiz pode ser montado
       somente para leitura, impossibilitando que os usuarios excluam ou
       editem inadvertidamente um arquivo critico. Separar sistemas de
       arquivos gravaveis pelo usuario, como /home, de outros sistemas de
       arquivos permite que eles sejam montados como nosuid. Essa opc,ao
       impede que os bits suid/guid dos executaveis armazenados no sistema de
       arquivos entrem em vigor, possivelmente melhorando a seguranc,a.

     * O FreeBSD otimiza automaticamente o layout dos arquivos em um sistema
       de arquivos, dependendo de como o sistema de arquivos esta sendo
       usado. Portanto, um sistema de arquivos que contem muitos arquivos
       pequenos que sao gravados com frequ:encia tera uma otimizac,ao
       diferente para um que contenha menos arquivos maiores. Ao ter um
       sistema de arquivos maior, essa otimizac,ao e quebrada.

     * Os sistemas de arquivos do FreeBSD sao robustos se a energia for
       perdida. No entanto, uma perda de energia em um ponto critico ainda
       pode danificar a estrutura do sistema de arquivos. Ao dividir dados em
       varios sistemas de arquivos, e mais provavel que o sistema ainda
       inicialize, facilitando a restaurac,ao do backup conforme necessario.

   Beneficio de um sistema de arquivos unico
     * Os sistemas de arquivos sao de tamanho fixo. Se voce cria um sistema
       de arquivos quando instala o FreeBSD e da a ele um tamanho especifico,
       voce pode descobrir mais tarde que precisa aumentar a partic,ao. Isso
       nao e facilmente realizado sem um backup, recriando o sistema de
       arquivos com o novo tamanho e, em seguida, restaurando os dados de
       backup.

  Importante:

       O FreeBSD possui o comando growfs(8), que torna possivel aumentar o
       tamanho do sistema de arquivos enquanto montado, removendo essa
       limitac,ao.

   Os sistemas de arquivos estao contidos em partic,oes. Isto nao tem o mesmo
   significado que o uso comum do termo partic,ao (por exemplo, a partic,ao
   MS-DOS(R)), por causa da heranc,a UNIX(R) do FreeBSD. Cada partic,ao e
   identificada por uma letra de a ate h. Cada partic,ao pode conter apenas
   um sistema de arquivos, o que significa que os sistemas de arquivos
   geralmente sao descritos por seu ponto de montagem tipico na hierarquia do
   sistema de arquivos ou pela letra da partic,ao em que estao contidos.

   O FreeBSD tambem usa espac,o em disco para espac,o de swap para fornecer
   memoria virtual. Isso permite que o seu computador se comporte como se
   tivesse muito mais memoria do que realmente tem. Quando o FreeBSD fica sem
   memoria, ele move alguns dos dados que nao estao sendo usados atualmente
   para o espac,o de swap, e os move de volta (removendo alguma outra coisa)
   quando precisa.

   Algumas partic,oes possuem certas convenc,oes associadas a elas.

   Partic,ao                            Convenc,ao                            
   a         Normalmente contem o sistema de arquivos raiz.                   
   b         Normalmente contem espac,o de swap.                              
   c         Normalmente o mesmo tamanho da slice que a envolve. Isso permite 
             que os programas que precisem trabalhar na slice inteira, como   
             um scanner de bloco defeituoso, trabalhem na partic,ao c. Um     
             sistema de arquivos normalmente nao seria criado nessa           
             partic,ao.                                                       
   d         A partic,ao d costumava ter um significado especial associado a  
             ela, mas isso foi descontinuado e d pode funcionar como qualquer 
             partic,ao normal.                                                

   Os discos no FreeBSD sao divididos em slices, referidas no Windows(R) como
   partic,oes, numeradas de 1 a 4. Estas sao entao divididas em partic,oes,
   que contem sistemas de arquivos, e sao rotuladas usando letras.

   Os numeros das slices seguem o nome do dispositivo, prefixado com um s,
   comec,ando em 1. Entao "da0s1" e a primeira slice na primeira unidade
   SCSI. Pode haver apenas quatro slices fisicas em um disco, mas pode haver
   slices logicas dentro de slices fisicas do tipo apropriado. Essas slices
   estendidas sao numeradas a partir de 5, entao "ada0s5" e a primeira slice
   estendida no primeiro disco SATA. Esses dispositivos sao usados por
   sistemas de arquivos que esperam ocupar uma slice.

   Slices, unidades fisicas "perigosamente dedicadas" e outras unidades
   contem partic,oes , que sao representadas como letras de a ate h. Esta
   letra e adicionada ao nome do dispositivo, entao "da0a" e a partic,ao a na
   primeira unidade da, que e "perigosamente dedicada". A "ada1s3e" e a
   quinta partic,ao na terceira slice da segunda unidade de disco SATA.

   Finalmente, cada disco no sistema e identificado. Um nome de disco comec,a
   com um codigo que indica o tipo de disco e, em seguida, um numero,
   indicando qual e o disco. Ao contrario das slices, a numerac,ao de discos
   comec,a em 0. Codigos usuais sao listados em Tabela 3.3, "Nomes de
   dispositivos de disco".

   Ao se referir a uma partic,ao, inclua o nome do disco, s, o numero da
   slice, em seguida, a letra da partic,ao. Exemplos sao mostrados em
   Exemplo 3.12, "Exemplo de Nomes de Disco, Slice e Partic,ao".

   Exemplo 3.13, "Modelo conceitual de um disco" mostra um modelo conceitual
   de um layout de disco.

   Ao instalar o FreeBSD, configure as slices de disco, crie partic,oes
   dentro da slice a ser usada para o FreeBSD, crie um sistema de arquivos ou
   espac,o de swap em cada partic,ao e decida onde cada sistema de arquivos
   sera montado.

   Tabela 3.3. Nomes de dispositivos de disco

           Tipo de drive                        Nome do drive                 
   discos rigidos SATA e IDE     ada ou ad                                    
   Discos rigidos SCSI e                                                      
   dispositivos de armazenamento da
   USB                           
   drives de CD-ROM SATA e IDE   cd ou acd                                    
   Unidades SCSI CD-ROM          cd                                           
   Unidades de disquete          fd                                           
   Unidades de CD-ROM nao-padrao mcd para CD-ROM Mitsumi e scd para           
   variadas                      dispositivos de CD-ROM Sony                  
   Unidades de fita SCSI         sa                                           
   Unidades de fita IDE          ast                                          
                                 Exemplos incluem aacd para Adaptec(R)        
   Drives RAID                   AdvancedRAID, mlxd e mlyd para Mylex(R),     
                                 amrd para AMI MegaRAID(R), idad para Compaq  
                                 Smart RAID, twed para 3ware(R) RAID.         

   Exemplo 3.12. Exemplo de Nomes de Disco, Slice e Partic,ao

    Nome                              Significado                             
   ada0s1a A primeira partic,ao (a) na primeira slice (s1) no primeiro disco  
           SATA (ada0).                                                       
   da1s2e  A quinta partic,ao (e) na segunda slice (s2) no segundo disco SCSI 
           (da1).                                                             

   Exemplo 3.13. Modelo conceitual de um disco

   Este diagrama mostra a visao do FreeBSD do primeiro disco SATA conectado
   ao sistema. Suponha que o disco tenha 250 GB de tamanho e contenha uma
   slice de 80 GB e uma slice de 170 GB (partic,oes MS-DOS(R)). A primeira
   slice contem um sistema de arquivos Windows(R) NTFS, C:, e a segunda fatia
   contem uma instalac,ao do FreeBSD. Este exemplo de instalac,ao do FreeBSD
   possui quatro partic,oes de dados e uma partic,ao swap.

   Cada uma das quatro partic,oes contem um sistema de arquivos. A partic,ao
   a e usada para o sistema de arquivos raiz, d para /var/, e para /tmp/ e f
   para /usr/. A letra de partic,ao c refere-se `a fatia inteira e, portanto,
   nao e usada para partic,oes comuns.

3.7. Montando e Desmontando Sistemas de Arquivos

   O sistema de arquivos e melhor visualizado como uma arvore, enraizada, por
   assim dizer, em /. O /dev, /usr, e os outros diretorios no diretorio raiz
   sao ramos, que podem ter suas proprias ramificac,oes, como /usr/local e
   assim por diante.

   Existem varias razoes para abrigar alguns desses diretorios em sistemas de
   arquivos separados. O /var contem os diretorios log/, spool/ e varios
   tipos de arquivos temporarios e, como tal, podem encher. Encher
   completamente o sistema de arquivos raiz nao e uma boa ideia, entao
   separar o /var do / geralmente e vantajoso.

   Outro motivo comum para colocar determinadas arvores de diretorio em
   outros sistemas de arquivos e se elas forem ser armazenadas em discos
   fisicos separados ou se sao discos virtuais separados, tal como montagens
   de NFS (Network File System), descritas em Sec,ao 29.3, "Network File
   System (NFS)" ou unidades de CD-ROM.

  3.7.1. O arquivo fstab

   Durante o processo de inicializac,ao (Capitulo 12, O processo de
   inicializac,ao do FreeBSD), os sistemas de arquivos listados em /etc/fstab
   sao automaticamente montados, exceto pelas entradas que contem noauto.
   Este arquivo contem entradas no seguinte formato:

 device       /mount-point fstype     options      dumpfreq     passno

   device

           Um nome de dispositivo existente, conforme explicado em
           Tabela 3.3, "Nomes de dispositivos de disco".

   mount-point

           Um diretorio existente no qual montar o sistema de arquivos.

   fstype

           O tipo de sistema de arquivos para passar para o mount(8). O
           sistema de arquivos padrao do FreeBSD e o ufs.

   options

           rw para sistemas de arquivos de leitura/gravac,ao, ou ro para
           sistemas de arquivos somente de leitura, seguidos por quaisquer
           outras opc,oes que possam ser necessarias. Uma opc,ao comum e
           noauto para sistemas de arquivos normalmente nao montados durante
           a sequ:encia de inicializac,ao. Outras opc,oes estao listadas em
           mount(8).

   dumpfreq

           Usado pelo dump(8) para determinar quais sistemas de arquivos
           requerem o dump. Se o campo estiver faltando, um valor zero sera
           assumido.

   passno

           Determina a ordem em que os sistemas de arquivos devem ser
           verificados. Os sistemas de arquivos que devem ser ignorados devem
           ter seu passno definido como zero. O sistema de arquivos raiz
           precisa ser verificado antes de todo o restante e deve ter seu
           passno definido como um. Os outros sistemas de arquivos devem ser
           configurados para valores maiores que um. Se mais de um sistema de
           arquivos tiver o mesmo passno, o fsck(8) tentara verificar os
           sistemas de arquivos em paralelo, se possivel.

   Consulte fstab(5) para obter maiores informac,oes sobre o formato do
   /etc/fstab e suas opc,oes.

  3.7.2. Usando o mount(8)

   Os sistemas de arquivos sao montados usando o comando mount(8). A sintaxe
   mais basica e a seguinte:

 # mount device mountpoint

   Este comando fornece muitas opc,oes que sao descritas em mount(8). As
   opc,oes mais usadas incluem:

   Opc,oes de montagem

   -a

           Monte todos os sistemas de arquivos listados em /etc/fstab, exceto
           aqueles marcados como "noauto", excluidos pela opc,ao -t, ou
           aqueles que ja estao montados.

   -d

           Faz tudo, exceto a chamada real do sistema de montagem. Esta
           opc,ao e util em conjunto com a opc,ao -v para determinar o que o
           mount(8) esta realmente tentando fazer.

   -f

           Forc,a a montagem de um sistema de arquivos sujo (perigoso) ou a
           revogac,ao do acesso de gravac,ao ao fazer o downgrade do status
           de montagem de um sistema de arquivos de leitura/gravac,ao para
           somente leitura.

   -r

           Monta o sistema de arquivos somente para leitura. Isso e identico
           ao uso de -o ro.

   -t fstype

           Monta o tipo de sistema de arquivos especificado ou monta somente
           sistemas de arquivos do tipo especificado, se -aestiver incluido.
           "ufs" e o tipo de sistema de arquivos padrao.

   -u

           Atualiza as opc,oes de montagem no sistema de arquivos.

   -v

           Fica verboso (mostra mais informac,oes).

   -w

           Monta o sistema de arquivos para leitura/gravac,ao.

   As seguintes opc,oes podem ser passadas para -o como uma lista separada
   por virgula:

   nosuid

           Nao interprete flags setuid ou setgid no sistema de arquivos. Essa
           tambem e uma opc,ao de seguranc,a util.

  3.7.3. Usando o umount(8)

   Para desmontar um sistema de arquivos use umount(8). Esse comando usa um
   parametro que pode ser um ponto de montagem, um nome do dispositivo, -a ou
   -A.

   Todos os usos aceitam -f para forc,ar a desmontagem e -v para ver mais
   informac,oes. Atenc,ao, em geral -f nao e uma boa opc,ao, pois pode travar
   o computador ou danificar os dados no sistema de arquivos.

   Para desmontar todos os sistemas de arquivos montados, ou apenas os tipos
   de sistema de arquivos listados apos -t, use -a ou -A. Note que -A nao
   tenta desmontar o sistema de arquivos raiz.

3.8. Processos e Daemons

   O FreeBSD e um sistema operacional multitarefa. Cada programa em execuc,ao
   a qualquer momento e chamado de processo. Todo comando em execuc,ao inicia
   pelo menos um novo processo e ha varios processos de sistema que sao
   executados pelo FreeBSD.

   Cada processo e identificado exclusivamente por um numero chamado ID do
   processo (PID). Semelhante aos arquivos, cada processo tem um proprietario
   e um grupo, e as permissoes de proprietario e grupo sao usadas para
   determinar quais arquivos e dispositivos o processo pode abrir. A maioria
   dos processos tambem possui um processo pai que os iniciou. Por exemplo, o
   shell e um processo e qualquer comando iniciado no shell e um processo que
   tem o shell como seu processo pai. A excec,ao e um processo especial
   chamado init(8) que e sempre o primeiro processo a rodar na inicializac,ao
   e que sempre possui um PID de 1.

   Alguns programas nao sao projetados para serem executados com a entrada
   continua do usuario e desconectam do terminal na primeira oportunidade.
   Por exemplo, um servidor da Web responde a solicitac,oes da Web, em vez de
   entradas do usuario. Servidores de email sao outro exemplo desse tipo de
   aplicativo. Esses tipos de programas sao conhecidos como daemons. O termo
   daemon vem da mitologia grega e representa uma entidade que nao e boa nem
   ma, e que invisivelmente realiza tarefas uteis. E por isso que o mascote
   do BSD e o daemon de aparencia alegre com tenis e um tridente.

   Existe uma convenc,ao para nomear programas que normalmente sao executados
   como daemons com um "d" `a direita. Por exemplo, BIND e o Berkeley
   Internet Name Domain, mas o programa real que e executado e named. O
   programa do servidor da web Apache e o httpd e o daemon de spooling da
   impressora de linha e o lpd. Esta e apenas uma convenc,ao de nomenclatura.
   Por exemplo, o daemon de correio principal para o aplicativo Sendmail e o
   sendmail e nao maild.

  3.8.1. Visualizando Processos

   Para ver os processos em execuc,ao no sistema, use o ps(1) ou o top(1).
   Para exibir uma lista estatica dos processos em execuc,ao no momento, seus
   PIDs, quanta memoria eles estao usando e o comando com o qual eles foram
   iniciados, use o ps(1). Para exibir todos os processos em execuc,ao e
   atualizar a exibic,ao a cada poucos segundos para ver interativamente o
   que o computador esta fazendo, use o top(1).

   Por padrao, o ps(1) mostra apenas os comandos que estao em execuc,ao e que
   sao de propriedade do usuario. Por exemplo:

 % ps
  PID TT  STAT    TIME COMMAND
 8203  0  Ss   0:00.59 /bin/csh
 8895  0  R+   0:00.00 ps

   A saida do ps(1) e organizada em varias colunas. A coluna PID exibe o ID
   do processo. Os PIDs sao atribuidos a partir de 1, vao ate 99999, e depois
   retornam ao inicio. No entanto, um PID nao e reatribuido se ja estiver em
   uso. A coluna TT mostra o tty em que o programa esta sendo executado e
   STAT mostra o estado do programa. TIME e a quantidade de tempo que o
   programa foi executado na CPU. Normalmente, esse nao e o tempo decorrido
   desde que o programa foi iniciado, pois a maioria dos programas gasta
   muito tempo esperando que as coisas acontec,am antes que precisem gastar
   tempo na CPU. Finalmente, COMMAND e o comando que foi usado para iniciar o
   programa.

   Varias opc,oes diferentes estao disponiveis para alterar as informac,oes
   exibidas. Um dos conjuntos mais uteis e auxww, onde a exibe informac,oes
   sobre todos os processos em execuc,ao de todos os usuarios, u exibe o nome
   de usuario e o uso de memoria do proprietario do processo, x exibe
   informac,oes sobre os processos do daemon e ww faz com que o ps(1) exiba a
   linha de comando completa para cada processo, em vez de trunca-la para
   caber na tela quando e muito longa.

   A saida do top(1) e semelhante a abaixo:

 % top
 last pid:  9609;  load averages:  0.56,  0.45,  0.36              up 0+00:20:03  10:21:46
 107 processes: 2 running, 104 sleeping, 1 zombie
 CPU:  6.2% user,  0.1% nice,  8.2% system,  0.4% interrupt, 85.1% idle
 Mem: 541M Active, 450M Inact, 1333M Wired, 4064K Cache, 1498M Free
 ARC: 992M Total, 377M MFU, 589M MRU, 250K Anon, 5280K Header, 21M Other
 Swap: 2048M Total, 2048M Free

   PID USERNAME    THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
   557 root          1 -21  r31   136M 42296K select  0   2:20  9.96% Xorg
  8198 dru           2  52    0   449M 82736K select  3   0:08  5.96% kdeinit4
  8311 dru          27  30    0  1150M   187M uwait   1   1:37  0.98% firefox
   431 root          1  20    0 14268K  1728K select  0   0:06  0.98% moused
  9551 dru           1  21    0 16600K  2660K CPU3    3   0:01  0.98% top
  2357 dru           4  37    0   718M   141M select  0   0:21  0.00% kdeinit4
  8705 dru           4  35    0   480M    98M select  2   0:20  0.00% kdeinit4
  8076 dru           6  20    0   552M   113M uwait   0   0:12  0.00% soffice.bin
  2623 root          1  30   10 12088K  1636K select  3   0:09  0.00% powerd
  2338 dru           1  20    0   440M 84532K select  1   0:06  0.00% kwin
  1427 dru           5  22    0   605M 86412K select  1   0:05  0.00% kdeinit4

   A saida e dividida em duas sec,oes. O cabec,alho (as primeiras cinco ou
   seis linhas) mostra o PID do ultimo processo executado, as medias de carga
   do sistema (que sao uma medida de quao ocupado o sistema esta), o tempo de
   atividade do sistema desde a ultima reinicializac,ao) e a hora atual. As
   outras informac,oes no cabec,alho se relacionam com quantos processos
   estao sendo executados, quanta memoria e swap estao em uso e quanto tempo
   o sistema esta gastando em diferentes estados da CPU. Se o modulo do
   sistema de arquivos ZFS foi carregado, uma linha ARC indica a quantidade
   de dados que foram lidos do cache de memoria, e nao do disco.

   Abaixo do cabec,alho ha uma serie de colunas contendo informac,oes
   semelhantes `a saida do ps(1), como o PID, nome de usuario, quantidade de
   tempo de CPU e o comando que iniciou o processo. Por padrao, o top(1)
   tambem exibe a quantidade de espac,o de memoria ocupada pelo processo.
   Isso e dividido em duas colunas: uma para o tamanho total e outra para o
   tamanho do residente. O tamanho total e a quantidade de memoria que o
   aplicativo precisa e o tamanho de residente e o quanto ele esta realmente
   usando agora.

   O top(1) atualiza automaticamente a exibic,ao a cada dois segundos. Um
   intervalo diferente pode ser especificado com -s.

  3.8.2. Matando Processos

   Uma maneira de se comunicar com qualquer processo ou daemon em execuc,ao e
   enviar um sinal usando o kill(1). Existem varios sinais diferentes; alguns
   tem um significado especifico, enquanto outros sao descritos na
   documentac,ao do comando. Um usuario so pode enviar um sinal para um
   processo que seja seu. Enviar um sinal para o processo de outra pessoa
   resultara em um erro de permissao negada. A excec,ao e o usuario root, que
   pode enviar sinais para os processos de qualquer pessoa.

   O sistema operacional tambem pode enviar um sinal para um processo. Se um
   aplicativo estiver mal escrito e tentar acessar a memoria que nao deveria,
   o FreeBSD enviara ao processo o sinal de "Segmentation Violation"
   (SIGSEGV). Se uma aplicac,ao foi escrita para usar a chamada de sistema
   alarm(3) para ser alertada apos um periodo de tempo, sera enviado o sinal
   "Alarm" (SIGALRM).

   Dois sinais podem ser usados para interromper um processo: SIGTERM e
   SIGKILL. SIGTERM e a maneira educada de eliminar um processo, pois o
   processo pode ler o sinal, fechar quaisquer arquivos de log que possam
   estar abertos e tentar terminar o que esta fazendo antes de desligar. Em
   alguns casos, um processo pode ignorar SIGTERM se estiver no meio de
   alguma tarefa que nao pode ser interrompida.

   SIGKILL nao pode ser ignorado por um processo. Enviar um SIGKILL para um
   processo geralmente interrompera esse processo de uma vez por todas. [1].

   Outros sinais comumente usados sao SIGHUP, SIGUSR1 e SIGUSR2. Como esses
   sao sinais de finalidade geral, diferentes aplicativos responderao de
   maneira diferente.

   Por exemplo, depois de alterar o arquivo de configurac,ao de um servidor
   da Web, o servidor da Web precisa ser instruido a reler sua configurac,ao.
   Reiniciar o httpd resultaria em um breve periodo de interrupc,ao no
   servidor da web. Em vez disso, envie ao daemon o sinal SIGHUP. Esteja
   ciente de que diferentes daemons terao um comportamento diferente, entao
   consulte a documentac,ao do daemon para determinar se SIGHUP tera os
   resultados desejados.

   Procedimento 3.1. Enviando um sinal para um processo

   Este exemplo mostra como enviar um sinal para o inetd(8). O arquivo de
   configurac,ao do inetd(8) e o /etc/inetd.conf e o inetd(8) ira reler este
   arquivo de configurac,ao quando for enviado um SIGHUP.

    1. Encontre o PID do processo para enviar o sinal usando pgrep(1). Neste
       exemplo, o PID do inetd(8) e 198:

 % pgrep -l inetd
 198  inetd -wW

    2. Use o kill(1) para enviar o sinal. Como o inetd(8) e de propriedade do
       root, use o su(1) para se tornar root primeiro.

 % su
 Password:
 # /bin/kill -s HUP 198

       Como a maioria dos comandos UNIX(R), o kill(1) nao imprimira nenhuma
       saida se for bem-sucedido. Se um sinal for enviado para um processo
       que nao pertence ao usuario, a mensagem kill: PID: Operation not
       permitted sera exibida. Errar o PID ira enviar o sinal para o processo
       errado, o que poderia ter resultados negativos, ou enviara o sinal
       para um PID que nao esteja em uso no momento, resultando em o erro
       kill: PID: No such process.

  Por que usar o /bin/kill?:

       Muitos shells fornecem o kill como um comando interno, o que significa
       que o shell enviara o sinal diretamente, em vez de executar o
       /bin/kill. Esteja ciente de que diferentes shells possuem uma sintaxe
       diferente para especificar o nome do sinal a ser enviado. Em vez de
       tentar aprender todos eles, pode ser mais simples especificar
       explicitamente o uso do /bin/kill.

   Ao enviar outros sinais, substitua TERM ou KILL pelo nome do sinal.

  Importante:

   Matar um processo aleatorio no sistema e uma ma ideia. Em particular, o
   init(8), PID 1, e especial. Executar /bin/kill -s KILL 1 e uma maneira
   rapida e nao recomendada de desligar o sistema. Sempre verifique os
   argumentos do kill(1) antes de pressionar a tecla Enter.

3.9. Shells

   Um shell fornece uma interface de linha de comandos para interagir com o
   sistema operacional. Um shell recebe comandos do canal de entrada e os
   executa. Muitos shells fornecem func,oes incorporadas para ajudar nas
   tarefas diarias, como gerenciamento de arquivos, referenciamento de
   arquivos, edic,ao de linha de comando, macros de comando e variaveis de
   ambiente. O FreeBSD vem com varios shells, incluindo o shell Bourne
   (sh(1)) e o shell C estendido (tcsh(1)). Outros shells estao disponiveis
   na Colec,ao de Ports do FreeBSD, como o zsh e o bash.

   O shell usado e realmente uma questao de gosto. Um programador C pode se
   sentir mais confortavel com um shell semelhante ao C, como o tcsh(1). Um
   usuario Linux(R) pode preferir o bash. Cada shell tem propriedades unicas
   que podem ou nao funcionar com o ambiente de trabalho preferido de um
   usuario, e e por isso que existe a opc,ao de qual shell usar.

   Um recurso de shell comum e a conclusao do nome do arquivo. Depois que um
   usuario digita as primeiras letras de um comando ou nome de arquivo e
   pressiona a tecla Tab, o shell completa o restante do comando ou nome do
   arquivo. Considere dois arquivos chamados foobar e football. Para excluir
   foobar, o usuario pode digitar rm foo e pressionar a tecla Tab para
   completar o nome do arquivo.

   Mas se o shell mostrar apenas rm foo. Nao foi possivel completar o nome do
   arquivo porque ambos foobar e football comec,am com foo. Algumas shells
   emitem um sinal sonoro ou mostram todas as opc,oes se houver mais de um
   nome. O usuario deve digitar mais caracteres para identificar o nome do
   arquivo desejado. Digitar um t e pressionar a tecla Tab novamente e
   suficiente para permitir que o shell determine qual nome de arquivo e
   desejado e preencha o resto.

   Outra caracteristica do shell e o uso de variaveis de ambiente. As
   variaveis de ambiente sao um par de variavel/chave armazenado no ambiente
   do shell. Esse ambiente pode ser lido por qualquer programa chamado pela
   shell e, portanto, contem muitas configurac,oes de programas. Tabela 3.4,
   "Variaveis de Ambiente Comuns" fornece uma lista de variaveis de ambiente
   comuns e seus significados. Observe que os nomes das variaveis de ambiente
   estao sempre em maiusculas.

   Tabela 3.4. Variaveis de Ambiente Comuns

   Variavel                            Descric,ao                             
   USER     Nome do usuario atual.                                            
   PATH     Lista de diretorios separados por dois pontos para pesquisa de    
            binarios (progamas).                                              
   DISPLAY  Nome de rede do display do Xorg para conexao, se disponivel.      
   SHELL    O shell atual.                                                    
   TERM     O nome do tipo de terminal do usuario. Usado para determinar os   
            recursos do terminal.                                             
   TERMCAP  Acesso `a base de dados dos codigos de escape do terminal para    
            executar varias func,oes do terminal.                             
   OSTYPE   Tipo de sistema operacional.                                      
   MACHTYPE A arquitetura da CPU do sistema.                                  
   EDITOR   O editor de texto preferencial do usuario.                        
   PAGER    O utilitario preferencial do usuario para visualizac,ao de texto  
            pagina `a pagina.                                                 
   MANPATH  Lista de diretorios separados por dois pontos para pesquisar      
            paginas de manual.                                                

   O processo para definir uma variavel de ambiente difere entre as shells.
   Em tcsh(1) e csh(1), use setenv para definir variaveis de ambiente. Em
   sh(1) e no bash, use export para definir as variaveis de ambiente atuais.
   Este exemplo define o EDITOR padrao para /usr/local/bin/emacs para a shell
   tcsh(1):

 % setenv EDITOR /usr/local/bin/emacs

   O comando equivalente para bash seria:

 % export EDITOR="/usr/local/bin/emacs"

   Para expandir uma variavel de ambiente para ver sua configurac,ao atual,
   digite um caracter $ na frente de seu nome na linha de comando. Por
   exemplo, echo $TERM exibe a configurac,ao atual do $TERM.

   Shells tratam caracteres especiais, conhecidos como meta-caracteres, como
   representac,oes especiais de dados. O meta-caracter mais comum e *, que
   representa qualquer numero de caracteres em um nome de arquivo.
   Meta-caracteres podem ser usados para executar a globalizac,ao de nomes de
   arquivos. Por exemplo, echo * e equivalente a ls porque a shell pega todos
   os arquivos que correspondem ao * e echo os lista na linha de comando.

   Para evitar que a shell interprete um caractere especial, escape-o a
   partir da shell, iniciando-o com uma barra invertida (\). Por exemplo,
   echo $TERM imprime a configurac,ao do terminal, enquanto echo \$TERM
   imprime literalmente a string $TERM.

  3.9.1. Alterando a Shell

   A maneira mais facil de alterar permanentemente a shell padrao e usar o
   chsh. A execuc,ao desse comando abrira o editor que esta configurado na
   variavel de ambiente EDITOR, que por padrao e definido como o vi(1).
   Altere a linha Shell: para o caminho completo da nova shell.

   Como alternativa, use chsh -s, que ira definir a shell especificada sem
   abrir um editor. Por exemplo, para alterar a shell para bash:

 % chsh -s /usr/local/bin/bash

  Nota:

   A nova shell deve estar presente no arquivo /etc/shells. Se a shell foi
   instalada a partir da colec,ao de ports do FreeBSD, como descrito em
   Capitulo 4, Instalando Aplicativos: Pacotes e Ports, ela deve ser
   adicionada automaticamente a este arquivo. Se estiver faltando, adicione-a
   usando este comando, substituindo o caminho pelo caminho da shell:

 # echo /usr/local/bin/bash >> /etc/shells

   Em seguida, execute novamente o chsh(1).

  3.9.2. Tecnicas Avanc,adas de Shell

   Escrito porTom Rhodes.

   A shell UNIX(R) nao e apenas um interpretador de comandos, ela atua como
   uma ferramenta poderosa que permite aos usuarios executar comandos,
   redirecionar sua saida, redirecionar sua entrada e encadear comandos para
   melhorar o resultado final. Quando essa funcionalidade e mesclada com
   comandos incorporados, e fornecido ao usuario um ambiente que pode
   maximizar a eficiencia.

   O redirecionamento de shell e a ac,ao de enviar a saida ou a entrada de um
   comando para outro comando ou para um arquivo. Para capturar a saida do
   comando ls(1), por exemplo, em um arquivo, redirecione a saida:

 % ls > directory_listing.txt

   O conteudo do diretorio agora sera listado em directory_listing.txt.
   Alguns comandos podem ser usados para ler entradas, como sort(1). Para
   classificar esta listagem, redirecione a entrada:

 % sort < directory_listing.txt

   A entrada sera classificada e colocada na tela. Para redirecionar essa
   entrada para outro arquivo, pode-se redirecionar a saida de sort(1)
   misturando a direc,ao:

 % sort < directory_listing.txt > sorted.txt

   Em todos os exemplos anteriores, os comandos estao executando o
   redirecionamento usando descritores de arquivos. Todo sistema UNIX(R)
   possui descritores de arquivos, que incluem entrada padrao (stdin), saida
   padrao (stdout) e erro padrao (stderr). Cada um tem um proposito, onde a
   entrada pode ser um teclado ou um mouse, algo que fornece entrada. A saida
   pode ser uma tela ou papel em uma impressora. E erro seria tudo o que pode
   ser usado para mensagens de diagnostico ou erro. Todos os tres sao
   considerados descritores de arquivos baseados em I/O e, `as vezes,
   considerados fluxos.

   Atraves do uso desses descritores, a shell permite que a saida e a entrada
   sejam passadas por varios comandos e redirecionadas para/ou a partir de um
   arquivo. Outro metodo de redirecionamento e o operador de pipe.

   O operador pipe UNIX(R), "|" permite que a saida de um comando seja
   transmitida diretamente ou direcionada para outro programa. Basicamente,
   um pipe permite que a saida padrao de um comando seja passada como entrada
   padrao para outro comando, por exemplo:

 % cat directory_listing.txt | sort | less

   Nesse exemplo, o conteudo de directory_listing.txt sera classificado e a
   saida sera transmitida para less(1). Isso permite que o usuario role pela
   saida em seu proprio ritmo e evite que ela role para fora da tela.

3.10. Editores de Texto

   A maioria das configurac,oes do FreeBSD e feita atraves da edic,ao de
   arquivos de texto. Por isso, e uma boa ideia familiarizar-se com um editor
   de texto. O FreeBSD vem com alguns como parte do sistema base, e muitos
   outros estao disponiveis na colec,ao do ports.

   Um editor simples para aprender e o ee(1), que significa editor facil
   (Ease Editor). Para iniciar este editor, digite eefilename em que filename
   e o nome do arquivo a ser editado. Uma vez dentro do editor, todos os
   comandos para manipular as func,oes do editor sao listados no topo da
   tela. O cursor (^) representa Ctrl, entao ^e expande para Ctrl+e. Para
   sair do ee(1), pressione Esc e escolha a opc,ao "leave editor" no menu
   principal. O editor pedira para salvar as alterac,oes, caso o arquivo
   tenha sido modificado.

   O FreeBSD tambem vem com editores de texto mais poderosos, como o vi(1),
   como parte do sistema base. Outros editores, como editors/emacs e
   editors/vim, fazem parte da colec,ao do ports do FreeBSD. Esses editores
   oferecem mais funcionalidade `as custas de serem mais complicados de
   aprender. Aprender um editor mais poderoso como o vim ou o Emacs pode
   economizar mais tempo a longo prazo.

   Muitos aplicativos que modificam arquivos ou exigem entrada digitada
   abrirao automaticamente um editor de texto. Para alterar o editor padrao,
   defina a variavel de ambiente EDITOR conforme descrito em Sec,ao 3.9,
   "Shells".

3.11. Dispositivos e nos de dispositivos

   Um dispositivo e um termo usado principalmente para atividades
   relacionadas a hardware em um sistema, incluindo discos, impressoras,
   placas graficas e teclados. Quando o FreeBSD inicializa, a maioria das
   mensagens de inicializac,ao se refere aos dispositivos sendo detectados.
   Uma copia das mensagens de inicializac,ao e salva em /var/run/dmesg.boot.

   Cada dispositivo tem um nome e um numero de dispositivo. Por exemplo, ada0
   e o primeiro disco rigido SATA, enquanto kbd0 representa o teclado.

   A maioria dos dispositivos no FreeBSD deve ser acessada atraves de
   arquivos especiais chamados nos de dispositivos (device nodes), que estao
   localizados em /dev.

3.12. Paginas de Manual

   A documentac,ao mais abrangente sobre o FreeBSD esta na forma de paginas
   de manual. Quase todos os programas do sistema vem com um breve manual de
   referencia explicando a operac,ao basica e os argumentos disponiveis.
   Estes manuais podem ser visualizados usando o man:

 % man command

   onde command e o nome do comando para aprender. Por exemplo, para saber
   mais sobre o ls(1), digite:

 % man ls

   As paginas de manual sao divididas em sec,oes que representam o tipo de
   topico. No FreeBSD, as seguintes sec,oes estao disponiveis:

    1. Comandos de usuario.

    2. Chamadas do sistema e numeros de erro.

    3. Func,oes nas bibliotecas C.

    4. Drivers de dispositivos.

    5. Formatos de arquivo.

    6. Jogos e outras diversoes.

    7. Informac,oes diversas.

    8. Comandos de manutenc,ao e operac,ao do sistema.

    9. Interfaces do kernel do sistema.

   Em alguns casos, o mesmo topico pode aparecer em mais de uma sec,ao do
   manual online. Por exemplo, existe um comando de usuario chmod e uma
   chamada de sistema chmod(). Para informar ao man(1) qual sec,ao exibir,
   especifique o numero da sec,ao:

 % man 1 chmod

   Isto ira mostrar a pagina de manual do comando chmod(1). Referencias a uma
   sec,ao em particular do manual online sao tradicionalmente colocadas entre
   parenteses na documentac,ao escrita, entao chmod(1) refere-se ao comando
   do usuario e chmod(2) refere-se `a chamada do sistema.

   Se o nome da pagina de manual for desconhecido, use man -k para procurar
   por palavras-chave nas descric,oes da pagina de manual:

 % man -k mail

   Este comando exibe uma lista de comandos que possuem a palavra-chave
   "mail" em suas descric,oes. Isso e equivalente a usar o apropos(1).

   Para ler as descric,oes de todos os comandos em /usr/bin, digite:

 % cd /usr/bin
 % man -f * | more

   ou

 % cd /usr/bin
 % whatis * |more

  3.12.1. Arquivos GNU Info

   O FreeBSD inclui varios aplicativos e utilitarios produzidos pela Free
   Software Foundation (FSF). Alem das paginas de manual, esses programas
   podem incluir documentos de hipertexto chamados arquivos info. Elas podem
   ser visualizadas usando info(1) ou, se o editors/emacs estiver instalado,
   o modo info do emacs.

   Para usar o info(1), digite:

 % info

   Para uma breve introduc,ao, digite h. Para uma referencia rapida de
   comandos, digite ?.

     ----------------------------------------------------------------------

   [1] Existem algumas tarefas que nao podem ser interrompidas. Por exemplo,
   se o processo estiver tentando ler de um arquivo que esta em outro
   computador na rede e o outro estiver indisponivel, o processo e
   considerado nao "interrompivel". Eventualmente, o processo expirara,
   normalmente apos dois minutos. Assim que esse tempo limite ocorrer, o
   processo sera eliminado.

Capitulo 4. Instalando Aplicativos: Pacotes e Ports

   Indice

   4.1. Sinopse

   4.2. Visao geral sobre a Instalac,ao de Software

   4.3. Encontrando Software

   4.4. Usando o pkg para o gerenciamento de pacotes binarios

   4.5. Usando a Colec,ao de Ports

   4.6. Compilando Pacotes com o Poudriere

   4.7. Considerac,oes pos-instalac,ao

   4.8. Lidando com ports quebrados

4.1. Sinopse

   O FreeBSD tem uma grande colec,ao de ferramentas dentro do sistema base.
   Alem disso, o FreeBSD fornece duas ferramentas complementares para a
   instalac,ao de software de terceiros: o a Colec,ao de Ports do FreeBSD,
   para instalac,ao a partir do codigo-fonte, e pacotes, para instalac,ao de
   binarios pre-compilados. Qualquer um dos metodos pode ser usado para
   instalar um software de uma midia local ou da rede.

   Depois de ler este capitulo, voce sabera:

     * A diferenc,a entre pacotes binarios e ports.

     * Como encontrar softwares de terceiros que tenham sido portados para o
       FreeBSD.

     * Como gerenciar pacotes binarios usando o pkg.

     * Como compilar software de terceiros a partir do codigo-fonte usando a
       colec,ao de ports.

     * Como encontrar os arquivos instalados do aplicativo para configurac,ao
       pos-instalac,ao.

     * O que fazer se a instalac,ao do software falhar.

4.2. Visao geral sobre a Instalac,ao de Software

   As etapas tipicas para instalar um software de terceiros em um sistema
   UNIX(R) incluem:

    1. Encontre e baixe o software, que pode ser distribuido no formato de
       codigo-fonte ou como um binario.

    2. Desempacote o software a partir do seu formato de distribuic,ao.
       Tipicamente e um arquivo tarball compactado com um programa como
       compress(1),gzip(1), bzip2(1) ou xz(1).

    3. Localize a documentac,ao em INSTALL, README ou algum arquivo em um
       subdiretorio doc/ e leia sobre como instalar o software.

    4. Se o software foi distribuido como codigo-fonte, compile-o. Isso pode
       envolver a edic,ao de um Makefile ou a execuc,ao de um script
       configure.

    5. Teste e instale o software.

   Um port do FreeBSD e uma colec,ao de arquivos projetados para automatizar
   o processo de compilac,ao de um aplicativo a partir do codigo-fonte. Os
   arquivos que compoem um port contem todas as informac,oes necessarias para
   baixar, extrair, corrigir, compilar e instalar automaticamente o
   aplicativo.

   Se o software ainda nao foi adaptado e testado no FreeBSD, o codigo-fonte
   pode precisar ser editado para que seja instalado e executado
   corretamente.

   No entanto, mais de 24.000 aplicativos de terceiros ja foram portados para
   o FreeBSD. Quando possivel, esses aplicativos sao disponibilizados para
   download como pacotes pre-compilados.

   Pacotes podem ser manipulados com os comandos de gerenciamento de pacotes
   do FreeBSD.

   Ambos, pacotes e ports, entendem dependencias. Se um pacote ou port for
   usado para instalar um aplicativo, e uma biblioteca dependente ainda nao
   estiver instalada, a biblioteca sera instalada automaticamente primeiro.

   Um pacote do FreeBSD contem copias pre-compiladas de todos os comandos
   para uma aplicac,ao, assim como quaisquer arquivos de configurac,ao e
   documentac,ao. Um pacote pode ser manipulado com os comandos pkg(8), como
   pkg install.

   Mesmo as duas tecnologias sendo semelhantes, os pacotes e os ports tem
   seus proprios pontos fortes. Selecione a tecnologia que melhor atenda aos
   seus requisitos para instalar um aplicativo especifico.

   Beneficios dos Pacotes
     * Um tarball compactado de um pacote geralmente e menor que o tarball
       compactado que contem o codigo-fonte do aplicativo.

     * Pacotes nao requerem tempo de compilac,ao. Para aplicativos grandes,
       como o Mozilla, KDE ou GNOME, isso pode ser importante em um sistema
       lento.

     * Pacotes nao requerem nenhum entendimento do processo envolvido na
       compilac,ao de software no FreeBSD.

   Beneficios dos Ports
     * Os pacotes sao normalmente compilados com opc,oes conservadoras porque
       eles precisam ser executados no numero maximo de sistemas. Ao compilar
       a partir do port, podem-se alterar as opc,oes de compilac,ao.

     * Alguns aplicativos tem opc,oes em tempo de compilac,ao relacionadas a
       quais recursos estao instalados. Por exemplo, o Apache pode ser
       configurado com uma ampla variedade de diferentes opc,oes internas.

       Em alguns casos, varios pacotes existirao para o mesmo aplicativo para
       especificar determinadas configurac,oes. Por exemplo, o Ghostscript
       esta disponivel como um pacote ghostscript e um pacote
       ghostscript-nox11, dependendo se o Xorg esta instalado ou nao. Criar
       varios pacotes rapidamente se torna impossivel se um aplicativo tiver
       mais de uma ou duas opc,oes diferentes de tempo de compilac,ao.

     * As condic,oes de licenciamento de alguns softwares proibem sua
       distribuic,ao em binario. Tais softwares devem ser distribuidos como
       codigo-fonte o qual deve ser compilado pelo usuario final.

     * Algumas pessoas nao confiam em distribuic,oes binarias ou preferem ler
       o codigo-fonte para procurar possiveis problemas.

     * O codigo-fonte e necessario para aplicar patches personalizados.

   Para acompanhar a atualizac,ao dos ports, inscreva-se na lista de
   discussao dos ports do FreeBSD e no link Lista de discussao de bugs no
   FreeBSD.

  Atenc,ao:

   Antes de instalar qualquer aplicativo, verifique
   https://vuxml.freebsd.org/ para questoes de seguranc,a relacionadas ao
   aplicativo ou digite pkg audit -F para verificar todas as instancias
   instaladas aplicativos para vulnerabilidades conhecidas.

   O restante deste capitulo explica como usar pacotes e ports para instalar
   e gerenciar software de terceiros no FreeBSD.

4.3. Encontrando Software

   A lista de aplicativos disponiveis do FreeBSD esta crescendo o tempo todo.
   Existem varias maneiras de encontrar softwares para instalar:

     * O site do FreeBSD mantem uma lista atualizada e pesquisavel de todos
       os aplicativos disponiveis, em https://www.FreeBSD.org/ ports/. Os
       ports podem ser pesquisados por nome do aplicativo ou por categoria de
       software.

     * Dan Langille mantem o FreshPorts.org, que fornece um utilitario de
       pesquisa abrangente e tambem rastreia alterac,oes nos aplicativos da
       Colec,ao de Ports. Os usuarios registrados podem criar uma lista de
       observac,ao personalizada para receber um e-mail automatizado quando
       seus ports sendo monitorados forem atualizados.

     * Se encontrar um aplicativo especifico se tornar desafiador, tente
       pesquisar um site como SourceForge.net ou GitHub.com entao volte no
       site do FreeBSD para ver se o aplicativo foi portado.

     * Para pesquisar o repositorio de pacotes binarios por um aplicativo:

 # pkg search subversion
 git-subversion-1.9.2
 java-subversion-1.8.8_2
 p5-subversion-1.8.8_2
 py27-hgsubversion-1.6
 py27-subversion-1.8.8_2
 ruby-subversion-1.8.8_2
 subversion-1.8.8_2
 subversion-book-4515
 subversion-static-1.8.8_2
 subversion16-1.6.23_4
 subversion17-1.7.16_2

       Os nomes dos pacotes incluem o numero da versao e, no caso de ports
       baseados em python, o numero da versao do pacote python sobre o qual o
       pacote foi compilado. Alguns ports tambem possuem varias versoes
       disponiveis. No caso do Subversion, existem diferentes versoes
       disponiveis, bem como diferentes opc,oes de compilac,ao. Neste caso, a
       versao estaticamente vinculada do Subversion. Ao indicar qual pacote
       instalar, e melhor especificar o aplicativo pela origem do port, que e
       o caminho na arvore de ports. Repita o pkg search com -o para listar a
       origem de cada pacote:

 # pkg search -o subversion
 devel/git-subversion
 java/java-subversion
 devel/p5-subversion
 devel/py-hgsubversion
 devel/py-subversion
 devel/ruby-subversion
 devel/subversion16
 devel/subversion17
 devel/subversion
 devel/subversion-book
 devel/subversion-static

       Pesquisar por shell globs, expressoes regulares, correspondencia
       exata, por descric,ao ou qualquer outro campo no banco de dados do
       repositorio tambem e suportado pelo pkg search. Depois de instalar o
       ports-mgmt/pkg ou o ports-mgmt/pkg-devel, veja pkg-search(8) para
       maiores detalhes.

     * Se a Colec,ao de Ports ja estiver instalada, existem varios metodos
       para consultar a versao local da arvore de ports. Para descobrir em
       qual categoria um port esta, digite whereis file , onde file e o
       programa a ser instalado:

 # whereis lsof
 lsof: /usr/ports/sysutils/lsof

       Como alternativa, uma declarac,ao echo(1) pode ser usada:

 # echo /usr/ports/*/*lsof*
 /usr/ports/sysutils/lsof

       Observe que isso tambem retornara todos os arquivos correspondentes
       baixados no diretorio /usr/ports/distfiles.

     * Outra maneira de encontrar software e usando o mecanismo de pesquisa
       integrado da Colec,ao de Ports. Para usar o recurso de pesquisa, cd
       para /usr/ports, execute make search name=program-name onde
       program-name e o nome do software. Por exemplo, para procurar por
       lsof:

 # cd /usr/ports
 # make search name=lsof
 Port:   lsof-4.88.d,8
 Path:   /usr/ports/sysutils/lsof
 Info:   Lists information about open files (similar to fstat(1))
 Maint:  ler@lerctr.org
 Index:  sysutils
 B-deps:
 R-deps:

  Dica:

       O mecanismo de pesquisa interna usa um arquivo de informac,oes de
       indice. Se uma mensagem indicar que o INDEX e necessario, execute make
       fetchindex para baixar o arquivo de indice atual. Com o INDEX
       presente, o make search podera realizar a pesquisa solicitada.

       A linha "Path:" indica onde encontrar o port.

       Para receber menos informac,oes, use o recurso quicksearch:

 # cd /usr/ports
 # make quicksearch name=lsof
 Port:   lsof-4.88.d,8
 Path:   /usr/ports/sysutils/lsof
 Info:   Lists information about open files (similar to fstat(1))

       Para uma busca mais aprofundada, use o make search key=string ou o
       make quicksearch key=string, onde string e algum texto para procurar.
       O texto pode estar em comentarios, descric,oes ou dependencias para
       encontrar ports relacionados a um assunto em particular quando o nome
       do programa e desconhecido.

       Ao usar pesquisa ou pesquisa rapida, a cadeia de pesquisa nao
       diferencia maiusculas de minusculas. Procurar por "LSOF" produzira os
       mesmos resultados que procurar por "lsof".

4.4. Usando o pkg para o gerenciamento de pacotes binarios

   O pkg e o substituto da proxima gerac,ao para as tradicionais ferramentas
   de gerenciamento de pacotes do FreeBSD, oferecendo muitos recursos que
   tornam o processamento de pacotes binarios mais rapido e facil.

   Para sites que desejam apenas usar pacotes binarios pre-construidos a
   partir dos espelhos do FreeBSD, o gerenciamento de pacotes com pkg pode
   ser suficiente.

   No entanto, para aqueles que optarem por compilar suas aplicac,oes a
   partir do codigo-fonte ou que utilizarem seus proprios repositorios, sera
   necessaria uma ferramenta de gerenciamento de ports separada.

   Como o pkg so funciona com pacotes binarios, ele nao e um substituto para
   tais ferramentas. Estas ferramentas podem ser usadas para instalar o
   software a partir de pacotes binarios e da Colec,ao do Ports, enquanto o
   pkg instala apenas pacotes binarios.

  4.4.1. Introduc,ao ao pkg

   O FreeBSD inclui um utilitario de bootstrap que pode ser usado para baixar
   e instalar o pkg e suas paginas de manual. Este utilitario foi projetado
   para funcionar com versoes do FreeBSD comec,ando com 10.X.

  Nota:

   Nem todas as versoes e arquiteturas do FreeBSD suportam este processo de
   bootstrap. A lista atual esta em https://pkg.freebsd.org/. Para outros
   casos, o pkg deve ser instalado a partir da colec,ao de ports ou como um
   pacote binario.

   Para inicializar o sistema, execute:

 # /usr/sbin/pkg

   Voce deve ter uma conexao com a Internet para que o processo de
   inicializac,ao seja bem-sucedido.

   Caso contrario, para instalar o port, execute:

 # cd /usr/ports/ports-mgmt/pkg
 # make
 # make install clean

   Ao atualizar um sistema existente que usava originalmente as ferramentas
   pkg_ * mais antigas, o banco de dados deve ser convertido para o novo
   formato, para que as novas ferramentas estejam cientes dos pacotes ja
   instalados. Uma vez que o pkg tenha sido instalado, o banco de dados de
   pacotes deve ser convertido do formato tradicional para o novo formato,
   executando este comando:

 # pkg2ng

  Nota:

   Esta etapa nao e necessaria para novas instalac,oes que ainda nao possuem
   nenhum software de terceiros instalado.

  Importante:

   Este passo nao e reversivel. Uma vez que o banco de dados de pacotes tenha
   sido convertido para o formato pkg, as ferramentas tradicionais pkg _ *
   nao devem mais ser usadas.

  Nota:

   A conversao do banco de dados de pacotes pode emitir erros conforme o
   conteudo e convertido para a nova versao. Geralmente, esses erros podem
   ser ignorados com seguranc,a. No entanto, uma lista com os softwares que
   nao foram convertidos com sucesso e mostrada apos o pkg2ng terminar. Esses
   aplicativos devem ser reinstalados manualmente.

   Para garantir que a Colec,ao de Ports registre novos softwares com o pkg
   ao inves do tradicional banco de dados de pacotes, versoes do FreeBSD
   anteriores a 10.X requerem esta linha em /etc/make.conf:

 WITH_PKGNG=     yes

   Por padrao, o pkg usa os pacotes binarios dos espelhos de pacotes do
   FreeBSD (o repositorio). Para obter informac,oes sobre como criar um
   repositorio de pacotes personalizados, consulte Sec,ao 4.6, "Compilando
   Pacotes com o Poudriere".

   Opc,oes adicionais de configurac,ao do pkg sao descritas em pkg.conf(5).

   As informac,oes de uso do pkg estao disponiveis na pagina de manual pkg(8)
   ou executando o pkg sem argumentos adicionais.

   Cada argumento do comando pkg e documentado em uma pagina de manual
   especifica do comando. Para ler a pagina de manual do pkg install, por
   exemplo, execute um destes comandos:

 # pkg help install

 # man pkg-install

   O restante desta sec,ao demonstra tarefas comuns de gerenciamento de
   pacotes binarios que podem ser executadas usando o pkg. Cada comando
   demonstrado fornece muitos switches para personalizar seu uso. Consulte a
   ajuda de um comando ou a pagina do manual para obter detalhes e mais
   exemplos.

  4.4.2. Obtendo informac,oes sobre os pacotes instalados

   Informac,oes sobre os pacotes instalados em um sistema podem ser
   visualizadas executando pkg info que, quando executado sem qualquer
   opc,ao, listara a versao do pacote para todos os pacotes instalados ou
   para o pacote especificado.

   Por exemplo, para ver qual versao do pkg esta instalada, execute:

 # pkg info pkg
 pkg-1.1.4_1

  4.4.3. Instalando e removendo pacotes

   Para instalar um pacote binario, use o seguinte comando, em que
   packagename e o nome do pacote a ser instalado:

 # pkg install packagename

   Esse comando usa os dados do repositorio para determinar qual versao do
   software instalar e se ele possui alguma dependencia faltando. Por
   exemplo, para instalar o curl:

 # pkg install curl
 Updating repository catalogue
 /usr/local/tmp/All/curl-7.31.0_1.txz          100% of 1181 kB 1380 kBps 00m01s

 /usr/local/tmp/All/ca_root_nss-3.15.1_1.txz   100% of  288 kB 1700 kBps 00m00s

 Updating repository catalogue
 The following 2 packages will be installed:

         Installing ca_root_nss: 3.15.1_1
         Installing curl: 7.31.0_1

 The installation will require 3 MB more space

 0 B to be downloaded

 Proceed with installing packages [y/N]: y
 Checking integrity... done
 [1/2] Installing ca_root_nss-3.15.1_1... done
 [2/2] Installing curl-7.31.0_1... done
 Cleaning up cache files...Done

   O novo pacote e quaisquer pacotes adicionais que foram instalados como
   dependencias podem ser vistos na lista de pacotes instalados:

 # pkg info
 ca_root_nss-3.15.1_1    The root certificate bundle from the Mozilla Project
 curl-7.31.0_1   Non-interactive tool to get files from FTP, GOPHER, HTTP(S) servers
 pkg-1.1.4_6     New generation package manager

   Pacotes que nao sao mais necessarios podem ser removidos com pkg delete.
   Por exemplo:

 # pkg delete curl
 The following packages will be deleted:

         curl-7.31.0_1

 The deletion will free 3 MB

 Proceed with deleting packages [y/N]: y
 [1/1] Deleting curl-7.31.0_1... done

  4.4.4. Atualizando os Pacotes Instalados

   Os pacotes instalados podem ser atualizados para as versoes mais recentes
   executando:

 # pkg upgrade

   Este comando ira comparar as versoes instaladas com as disponiveis no
   catalogo do repositorio e atualiza-las a partir do repositorio.

  4.4.5. Auditando os Pacotes Instalados

   Vulnerabilidades de software sao regularmente descobertas em aplicativos
   de terceiros. Para resolver isso, o pkg inclui um mecanismo de auditoria
   integrado. Para determinar se ha alguma vulnerabilidade conhecida para o
   software instalado no sistema, execute:

 # pkg audit -F

  4.4.6. Removendo Pacotes Nao Utilizados Automaticamente

   Remover um pacote pode deixar dependencias que nao sao mais necessarias.
   Pacotes desnecessarios que foram instalados como dependencias podem ser
   automaticamente detectados e removidos usando:

 # pkg autoremove
 Packages to be autoremoved:
         ca_root_nss-3.15.1_1

 The autoremoval will free 723 kB

 Proceed with autoremoval of packages [y/N]: y
 Deinstalling ca_root_nss-3.15.1_1... done

   Os pacotes instalados como dependencias sao chamados de pacotes
   automaticos. Pacotes nao automaticos, ou seja, os pacotes que nao foram
   instalados como uma dependencia para outro pacote, podem ser listados
   usando:

 # pkg prime-list
 nginx
 openvpn
 sudo

   O pkg prime-list e um alias de comando declarado no
   /usr/local/etc/pkg.conf. Existem muitos outros que podem ser usados para
   consultar o banco de dados de pacotes do sistema. Por exemplo, o comando
   pkg prime-origins pode ser usado para obter o diretorio de origem dos
   ports da lista mencionada acima:

 # pkg prime-origins
 www/nginx
 security/openvpn
 security/sudo

   Esta lista pode ser usada para recompilar todos os pacotes instalados em
   um sistema usando ferramentas de compilac,ao como o ports-mgmt/poudriere
   ou o ports-mgmt/synth.

   Marcar um pacote instalado como automatico pode ser feito usando:

 # pkg set -A 1 devel/cmake

   Uma vez que um pacote e um pacote orfao e esta marcado como automatico,
   ele sera selecionado por pkg autoremove.

   Marcar um pacote instalado como nao automatico pode ser feito usando:

 # pkg set -A 0 devel/cmake

  4.4.7. Restaurando o banco de dados de pacotes

   Ao contrario do sistema tradicional de gerenciamento de pacotes, o pkg
   inclui seu proprio mecanismo de backup de banco de dados de pacotes. Essa
   funcionalidade e habilitada por padrao.

  Dica:

   Para desabilitar o script que faz o backup periodico do banco de dados de
   pacotes, defina daily_backup_pkgdb_enable="NO" no periodic.conf(5).

   Para restaurar o conteudo de um backup anterior do banco de dados de
   pacotes, execute o seguinte comando substituindo /path/to/pkg.sql pelo
   local do backup:

 # pkg backup -r /path/to/pkg.sql

  Nota:

   Se estiver restaurando um backup feito pelo script periodico, ele deve ser
   descompactado antes de ser restaurado.

   Para executar um backup manual do banco de dados pkg, execute o seguinte
   comando, substituindo /path/to/pkg.sql por um nome de arquivo e local
   adequados:

 # pkg backup -d /path/to/pkg.sql

  4.4.8. Removendo Pacotes Obsoletos

   Por padrao, o pkg armazena pacotes binarios em um diretorio de cache
   definido por PKG_CACHEDIR no pkg.conf(5). Somente copias dos ultimos
   pacotes instalados sao mantidas. Versoes mais antigas do pkg mantinham
   todos os pacotes anteriores. Para remover esses pacotes binarios
   desatualizados, execute:

 # pkg clean

   O cache inteiro pode ser limpo executando:

 # pkg clean -a

  4.4.9. Modificando Metadados de Pacotes

   Os softwares dentro da Colec,ao de Ports do FreeBSD podem passar por
   grandes mudanc,as no numero de versao. Para resolver isso, o pkg possui um
   comando interno para atualizar as origens do pacote. Isto pode ser util,
   por exemplo, se lang/php5 for renomeado para lang/php53 para que lang/php5
   possa agora representar a versao 5.4.

   Para alterar a origem do pacote para o exemplo acima, execute:

 # pkg set -o lang/php5:lang/php53

   Como outro exemplo, para atualizar lang/ruby18 para lang/ruby19, execute:

 # pkg set -o lang/ruby18:lang/ruby19

   Como um exemplo final, para alterar a origem das bibliotecas
   compartilhadas libglut de graphics/libglut para graphics/freeglut,
   execute:

 # pkg set -o graphics/libglut:graphics/freeglut

  Nota:

   Ao alterar as origens do pacote, e importante reinstalar os pacotes que
   dependem do pacote com a origem modificada. Para forc,ar uma reinstalac,ao
   dos pacotes dependentes, execute:

 # pkg install -Rf graphics/freeglut

4.5. Usando a Colec,ao de Ports

   A Colec,ao de Ports e um conjunto de arquivos Makefiles, patches e
   arquivos de descric,ao. Cada conjunto desses arquivos e usado para
   compilar e instalar um aplicativo individual no FreeBSD, e e chamado de
   port.

   Por padrao, a propria colec,ao de ports e armazenada como um subdiretorio
   de /usr/ports.

   Antes que um aplicativo possa ser compilado usando um port, a Colec,ao de
   Ports deve primeiro ser instalada. Se ela nao foi instalada durante a
   instalac,ao do FreeBSD, use um dos seguintes metodos para instala-la:

   Procedimento 4.1. Metodo Portsnap

   O sistema basico do FreeBSD inclui o Portsnap. Esta e uma ferramenta
   rapida e facil de usar para recuperar a colec,ao de ports e e a escolha
   recomendada para a maioria dos usuarios. Este utilitario se conecta a um
   site do FreeBSD, verifica a chave segura e faz o download de uma nova
   copia da Colec,ao de Ports. A chave e usada para verificar a integridade
   de todos os arquivos baixados.

    1. Para baixar um snapshot compactado da colec,ao de ports em
       /var/db/portsnap:

 # portsnap fetch

    2. Ao executar o Portsnap pela primeira vez, extraia o snapshot em
       /usr/ports:

 # portsnap extract

    3. Apos o primeiro uso do Portsnap ter sido concluido, como mostrado
       acima, o /usr/ports pode ser atualizado conforme necessario
       executando:

 # portsnap fetch
 # portsnap update

       Ao usar fetch, a operac,ao extract ou update pode ser executada
       consecutivamente, da seguinte forma:

 # portsnap fetch update

   Procedimento 4.2. Metodo Subversion

   Se for necessario mais controle sobre a arvore de ports ou se as mudanc,as
   locais precisarem ser mantidas, o Subversion pode ser usado para obter a
   colec,ao de ports. Consulte O Subversion Primer para uma descric,ao
   detalhada do Subversion.

    1. O Subversion deve ser instalado antes de poder ser usado para fazer o
       check-out da arvore de ports. Se uma copia da arvore de ports ja
       estiver presente, instale o Subversion desta forma:

 # cd /usr/ports/devel/subversion
 # make install clean

       Se a arvore de ports nao estiver disponivel, ou o pkg estiver sendo
       usado para gerenciar pacotes, o Subversion podera ser instalado como
       um pacote:

 # pkg install subversion

    2. Fac,a o check out de uma copia da arvore de ports:

 # svn checkout https://svn.FreeBSD.org/ports/head /usr/ports

    3. Conforme necessario, atualize o /usr/ports apos o check out inicial do
       Subversion:

 # svn update /usr/ports

   A colec,ao de ports contem diretorios para categorias de software. Dentro
   de cada categoria estao subdiretorios para aplicativos individuais. Cada
   subdiretorio de aplicativo contem um conjunto de arquivos que informa ao
   FreeBSD como compilar e instalar esse programa, chamado de esqueleto do
   ports. Cada esqueleto de port inclui esses arquivos e diretorios:

     * Makefile: contem instruc,oes que especificam como o aplicativo deve
       ser compilado e onde seus componentes devem ser instalados.

     * distinfo: contem os nomes e checksums dos arquivos que devem ser
       baixados para compilar o port.

     * files/: este diretorio contem quaisquer patches necessarios para o
       programa compilar e instalar no FreeBSD. Esse diretorio tambem pode
       conter outros arquivos usados para compilar o port.

     * pkg-descr: fornece uma descric,ao mais detalhada do programa.

     * pkg-plist: uma lista de todos os arquivos que serao instalados pelo
       port. Ele tambem informa ao sistema de ports quais arquivos devem ser
       removidos apos a desinstalac,ao.

   Alguns ports incluem pkg-message ou outros arquivos para lidar com
   situac,oes especiais. Para obter mais detalhes sobre esses arquivos e
   sobre os ports em geral, consulte o FreeBSD Porter's Manual.

   O port nao inclui o codigo-fonte real, tambem conhecido como distfile. A
   etapa de extrac,ao da compilac,ao de um port salvara automaticamente o
   codigo-fonte transferido por download para /usr/ports/distfiles.

  4.5.1. Instalando Ports

   Esta sec,ao fornece instruc,oes basicas sobre o uso da Colec,ao de Ports
   para instalar ou remover software. A descric,ao detalhada dos targets
   disponiveis do make e das variaveis de ambiente esta disponivel em
   ports(7).

  Atenc,ao:

   Antes de compilar qualquer port, certifique-se de atualizar a Colec,ao de
   Ports conforme descrito na sec,ao anterior. Como a instalac,ao de qualquer
   software de terceiros pode introduzir vulnerabilidades de seguranc,a,
   recomenda-se primeiro verificar https://vuxml.freebsd.org/ para problemas
   de seguranc,a conhecidos relacionados ao port. Alternativamente, execute
   pkg -f antes de instalar um novo port. Esse comando pode ser configurado
   para executar automaticamente uma auditoria de seguranc,a e uma
   atualizac,ao do banco de dados de vulnerabilidades durante a verificac,ao
   diaria do sistema de seguranc,a. Para obter maiores informac,oes, consulte
   pkg-audit(8) e periodic(8).

   O uso da colec,ao de ports pressupoe uma conexao de Internet ativa. Tambem
   requer privilegios de superusuario.

   Para compilar e instalar o port, mude para o diretorio do port a ser
   instalado e, em seguida, digite make install no prompt. Mensagens
   indicarao o progresso:

 # cd /usr/ports/sysutils/lsof
 # make install
 >> lsof_4.88D.freebsd.tar.gz doesn't seem to exist in /usr/ports/distfiles/.
 >> Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
 ===>  Extracting for lsof-4.88
 ...
 [extraction output snipped]
 ...
 >> Checksum OK for lsof_4.88D.freebsd.tar.gz.
 ===>  Patching for lsof-4.88.d,8
 ===>  Applying FreeBSD patches for lsof-4.88.d,8
 ===>  Configuring for lsof-4.88.d,8
 ...
 [configure output snipped]
 ...
 ===>  Building for lsof-4.88.d,8
 ...
 [compilation output snipped]
 ...

 ===>  Installing for lsof-4.88.d,8
 ...
 [installation output snipped]
 ...
 ===>   Generating temporary packing list
 ===>   Compressing manual pages for lsof-4.88.d,8
 ===>   Registering installation for lsof-4.88.d,8
 ===>  SECURITY NOTE:
       This port has installed the following binaries which execute with
       increased privileges.
 /usr/local/sbin/lsof
 #

   Como o lsof e um programa que e executado com privilegios aumentados, um
   aviso de seguranc,a e exibido quando e instalado. Quando a instalac,ao
   estiver concluida, o prompt sera retornado.

   Algumas shells mantem um cache dos comandos que estao disponiveis nos
   diretorios listados na variavel de ambiente PATH, para acelerar as
   operac,oes de pesquisa do arquivo executavel desses comandos. Os usuarios
   do shell tcsh devem digitar rehash para que um comando recem-instalado
   possa ser usado sem especificar seu caminho completo. Use hash -r para o
   shell sh. Consulte a documentac,ao do shell para mais informac,oes.

   Durante a instalac,ao, e criado um subdiretorio de trabalho que contem
   todos os arquivos temporarios usados durante a compilac,ao. A remoc,ao
   desse diretorio economiza espac,o em disco e minimiza a possibilidade de
   problemas mais tarde ao atualizar para a versao mais recente do port:

 # make clean
 ===>  Cleaning for lsof-88.d,8
 #

  Nota:

   Para evitar esta etapa extra, use make install clean ao compilar o port.

    4.5.1.1. Personalizando a instalac,ao de ports

   Alguns ports fornecem opc,oes de compilac,ao que podem ser usadas para
   habilitar ou desabilitar componentes do aplicativo, fornecer opc,oes de
   seguranc,a ou permitir outras personalizac,oes. Os exemplos incluem o
   www/firefox, security/gpgme, e mail/sylpheed-claws. Se o port depender de
   outros ports que tenham opc,oes configuraveis, ela podera pausar varias
   vezes para interac,ao do usuario, pois o comportamento padrao e solicitar
   ao usuario que selecione opc,oes de um menu. Para evitar isso e fazer toda
   a configurac,ao em um lote, execute make config-recursive dentro do
   diretorio do port. Em seguida, execute make install [clean] para compilar
   e instalar o port.

  Dica:

   Ao usar config-recursive, a lista de ports a serem configurados e reunida
   pelo target all-depends-list. E recomendado executar o make
   config-recursive ate que todas as opc,oes dos ports dependentes tenham
   sido definidas, e as telas de opc,oes de ports nao aparec,am mais, para
   ter certeza de que todas as opc,oes das dependencia foram configuradas.

   Ha varias maneiras de revisitar o menu de opc,oes de compilac,ao de um
   port para adicionar, remover ou alterar essas opc,oes apos a compilac,ao
   de um port. Um metodo e efetuar cd no diretorio que contem o port e
   digitar make config. Outra opc,ao e usar o make showconfig. Outra opc,ao e
   executar make rmconfig, o que removera todas as opc,oes selecionadas e
   permitira que voce comece de novo. Todas essas opc,oes, e outras, sao
   explicadas detalhadamente em ports(7).

   O sistema de ports usa o fetch(1) para fazer o download dos arquivos com o
   codigo-fonte, que suportam varias variaveis de ambiente. As variaveis
   FTP_PASSIVE_MODE, FTP_PROXY e FTP_PASSWORD podem precisar ser definidas se
   o sistema FreeBSD estiver por tras de um firewall ou proxy FTP/HTTP. Veja
   fetch(3) para a lista completa de variaveis suportadas.

   Para usuarios que nao podem estar conectados `a Internet o tempo todo, o
   make fetch pode ser executado dentro do /usr/ports, para buscar todos os
   distfiles, ou dentro de uma categoria, como /usr/ports/net, ou dentro do
   diretorio de um port especifico. Observe que, se um port tiver alguma
   dependencia, executar este comando em uma categoria ou diretorio de um
   port especifico nao buscara os distfiles de ports de outra categoria. Em
   vez disso, use make fetch-recursive para tambem buscar os distfiles para
   todas as dependencias de um port.

   Em casos raros, como quando uma organizac,ao tem um repositorio local de
   distfiles, a variavel MASTER_SITES pode ser usada para substituir os
   locais de download especificados no Makefile. Ao usar, especifique o local
   alternativo:

 # cd /usr/ports/directory
 # make MASTER_SITE_OVERRIDE= \
 ftp://ftp.organization.org/pub/FreeBSD/ports/distfiles/ fetch

   As variaveis WRKDIRPREFIX e PREFIX podem substituir os diretorios de
   trabalho e de destino padrao. Por exemplo:

 # make WRKDIRPREFIX=/usr/home/example/ports install

   ira compilar o port em /usr/home/example/ports e instalar tudo sob
   /usr/local.

 # make PREFIX=/usr/home/example/local install

   ira compilar o port em /usr/ports e instala-lo em /usr/home/example/local.
   E:

 # make WRKDIRPREFIX=../ports PREFIX=../local install

   vai combinar os dois.

   Estes tambem podem ser definidos como variaveis ambientais. Consulte a
   pagina de manual do seu shell para obter instruc,oes sobre como definir
   uma variavel de ambiente.

  4.5.2. Removendo Ports Instalados

   Ports instalados podem ser desinstalados usando pkg delete. Exemplos para
   usar este comando podem ser encontrados na pagina de manual pkg-delete(8).

   Alternativamente, o make deinstall pode ser executado no diretorio do
   port:

 # cd /usr/ports/sysutils/lsof
 # make deinstall
 ===>  Deinstalling for sysutils/lsof
 ===>   Deinstalling
 Deinstallation has been requested for the following 1 packages:

         lsof-4.88.d,8

 The deinstallation will free 229 kB
 [1/1] Deleting lsof-4.88.d,8... done

   Recomenda-se ler as mensagens quando o port for desinstalado. Se o port
   tiver algum aplicativo que dependa dele, essas informac,oes serao
   exibidas, mas a desinstalac,ao continuara. Nesses casos, talvez seja
   melhor reinstalar o aplicativo para evitar dependencias quebradas.

  4.5.3. Atualizando os Ports

   Com o tempo, novas versoes de software ficam disponiveis na colec,ao de
   ports. Esta sec,ao descreve como determinar qual software pode ser
   atualizado e como executar a atualizac,ao.

   Para determinar se versoes mais recentes dos ports instalados estao
   disponiveis, verifique se a versao mais recente da arvore de ports esta
   instalada, usando o comando de atualizac,ao descrito em Procedimento 4.1,
   "Metodo Portsnap" ou Procedimento 4.2, "Metodo Subversion". No FreeBSD 10
   e posterior, ou se o sistema foi convertido para pkg, o seguinte comando
   listara os ports instalados que estao desatualizadas:

 # pkg version -l "<"

   Para o FreeBSD 9.X e menor, o seguinte comando listara os ports instalados
   que estao desatualizados:

 # pkg_version -l "<"

  Importante:

   Antes de tentar uma atualizac,ao, leia o /usr/ports/UPDATING da parte
   superior do arquivo ate a data mais proxima da ultima vez em que os ports
   foram atualizados ou o sistema foi instalado. Este arquivo descreve varios
   problemas e etapas adicionais que os usuarios podem encontrar e precisar
   executar ao atualizar um port, incluindo coisas como alterac,oes de
   formato de arquivo, alterac,oes nos locais de arquivos de configurac,ao ou
   incompatibilidades com versoes anteriores. Anote quaisquer instruc,oes que
   correspondam a qualquer um dos ports que precisam de atualizac,ao e siga
   estas instruc,oes ao executar a atualizac,ao.

    4.5.3.1. Ferramentas para atualizar e gerenciar ports

   A colec,ao de ports contem varios utilitarios para executar a atualizac,ao
   real. Cada um tem seus pontos fortes e fracos.

   Historicamente, a maioria das instalac,oes usava o Portmaster ou o
   Portupgrade. O Synth e uma alternativa mais recente.

  Nota:

   A escolha da melhor ferramenta para um determinado sistema depende do
   administrador do sistema. Recomenda-se a pratica de fazer backup de seus
   dados antes de usar qualquer uma dessas ferramentas.

    4.5.3.2. Atualizando Ports Usando o Portmaster

   O ports-mgmt/portmaster e um utilitario muito pequeno para atualizar os
   ports instalados. Ele e projetado para usar as ferramentas instaladas com
   o sistema base do FreeBSD sem depender de outros ports ou bancos de dados.
   Para instalar este utilitario como um port:

 # cd /usr/ports/ports-mgmt/portmaster
 # make install clean

   O Portmaster define quatro categorias de ports:

     * Port Root: nao tem dependencias e nao e uma dependencia de outros
       ports.

     * Port Trunk: nao tem dependencias, mas outros ports dependem dele.

     * Port Branch: tem dependencias e outros ports dependem dele.

     * Port Leaf: tem dependencias, mas nenhum outro port depende dele.

   Para listar essas categorias e procurar atualizac,oes:

 # portmaster -L
 ===>>> Root ports (No dependencies, not depended on)
 ===>>> ispell-3.2.06_18
 ===>>> screen-4.0.3
         ===>>> New version available: screen-4.0.3_1
 ===>>> tcpflow-0.21_1
 ===>>> 7 root ports
 ...
 ===>>> Branch ports (Have dependencies, are depended on)
 ===>>> apache22-2.2.3
         ===>>> New version available: apache22-2.2.8
 ...
 ===>>> Leaf ports (Have dependencies, not depended on)
 ===>>> automake-1.9.6_2
 ===>>> bash-3.1.17
         ===>>> New version available: bash-3.2.33
 ...
 ===>>> 32 leaf ports

 ===>>> 137 total installed ports
         ===>>> 83 have new versions available

   Este comando e usado para atualizar todos os ports desatualizados:

 # portmaster -a

  Nota:

   Por padrao, o Portmaster faz um backup do pacote antes de excluir o port
   existente. Se a instalac,ao da nova versao for bem-sucedida, o Portmaster
   excluira o backup. O uso de -b instrui o Portmaster a nao excluir
   automaticamente o backup. Adicionar -i inicia o Portmaster no modo
   interativo, solicitando a confirmac,ao antes de atualizar cada port.
   Muitas outras opc,oes estao disponiveis. Leia a pagina de manual para o
   portmaster(8) para obter detalhes sobre seu uso.

   Se forem encontrados erros durante o processo de atualizac,ao, adicione -f
   para atualizar e recompilar todos os ports:

 # portmaster -af

   O Portmaster tambem pode ser usado para instalar novos ports no sistema,
   atualizando todas as dependencias antes de compilar e instalar o novo
   port. Para usar essa func,ao, especifique o local do port na colec,ao de
   ports:

 # portmaster shells/bash

   Maiores informac,oes sobre ports-mgmt/portmaster podem ser encontradas no
   pkg-descr.

    4.5.3.3. Atualizando Ports Usando o Portupgrade

   O ports-mgmt/portupgrade e outro utilitario que pode ser usado para
   atualizar ports. Ele instala um conjunto de aplicativos que podem ser
   usados para gerenciar ports. No entanto, ele depende do Ruby. Para
   instalar o port:

 # cd /usr/ports/ports-mgmt/portupgrade
 # make install clean

   Antes de executar uma atualizac,ao usando esse utilitario, e recomendavel
   verificar a lista de ports instalados usando o pkgdb -F e corrigir todas
   as inconsistencias relatadas.

   Para atualizar todos os ports desatualizados instalados no sistema, use o
   portupgrade -a. Como alternativa, inclua -i para ser solicitado da
   confirmac,ao de cada atualizac,ao individual:

 # portupgrade -ai

   Para atualizar apenas um aplicativo especifico em vez de todos os ports
   disponiveis, use portupgrade pkgname. E muito importante incluir -R para
   primeiro atualizar todos os ports requeridos pelo aplicativo fornecido:

 # portupgrade -R firefox

   Se -P estiver incluido, o Portupgrade procura pacotes disponiveis nos
   diretorios locais listados em PKG_PATH. Se nenhum estiver disponivel
   localmente, ele buscara pacotes de um site remoto. Se os pacotes nao
   puderem ser encontrados localmente ou buscados remotamente, o Portupgrade
   utilizara os ports. Para evitar completamente o uso do ports, especifique
   -PP. Este ultimo conjunto de opc,oes diz ao Portupgrade para cancelar se
   nenhum pacote estiver disponivel:

 # portupgrade -PP gnome3

   Para obter apenas os distfiles do port, ou pacotes, se -P for
   especificado, sem compilar ou instalar nada, use -F. Para mais
   informac,oes sobre todas as opc,oes disponiveis, consulte a pagina de
   manual do portupgrade.

   Maiores informac,oes sobre o ports-mgmt/portupgrade podem ser encontradas
   no pkg-descr.

  4.5.4. Ports e o Espac,o em Disco

   A utilizac,ao da colec,ao de ports ira ocupar espac,o em disco ao longo do
   tempo. Depois de compilar e instalar um port, executar make clean dentro
   do diretorio de um port limpara o diretorio temporario de trabalho. Se o
   Portmaster for usado para instalar um port, ele removera automaticamente
   esse diretorio, a menos que -K seja especificado. Se o Portupgrade estiver
   instalado, este comando removera todos os diretorios de trabalho
   encontrados na copia local da colec,ao de ports:

 # portsclean -C

   Alem disso, arquivos de distribuic,ao de codigo-fonte desatualizados se
   acumulam no /usr/ports/distfiles ao longo do tempo. Para usar Portupgrade
   para excluir todos os distfiles que nao sao mais referenciados por nenhum
   port:

 # portsclean -D

   O Portupgrade pode remover todos os distfiles nao referenciados por
   qualquer port atualmente instalado no sistema:

 # portsclean -DD

   Se o Portmaster estiver instalado, use:

 # portmaster --clean-distfiles

   Por padrao, esse comando e interativo e solicita que o usuario confirme se
   um distfile deve ser excluido.

   Alem desses comandos, o ports-mgmt/pkg_cutleaves automatiza a tarefa de
   remover os ports instalados que nao sao mais necessarios.

4.6. Compilando Pacotes com o Poudriere

   O Poudriere e um utilitario licenciado sob a licenc,a BSD para criar e
   testar pacotes do FreeBSD. Ele usa o jails do FreeBSD para configurar
   ambientes de compilac,ao isolados. Esses jails podem ser usados para
   compilar pacotes para versoes do FreeBSD que sao diferentes do sistema no
   qual ele esta instalado, e tambem para construir pacotes para o i386 se o
   host for um sistema amd64. Uma vez que os pacotes sao compilados, eles
   estao em um layout identico aos espelhos oficiais. Esses pacotes podem ser
   usados pelo pkg(8) e por outras ferramentas de gerenciamento de pacotes.

   O Poudriere e instalado usando o pacote ou port ports-mgmt/poudriere. A
   instalac,ao inclui um arquivo de configurac,ao de exemplo,
   /usr/local/etc/poudriere.conf.sample. Copie este arquivo para
   /usr/local/etc/poudriere.conf. Edite o arquivo copiado de acordo com a
   configurac,ao local.

   Embora o ZFS nao seja necessario no sistema que executa o poudriere, o seu
   uso e benefico. Quando o ZFS e usado, o ZPOOL deve ser especificado em
   /usr/local/etc/poudriere.conf e o FREEBSD_HOST deve ser definido para um
   espelho proximo. A definic,ao de CCACHE_DIR permite o uso de devel/ccache
   para armazenar em cache a compilac,ao e reduzir os tempos de compilac,ao
   para o codigo compilado com frequ:encia. Pode ser conveniente colocar os
   conjuntos de dados do poudriere em uma arvore isolada montada em
   /poudriere. Os valores padroes para as outras variaveis de configurac,ao
   sao adequados.

   O numero de nucleos do processador detectados e usado para definir quantas
   compilac,oes serao executadas em paralelo. Fornec,a memoria virtual
   suficiente, seja por meio de RAM ou espac,o de swap. Se a memoria virtual
   se esgotar, as jails de compilac,ao serao interrompidas e desativadas,
   resultando em mensagens de erro estranhas.

  4.6.1. Inicializar o Jails e o Port Trees

   Apos a configurac,ao, inicialize o poudriere para que ele instale um jail
   com a arvore do FreeBSD requerida e uma arvore de ports. Especifique um
   nome para o jail usando -j e a versao do FreeBSD com -v. Em sistemas que
   executam o FreeBSD/amd64, a arquitetura pode ser definida com -a para i386
   ou amd64. O padrao e a arquitetura mostrada pelo uname.

 # poudriere jail -c -j 10amd64 -v 10.0-RELEASE
 ====>> Creating 10amd64 fs... done
 ====>> Fetching base.txz for FreeBSD 10.0-RELEASE amd64
 /poudriere/jails/10amd64/fromftp/base.txz      100% of   59 MB 1470 kBps 00m42s
 ====>> Extracting base.txz... done
 ====>> Fetching src.txz for FreeBSD 10.0-RELEASE amd64
 /poudriere/jails/10amd64/fromftp/src.txz       100% of  107 MB 1476 kBps 01m14s
 ====>> Extracting src.txz... done
 ====>> Fetching games.txz for FreeBSD 10.0-RELEASE amd64
 /poudriere/jails/10amd64/fromftp/games.txz     100% of  865 kB  734 kBps 00m01s
 ====>> Extracting games.txz... done
 ====>> Fetching lib32.txz for FreeBSD 10.0-RELEASE amd64
 /poudriere/jails/10amd64/fromftp/lib32.txz     100% of   14 MB 1316 kBps 00m12s
 ====>> Extracting lib32.txz... done
 ====>> Cleaning up... done
 ====>> Jail 10amd64 10.0-RELEASE amd64 is ready to be used

 # poudriere ports -c -p local
 ====>> Creating local fs... done
 ====>> Extracting portstree "local"...
 Looking up portsnap.FreeBSD.org mirrors... 7 mirrors found.
 Fetching public key from ec2-eu-west-1.portsnap.freebsd.org... done.
 Fetching snapshot tag from ec2-eu-west-1.portsnap.freebsd.org... done.
 Fetching snapshot metadata... done.
 Fetching snapshot generated at Tue Feb 11 01:07:15 CET 2014:
 94a3431f0ce567f6452ffde4fd3d7d3c6e1da143efec76100% of   69 MB 1246 kBps 00m57s
 Extracting snapshot... done.
 Verifying snapshot integrity... done.
 Fetching snapshot tag from ec2-eu-west-1.portsnap.freebsd.org... done.
 Fetching snapshot metadata... done.
 Updating from Tue Feb 11 01:07:15 CET 2014 to Tue Feb 11 16:05:20 CET 2014.
 Fetching 4 metadata patches... done.
 Applying metadata patches... done.
 Fetching 0 metadata files... done.
 Fetching 48 patches.
 (48/48) 100.00%  done.
 done.
 Applying patches...
 done.
 Fetching 1 new ports or files... done.
 /poudriere/ports/tester/CHANGES
 /poudriere/ports/tester/COPYRIGHT

 [...]

 Building new INDEX files... done.

   Em um unico computador, o poudriere pode construir ports com varias
   configurac,oes, em varios jails e de diferentes arvores de ports.
   Configurac,oes customizadas para estas combinac,oes sao chamadas de sets.
   Veja a sec,ao CUSTOMIZAC,AO do poudriere(8) para detalhes depois que o
   ports-mgmt/poudriere ou o ports-mgmt/poudriere-devel estiver instalado.

   A configurac,ao basica mostrada aqui coloca um unico jail-, port-, e um
   set especifico make.conf em /usr/local/etc/poudriere.d. O nome do arquivo
   neste exemplo e criado combinando o nome do jail, o nome do port e o nome
   do set: 10amd64-local-workstation-make.conf. O sistema make.conf e este
   novo arquivo sao combinados em tempo de compilac,ao para criar o make.conf
   usado pela jail de compilac,ao.

   Os pacotes a serem criados sao inseridos em
   10amd64-local-workstation-pkglist:

 editors/emacs
 devel/git
 ports-mgmt/pkg
 ...

   Opc,oes e dependencias para os ports especificados sao configuradas:

 # poudriere options -j 10amd64 -p local -z workstation -f 10amd64-local-workstation-pkglist

   Finalmente, os pacotes sao compilados e um repositorio de pacotes e
   criado:

 # poudriere bulk -j 10amd64 -p local -z workstation -f 10amd64-local-workstation-pkglist

   Durante a execuc,ao, pressionar Ctrl+t exibe o estado atual da
   compilac,ao. O Poudriere tambem cria arquivos em
   /poudriere/logs/bulk/jailname que podem ser usados com um servidor da Web
   para exibir informac,oes de compilac,ao.

   Apos a conclusao, os novos pacotes estao agora disponiveis para
   instalac,ao a partir do repositorio poudriere.

   Para obter maiores informac,oes sobre o uso do poudriere, consulte
   poudriere(8) e o site principal,
   https://github.com/freebsd/poudriere/wiki.

  4.6.2. Configurando Clientes do pkg para usar um repositorio de Poudriere

   Embora seja possivel usar um repositorio personalizado ao lado do
   repositorio oficial, `as vezes e util desativar o repositorio oficial.
   Isso e feito criando um arquivo de configurac,ao que substitui e desativa
   o arquivo de configurac,ao oficial. Crie o
   /usr/local/etc/pkg/repos/FreeBSD.conf que devera conter o seguinte:

 FreeBSD: {
         enabled: no
 }

   Geralmente, e mais facil servir um repositorio poudriere para as maquinas
   clientes via HTTP. Configure um servidor da web para servir o diretorio de
   pacotes, por exemplo: /usr/local/poudriere/data/packages/10amd64, onde
   10amd64 e o nome da compilac,ao.

   Se a URL para o repositorio de pacotes for:
   http://pkg.example.com/10amd64, o arquivo de configurac,ao do repositorio
   em /usr/local/etc/pkg/repos/custom.conf ficaria assim:

 custom: {
         url: "http://pkg.example.com/10amd64",
         enabled: yes,
 }

4.7. Considerac,oes pos-instalac,ao

   Independentemente do software ter sido instalado a partir de um pacote
   binario ou de um port, a maioria dos aplicativos de terceiros requer algum
   nivel de configurac,ao apos a instalac,ao. Os seguintes comandos e locais
   podem ser usados para ajudar a determinar o que foi instalado com o
   aplicativo.

     * A maioria dos aplicativos instala pelo menos um arquivo de
       configurac,ao padrao em /usr/local/etc. Nos casos em que um aplicativo
       possui um grande numero de arquivos de configurac,ao, um subdiretorio
       sera criado para mante-los. Geralmente, os arquivos de configurac,ao
       de exemplo sao instalados e terminam com um sufixo, como .sample. Os
       arquivos de configurac,ao devem ser revisados e possivelmente editados
       para atender `as necessidades do sistema. Para editar um arquivo de
       amostra, primeiro copie-o sem a extensao .sample.

     * As aplicac,oes que fornecem documentac,ao irao instala-la em
       /usr/local/share/doc e muitos aplicativos tambem instalam paginas de
       manual. Esta documentac,ao deve ser consultada antes de continuar.

     * Alguns aplicativos executam servic,os que devem ser adicionados ao
       /etc/rc.conf antes de iniciar o aplicativo. Esses aplicativos
       geralmente instalam um script de inicializac,ao em
       /usr/local/etc/rc.d. Veja Iniciando Servic,os para maiores
       informac,oes.

  Nota:

       Por padrao, os aplicativos nao executam o script de inicializac,ao
       durante a instalac,ao, nem executam o script de parada apos a
       desinstalac,ao ou atualizac,ao. Essa decisao e deixada para o
       administrador do sistema.

     * Os usuarios de csh(1) devem executar rehash para reconstruir a lista
       dos binarios conhecidos nos shells PATH.

     * Use pkg info para determinar quais arquivos, paginas man e binarios
       foram instalados com o aplicativo.

4.8. Lidando com ports quebrados

   Quando um port nao e compilado ou instalado, tente o seguinte:

    1. Procure para ver se ha uma correc,ao pendente para o port no Banco de
       Dados do Relatorio de Problemas. Nesse caso, implementar a correc,ao
       proposta pode corrigir o problema.

    2. Pec,a ajuda ao mantenedor do port. Digite make maintainer no diretorio
       do port ou leia o Makefile do port para encontrar o enderec,o de
       e-mail do mantenedor. Lembre-se de incluir a linha $FreeBSD: do
       Makefile do port e a saida que leva ao erro no e-mail para o
       mantenedor.

  Nota:

       Alguns ports nao sao mantidos por um individuo, mas sim por um grupo
       de mantenedores representado por uma lista de discussao. Muitos, mas
       nao todos, esses enderec,os se parecem com
       <freebsd-listname@FreeBSD.org>. Por favor, leve isso em considerac,ao
       ao enviar um email.

       Em particular, os ports mantidos por <ports@FreeBSD.org> nao sao
       mantidos por um individuo especifico. Em vez disso, quaisquer
       correc,oes e suporte vem da comunidade geral que se inscreve nessa
       lista de discussao. Mais voluntarios sao sempre necessarios!

       Se nao houver resposta ao email, use o Bugzilla para enviar um
       relatorio de bug usando as instruc,oes em Escrevendo Relatorios de
       Problemas do FreeBSD.

    3. Conserte-o! O Porters Handbook inclui informac,oes detalhadas sobre a
       infra-estrutura da arvore de ports para que voce possa corrigir
       possiveis erros na compilacao de um ports que quebrou ou ocasionou um
       erro de compilacao ou ate mesmo submeta seu proprio projeto!

    4. Instale o pacote em vez do port usando as instruc,oes em Sec,ao 4.4,
       "Usando o pkg para o gerenciamento de pacotes binarios".

Capitulo 5. O sistema X Window

   Indice

   5.1. Sinopse

   5.2. Terminologia

   5.3. Instalando o Xorg

   5.4. Configurac,ao do Xorg

   5.5. Usando fontes no Xorg

   5.6. O Gerenciador de Display X

   5.7. Ambientes de desktop

   5.8. Instalando o Compiz Fusion

   5.9. Soluc,ao de problemas

5.1. Sinopse

   Uma instalac,ao padrao do FreeBSD usando o bsdinstall nao ira instalar
   automaticamente uma interface grafica para o usuario. Este capitulo
   descreve como instalar e configurar o Xorg, que fornece o sistema X Window
   open source usado para fornecer um ambiente grafico. Em seguida, descreve
   como encontrar e instalar um ambiente de area de trabalho ou um
   gerenciador de janelas.

  Nota:

   Os usuarios que preferem um metodo de instalac,ao que configure
   automaticamente o Xorg e que oferec,a uma grande variedade de opc,oes de
   gerenciadores de janela durante a instalac,ao devem consultar o web site
   http://www.trueos.org/.

   Para obter maiores informac,oes sobre o hardware de video suportado pelo
   Xorg, consulte o web site x.org.

   Depois de ler este capitulo, voce sabera:

     * Quais sao os varios componentes do Sistema X Window e como eles
       interoperam.

     * Como instalar e configurar o Xorg.

     * Como instalar e configurar varios gerenciadores de janelas e ambientes
       de desktop.

     * Como usar fontes TrueType(R) no Xorg.

     * Como configurar seu sistema para usar um sistema de login grafico
       (XDM).

   Antes de ler este capitulo, voce deve:

     * Saber como instalar softwares adicionais de terceiros, conforme
       descrito em Capitulo 4, Instalando Aplicativos: Pacotes e Ports.

5.2. Terminologia

   Embora nao seja necessario entender todos os detalhes dos varios
   componentes do Sistema X Window e como eles interagem, algum conhecimento
   basico desses componentes pode ser util.

   Servidor X

           O X foi projetado desde o inicio para ser centrado em rede e para
           adotar um modelo "cliente-servidor". Neste modelo, o "Servidor X"
           e executado no computador que possui o teclado, o monitor e o
           mouse conectados. A responsabilidade do servidor inclui tarefas
           como gerenciar o monitor, manipular a entrada do teclado e do
           mouse e manipular a entrada ou saida de outros dispositivos, como
           um tablet ou um projetor de video. Isso confunde algumas pessoas,
           porque a terminologia X e exatamente o oposto do que eles esperam.
           Eles esperam que o "X server" seja a grande maquina poderosa no
           final das contas, e o "Ciente X" seja a maquina em sua mesa.

   Cliente X

           Cada aplicativo X, como o XTerm ou o Firefox, e um "cliente". Um
           cliente envia mensagens para o servidor, como "Por favor, desenhe
           uma janela nessas coordenadas", e o servidor envia de volta
           mensagens como "O usuario apenas clicou no botao OK".

           Em um ambiente domestico ou de uma pequena empresa, o servidor X e
           os clientes X geralmente sao executados no mesmo computador.
           Tambem e possivel executar o servidor X em um computador menos
           potente e executar os aplicativos X em um sistema mais poderoso.
           Nesse cenario, a comunicac,ao entre o cliente X e o servidor
           ocorre atraves da rede.

   Gerenciador de janelas

           O X nao dita como as janelas devem se parecer na tela, como
           move-las com o mouse, quais teclas devem ser usadas para mover-se
           entre as janelas, como devem ficar as barras de titulo em cada
           janela, se elas tem ou nao botoes para fechar nelas e assim por
           diante. Em vez disso, o X delega essa responsabilidade para um
           gerenciador de janelas separado. Existem dezenas de gerenciadores
           de janelas disponiveis. Cada gerenciador de janelas oferece uma
           aparencia diferente: alguns oferecem suporte a desktops virtuais,
           alguns permitem pressionamentos de tecla personalizados para
           gerenciar a area de trabalho, alguns tem um botao "Iniciar" e
           alguns sao personalizaveis, permitindo uma alterac,ao completa da
           aparencia da area de trabalho. Os gerenciadores de janelas estao
           disponiveis na categoria x11-wm da colec,ao de ports.

           Cada gerenciador de janelas usa um mecanismo de configurac,ao
           diferente. Alguns esperam que o arquivo de configurac,ao seja
           escrito `a mao, enquanto outros fornecem ferramentas graficas para
           a maioria das tarefas de configurac,ao.

   Ambiente de desktop

           O KDE e o GNOME sao considerados ambientes de desktop, pois
           incluem um conjunto completo de aplicativos para executar tarefas
           comuns de desktop. Estes podem incluir pacotes de escritorio,
           navegadores da web e jogos.

   Politica de foco

           O gerenciador de janelas e responsavel pela politica de foco do
           mouse. Essa politica fornece alguns meios para escolher qual
           janela esta recebendo ativamente as teclas digitadas e tambem deve
           indicar visivelmente qual janela esta ativa no momento.

           Uma politica de foco e chamada "click-to-focus". Neste modelo, uma
           janela fica ativa ao receber um clique do mouse. Na politica
           "focus-follows-mouse", a janela que esta sob o ponteiro do mouse
           tem foco e o foco e alterado apontando para outra janela. Se o
           mouse estiver sobre a janela raiz, esta janela estara focada. No
           modelo "sloppy-focus", se o mouse for movido sobre a janela raiz,
           a janela usada mais recentemente ainda tera o foco. Com
           sloppy-focus, o foco so e alterado quando o cursor entra em uma
           nova janela, e nao ao sair da janela atual. Na politica de
           "click-to-focus", a janela ativa e selecionada pelo clique do
           mouse. A janela pode entao ser destacada para aparecer na frente
           de todas as outras janelas. Todas as teclas digitadas serao
           direcionadas para esta janela, mesmo se o cursor for movido para
           outra janela.

           Diferentes gerenciadores de janela suportam diferentes modelos de
           foco. Todos eles suportam click-to-focus, e a maioria deles tambem
           suporta outras politicas. Consulte a documentac,ao do gerenciador
           de janelas para determinar quais modelos de foco estao
           disponiveis.

   Widgets

           Widget e um termo para todos os itens na interface do usuario que
           podem ser clicados ou manipulados de alguma forma. Isso inclui
           botoes, caixas de selec,ao, botoes de opc,ao, icones e listas. Um
           kit de ferramentas de widget e um conjunto de widgets usado para
           criar aplicativos graficos. Existem varios toolkits de widgets
           populares, incluindo o Qt, usado pelo KDE, e o GTK+, usado pelo
           GNOME. Como resultado, os aplicativos terao uma aparencia e
           comportamentos diferentes, dependendo de qual kit de ferramentas
           de widget foi usado para criar o aplicativo.

5.3. Instalando o Xorg

   No FreeBSD, o Xorg pode ser instalado como um pacote ou port.

   O pacote binario pode ser instalado rapidamente, mas com menos opc,oes de
   personalizac,ao:

 # pkg install xorg

   Para compilar e instalar a partir da Colec,ao de Ports:

 # cd /usr/ports/x11/xorg
 # make install clean

   Qualquer uma dessas instalac,oes resulta no sistema completo do Xorg sendo
   instalado. Pacotes binarios sao a melhor opc,ao para a maioria dos
   usuarios.

   Uma versao menor do sistema X adequada para usuarios experientes esta
   disponivel em x11/xorg-minimal. A maioria dos documentos, bibliotecas e
   aplicativos nao sera instalada. Algumas aplicac,oes requerem esses
   componentes adicionais para funcionarem.

5.4. Configurac,ao do Xorg

   Warren Block

  5.4.1. Inicio Rapido

   O Xorg suporta as placas de video, teclados e dispositivos USB mais
   comuns.

  Dica:

   Placas de video, monitores e dispositivos de entrada sao detectados
   automaticamente e nao exigem nenhuma configurac,ao manual. Nao crie o
   xorg.conf ou execute o passo -configure a menos que a configurac,ao
   automatica falhe.

    1. Se o Xorg tiver sido usado neste computador antes, mova ou remova
       qualquer arquivo de configurac,ao existente:

 # mv /etc/X11/xorg.conf ~/xorg.conf.etc
 # mv /usr/local/etc/X11/xorg.conf ~/xorg.conf.localetc

    2. Adicione o usuario que executara o Xorg ao grupo video ou wheel para
       ativar a acelerac,ao 3D quando disponivel. Para adicionar o usuario
       jru ao grupo que estiver disponivel:

 # pw groupmod video -m jru || pw groupmod wheel -m jru

    3. O gerenciador de janelas TWM e incluido por padrao. Ele e iniciado
       quando o Xorg e iniciado:

 % startx

    4. Em algumas versoes mais antigas do FreeBSD, o console do sistema deve
       ser definido como vt(4) antes que a volta para o console de texto
       funcione corretamente. Veja Sec,ao 5.4.3, "Configurac,ao do Modo
       Kernel (KMS)".

  5.4.2. Grupo de Usuarios para Video Acelerado

   O acesso ao /dev/dri e necessario para permitir a acelerac,ao 3D nas
   placas de video. Geralmente e mais simples adicionar o usuario que estara
   executando o X no grupo video ou no wheel. Aqui, o pw(8) e usado para
   adicionar o usuario slurms ao grupo video, ou ao grupo wheel se nao houver
   nenhum grupo video:

 # pw groupmod video -m slurms || pw groupmod wheel -m slurms

  5.4.3. Configurac,ao do Modo Kernel (KMS)

   Quando o computador alterna a exibic,ao do console para uma resoluc,ao de
   tela mais alta para o X, ele deve definir o modo da saida de video.
   Versoes recentes do Xorg usam um sistema dentro do kernel para fazer essas
   mudanc,as de modo mais eficiente. Versoes mais antigas do FreeBSD usam o
   sc(4), que nao tem conhecimento do sistema KMS. O resultado final e que
   depois de fechar o X, o console do sistema fica em branco, embora ainda
   esteja funcionando. O console vt(4) mais recente evita esse problema.

   Adicione esta linha ao /boot/loader.conf para ativar o vt(4):

 kern.vty=vt

  5.4.4. Arquivos de Configurac,ao

   A configurac,ao manual geralmente nao e necessaria. Por favor, nao crie
   manualmente arquivos de configurac,ao, a menos que a autoconfigurac,ao nao
   funcione.

    5.4.4.1. Diretorio

   O Xorg procura em varios diretorios por arquivos de configurac,ao. O
   /usr/local/etc/X11/ e o diretorio recomendado para esses arquivos no
   FreeBSD. Usar esse diretorio ajuda a manter os arquivos dos aplicativos
   separados dos arquivos do sistema operacional.

   Armazenar arquivos de configurac,ao no diretorio legado /etc/X11/ ainda
   funciona. No entanto, isso combina arquivos de aplicativos com os arquivos
   basicos do FreeBSD e nao e recomendado.

    5.4.4.2. Arquivos Unicos ou Multiplos

   E mais facil usar multiplos arquivos em que cada um controla uma
   configurac,ao especifica ao inves do unico e tradicional xorg.conf. Esses
   arquivos sao armazenados no subdiretorio xorg.conf.d/ do diretorio
   principal do arquivo de configurac,ao. O caminho completo e tipicamente
   /usr/local/etc/X11/xorg.conf.d/.

   Exemplos desses arquivos serao mostrados posteriormente nesta sec,ao.

   O tradicional e unico arquivo xorg.conf ainda funciona, mas nao e tao
   claro e nem tao flexivel quanto varios arquivos no subdiretorio
   xorg.conf.d/.

  5.4.5. Placas de Video

   Devido as mudanc,as feitas nas versoes recentes do FreeBSD, agora e
   possivel usar drivers graficos fornecidos pelo Framework do Ports, assim
   como pelos pacotes. Assim sendo, os usuarios podem usar um dos seguintes
   drivers disponiveis em graphics/drm-kmod.

   Intel KMS driver, Radeon KMS driver, AMD KMS driver

           A acelerac,ao 2D e 3D e suportada na maioria das placas graficas
           do driver Intel KMS fornecidas pela Intel.

           Nome do driver: i915kms

           A acelerac,ao 2D e 3D e suportada na maioria das placas graficas
           de driver Radeon KMS mais antigas fornecidas pela AMD.

           Nome do Driver: radeonkms

           A acelerac,ao 2D e 3D e suportada nas mais recentes placas
           graficas do driver AMD KMS fornecidas pela AMD.

           Nome do Driver: amdgpu

           Para referencia, veja
           https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units
           ou
           https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units
           para uma lista das GPUs suportadas.

   Intel(R)

           A acelerac,ao 3D e suportada na maioria dos chipsets graficos da
           Intel(R) ate o Ivy Bridge (HD Graphics 2500, 4000 e P4000),
           incluindo Iron Lake (HD Graphics) e Sandy Bridge (HD Graphics
           2000) .

           Nome do driver: intel

           Para referencia, veja
           https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units.

   AMD(R) Radeon

           Acelerac,ao 2D e 3D e suportada em placas Radeon das mais antigas
           ate a serie HD6000.

           Nome do Driver: radeon

           Para referencia, veja
           https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units.

   NVIDIA

           Varios drivers da NVIDIA estao disponiveis na categoria x11 da
           Colec,ao de Ports. Instale o driver que corresponde `a sua placa
           de video.

           Para referencia, veja
           https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units.

   Graficos Hibridos de Combinac,ao

           Alguns notebooks adicionam unidades de processamento grafico
           adicionais `aquelas incorporadas ao chipset ou ao processador. O
           Optimus combina o hardware da Intel(R) e da NVIDIA. O Switchable
           Graphics ou Hybrid Graphics sao uma combinac,ao dos processadores
           Intel(R) ou AMD(R) e uma GPU AMD(R) Radeon.

           As implementac,oes desses sistemas graficos hibridos variam e o
           Xorg no FreeBSD nao e capaz de controlar todas as versoes deles.

           Alguns computadores fornecem uma opc,ao no BIOS para desativar um
           dos adaptadores graficos ou selecionar um modo discreto que pode
           ser usado com um dos drivers de placa de video padrao. Por
           exemplo, `as vezes e possivel desativar a GPU NVIDIA em um sistema
           Optimus. O video Intel(R) pode entao ser usado com um driver
           Intel(R).

           Configurac,oes de BIOS dependem do modelo do computador. Em
           algumas situac,oes, ambas GPUs podem ser deixadas ativadas, mas
           criar um arquivo de configurac,ao que use apenas a GPU principal
           na sec,ao Device e o suficiente para tornar esse sistema
           funcional.

   Outras placas de video

           Drivers para algumas placas de video menos comuns podem ser
           encontrados no diretorio x11-drivers da Colec,ao de Ports.

           PLacas que nao sao suportadas por um driver especifico ainda podem
           ser usadas com o driver x11-drivers/xf86-video-vesa. Este driver e
           instalado pelo x11/xorg. Ele tambem pode ser instalado manualmente
           como x11-drivers/xf86-video-vesa. O Xorg tenta usar este driver
           quando um driver especifico nao e encontrado para a placa de
           video.

           O x11-drivers/xf86-video-scfb e um driver de video nao
           especializado similar que funciona em muitos computadores UEFI e
           ARM(R).

   Configurando o driver de video em um arquivo

           Para definir o driver Intel(R) em um arquivo de configurac,ao:

           Exemplo 5.1. Selecione o driver de video Intel(R) em um arquivo

           /usr/local/etc/X11/xorg.conf.d/driver-intel.conf

 Section "Device"
         Identifier "Card0"
         Driver     "intel"
         # BusID    "PCI:1:0:0"
 EndSection

           Se mais de uma placa de video estiver presente, o identificador
           BusID pode ser descomentado e configurado para selecionar a placa
           desejada. Uma lista de barramento de placa de video ID pode ser
           exibida com pciconf -lv | grep -B3 display.

           Para definir o driver Radeon em um arquivo de configurac,ao:

           Exemplo 5.2. Selecione o driver de video Radeon em um arquivo

           /usr/local/etc/X11/xorg.conf.d/driver-radeon.conf

 Section "Device"
         Identifier "Card0"
         Driver     "radeon"
 EndSection

           Para definir o driver VESA em um arquivo de configurac,ao:

           Exemplo 5.3. Selecione o driver de video VESA em um arquivo

           /usr/local/etc/X11/xorg.conf.d/driver-vesa.conf

 Section "Device"
         Identifier "Card0"
         Driver     "vesa"
 EndSection

           Para definir o driver scfb para uso com um computador UEFI ou
           ARM(R):

           Exemplo 5.4. Selecione o driver de video scfb em um arquivo

           /usr/local/etc/X11/xorg.conf.d/driver-scfb.conf

 Section "Device"
         Identifier "Card0"
         Driver     "scfb"
 EndSection

  5.4.6. Monitores

   Quase todos os monitores suportam o padrao Extended Display Identification
   Data (EDID). O Xorg usa o EDID para se comunicar com o monitor e detectar
   as resoluc,oes e taxas de atualizac,ao suportadas. Em seguida, seleciona a
   combinac,ao mais adequada de configurac,oes para usar com esse monitor.

   Outras resoluc,oes suportadas pelo monitor podem ser escolhidas definindo
   a resoluc,ao desejada nos arquivos de configurac,ao, ou apos o servidor X
   ter sido iniciado com xrandr(1).

   Usando xrandr(1)

           Execute o xrandr(1) sem nenhum parametro para ver uma lista de
           saidas de video e modos de monitor detectados:

 % xrandr
 Screen 0: minimum 320 x 200, current 3000 x 1920, maximum 8192 x 8192
 DVI-0 connected primary 1920x1200+1080+0 (normal left inverted right x axis y axis) 495mm x 310mm
    1920x1200     59.95*+
    1600x1200     60.00
    1280x1024     85.02    75.02    60.02
    1280x960      60.00
    1152x864      75.00
    1024x768      85.00    75.08    70.07    60.00
    832x624       74.55
    800x600       75.00    60.32
    640x480       75.00    60.00
    720x400       70.08
 DisplayPort-0 disconnected (normal left inverted right x axis y axis)
 HDMI-0 disconnected (normal left inverted right x axis y axis)

           Isso mostra que a saida DVI-0 esta sendo usada para exibir uma
           resoluc,ao de tela de 1920x1200 pixels a uma taxa de atualizac,ao
           de cerca de 60 Hz. Os monitores nao estao conectados aos
           conectores DisplayPort-0 e HDMI-0.

           Qualquer um dos outros modos de exibic,ao pode ser selecionado com
           xrandr(1). Por exemplo, para mudar para 1280x1024 a 60 Hz:

 % xrandr --mode 1280x1024 --rate 60

           Uma tarefa comum e usar a saida de video externa em um notebook
           para um projetor de video.

           O tipo e a quantidade de conectores de saida variam entre os
           dispositivos, e o nome dado a cada saida varia de driver para
           driver. O que um driver chama de HDMI-1, outro pode chamar de
           HDMI1. Portanto, o primeiro passo e executar xrandr(1) para listar
           todas as saidas disponiveis:

 % xrandr
 Screen 0: minimum 320 x 200, current 1366 x 768, maximum 8192 x 8192
 LVDS1 connected 1366x768+0+0 (normal left inverted right x axis y axis) 344mm x 193mm
    1366x768      60.04*+
    1024x768      60.00
    800x600       60.32    56.25
    640x480       59.94
 VGA1 connected (normal left inverted right x axis y axis)
    1280x1024     60.02 +  75.02
    1280x960      60.00
    1152x864      75.00
    1024x768      75.08    70.07    60.00
    832x624       74.55
    800x600       72.19    75.00    60.32    56.25
    640x480       75.00    72.81    66.67    60.00
    720x400       70.08
 HDMI1 disconnected (normal left inverted right x axis y axis)
 DP1 disconnected (normal left inverted right x axis y axis)

           Quatro saidas foram encontradas: os conectores LVDS1 e VGA1, HDMI1
           e DP1 do painel interno.

           O projetor foi conectado `a saida VGA1. O xrandr(1) agora e usado
           para definir essa saida para a resoluc,ao nativa do projetor e
           adicionar o espac,o adicional `a direita da area de trabalho:

 % xrandr --output VGA1 --auto --right-of LVDS1

           A opc,ao --auto escolhe a resoluc,ao e a taxa de atualizac,ao
           detectadas pelo EDID. Se a resoluc,ao nao for detectada
           corretamente, um valor fixo pode ser fornecido com --mode em vez
           da instruc,ao --auto. Por exemplo, a maioria dos projetores pode
           ser usada com uma resoluc,ao de 1024x768, que e definida com
           --mode 1024x768.

           O xrandr(1) geralmente e executado a partir do .xinitrc para
           definir o modo apropriado quando o X e iniciado.

   Configurando a resoluc,ao do monitor em um arquivo

           Para definir uma resoluc,ao de tela de 1024x768 em um arquivo de
           configurac,ao:

           Exemplo 5.5. Defina a resoluc,ao de tela em um arquivo

           /usr/local/etc/X11/xorg.conf.d/screen-resolution.conf

 Section "Screen"
         Identifier "Screen0"
         Device     "Card0"
         SubSection "Display"
         Modes      "1024x768"
         EndSubSection
 EndSection

           Os poucos monitores que nao possuem EDID podem ser configurados
           setando o HorizSync e o VertRefresh para o intervalo de
           frequencias suportado pelo monitor.

           Exemplo 5.6. Configurando Manualmente as Frequencias do Monitor

           /usr/local/etc/X11/xorg.conf.d/monitor0-freq.conf

 Section "Monitor"
         Identifier   "Monitor0"
         HorizSync    30-83   # kHz
         VertRefresh  50-76   # Hz
 EndSection

  5.4.7. Dispositivos de Entrada

    5.4.7.1. Teclados

   Layout do Teclado

           A localizac,ao padronizada das teclas em um teclado e chamada de
           layout. Layouts e outros parametros ajustaveis sao listados em
           xkeyboard-config(7).

           Um layout dos Estados Unidos e o padrao. Para selecionar um layout
           alternativo, defina as opc,oes XkbLayout e XkbVariant em um
           InputClass. Isso sera aplicado a todos os dispositivos de entrada
           que correspondam `a classe.

           Este exemplo seleciona um layout de teclado frances com a variante
           oss.

           Exemplo 5.7. Definindo um layout de teclado

           /usr/local/etc/X11/xorg.conf.d/keyboard-fr-oss.conf

 Section "InputClass"
         Identifier      "KeyboardDefaults"
         Driver          "keyboard"
         MatchIsKeyboard "on"
         Option          "XkbLayout" "fr"
         Option          "XkbVariant" "oss"
 EndSection

           Exemplo 5.8. Definindo varios layouts de teclado

           Define os layouts de teclado para Estados Unidos, Espanhol e
           Ucraniano. Alterne entre esses layouts pressionando Alt+Shift. O
           x11/xxkb ou x11/sbxkb pode ser usado para um melhor controle da
           mudanc,a de layout e dos indicadores do layout atual.

           /usr/local/etc/X11/xorg.conf.d/kbd-layout-multi.conf

 Section "InputClass"
         Identifier      "All Keyboards"
         MatchIsKeyboard "yes"
         Option          "XkbLayout" "us, es, ua"
 EndSection

   Fechando o Xorg pelo teclado

           X pode ser fechado com uma combinac,ao de teclas. Por padrao, essa
           combinac,ao de teclas nao esta definida porque entra em conflito
           com os comandos do teclado para alguns aplicativos. Ativar essa
           opc,ao requer alterac,oes na sec,ao InputDevice do teclado:

           Exemplo 5.9. Ativando o fechamento de X pelo teclado

           /usr/local/etc/X11/xorg.conf.d/keyboard-zap.conf

 Section "InputClass"
         Identifier      "KeyboardDefaults"
         Driver          "keyboard"
         MatchIsKeyboard "on"
         Option          "XkbOptions" "terminate:ctrl_alt_bksp"
 EndSection

    5.4.7.2. Mouse e Dispositivos Similares

   Muitos parametros do mouse podem ser ajustados com opc,oes de
   configurac,ao. Veja mousedrv(4) para obter uma lista completa.

   Botoes do Mouse

           O numero de botoes em um mouse pode ser definido na sec,ao
           InputDevice do xorg.conf. Para definir o numero de botoes para 7:

           Exemplo 5.10. Definindo o numero de botoes do mouse

           /usr/local/etc/X11/xorg.conf.d/mouse0-buttons.conf

 Section "InputDevice"
         Identifier  "Mouse0"
         Option      "Buttons" "7"
 EndSection

  5.4.8. Configurac,ao manual

   Em alguns casos, a autoconfigurac,ao do Xorg nao funciona com alguns
   hardwares especificos, ou uma configurac,ao diferente e desejada. Para
   esses casos, um arquivo de configurac,ao personalizado pode ser criado.

  Atenc,ao:

   Nao crie arquivos de configurac,ao manualmente, a menos que seja
   necessario. A configurac,ao manual desnecessaria pode impedir o
   funcionamento adequado.

   Um arquivo de configurac,ao pode ser gerado pelo Xorg baseado no hardware
   detectado. Esse arquivo geralmente e um ponto de partida util para
   configurac,oes personalizadas.

   Gerando um arquivo xorg.conf:

 # Xorg -configure

   O arquivo de configurac,ao e salvo em /root/xorg.conf.new. Fac,a as
   alterac,oes desejadas e teste esse arquivo com:

 # Xorg -config /root/xorg.conf.new

   Apos a nova configurac,ao ter sido ajustada e testada, ela pode ser
   dividida em arquivos menores no diretorio,
   /usr/local/etc/X11/xorg.conf.d/.

5.5. Usando fontes no Xorg

  5.5.1. Fontes Type1

   As fontes padroes que vem com o Xorg nao sao adequadas para muitas
   aplicac,oes desktop. As fontes grandes aparecem irregulares e com
   aparencia nao profissional, e as fontes pequenas sao quase ilegiveis.
   Contudo existem muitas fontes Type1 (PostScript(R)) gratuitas de alta
   qualidade prontas para uso no Xorg. Por exemplo, a colec,ao de fontes URW
   (x11-fonts/urwfonts) inclui versoes de alta qualidade de fontes type1
   padrao (Times Roman(R), Helvetica(R), Palatino(R) e outras). A colec,ao
   Freefonts (x11-fonts/freefonts) inclui muito mais fontes, mas a maioria
   delas direcionadas para uso em softwares graficos como o Gimp, e nao sao
   tao completas para servir como fontes de tela. Alem disso, o Xorg pode ser
   configurado para usar fontes TrueType(R) com um minimo esforc,o. Para
   maiores detalhes sobre isso veja a pagina de manual do X(7) ou
   Sec,ao 5.5.2, "Fontes TrueType(R)".

   Para instalar as colec,oes de fontes Type1 usando pacotes binarios,
   execute os seguintes comandos:

 # pkg install urwfonts

   Como alternativa, para compilar a partir da colec,ao de Ports, execute os
   seguintes comandos:

 # cd /usr/ports/x11-fonts/urwfonts
 # make install clean

   Proceda da mesma forma com a freefont ou outras colec,oes. Para que o
   servidor X detecte essas fontes, adicione uma linha apropriada ao arquivo
   de configurac,ao do servidor X (/etc/X11/xorg.conf):

 FontPath "/usr/local/share/fonts/urwfonts/"

   Alternativamente, na linha de comando de execuc,ao da sessao X:

 % xset fp+ /usr/local/share/fonts/urwfonts
 % xset fp rehash

   Isso funcionara, mas sera perdido quando a sessao X for fechada, a menos
   que seja adicionada ao arquivo de inicializac,ao (~/.xinitrc para uma
   sessao startx normal ou ~/.xsession ao efetuar login atraves de um
   gerenciador de login grafico como o XDM). Uma terceira forma e usar o novo
   /usr/local/etc/fonts/local.conf, como demonstrado em Sec,ao 5.5.3, "Fontes
   com Anti-Alias".

  5.5.2. Fontes TrueType(R)

   O Xorg tem suporte nativo para renderizar fontes TrueType(R). Existem dois
   modulos diferentes que podem ativar essa funcionalidade. O modulo freetype
   e usado neste exemplo porque e mais consistente com os outros backends de
   renderizac,ao de fonte. Para habilitar o modulo freetype, basta adicionar
   a seguinte linha `a sec,ao "Module" do /etc/X11/xorg.conf.

 Load  "freetype"

   Agora crie um diretorio para as fontes TrueType(R) (por exemplo,
   /usr/local/share/fonts/TrueType) e copie todas as fontes TrueType(R) para
   este diretorio. Tenha em mente que as fontes TrueType(R) nao podem ser
   obtidas diretamente de um Apple(R) Mac(R); elas devem estar no formato
   UNIX(R)/MS-DOS(R)/Windows(R) para uso pelo Xorg. Uma vez que os arquivos
   foram copiados para este diretorio, use mkfontdir para criar um fonts.dir,
   para que o renderizador de fontes do X saiba que esses novos arquivos
   foram instalados. O mkfontdir pode ser instalado como um pacote binario
   com o comando:

 # pkg install mkfontdir

   Em seguida, crie um indice de arquivos de fontes X em um diretorio:

 # cd /usr/local/share/fonts/TrueType
 # mkfontdir

   Agora adicione o diretorio TrueType(R) ao caminho da fonte. Isso e
   exatamente o mesmo descrito em Sec,ao 5.5.1, "Fontes Type1":

 % xset fp+ /usr/local/share/fonts/TrueType
 % xset fp rehash

   ou adicione uma linha de FontPath ao xorg.conf.

   Agora, o Gimp, o Apache OpenOffice e todos os outros aplicativos X devem
   reconhecer as fontes TrueType(R) instaladas. Fontes extremamente pequenas
   (como o texto em uma tela de alta resoluc,ao em uma pagina da Web) e
   fontes extremamente grandes (dentro do StarOffice(TM) ) ficarao muito
   melhores agora.

  5.5.3. Fontes com Anti-Alias

   Todas as fontes do Xorg que sao encontradas em /usr/local/share/fonts/ e
   ~/.fonts/ sao automaticamente disponibilizadas para anti-aliasing para
   aplicativos compativeis com Xft-aware. Os aplicativos mais recentes sao
   compativeis com o Xft-aware, incluindo o KDE, o GNOME e o Firefox.

   Para controlar quais fontes sao anti-aliased, ou para configurar as
   propriedades do anti-alias, crie (ou edite, se ja existir) o arquivo
   /usr/local/etc/fonts/local.conf. Varios recursos avanc,ados do sistema de
   fontes Xft podem ser ajustados usando este arquivo; Esta sec,ao descreve
   apenas algumas possibilidades simples. Para maiores detalhes, por favor
   veja fonts-conf(5).

   Este arquivo deve estar no formato XML. Preste muita atenc,ao ao uso de
   letras maiusculas e minusculas e certifique-se de que todas as tags
   estejam corretamente fechadas. O arquivo comec,a com o cabec,alho XML
   usual seguido por uma definic,ao DOCTYPE e, em seguida, a tag
   <fontconfig>:

 <?xml version="1.0"?>
       <!DOCTYPE fontconfig SYSTEM "fonts.dtd">
       <fontconfig>

   Como dito anteriormente, todas as fontes em /usr/local/share/fonts/ e
   ~/.fonts/ ja estao disponiveis para aplicativos Xft-aware. Para adicionar
   outro diretorio fora dessas duas arvores de diretorios, adicione uma linha
   como essa a /usr/local/etc/fonts/local.conf:

 <dir>/path/to/my/fonts</dir>

   Depois de adicionar novas fontes e especialmente novos diretorios de
   fontes, reconstrua os caches de fontes:

 # fc-cache -f

   O anti-aliasing torna as bordas um pouco confusas, o que torna o texto
   muito pequeno mais legivel e remove os "serrilhados" do texto grande, mas
   pode causar fadiga ocular se aplicado ao texto normal. Para excluir
   tamanhos de fonte menores que 14 pontos do anti-aliasing, inclua estas
   linhas:

         <match target="font">
             <test name="size" compare="less">
                 <double>14</double>
             </test>
             <edit name="antialias" mode="assign">
                 <bool>false</bool>
             </edit>
         </match>
         <match target="font">
             <test name="pixelsize" compare="less" qual="any">
                 <double>14</double>
             </test>
             <edit mode="assign" name="antialias">
                 <bool>false</bool>
             </edit>
         </match>

   O espac,amento para algumas fontes monoespac,adas tambem pode ser
   inadequado com o anti-aliasing. Este parece ser um problema com o KDE, em
   particular. Uma possivel correc,ao e forc,ar o espac,amento dessas fontes
   para que seja 100. Adicione essas linhas:

         <match target="pattern" name="family">
            <test qual="any" name="family">
                <string>fixed</string>
            </test>
            <edit name="family" mode="assign">
                <string>mono</string>
            </edit>
         </match>
         <match target="pattern" name="family">
             <test qual="any" name="family">
                 <string>console</string>
             </test>
             <edit name="family" mode="assign">
                 <string>mono</string>
             </edit>
         </match>

   (isto cria um apelido para outros nomes comuns para fontes fixas como
   "mono"), e entao adicione:

          <match target="pattern" name="family">
              <test qual="any" name="family">
                  <string>mono</string>
              </test>
              <edit name="spacing" mode="assign">
                  <int>100</int>
              </edit>
          </match>     

   Determinadas fontes, como Helvetica, podem ter um problema com o
   anti-alias. Geralmente isso se manifesta como uma fonte que parece cortada
   ao meio na vertical. Na pior das hipoteses, pode causar falhas nos
   aplicativos. Para evitar isso, considere adicionar o seguinte ao
   local.conf:

          <match target="pattern" name="family">
              <test qual="any" name="family">
                  <string>Helvetica</string>
              </test>
              <edit name="family" mode="assign">
                  <string>sans-serif</string>
              </edit>
          </match>       

   Depois de editar o local.conf, certifique-se de finalizar o arquivo com a
   tag </fontconfig>. Nao fazer isso fara com que as alterac,oes sejam
   ignoradas.

   Os usuarios podem adicionar configurac,oes personalizadas criando seus
   proprios arquivos ~/.config/fontconfig/fonts.conf. Este arquivo usa o
   mesmo formato XML descrito acima.

   Um ultimo ponto: com uma tela de LCD, a amostragem de sub-pixels pode ser
   desejada. Isso basicamente trata os componentes vermelho, verde e azul
   (separados horizontalmente) separadamente para melhorar a resoluc,ao
   horizontal; os resultados podem ser dramaticos. Para habilitar isso,
   adicione a linha em algum lugar do local.conf:

          <match target="font">
              <test qual="all" name="rgba">
                  <const>unknown</const>
              </test>
              <edit name="rgba" mode="assign">
                  <const>rgb</const>
              </edit>
          </match>

  Nota:

   Dependendo do tipo de display, o rgb pode precisar ser alterado para bgr,
   vrgb ou vbgr: experimente e veja qual funciona melhor.

5.6. O Gerenciador de Display X

   Contribuido Originalmente por Seth Kingsley.

   O Xorg fornece um Gerenciador de Display X, o XDM, que pode ser usado para
   o gerenciamento de sessoes de login. O XDM fornece uma interface grafica
   para escolher em qual servidor de display se conectar para inserir
   informac,oes de autorizac,ao, tal como uma combinac,ao de login e senha.

   Esta sec,ao demonstra como configurar o X Display Manager no FreeBSD.
   Alguns ambientes de desktop fornecem seu proprio gerenciador de login
   grafico. Consulte Sec,ao 5.7.1, "GNOME" para instruc,oes sobre como
   configurar o GNOME Display Manager e Sec,ao 5.7.2, "KDE" para instruc,oes
   sobre como configurar o KDE Display Manager.

  5.6.1. Configurando o XDM

   Para instalar o XDM, use o pacote ou ports x11/xdm. Uma vez instalado, o
   XDM pode ser configurado para ser executado quando a maquina for
   inicializada editando esta entrada em /etc/ttys:

 ttyv8   "/usr/local/bin/xdm -nodaemon"  xterm   off secure

   Altere o off para on e salve a edic,ao. O ttyv8 nesta entrada indica que o
   XDM sera executado no nono terminal virtual.

   O diretorio de configurac,ao do XDM esta localizado em
   /usr/local/lib/X11/xdm. Esse diretorio contem diversos arquivos usados
   para alterar o comportamento e a aparencia do XDM, bem como alguns scripts
   e programas usados para configurar a area de trabalho quando o XDM esta em
   execuc,ao. Tabela 5.1, "Arquivos de Configurac,ao do XDM" resume a func,ao
   de cada um desses arquivos. A sintaxe exata e o uso desses arquivos sao
   descritos em xdm(1).

   Tabela 5.1. Arquivos de Configurac,ao do XDM

    Arquivo                             Descric,ao                            
              O protocolo para conectar ao XDM e chamado de X Display Manager 
              Connection Protocol (XDMCP). Este arquivo e um conjunto de      
   Xaccess    regras de autorizac,ao do cliente para controlar conexoes de    
              XDMCP de maquinas remotas. Por padrao, esse arquivo nao permite 
              a conexao de nenhum cliente remoto.                             
              Este arquivo controla a aparencia do seletor de display XDM e   
              das telas de login. A configurac,ao padrao e uma janela de      
   Xresources login retangular simples com o nome do host da maquina exibido  
              na parte superior em uma fonte grande e "Login:" e "Senha:"     
              solicitado abaixo. O formato deste arquivo e identico ao        
              arquivo app-defaults descrito na documentac,ao do Xorg.         
   Xservers   A lista de exibic,oes locais e remotas que o seletor deve       
              fornecer como opc,oes de login.                                 
              Script de sessao padrao para logins que e executado pelo XDM    
   Xsession   apos um usuario realizar o login. Isso aponta para um script de 
              sessao personalizado em ~/.xsession.                            
              Script para iniciar automaticamente os aplicativos antes de     
              exibir as interfaces de selec,ao ou de login. Ha um script para 
   Xsetup_*   cada exibic,ao sendo usada, denominada Xsetup_*, em que * e o   
              numero de exibic,ao local. Geralmente, esses scripts executam   
              um ou dois programas em segundo plano, como xconsole.           
   xdm-config Configurac,ao global para todos os monitores executados nesta   
              maquina.                                                        
              Contem os erros gerados pelo programa do servidor. Se um        
   xdm-errors display que o XDM esta tentando iniciar travar, procure neste   
              arquivo por mensagens de erro. Essas mensagens tambem sao       
              gravadas no ~/.xsession-errors do usuario.                      
   xdm-pid    O ID do processo XDM em execuc,ao.                              

  5.6.2. Configurando o acesso remoto

   Por padrao, somente usuarios no mesmo sistema podem efetuar login usando o
   XDM. Para permitir que os usuarios em outros sistemas se conectem ao
   servidor de Display, edite as regras de controle de acesso e ative o
   listener de conexao.

   Para configurar o XDM para escutar qualquer conexao remota, comente a
   linha DisplayManager.requestPort em /usr/local/etc/X11/xdm/xdm-config
   colocando um ! na frente dele:

 ! SECURITY: do not listen for XDMCP or Chooser requests
 ! Comment out this line if you want to manage X terminals with xdm
 DisplayManager.requestPort:     0

   Salve as edic,oes e reinicie o XDM. Para restringir o acesso remoto, veja
   as entradas de exemplo em /usr/local/lib/X11/xdm/Xaccess e consulte xdm(1)
   para mais informac,oes.

5.7. Ambientes de desktop

   Contribuido por Valentino Vaschetto.

   Esta sec,ao descreve como instalar tres ambientes de desktop populares em
   um sistema FreeBSD. Um ambiente de desktop pode variar de um gerenciador
   de janelas simples a um conjunto completo de aplicativos de desktop. Mais
   de cem ambientes de area de trabalho estao disponiveis na categoria x11-wm
   da Colec,ao de Ports.

  5.7.1. GNOME

   O GNOME e um ambiente de area de trabalho amigavel. Ele inclui um painel
   para iniciar aplicativos e exibir status, uma area de trabalho, um
   conjunto de ferramentas e aplicativos e um conjunto de convenc,oes que
   facilitam a cooperac,ao entre os aplicativos e a compatibilidade entre
   eles. Mais informac,oes sobre o GNOME no FreeBSD podem ser encontradas em
   https://www.FreeBSD.org/gnome. Esse site contem documentac,ao adicional
   sobre instalac,ao, configurac,ao e gerenciamento do GNOME no FreeBSD.

   Este ambiente de desktop pode ser instalado a partir de um pacote binario:

 # pkg install gnome3

   Para instalar o GNOME a partir do ports, use o seguinte comando. O GNOME e
   um aplicativo grande e levara algum tempo para compilar, mesmo em um
   computador rapido.

 # cd /usr/ports/x11/gnome3
 # make install clean

   O GNOME requer que o /proc seja montado. Adicione esta linha ao /etc/fstab
   para montar este sistema de arquivos automaticamente durante a
   inicializac,ao do sistema:

 proc           /proc       procfs  rw  0   0

   O GNOME usa o D-Bus e o HAL para barramento de mensagens e abstrac,ao de
   hardware. Esses aplicativos sao instalados automaticamente como
   dependencias do GNOME. Habilite-os em /etc/rc.conf para que eles sejam
   iniciados quando o sistema inicializar:

 dbus_enable="YES"
 hald_enable="YES"

   Apos a instalac,ao, configure o Xorg para iniciar o GNOME. A maneira mais
   facil de fazer isso e habilitar o Gerenciador de Display do GNOME, o GDM,
   que e instalado como parte do pacote ou ports do GNOME. Pode ser ativado
   adicionando esta linha ao /etc/rc.conf:

 gdm_enable="YES"

   Geralmente e desejavel tambem iniciar todos os servic,os do GNOME. Para
   conseguir isso, adicione uma segunda linha ao /etc/rc.conf:

 gnome_enable="YES"

   O GDM sera iniciado automaticamente quando o sistema for inicializado.

   Um segundo metodo para iniciar o GNOME e digitar startx na linha de
   comando depois de configurar o ~/.xinitrc. Se este arquivo ja existir,
   substitua a linha que inicia o gerenciador de janelas atual por uma que
   inicie o /usr/local/bin/gnome-session. Se este arquivo nao existir, crie-o
   com este comando:

 % echo "exec /usr/local/bin/gnome-session" > ~/.xinitrc

   Um terceiro metodo e usar o XDM como o gerenciador de Display. Neste caso,
   crie um executavel ~/.xsession:

 % echo "exec /usr/local/bin/gnome-session" > ~/.xsession

  5.7.2. KDE

   O KDE e outro ambiente de trabalho facil de usar. Essa area de trabalho
   fornece um conjunto de aplicativos com aparencia e comportamento
   consistentes, um menu e barras de ferramentas padronizadas, atalhos de
   teclado, esquemas de cores, internacionalizac,ao e uma configurac,ao de
   area de trabalho centralizada e orientada a dialogos. Mais informac,oes
   sobre o KDE podem ser encontradas em http://www.kde.org/. Para
   informac,oes especificas do FreeBSD, consulte http://freebsd.kde.org.

   Para instalar o pacote KDE, digite:

 # pkg install x11/kde5

   Para instalar o KDE via ports, use o seguinte comando. A instalac,ao do
   ports fornecera um menu para selecionar quais componentes instalar. O KDE
   e um aplicativo grande e levara algum tempo para compilar, mesmo em um
   computador rapido.

 # cd /usr/ports/x11/kde5
 # make install clean

   O KDE requer que o /proc esteja montado. Adicione esta linha ao /etc/fstab
   para montar este sistema de arquivos automaticamente durante a
   inicializac,ao do sistema:

 proc           /proc       procfs  rw  0   0

   O KDE usa o D-Bus e o HAL para barramento de mensagens e abstrac,ao de
   hardware. Estas aplicac,oes sao automaticamente instaladas como
   dependencias do KDE. Habilite-os em /etc/rc.conf para que eles sejam
   iniciados quando o sistema inicializar:

 dbus_enable="YES"
 hald_enable="YES"

   Desde o KDE Plasma 5, o Gerenciador de Display do KDE, KDM, nao e mais
   desenvolvido. Uma possivel substituic,ao e o SDDM. Para instala-lo,
   digite:

 # pkg install x11/sddm

   Adicione esta linha em /etc/rc.conf:

 sddm_enable="YES"

   Um segundo metodo para iniciar o KDE Plasma e digitar startx na linha de
   comando. Para que isso funcione, a seguinte linha e necessaria em
   ~/.xinitrc:

 exec ck-launch-session startplasma-x11

   Um terceiro metodo para iniciar o KDE Plasma e atraves do XDM. Para fazer
   isso, crie um arquivo executavel ~/.xsession da seguinte maneira:

 % echo "exec ck-launch-session startplasma-x11" > ~/.xsession

   Uma vez iniciado o KDE Plasma , consulte o sistema de ajuda integrado para
   obter mais informac,oes sobre como usar seus diversos menus e aplicativos.

  5.7.3. Xfce

   O Xfce e um ambiente de desktop baseado no kit de ferramentas GTK+ usado
   pelo GNOME. No entanto, e mais leve e fornece um desktop simples,
   eficiente e facil de usar. E totalmente configuravel, possui um painel
   principal com menus, applets e lanc,adores de aplicativos, fornece um
   gerenciador de arquivos e um gerenciador de som e e personalizavel. Como e
   rapido, leve e eficiente, e ideal para maquinas mais antigas ou mais
   lentas com limitac,oes de memoria. Mais informac,oes sobre o Xfce podem
   ser encontradas em http://www.xfce.org.

   Para instalar o pacote Xfce:

 # pkg install xfce

   Alternativamente , para compilar o port:

 # cd /usr/ports/x11-wm/xfce4
 # make install clean

   O Xfce usa o D-Bus para barramento de mensagens. Este aplicativo e
   instalado automaticamente como dependencia do Xfce. Habilite-o em
   /etc/rc.conf para que ele seja iniciado quando o sistema inicializar:

 dbus_enable="YES"

   Ao contrario do GNOME ou KDE, o Xfce nao disponibiliza seu proprio
   gerenciador de login. Para iniciar o Xfce `a partir da linha de comando
   digitando startx, mas primeiro adicione sua entrada ao ~/.xinitrc:

 % echo ". /usr/local/etc/xdg/xfce4/xinitrc" > ~/.xinitrc

   Um metodo alternativo e usar o XDM. Para configurar este metodo, crie um
   executavel ~/.xsession:

 % echo ". /usr/local/etc/xdg/xfce4/xinitrc" > ~/.xsession

5.8. Instalando o Compiz Fusion

   Uma maneira de tornar o uso de um computador desktop mais agradavel e com
   bons efeitos 3D.

   Instalar o pacote Compiz Fusion e facil, mas a configurac,ao requer alguns
   passos que nao estao descritos na documentac,ao do ports.

  5.8.1. Configurando o Driver nVidia no FreeBSD

   Os efeitos da area de trabalho podem causar uma carga consideravel na
   placa grafica. Para uma placa grafica baseada na nVidia, o driver
   proprietario e necessario para um bom desempenho. Usuarios de outras
   placas graficas podem pular esta sec,ao e continuar com a configurac,ao do
   xorg.conf.

   Para determinar qual o driver nVidia e necessario, consulte a Perguntas
   frequentes sobre o assunto.

   Tendo determinado o driver correto para usar em sua placa grafica, a
   instalac,ao e tao simples quanto instalar qualquer outro pacote.

   Por exemplo, para instalar o driver mais recente:

 # pkg install x11/nvidia-driver

   O driver ira criar um modulo do kernel, que precisa ser carregado na
   inicializac,ao do sistema. Adicione a seguinte linha ao /boot/loader.conf:

 nvidia_load="YES"

  Nota:

   Para carregar imediatamente o modulo no kernel em execuc,ao, voce pode
   executar o comando kldload nvidia. No entanto, foi observado que algumas
   versoes do Xorg nao funcionarao corretamente se o driver nao for carregado
   no momento da inicializac,ao. Desta forma, depois de editar o
   /boot/loader.conf, e recomendado reiniciar o sistema.

   Com o modulo do kernel carregado, voce normalmente so precisa alterar uma
   unica linha no xorg.conf para habilitar o driver proprietario:

   Encontre a seguinte linha no /etc/X11/xorg.conf:

 Driver      "nv"

   e mude para:

 Driver      "nvidia"

   Inicie a GUI como de costume, e voce sera saudado pelo splash da nVidia.
   Tudo deve funcionar como de costume.

  5.8.2. Configurando o xorg.conf para Efeitos de Desktop

   Para ativar o Compiz Fusion, o /etc/X11/xorg.conf precisa ser modificado:

   Adicione a seguinte sec,ao para habilitar os efeitos compostos:

 Section "Extensions"
     Option         "Composite" "Enable"
 EndSection

   Localize a sec,ao "Screen", que deve ser semelhante `a abaixo:

 Section "Screen"
     Identifier     "Screen0"
     Device         "Card0"
     Monitor        "Monitor0"
     ...

   e adicione as duas linhas seguintes (apos "Monitor"):

 DefaultDepth    24
 Option         "AddARGBGLXVisuals" "True"

   Localize a "Subsection" que se refere `a resoluc,ao da tela que voce
   deseja usar. Por exemplo, se voce deseja usar 1280x1024, localize a sec,ao
   a seguir. Se a resoluc,ao desejada nao aparecer em nenhuma subsec,ao, voce
   pode adicionar a entrada relevante `a mao:

 SubSection     "Display"
     Viewport    0 0
     Modes      "1280x1024"
 EndSubSection

   Uma profundidade de cor de 24 bits e necessaria para a composic,ao do
   desktop, altere a subsec,ao acima para:

 SubSection     "Display"
     Viewport    0 0
     Depth       24
     Modes      "1280x1024"
 EndSubSection

   Finalmente, confirme que os modulos "glx" e "extmod" estao carregados na
   sec,ao "Module":

 Section "Module"
     Load           "extmod"
     Load           "glx"
     ...

   A configurac,ao acima pode ser feita automaticamente com o
   x11/nvidia-xconfig, executando como root:

 # nvidia-xconfig --add-argb-glx-visuals
 # nvidia-xconfig --composite
 # nvidia-xconfig --depth=24

  5.8.3. Instalando e Configurando o Compiz Fusion

   Instalar o Compiz Fusion e tao simples quanto qualquer outro pacote:

 # pkg install x11-wm/compiz-fusion

   Quando a instalac,ao estiver concluida, inicie o Desktop Grafico e, em um
   terminal, digite os seguintes comandos (como usuario normal):

 % compiz --replace --sm-disable --ignore-desktop-hints ccp &
 % emerald --replace &

   Sua tela piscara por alguns segundos, pois o gerenciador de janelas (por
   exemplo, Metacity se voce estiver usando o GNOME) sera substituido pelo
   Compiz Fusion. O Emerald cuida das decorac,oes da janela (isto e, botoes
   de fechar, minimizar, maximizar, barras de titulo e assim por diante).

   Voce pode converter isso em um script trivial e executa-lo na
   inicializac,ao automaticamente (por exemplo, adicionando a "Sessions" em
   um Desktop do GNOME):

 #! /bin/sh
 compiz --replace --sm-disable --ignore-desktop-hints ccp &
 emerald --replace &

   Salve isso no seu diretorio home como, por exemplo, start-compiz e torne-o
   executavel:

 % chmod +x ~/start-compiz

   Em seguida, utilize a GUI para adiciona-lo a Startup Programs (localizado
   em System, Preferences, Sessions em um desktop GNOME).

   Para selecionar realmente todos os efeitos desejados e suas
   configurac,oes, execute (novamente como um usuario normal) o Compiz Config
   Settings Manager:

 % ccsm

  Nota:

   No GNOME, isso tambem pode ser encontrado no menu System, Preferences.

   Se voce selecionou "gconf support" durante a compilac,ao, voce tambem sera
   capaz de ver estas configurac,oes usando o gconf-editor sob apps/compiz.

5.9. Soluc,ao de problemas

   Se o mouse nao funcionar, voce precisara primeiro configura-lo antes de
   prosseguir. Em versoes recentes do Xorg, as sec,oes InputDevice em
   xorg.conf sao ignoradas em favor dos dispositivos autodetectados. Para
   restaurar o comportamento antigo, adicione a seguinte linha `a sec,ao
   ServerLayout ou ServerFlags deste arquivo:

 Option "AutoAddDevices" "false"

   Os dispositivos de entrada podem entao ser configurados como nas versoes
   anteriores, juntamente com quaisquer outras opc,oes necessarias (por
   exemplo, troca do layout de teclado).

  Nota:

   Como explicado anteriormente, o daemon hald ira, por padrao, detectar
   automaticamente o seu teclado. Ha chances de que o layout ou modelo do
   teclado nao esteja correto, ambientes de Desktop como o GNOME, KDE ou Xfce
   fornecem ferramentas para configurar o teclado. No entanto, e possivel
   definir as propriedades do teclado diretamente com a ajuda do utilitario
   setxkbmap(1) ou com uma regra de configurac,ao do aplicativohald.

   Por exemplo, se alguem quiser usar um teclado de teclas PC 102 vindo com
   um layout frances, temos que criar um arquivo de configurac,ao de teclado
   para o hald chamado x11-input.fdi e salva-lo no diretorio
   /usr/local/etc/hal/fdi/policy. Este arquivo deve conter as seguintes
   linhas:

 <?xml version="1.0" encoding="iso-8859-1"?>
 <deviceinfo version="0.2">
   <device>
     <match key="info.capabilities" contains="input.keyboard">
           <merge key="input.x11_options.XkbModel" type="string">pc102</merge>
           <merge key="input.x11_options.XkbLayout" type="string">fr</merge>
     </match>
   </device>
 </deviceinfo>

   Se este arquivo ja existir, apenas copie e adicione ao seu arquivo as
   linhas referentes `a configurac,ao do teclado.

   Voce tera que reinicializar sua maquina para forc,ar o hald a ler este
   arquivo.

   E possivel fazer a mesma configurac,ao a partir de um terminal X ou um
   script com esta linha de comando:

 % setxkbmap -model pc102 -layout fr

   O /usr/local/share/X11/xkb/rules/base.lst lista os varios teclados,
   layouts e opc,oes disponiveis.

   O arquivo de configurac,ao xorg.conf.new pode agora ser ajustado para o
   seu gosto. Abra o arquivo em um editor de texto, como emacs(1) ou o ee(1).
   Se o monitor for um modelo antigo ou incomum que nao suporta a detecc,ao
   automatica de frequencias de sincronizac,ao, essas configurac,oes podem
   ser adicionadas ao xorg.conf.new na sec,ao "Monitor":

 Section "Monitor"
         Identifier   "Monitor0"
         VendorName   "Monitor Vendor"
         ModelName    "Monitor Model"
         HorizSync    30-107
         VertRefresh  48-120
 EndSection

   A maioria dos monitores suporta autodetecc,ao de frequencia de
   sincronizac,ao, tornando desnecessaria a entrada manual desses valores.
   Para os poucos monitores que nao suportam a detecc,ao automatica, evite
   possiveis danos inserindo apenas valores fornecidos pelo fabricante.

   O X permite que os recursos do DPMS (Energy Star) sejam usados com
   monitores capazes. O programa xset(1) controla os tempos limite e pode
   forc,ar os modos de espera, suspensao ou desativac,ao. Se voce deseja
   habilitar recursos de DPMS para o seu monitor, voce deve adicionar a
   seguinte linha `a sec,ao do monitor:

 Option       "DPMS"

   Enquanto o arquivo de configurac,ao xorg.conf.new ainda estiver aberto em
   um editor, selecione a resoluc,ao padrao e a profundidade de cor desejada.
   Isso e definido na sec,ao "Screen":

 Section "Screen"
         Identifier "Screen0"
         Device     "Card0"
         Monitor    "Monitor0"
         DefaultDepth 24
         SubSection "Display"
                 Viewport  0 0
                 Depth     24
                 Modes     "1024x768"
         EndSubSection
 EndSection

   A palavra-chave DefaultDepth descreve a profundidade de cor a ser
   executada por padrao. Isto pode ser sobrescrito com a opc,ao de linha de
   comando -depth para Xorg(1). A palavra-chave Modes descreve a resoluc,ao a
   ser executada na profundidade de cor especificada. Observe que somente os
   modos padrao VESA sao suportados, conforme definido pelo hardware grafico
   do sistema de destino. No exemplo acima, a profundidade de cor padrao e de
   vinte e quatro bits por pixel. Nesta profundidade de cor, a resoluc,ao
   aceita e 1024 por 768 pixels.

   Finalmente, escreva o arquivo de configurac,ao e teste-o usando o modo de
   teste dado acima.

  Nota:

   Uma das ferramentas disponiveis para ajuda-lo durante o processo de
   soluc,ao de problemas sao os arquivos de log do Xorg, que contem
   informac,oes sobre cada dispositivo ao qual o servidor Xorg se conecta. Os
   nomes de arquivos de log do Xorg estao no formato /var/log/Xorg.0.log. O
   nome exato do log pode variar de Xorg.0.log para Xorg.8.log e assim por
   diante.

   Se tudo estiver bem, o arquivo de configurac,ao precisa ser instalado em
   um local comum onde o Xorg(1) possa encontra-lo. Isto e tipicamente
   /etc/X11/xorg.conf ou /usr/local/etc/X11/xorg.conf.

 # cp xorg.conf.new /etc/X11/xorg.conf

   O processo de configurac,ao do Xorg agora esta completo. O Xorg pode agora
   ser iniciado com o utilitario startx(1). O servidor Xorg tambem pode ser
   iniciado com o uso de xdm(1).

  5.9.1. Configurac,ao com Chipsets graficos Intel(R) i810

   A configurac,ao com chipsets integrados i810 da Intel(R) requer a
   interface de programac,ao AGP agpgart para o Xorg para conduzir a placa.
   Consulte a pagina de manual do driver agp(4) para obter maiores
   informac,oes.

   Isso permitira a configurac,ao do hardware como qualquer outra placa
   grafica. Observe que nos sistemas sem o driver agp(4) compilado no kernel,
   tentar carregar o modulo com kldload(8) nao funcionara. Este driver tem
   que estar no kernel no momento da inicializac,ao, atraves da compilac,ao
   ou usando o /boot/loader.conf.

  5.9.2. Adicionando um Flatpanel Widescreen ao Mix

   Esta sec,ao pressupoe um pouco de conhecimento avanc,ado de configurac,ao.
   Se as tentativas de usar as ferramentas de configurac,ao padrao acima nao
   resultaram em uma configurac,ao funcional, ha informac,oes suficientes nos
   arquivos de log para serem uteis para fazer a configurac,ao funcionar. O
   uso de um editor de texto sera necessario.

   Os formatos widescreen atuais (WSXGA, WSXGA+, WUXGA, WXGA, WXGA+, etc.)
   suportam formatos ou proporc,oes de formato 16:10 e 10:9 que podem ser
   problematicos. Exemplos de algumas resoluc,oes de tela comuns para
   proporc,oes de 16:10 sao:

     * 2560x1600

     * 1920x1200

     * 1680x1050

     * 1440x900

     * 1280x800

   Em algum momento, sera tao facil quanto adicionar uma dessas resoluc,oes
   como um possivel Mode na Section "Screen" como tal:

 Section "Screen"
 Identifier "Screen0"
 Device     "Card0"
 Monitor    "Monitor0"
 DefaultDepth 24
 SubSection "Display"
         Viewport  0 0
         Depth     24
         Modes     "1680x1050"
 EndSubSection
 EndSection

   O Xorg e inteligente o suficiente para extrair as informac,oes de
   resoluc,ao da tela widescreen via informac,oes I2C/DDC, para que ele saiba
   o que o monitor pode suportar em termos de frequ:encias e resoluc,oes.

   Se aqueles ModeLines nao existem nos drivers, pode ser necessario dar ao
   Xorg uma pequena dica. Usando o /var/log/Xorg.0.log pode-se extrair
   informac,oes suficientes para criar manualmente um ModeLine que
   funcionara. Basta procurar informac,oes semelhantes:

 (II) MGA(0): Supported additional Video Mode:
 (II) MGA(0): clock: 146.2 MHz   Image Size:  433 x 271 mm
 (II) MGA(0): h_active: 1680  h_sync: 1784  h_sync_end 1960 h_blank_end 2240 h_border: 0
 (II) MGA(0): v_active: 1050  v_sync: 1053  v_sync_end 1059 v_blanking: 1089 v_border: 0
 (II) MGA(0): Ranges: V min: 48  V max: 85 Hz, H min: 30  H max: 94 kHz, PixClock max 170 MHz

   Esta informac,ao e chamada de informac,ao EDID. Criar uma ModeLine a
   partir disso e apenas uma questao de colocar os numeros na ordem correta:

 ModeLine <name> <clock> <4 horiz. timings> <4 vert. timings>

   Assim, o ModeLine na Section "Monitor" para este exemplo ficaria assim:

 Section "Monitor"
 Identifier      "Monitor1"
 VendorName      "Bigname"
 ModelName       "BestModel"
 ModeLine        "1680x1050" 146.2 1680 1784 1960 2240 1050 1053 1059 1089
 Option          "DPMS"
 EndSection

   Agora, tendo completado estes passos simples de edic,ao, o X deve iniciar
   no seu novo monitor widescreen.

  5.9.3. Soluc,ao de problemas do Compiz Fusion

   5.9.3.1. Eu instalei o Compiz Fusion, e depois de executar os comandos que
   voce mencionou, minhas janelas ficaram sem barras de titulo e botoes. O
   que esta errado?

   5.9.3.2. Quando executo o comando para iniciar o Compiz Fusion, o servidor
   X trava e eu volto ao console. O que esta errado?

5.9.3.1. Eu instalei o Compiz Fusion, e depois de executar os comandos que voce          
         mencionou, minhas janelas ficaram sem barras de titulo e botoes. O que esta     
         errado?                                                                         
         Provavelmente esta faltando alguma configurac,ao em /etc/X11/xorg.conf. Revise  
         este arquivo cuidadosamente e verifique especialmente as diretivas DefaultDepth 
         e AddARGBGLXVisuals.                                                            
5.9.3.2. Quando executo o comando para iniciar o Compiz Fusion, o servidor X trava e eu  
         volto ao console. O que esta errado?                                            
         Se voce verificar o /var/log/Xorg.0.log, voce provavelmente encontrara          
         mensagens de erro durante a inicializac,ao do X. As mais comuns seriam:         
                                                                                         
         (EE) NVIDIA(0):     Failed to initialize the GLX module; please check in your X 
         (EE) NVIDIA(0):     log file that the GLX module has been loaded in your X      
         (EE) NVIDIA(0):     server, and that the module is the NVIDIA GLX module.  If   
         (EE) NVIDIA(0):     you continue to encounter problems, Please try              
         (EE) NVIDIA(0):     reinstalling the NVIDIA driver.                             
                                                                                         
         Este e geralmente o caso quando voce atualiza o Xorg. Voce precisara reinstalar 
         o pacote x11/nvidia-driver para que o glx seja compilado novamente.             

                            Parte II. Tarefas comuns

   Agora que o basico foi abordado, esta parte do livro discute alguns
   recursos frequ:entemente usados do FreeBSD. Estes capitulos:

     * Introduzem aplicativos de desktop populares e uteis: navegadores,
       ferramentas de produtividade, visualizadores de documentos e muito
       mais.

     * Introduzem uma serie de ferramentas multimidia disponiveis para o
       FreeBSD.

     * Explicam o processo de compilac,ao de um kernel customizado do FreeBSD
       para habilitar funcionalidades extras.

     * Descrevem o sistema de impressao em detalhes, tanto configurac,oes de
       impressoras conectadas em desktops quanto impressoras conectadas `a
       rede.

     * Mostram como executar aplicativos Linux no sistema FreeBSD.

   Alguns destes capitulos recomendam leituras previas, e isso e destacado na
   sinopse no inicio de cada capitulo.

   Indice

   6. Aplicac,oes de Desktop

                6.1. Sinopse

                6.2. Navegadores

                6.3. Produtividade

                6.4. Visualizadores de Documentos

                6.5. Financ,as

   7. Multimidia

                7.1. Sinopse

                7.2. Configurando a Placa de Som

                7.3. Audio MP3

                7.4. Reproduc,ao de Video

                7.5. Placas de TV

                7.6. MythTV

                7.7. Scanners de Imagem

   8. Configurando o kernel do FreeBSD

                8.1. Sinopse

                8.2. Por que compilar um kernel personalizado?

                8.3. Encontrando o hardware do sistema

                8.4. O Arquivo de Configurac,ao

                8.5. Criando e Instalando um Kernel Customizado

                8.6. Se algo der errado

   9. Impressao

                9.1. Inicio Rapido

                9.2. Conexoes de Impressora

                9.3. Linguagens de Descric,ao de Pagina Comuns

                9.4. Impressao Direta

                9.5. LPD (Daemon de impressora de linha)

                9.6. Outros sistemas de impressao

   10. Compatibilidade binaria com o Linux(R)

                10.1. Sinopse

                10.2. Configurando a compatibilidade binaria com o Linux(R)

                10.3. Topicos Avanc,ados

Capitulo 6. Aplicac,oes de Desktop

   Indice

   6.1. Sinopse

   6.2. Navegadores

   6.3. Produtividade

   6.4. Visualizadores de Documentos

   6.5. Financ,as

6.1. Sinopse

   Embora o FreeBSD seja popular como um servidor por seu desempenho e
   estabilidade, ele tambem e adequado para o uso diario como desktop. Com
   mais de 24.000 aplicativos disponiveis como pacotes ou ports para o
   FreeBSD, e facil construir um desktop personalizado que executa uma ampla
   variedade de aplicativos de desktop. Este capitulo demonstra como instalar
   varios aplicativos de desktop, incluindo navegadores da Web, software de
   produtividade, visualizadores de documentos e softwares financeiros.

  Nota:

   Os usuarios que preferem instalar uma versao de desktop pre-configurada do
   FreeBSD em vez de configurar um do zero devem consultar o Website
   trueos.org.

   Os leitores deste capitulo devem saber como:

     * Instalar software adicional usando pacotes ou ports, conforme descrito
       em Capitulo 4, Instalando Aplicativos: Pacotes e Ports.

     * Instalar o X e um gerenciador de janelas, conforme descrito em
       Capitulo 5, O sistema X Window.

   Para obter informac,oes sobre como configurar um ambiente multimidia,
   consulte Capitulo 7, Multimidia.

6.2. Navegadores

   O FreeBSD nao vem com um navegador Web pre-instalado. Em vez disso, a
   categoria www da Colec,ao de Ports contem muitos navegadores que podem ser
   instalados como um pacote ou compilados a partir da colec,ao de Ports.

   Os ambientes de area de trabalho KDE e GNOME incluem seu proprio navegador
   HTML. Consulte Sec,ao 5.7, "Ambientes de desktop" para mais informac,oes
   sobre como configurar esses desktops completos.

   Alguns navegadores leves incluem o www/dillo2, o www/links e o www/w3m.

   Esta sec,ao demonstra como instalar os seguintes navegadores Web populares
   e indica se o aplicativo e pesado em recursos, se leva tempo para compilar
   a partir do Ports ou se possui dependencias importantes.

    Nome da    Recursos    Instalac,ao a                 Notas                
   aplicac,ao necessarios partir do Ports 
   Firefox    medio       pesado          FreeBSD, Linux(R), e versoes        
                                          localizadas estao disponiveis       
   Konqueror  medio       pesado          Requer bibliotecas do KDE           
   Chromium   medio       pesado          Requer Gtk+                         

  6.2.1. Firefox

   O Firefox e um navegador de codigo-fonte aberto que apresenta um mecanismo
   de exibic,ao HTML compativel com os padroes, navegac,ao por guias,
   bloqueio de pop-up, extensoes, seguranc,a aprimorada e muito mais. O
   Firefox e baseado na base de codigo Mozilla.

   Para instalar o pacote da versao mais recente do Firefox, digite:

 # pkg install firefox

   Para instalar a versao ESR (Extended Support Release) do Firefox, use:

 # pkg install firefox-esr

   A Colec,ao de Ports pode ser usada para compilar a versao desejada do
   Firefox a partir do codigo-fonte. Este exemplo compila o www/firefox, onde
   o firefox pode ser substituido pelo ESR ou pela versao localizada para
   instalar.

 # cd /usr/ports/www/firefox
 # make install clean

  6.2.2. Konqueror

   O Konqueror e mais do que um navegador Web, pois tambem e um gerenciador
   de arquivos e um visualizador de multimidia. Ele faz parte do pacote ou
   Port x11/kde4-baseapps.

   O Konqueror suporta o WebKit, assim como o seu proprio KHTML. O WebKit e
   um mecanismo de renderizac,ao usado por muitos navegadores modernos,
   incluindo o Chromium. Para usar o WebKit com o Konqueror no FreeBSD,
   instale o pacote ou Port www/kwebkitpart. Este exemplo instala o pacote:

 # pkg install kwebkitpart

   Para instalar a partir da Colec,ao de Ports:

 # cd /usr/ports/www/kwebkitpart
 # make install clean

   Para habilitar o WebKit no Konqueror, clique em "Settings", "Configure
   Konqueror". Na pagina de configurac,oes "General", clique no menu suspenso
   ao lado de "Default web browser engine" e altere "KHTML" para "WebKit".

   O Konqueror tambem suporta Flash(R). Um guia sobre "como obter suporte" a
   Flash(R) no Konqueror esta disponivel em
   http://freebsd.kde.org/howtos/konqueror-flash.php.

  6.2.3. Chromium

   O Chromium e um projeto de navegador de codigo aberto que visa criar uma
   experiencia de navegac,ao na Web mais segura, mais rapida e mais estavel.
   O Chromium apresenta navegac,ao com guias, bloqueio de pop-up, extensoes e
   muito mais. O Chromium e o projeto de codigo-fonte aberto no qual o
   navegador Web do Google Chrome e baseado.

   O Chromium pode ser instalado como um pacote digitando:

 # pkg install chromium

   Alternativamente, o Chromium pode ser compilado a partir do codigo-fonte
   usando a Colec,ao de Ports:

 # cd /usr/ports/www/chromium
 # make install clean

  Nota:

   O executavel do Chromium e /usr/local/bin/chrome, nao
   /usr/local/bin/chromium.

6.3. Produtividade

   Quando se trata de produtividade, os usuarios geralmente procuram uma
   suite de escritorio ou um processador de texto facil de usar. Embora
   alguns ambientes de desktop como o KDE fornec,am uma suite de escritorio,
   nao ha um pacote de produtividade padrao. Varias suites de escritorio e
   processadores de texto graficos estao disponiveis para o FreeBSD,
   independentemente do gerenciador de janelas instalado.

   Esta sec,ao demonstra como instalar os seguintes softwares populares de
   produtividade e indica se o aplicativo e pesado em recursos, se leva tempo
   para compilar a partir do ports ou se possui dependencias importantes.

        Nome da         Recursos      Instalac,ao a  Principais Dependencias  
      aplicac,ao       necessarios   partir do Ports 
   Calligra          leve            pesado          KDE                      
   AbiWord           leve            leve            Gtk+ ou GNOME            
   The Gimp          leve            pesado          Gtk+                     
   Apache OpenOffice pesado          enorme          JDK(TM) e Mozilla        
   LibreOffice       um pouco pesado enorme          Gtk+, ou KDE/ GNOME, ou  
                                                     JDK(TM)                  

  6.3.1. Calligra

   O ambiente de area de trabalho do KDE inclui uma suite de escritorio que
   pode ser instalada separadamente do KDE. O Calligra inclui componentes
   padroes que podem ser encontrados em outros pacotes de escritorio. O Words
   e o processador de texto, Sheets e o programa de planilha eletronica, o
   Stage gerencia apresentac,oes de slides e Karbon e usado para desenhar
   documentos graficos.

   No FreeBSD, o editors/calligra pode ser instalado como um pacote ou um
   port. Para instalar o pacote:

 # pkg install calligra

   Se o pacote nao estiver disponivel, use a Colec,ao de Ports:

 # cd /usr/ports/editors/calligra
 # make install clean

  6.3.2. AbiWord

   O AbiWord e um programa gratuito de processamento de texto semelhante em
   aparencia ao Microsoft(R) Word. E rapido, contem muitos recursos e e de
   facil utilizac,ao.

   O AbiWord pode importar ou exportar muitos formatos de arquivo, incluindo
   alguns formatos proprietarios como o Microsoft(R) .rtf.

   Para instalar o pacote do AbiWord:

 # pkg install abiword

   Se o pacote nao estiver disponivel, ele pode ser compilado a partir da
   Colec,ao de Ports:

 # cd /usr/ports/editors/abiword
 # make install clean

  6.3.3. O GIMP

   Para autoria ou retoque de imagens, o GIMP fornece um sofisticado programa
   de manipulac,ao de imagens. Ele pode ser usado como um programa de pintura
   simples ou como um pacote de qualidade para retoque de fotos. Ele suporta
   um grande numero de plugins e possui uma interface de script. O GIMP pode
   ler e gravar uma grande variedade de formatos de arquivos e suporta
   interfaces com scanners e tablets.

   Para instalar o pacote:

 # pkg install gimp

   Como alternativa, use a Colec,ao de Ports:

 # cd /usr/ports/graphics/gimp
 # make install clean

   A categoria de programas graficos (freebsd.org/ports/graphics.html) da
   Colec,ao de Ports contem varios plugins relacionados ao GIMP, arquivos de
   ajuda e manuais do usuario.

  6.3.4. Apache OpenOffice

   O Apache OpenOffice e uma suite de escritorio de codigo-fonte aberto que e
   desenvolvida sob a asa da Incubadora da Apache Software Foundation. Ele
   inclui todos os aplicativos encontrados em um pacote completo de
   produtividade de escritorio: um processador de texto, uma planilha
   eletronica, um gerenciador de apresentac,ao e um programa de desenho. Sua
   interface de usuario e semelhante a outros pacotes de escritorio e pode
   importar e exportar em varios formatos de arquivo populares. Esta
   disponivel em varios idiomas diferentes e a internacionalizac,ao foi
   estendida para interfaces, corretores ortograficos e dicionarios.

   O processador de texto do Apache OpenOffice usa um formato de arquivo XML
   nativo para maior portabilidade e flexibilidade. O programa de planilha
   eletronica possui uma linguagem de macros que pode ser conectada a bancos
   de dados externos. O Apache OpenOffice e estavel e roda nativamente em
   Windows(R), Solaris(TM), Linux(R), FreeBSD, e Mac OS(R) X. Maiores
   informac,oes sobre o Apache OpenOffice podem ser encontradas em
   openoffice.org. Para informac,oes especificas do FreeBSD, consulte
   porting.openoffice.org/freebsd/.

   Para instalar o pacote Apache OpenOffice:

 # pkg install apache-openoffice

   Depois que o pacote for instalado, digite o seguinte comando para iniciar
   o Apache OpenOffice:

 % openoffice-X.Y.Z

   onde X.Y.Z e o numero da versao instalada do Apache OpenOffice. Na
   primeira vez que o Apache OpenOffice for iniciado, algumas perguntas serao
   feitas e uma pasta .openoffice.org sera criada no diretorio pessoal do
   usuario.

   Se o pacote do Apache OpenOffice desejado nao estiver disponivel, a
   compilac,ao do port ainda sera uma opc,ao. No entanto, isso requer muito
   espac,o em disco e um tempo bastante longo para compilar:

 # cd /usr/ports/editors/openoffice-4
 # make install clean

  Nota:

   Para compilar uma versao localizada, substitua o comando anterior por:

 # make LOCALIZED_LANG=your_language install clean

   Substitua your_language pelo codigo ISO do idioma correto. Uma lista de
   codigos de idiomas suportados esta disponivel em files/Makefile.localized,
   localizado no diretorio do port.

  6.3.5. LibreOffice

   O LibreOffice e um pacote de software livre desenvolvido por
   documentfoundation.org. E compativel com outras grandes suites de
   escritorios e esta disponivel em diversas plataformas. Ele e um fork
   renomeado do Apache OpenOffice e inclui aplicativos encontrados em um
   pacote completo de produtividade de escritorio: processador de texto,
   planilha, gerenciador de apresentac,ao, programa de desenho, programa de
   gerenciamento de banco de dados e uma ferramenta para criar e editar
   formulas matematicas. Esta disponivel em varios idiomas diferentes e a
   internacionalizac,ao foi estendida para interfaces, corretores
   ortograficos e dicionarios.

   O processador de texto do LibreOffice usa um formato de arquivo XML nativo
   para maior portabilidade e flexibilidade. O programa de planilha
   eletronica possui uma linguagem de macros que pode ser conectada a bancos
   de dados externos. O LibreOffice e estavel e roda nativamente em
   Windows(R), Linux(R), FreeBSD e Mac OS(R) X. Maiores informac,oes sobre o
   LibreOffice podem ser encontradas em libreoffice.org.

   Para instalar a versao em ingles do pacote LibreOffice:

 # pkg install libreoffice

   A categoria de editores de texto ( freebsd.org/ports/editors.html ) da
   Colec,ao de Ports contem varias versoes versoes localizadas do
   LibreOffice. Ao instalar um pacote localizado, substitua libreoffice pelo
   nome do pacote localizado.

   Quando o pacote estiver instalado, digite o seguinte comando para executar
   o LibreOffice:

 % libreoffice

   Durante a primeira execuc,ao, algumas perguntas serao feitas e uma pasta
   .libreoffice sera criada no diretorio pessoal do usuario.

   Se o pacote LibreOffice desejado nao estiver disponivel, a compilac,ao do
   port ainda sera uma opc,ao. No entanto, isso requer muito espac,o em disco
   e um tempo bastante longo para compilar. Este exemplo compila a versao em
   ingles:

 # cd /usr/ports/editors/libreoffice
 # make install clean

  Nota:

   Para compilar uma versao localizada, fac,a cd para o diretorio do port do
   idioma desejado. Os idiomas suportados podem ser encontrados na categoria
   de editores (freebsd.org/ports/editors.html) da Colec,ao de Ports.

6.4. Visualizadores de Documentos

   Alguns novos formatos de documentos ganharam popularidade desde o advento
   do UNIX(R) e os visualizadores que eles exigem podem nao estar disponiveis
   no sistema base. Esta sec,ao demonstra como instalar os seguintes
   visualizadores de documentos:

        Nome da          Recursos         Instalac,ao a        Principais     
      aplicac,ao        necessarios      partir do Ports      Dependencias    
   Xpdf              leve              leve                FreeType           
   gv                leve              leve                Xaw3d              
   Geeqie            leve              leve                Gtk+ ou GNOME      
   ePDFView          leve              leve                Gtk+               
   Okular            leve              pesado              KDE                

  6.4.1. Xpdf

   Para os usuarios que preferem um pequeno visualizador de PDF do FreeBSD, o
   Xpdf fornece um visualizador leve e eficiente que requer poucos recursos.
   Ele usa as fontes X padrao e nao requer nenhum kit de ferramentas
   adicional.

   Para instalar o pacote Xpdf:

 # pkg install xpdf

   Se o pacote nao estiver disponivel, use a Colec,ao de Ports:

 # cd /usr/ports/graphics/xpdf
 # make install clean

   Quando a instalac,ao estiver concluida, inicie o xpdf e use o botao
   direito do mouse para ativar o menu.

  6.4.2. gv

   O gv e um visualizador de arquivos PostScript(R) e PDF. Ele e baseado no
   ghostview, mas tem uma aparencia mais agradavel, pois e baseado no kit de
   ferramentas do widget Xaw3d. O gv possui muitos recursos configuraveis,
   como orientac,ao, tamanho do papel, escala e anti-aliasing. Quase qualquer
   operac,ao pode ser executada com o teclado ou com o mouse.

   Para instalar o gv como um pacote:

 # pkg install gv

   Se um pacote nao estiver disponivel, use a Colec,ao de Ports:

 # cd /usr/ports/print/gv
 # make install clean

  6.4.3. Geeqie

   O Geeqie e um fork do projeto abandonado GQView, em um esforc,o para levar
   o desenvolvimento adiante e integrar os patches existentes. O Geeqie e um
   gerenciador de imagens que suporta a visualizac,ao de um arquivo com um
   unico clique, a execuc,ao de um editor externo e a visualizac,ao de
   miniaturas. Ele tambem possui um modo de apresentac,ao de slides e algumas
   operac,oes basicas de arquivo, facilitando o gerenciamento das colec,oes
   de imagens e a localizac,ao de arquivos duplicados. O Geeqie suporta
   visualizac,ao em tela cheia e a internacionalizac,ao.

   Para instalar o pacote Geeqie:

 # pkg install geeqie

   Se o pacote nao estiver disponivel, use a Colec,ao de Ports:

 # cd /usr/ports/graphics/geeqie
 # make install clean

  6.4.4. ePDFView

   O ePDFView e um visualizador de documentos PDF leve que usa somente as
   bibliotecas Gtk+ e Poppler. Ele esta atualmente em desenvolvimento, mas ja
   abre a maioria dos arquivos PDF (ate os criptografados), salva copias de
   documentos e tem suporte para impressao usando o CUPS.

   Para instalar o ePDFView como um pacote:

 # pkg install epdfview

   Se um pacote nao estiver disponivel, use a Colec,ao de Ports:

 # cd /usr/ports/graphics/epdfview
 # make install clean

  6.4.5. Okular

   O Okular e um visualizador de documentos universal baseado no KPDF para
   KDE. Ele pode abrir muitos formatos de documentos, incluindo PDF,
   PostScript(R), DjVu, CHM, XPS e ePub.

   Para instalar o Okular como um pacote:

 # pkg install okular

   Se um pacote nao estiver disponivel, use a Colec,ao de Ports:

 # cd /usr/ports/graphics/okular
 # make install clean

6.5. Financ,as

   Para gerenciar financ,as pessoais em um desktop FreeBSD, alguns
   aplicativos poderosos e faceis de usar podem ser instalados. Alguns sao
   compativeis com formatos de arquivos comuns, como os formatos usados pelo
   Quicken e Excel.

   Esta sec,ao cobre estes programas:

        Nome da          Recursos         Instalac,ao a        Principais     
      aplicac,ao        necessarios      partir do Ports      Dependencias    
   GnuCash           leve              pesado              GNOME              
   Gnumeric          leve              pesado              GNOME              
   KMyMoney          leve              pesado              KDE                

  6.5.1. GnuCash

   O GnuCash faz parte do esforc,o do GNOME para fornecer aplicativos faceis
   de usar, mas poderosos, para usuarios finais. O GnuCash pode ser usado
   para acompanhar receitas e despesas, contas bancarias e ac,oes. Ele
   apresenta uma interface intuitiva, mantendo-se profissional.

   O GnuCash fornece um registro inteligente, um sistema hierarquico de
   contas e muitos aceleradores de teclado e metodos de preenchimento
   automatico. Ele pode dividir uma unica transac,ao em varias partes mais
   detalhadas. O GnuCash pode importar e mesclar arquivos QIF do Quicken. Ele
   tambem lida com a maioria dos formatos internacionais de data e moeda.

   Para instalar o pacote GnuCash:

 # pkg install gnucash

   Se o pacote nao estiver disponivel, use a Colec,ao de Ports:

 # cd /usr/ports/finance/gnucash
 # make install clean

  6.5.2. Gnumeric

   O Gnumeric e um programa de planilha eletronica desenvolvido pela
   comunidade GNOME. Ele possui adivinhac,ao automatica e conveniente de
   entrada do usuario de acordo com o formato da celula para muitas
   sequencias. Ele pode importar arquivos em varios formatos populares,
   incluindo Excel, Lotus 1-2-3 e Quattro Pro. Ele tem um grande numero de
   func,oes internas e permite todos os formatos usuais de celula, como
   numero, moeda, data, hora e muito mais.

   Para instalar o Gnumeric como um pacote:

 # pkg install gnumeric

   Se o pacote nao estiver disponivel, use a Colec,ao de Ports:

 # cd /usr/ports/math/gnumeric
 # make install clean

  6.5.3. KMyMoney

   O KMyMoney e uma aplicac,ao de financ,as pessoais criada pela comunidade
   KDE. O KMyMoney tem como objetivo fornecer os recursos importantes
   encontrados em aplicativos comerciais de gerenciamento de financ,as
   pessoais. Ele tambem destaca a facilidade de uso e a contabilidade
   adequada de dupla entrada entre seus recursos. O KMyMoney importa a partir
   de arquivos QIF padrao do Quicken, rastreia investimentos, manipula varias
   moedas e fornece diversos relatorios.

   Para instalar o KMyMoney como um pacote:

 # pkg install kmymoney-kde4

   Se o pacote nao estiver disponivel, use a Colec,ao de Ports:

 # cd /usr/ports/finance/kmymoney-kde4
 # make install clean

Capitulo 7. Multimidia

   Editado por Ross Lippert.
   Indice

   7.1. Sinopse

   7.2. Configurando a Placa de Som

   7.3. Audio MP3

   7.4. Reproduc,ao de Video

   7.5. Placas de TV

   7.6. MythTV

   7.7. Scanners de Imagem

7.1. Sinopse

   O FreeBSD suporta uma ampla variedade de placas de som, permitindo que os
   usuarios aproveitem a saida de alta fidelidade de um sistema FreeBSD. Isso
   inclui a capacidade de gravar e reproduzir audio MPEG Layer 3 (MP3),
   arquivo de audio Waveform (WAV), Ogg Vorbis e outros formatos. A colec,ao
   de Ports do FreeBSD contem muitas aplicac,oes para editar audio gravado,
   adicionar efeitos sonoros e controlar dispositivos MIDI conectados.

   O FreeBSD tambem suporta a reproduc,ao de arquivos de video e DVDs. A
   colec,ao de Ports do FreeBSD contem aplicativos para codificar, converter
   e reproduzir varias midias de video.

   Este capitulo descreve como configurar placas de som, reproduc,ao de
   video, placas sintonizadoras de TV e scanners no FreeBSD. Tambem descreve
   algumas das aplicac,oes que estao disponiveis para usar esses
   dispositivos.

   Depois de ler este capitulo, voce ira saber como:

     * Configurar uma placa de som no FreeBSD.

     * Solucionar problemas de configurac,ao de som.

     * Reproduzir e codificar MP3 e outros audios.

     * Preparar um sistema FreeBSD para reproduc,ao de video.

     * Reproduzir DVDs, arquivos .mpg e .avi.

     * Copiar o conteudo de um CD ou DVD em arquivos arquivos.

     * Configurar uma placa de TV.

     * Instale e configure o MythTV no FreeBSD

     * Configurar um scanner de imagem.

     * Configurar um headset Bluetooth.

   Antes de ler este capitulo, voce deve:

     * Saber como instalar aplicativos conforme descrito em Capitulo 4,
       Instalando Aplicativos: Pacotes e Ports.

7.2. Configurando a Placa de Som

   Contribuido porMoses Moore.
   Aprimorado porMarc Fonvieille.

   Antes de iniciar a configurac,ao, determine o modelo da placa de som e o
   chip usado. O FreeBSD suporta uma ampla variedade de placas de som.
   Verifique a lista de dispositivos de audio compativeis nas Notas de
   Hardware, para ver se a placa de som e suportada e quais drivers do
   FreeBSD que ela usa.

   Para usar um dispositivo de som, seu driver deve ser carregado. A maneira
   mais facil e carregar o modulo do kernel para a placa de som com o
   kldload(8). Este exemplo carrega o driver para um chipset de audio
   integrado baseado na especificac,ao Intel:

 # kldload snd_hda

   Para automatizar o carregamento desse driver no momento da inicializac,ao,
   fac,a edic,ao adicionando a seguinte linha ao arquivo /boot/loader.conf:

 snd_hda_load="YES"

   Outros modulos de som disponiveis estao listados no arquivo
   /boot/defaults/loader.conf. Quando nao tiver certeza de qual driver usar,
   carregue o modulo snd_driver:

 # kldload snd_driver

   Este e um metadriver que carrega todos os drivers de som mais comuns e
   pode ser usado para acelerar a busca pelo driver correto. Tambem e
   possivel carregar todos os drivers de som adicionando o metadriver no
   arquivo /boot/loader.conf.

   Para determinar qual driver foi selecionado para a placa de som apos
   carregar o metadriver snd_driver, digite, cat /dev/sndstat.

  7.2.1. Configurando um kernel Personalizado com Suporte de Som

   Esta sec,ao e para usuarios que preferem compilar estaticamente em suporte
   para a placa de som em um kernel personalizado. Para mais informac,oes
   sobre como recompilar um kernel, consulte Capitulo 8, Configurando o
   kernel do FreeBSD.

   Ao usar um kernel personalizado para fornecer suporte ao som, verifique se
   o driver do framework de audio existe no arquivo de configurac,ao do
   kernel personalizado:

 device sound

   Em seguida, adicione suporte para a placa de som. Para continuar o exemplo
   do chipset de audio integrado baseado na especificac,ao Intel da sec,ao
   anterior, use a seguinte linha no arquivo de configurac,ao do kernel
   personalizado:

 device snd_hda

   Certifique-se de ler a pagina de manual do driver para o nome do
   dispositivo a ser usado pelo driver.

   Placas de som ISA nao-PnP podem requerer que as configurac,oes de porta
   IRQ e I/O da placa sejam adicionadas ao arquivo /boot/device.hints.
   Durante o processo de inicializac,ao, o loader(8) le este arquivo e passa
   as configurac,oes para o kernel. Por exemplo, uma placa antiga ISA nao-PnP
   da Creative SoundBlaster(R) usara o driver snd_sbc(4) em conjunto com
   snd_sb16. Para esta placa, as seguintes linhas devem ser adicionadas ao
   arquivo de configurac,ao do kernel:

 device snd_sbc
 device snd_sb16

   Se a placa usar a porta de I/O 0x220 e a IRQ 5, essas linhas tambem
   deverao ser adicionadas ao arquivo /boot/device.hints:

 hint.sbc.0.at="isa"
 hint.sbc.0.port="0x220"
 hint.sbc.0.irq="5"
 hint.sbc.0.drq="1"
 hint.sbc.0.flags="0x15"

   A sintaxe usada no arquivo /boot/device.hints e descrita em sound(4) e na
   pagina de manual do driver da placa de som.

   As configurac,oes mostradas acima sao os padroes. Em alguns casos, a IRQ
   ou outras configurac,oes podem precisar ser alterados para corresponder `a
   placa. Consulte snd_sbc(4) para obter mais informac,oes sobre esta placa.

  7.2.2. Testando o Som

   Depois de carregar o modulo necessario ou reinicializar no kernel
   personalizado, a placa de som deve ser detectada. Para confirmar, execute
   dmesg | grep pcm. Este exemplo e de um sistema com um chipset integrado
   Conexant CX20590:

 pcm0: <NVIDIA (0x001c) (HDMI/DP 8ch)> at nid 5 on hdaa0
 pcm1: <NVIDIA (0x001c) (HDMI/DP 8ch)> at nid 6 on hdaa0
 pcm2: <Conexant CX20590 (Analog 2.0+HP/2.0)> at nid 31,25 and 35,27 on hdaa1

   O status da placa de som tambem pode ser verificado usando este comando:

 # cat /dev/sndstat
 FreeBSD Audio Driver (newpcm: 64bit 2009061500/amd64)
 Installed devices:
 pcm0: <NVIDIA (0x001c) (HDMI/DP 8ch)> (play)
 pcm1: <NVIDIA (0x001c) (HDMI/DP 8ch)> (play)
 pcm2: <Conexant CX20590 (Analog 2.0+HP/2.0)> (play/rec) default

   A saida ira variar dependendo da placa de som. Se nenhum dispositivo pcm
   estiver listado, verifique se o driver de dispositivo correto foi
   carregado ou compilado no kernel. A proxima sec,ao lista alguns problemas
   comuns e suas soluc,oes.

   Se tudo correr bem, a placa de som devera funcionar no FreeBSD. Se a
   unidade de CD ou DVD estiver corretamente conectada `a placa de som, e
   possivel inserir um CD de audio na unidade e reproduzi-lo com
   cdcontrol(1):

 % cdcontrol -f /dev/acd0 play 1

  Atenc,ao:

   CD de audio tem codificac,oes especializadas, o que significa que nao
   devem ser montados usando mount(8).

   Varias aplicac,oes, como audio/workman, fornecem uma interface mais
   amigavel. O Port audio/mpg123 pode ser instalado para ouvir arquivos de
   audio MP3.

   Outra maneira rapida de testar a placa e enviar dados para /dev/dsp:

 % cat filename > /dev/dsp

   onde filename pode ser qualquer tipo de arquivo. Este comando deve
   produzir algum ruido, confirmando que a placa de som esta funcionando.

  Nota:

   Os nos de dispositivo /dev/dsp* serao criados automaticamente conforme
   necessario. Quando nao estao em uso, eles nao existem e nao aparecerao na
   saida de ls(1).

  7.2.3. Configurando Dispositivos de Som Bluetooth

   Conectar a um dispositivo Bluetooth esta fora do escopo deste capitulo.
   Consulte a Sec,ao 31.5, "Bluetooth" para mais informac,oes.

   Para que o dispositivo Bluetooth funcione com o sistema de som do FreeBSD,
   os usuarios precisam primeiramente instalar o audio/virtual_oss:

 # pkg install virtual_oss

   audio/virtual_oss requer cuse para ser carregado no kernel:

 # kldload cuse

   Para carregar o cuse durante a inicializac,ao do sistema, execute o
   comando:

 # sysrc -f /boot/loader.conf cuse_load=yes

   Para usar fones de ouvido como reprodutor de som com audio/virtual_oss, os
   usuarios precisam criar um dispositivo virtual depois de se conectarem a
   um dispositivo de audio Bluetooth:

 # virtual_oss -C 2 -c 2 -r 48000 -b 16 -s 768 -R /dev/null -P /dev/bluetooth/headphones -d dsp

  Nota:

   headphones neste exemplo e o nome de host de /etc/bluetooth/hosts. BT_ADDR
   tambem poderia ser usado.

   Consulte virtual_oss(8) para mais informac,oes.

  7.2.4. Soluc,ao de Problemas de Som

   Tabela 7.1, "Mensagens de Erros Comuns" lista algumas mensagens de erros
   comuns e suas soluc,oes:

   Tabela 7.1. Mensagens de Erros Comuns

              Erro                               Soluc,ao                     
   sb_dspwr(XX) timed out     A porta de I/O nao esta configurada             
                              corretamente.                                   
                              A IRQ esta definida incorretamente.             
   bad irq XX                 Certifique-se de que a IRQ definido e a IRQ do  
                              som sao as mesmas.                              
   xxx: gus pcm not attached, Nao ha memoria disponivel suficiente para usar  
   out of memory              o dispositivo.                                  
                              Digite fstat | grep dsp para verificar se outro 
   xxx: can't open /dev/dsp!  aplicativo esta mantendo o dispositivo aberto.  
                              Os causadores de problemas notaveis sao o       
                              suporte a som do esound e do KDE.               

   Placas graficas modernas geralmente vem com seu proprio driver de som para
   uso com HDMI. As vezes, esse dispositivo de som e enumerado antes da placa
   de som, o que significa que a placa de som nao sera usada como o
   dispositivo de reproduc,ao padrao. Para verificar se este e o caso,
   execute dmesg e procure por pcm. A saida e algo como isto:

 ...
 hdac0: HDA Driver Revision: 20100226_0142
 hdac1: HDA Driver Revision: 20100226_0142
 hdac0: HDA Codec #0: NVidia (Unknown)
 hdac0: HDA Codec #1: NVidia (Unknown)
 hdac0: HDA Codec #2: NVidia (Unknown)
 hdac0: HDA Codec #3: NVidia (Unknown)
 pcm0: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 0 nid 1 on hdac0
 pcm1: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 1 nid 1 on hdac0
 pcm2: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 2 nid 1 on hdac0
 pcm3: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 3 nid 1 on hdac0
 hdac1: HDA Codec #2: Realtek ALC889
 pcm4: <HDA Realtek ALC889 PCM #0 Analog> at cad 2 nid 1 on hdac1
 pcm5: <HDA Realtek ALC889 PCM #1 Analog> at cad 2 nid 1 on hdac1
 pcm6: <HDA Realtek ALC889 PCM #2 Digital> at cad 2 nid 1 on hdac1
 pcm7: <HDA Realtek ALC889 PCM #3 Digital> at cad 2 nid 1 on hdac1
 ...

   Neste exemplo, a placa grafica (NVidia) foi enumerada antes da placa de
   som (Realtek ALC889). Para usar a placa de som como o dispositivo de
   reproduc,ao padrao, altere a variavel hw.snd.default_unit para a unidade
   que deve ser usada para reproduc,ao:

 # sysctl hw.snd.default_unit=n

   onde n e o numero do dispositivo de som a ser usado. Neste exemplo, deve
   ser 4. Deixe esta mudanc,a permanente adicionando a seguinte linha ao
   arquivo /etc/sysctl.conf:

 hw.snd.default_unit=4

  7.2.5. Utilizando Multiplas Fontes de Som

   Contribuido porMunish Chopra.

   Muitas vezes e desejavel ter varias fontes de som capazes de tocar
   simultaneamente. O FreeBSD usa "Canais de Som Virtuais" para multiplexar a
   reproduc,ao da placa de som mixando o som no kernel.

   Tres variaveis no sysctl(8) estao disponiveis para configurar canais
   virtuais:

 # sysctl dev.pcm.0.play.vchans=4
 # sysctl dev.pcm.0.rec.vchans=4
 # sysctl hw.snd.maxautovchans=4

   Este exemplo aloca quatro canais virtuais, que e um numero pratico para o
   uso diario. Ambos dev.pcm.0.play.vchans=4 e dev.pcm.0.rec.vchans=4 sao
   configuraveis depois que um dispositivo foi anexado e representa o numero
   de canais virtuais pcm0 para reproduc,ao e gravac,ao. Como o modulo pcm
   pode ser carregado independentemente dos drivers de hardware,
   hw.snd.maxautovchans indica quantos canais virtuais serao dados a um
   dispositivo de audio quando ele estiver conectado. Consulte pcm(4) para
   obter mais informac,oes.

  Nota:

   O numero de canais virtuais para um dispositivo nao pode ser alterado
   enquanto estiver em uso. Primeiramente, feche todos os programas usando o
   dispositivo, como players de musica ou daemons de som.

   O dispositivo pcm correto sera automaticamente alocado de forma
   transparente para um programa que solicite /dev/dsp0.

  7.2.6. Configurando Valores Padroes para Canais de Mixer

   Contribuido porJosef El-Rayes.

   Os valores padroes para os diferentes canais do mixer sao codificados
   permanentemente no codigo-fonte do driver pcm(4). Embora os niveis do
   mixer da placa de som possam ser alterados usando mixer(8) ou aplicativos
   e daemons de terceiros, essa nao e uma soluc,ao permanente. Para definir
   os valores padroes do mixer no nivel do driver, defina os valores
   apropriados no arquivo /boot/device.hints, conforme mostrado neste
   exemplo:

 hint.pcm.0.vol="50"

   Isso definira o canal de volume como um valor padrao de 50 quando o modulo
   pcm(4) for carregado.

7.3. Audio MP3

   Contribuido porChern Lee.

   Esta sec,ao descreve alguns players MP3 disponiveis para o FreeBSD, como
   ripar trilhas de CD de audio e como codificar e decodificar MP3.

  7.3.1. Players de MP3

   Um popular reprodutor grafico de MP3 e o Audacious. Ele suporta skins do
   Winamp e plugins adicionais. A interface e intuitiva, com uma lista de
   reproduc,ao, equalizador grafico e muito mais. Para aqueles que estao
   familiarizados com o Winamp, acharao o Audacious simples de usar. No
   FreeBSD, o Audacious pode ser instalado a partir de pacotes ou colec,ao de
   Ports multimedia/audacious. Audacious e descendente do XMMS.

   O pacote ou Port audio/mpg123 fornece um reprodutor de MP3 alternativo em
   linha de comando. Uma vez instalado, especifique o arquivo MP3 para
   reproduzir na linha de comando. Se o sistema tiver varios dispositivos de
   audio, o dispositivo de som tambem pode ser especificado:

 # mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3
 High Performance MPEG 1.0/2.0/2.5 Audio Player for Layers 1, 2 and 3
         version 1.18.1; written and copyright by Michael Hipp and others
         free software (LGPL) without any warranty but with best wishes

 Playing MPEG stream from Foobar-GreatestHits.mp3 ...
 MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo

   Outros players MP3 estao disponiveis na Colec,ao de Ports do FreeBSD.

  7.3.2. Copiando Trilhas de CD de Audio

   Antes de codificar um CD ou CD para MP3, os dados de audio no CD devem ser
   copiados para o disco rigido. Isso e feito copiando os dados brutos do CD
   Digital Audio (CDDA) como arquivos WAV.

   A ferramenta cdda2wav, que e instalada com o suite de programas
   sysutils/cdrtools, pode ser usada para extrair informac,oes de audio do
   CD.

   Com o CD de audio na unidade, o seguinte comando pode ser executado como
   root para ripar um CD inteiro em arquivos WAV, por trilhas:

 # cdda2wav -D 0,1,0 -B

   Neste exemplo, o -D 0,1,0 indica o dispositivo SCSI 0,1,0 contendo o CD
   para ripar. Use o comando cdrecord -scanbus para determinar os parametros
   corretos do dispositivo para o sistema.

   Para ripar trilhas individuais, use a opc,ao -t para especificar a trilha:

 # cdda2wav -D 0,1,0 -t 7

   Para extrair um intervalo de trilhas, como as trilhas de um a sete,
   especifique um intervalo:

 # cdda2wav -D 0,1,0 -t 1+7

   Para extrair de uma unidade ATAPI(IDE) CDROM, especifique o nome do
   dispositivo no lugar dos numeros da unidade SCSI. Por exemplo, para
   extrair a trilha 7 de uma unidade IDE:

 # cdda2wav -D /dev/acd0 -t 7

   Alternativamente, o comando dd pode ser usado para extrair trilhas de
   audio em unidades ATAPI, conforme descrito em Sec,ao 17.5.5, "Duplicando
   CDs de Audio".

  7.3.3. Codificac,ao e Decodificac,ao de MP3

   Lame e um codificador popular para MP3 que pode ser instalado a partir do
   port audio/lame. Devido a problemas de patente, o pacote nao esta
   disponivel.

   O comando a seguir convertera o arquivo WAV audio01.wav para audio01.mp3:

 # lame -h -b 128 --tt "Foo Song Title" --ta "FooBar Artist" --tl "FooBar Album" \
 --ty "2014" --tc "Ripped and encoded by Foo" --tg "Genre" audio01.wav audio01.mp3

   Os 128 kbits especificados sao uma taxa de bits padrao para MP3, enquanto
   as taxas de bits 160 e 192 fornecem maior qualidade. Quanto maior a taxa
   de bits, maior o tamanho do arquivo MP3 resultante. A opc,ao -h ativa o
   modo " de maior qualidade, mas um pouco mais lento ". As opc,oes que
   comec,am com --t indicam as tags ID3, que geralmente contem informac,oes
   sobre musicas, para serem incorporadas no arquivo MP3. Opc,oes adicionais
   de codificac,ao podem ser encontradas na pagina de manual do lame.

   Para gravar um CD de audio usando arquivos MP3, primeiro estes devem ser
   convertidos em um formato de arquivo nao compactado. O XMMS pode ser usado
   para converter para o formato WAV, enquanto o mpg123 pode ser usado para
   converter para o formato de dados de audio bruto, Pulse Code Modulation
   (PCM).

   Para converter o arquivo audio01.mp3 usando mpg123, especifique o nome do
   arquivo PCM:

 # mpg123 -s audio01.mp3 > audio01.pcm

   Para usar XMMS para converter um arquivo MP3 para WAV, use esses passos:

   Procedimento 7.1. Convertendo para o Formato WAV no XMMS
    1. Inicie o XMMS.

    2. Clique com o botao direito do mouse na janela para abrir o menu XMMS.

    3. Selecione Preferences abaixo de Options.

    4. Altere o Plugin de Saida para "Disk Writer Plugin".

    5. Pressione Configure.

    6. Digite ou procure um diretorio para gravar os arquivos descompactados.

    7. Carregue o arquivo MP3 no XMMS como de costume, com o volume em 100% e
       as configurac,oes de EQ desativadas.

    8. Pressione Play. O XMMS aparecera como se estivesse tocando o MP3, mas
       nenhuma musica sera ouvida. Na verdade, esta tocando o MP3 para um
       arquivo.

    9. Quando terminar, certifique-se de ajustar o Plugin de Saida padrao de
       volta ao que era antes para ouvir MP3 novamente.

   Os formatos WAV e PCM podem ser usados com cdrecord. Ao usar arquivos WAV,
   havera um pequeno som no inicio de cada trilha. Este som e o cabec,alho do
   arquivo WAV. O pacote binario ou port audio/sox pode ser usado para
   remover o cabec,alho:

 % sox -t wav -r 44100 -s -w -c 2 track.wav track.raw

   Consulte Sec,ao 17.5, "Criando e Usando Midia em CD" para mais
   informac,oes sobre o uso de um gravador de CD no FreeBSD.

7.4. Reproduc,ao de Video

   Contribuido porRoss Lippert.

   Antes de configurar a reproduc,ao de video, determine o modelo e o chipset
   da placa de video. Embora o Xorg suporte uma ampla variedade de placas de
   video, nem todas oferecem um bom desempenho de reproduc,ao. Para obter uma
   lista de extensoes suportadas pelo servidor Xorg usando a placa, execute
   xdpyinfo enquanto o Xorg esta sendo executado.

   E interessante ter um arquivo de teste MPEG pequeno para avaliar varios
   players e opc,oes. Como alguns aplicativos de DVD procuram por midia DVD
   em /dev/dvd por padrao, ou possuem esse nome de dispositivo codificado
   neles, pode ser util fazer um link simbolico para o dispositivo adequado:

 # ln -sf /dev/cd0 /dev/dvd

   Devido `a natureza do devfs(5), os links criados manualmente nao
   persistirao apos a reinicializac,ao do sistema. Para recriar o link
   simbolico automaticamente quando o sistema inicializar, adicione a
   seguinte linha ao arquivo /etc/devfs.conf:

 link cd0 dvd

   A decriptografia do DVD invoca certas func,oes que exigem permissao de
   gravac,ao para o dispositivo DVD.

   Para melhorar a interface de memoria compartilhada do Xorg, recomenda-se
   aumentar os valores dessas variaveis sysctl(8):

 kern.ipc.shmmax=67108864
 kern.ipc.shmall=32768

  7.4.1. Determinando os Recursos de Video

   Existem varias maneiras possiveis de exibir video no Xorg e o que funciona
   e, em grande parte, dependente de hardware. Cada metodo descrito abaixo
   tera qualidade variavel em diferentes hardwares.

   Interfaces de video comuns incluem:

    1. Xorg: saida normal usando memoria compartilhada.

    2. XVideo: uma extensao para a interface Xorg que permite que o video
       seja exibido diretamente em objetos que podem ser desenhados atraves
       de uma acelerac,ao especial. Esta extensao oferece reproduc,ao de boa
       qualidade, mesmo em maquinas de baixo custo. A proxima sec,ao descreve
       como determinar se esta extensao esta sendo executada.

    3. SDL: Simple Directmedia Layer e uma camada de portabilidade para
       muitos sistemas operacionais, permitindo o desenvolvimento de
       aplicativos multiplataforma que fazem uso eficiente de som e graficos.
       O SDL fornece uma abstrac,ao de baixo nivel para o hardware, que `as
       vezes pode ser mais eficiente que a interface do Xorg. No FreeBSD, o
       SDL pode ser instalado usando o pacote ou port devel/sdl20.

    4. DGA: Direct Graphics Access e uma extensao do Xorg que permite que um
       programa contorne o servidor Xorg e altere diretamente o quadro de
       buffer. Como ele depende de um mapeamento de memoria de baixo nivel,
       os programas que o utilizam devem ser executados como root. A extensao
       DGA pode ser testada e comparada usando dga(1). Quando o dga esta em
       execuc,ao, ele altera as cores do display sempre que uma tecla e
       pressionada. Para sair, pressione q.

    5. SVGAlib: uma camada grafica de console de baixo nivel.

    7.4.1.1. XVideo

   Para verificar se esta extensao esta em execuc,ao, use xvinfo:

 % xvinfo

   O XVideo e suportado pela placa de video se o resultado for semelhante a:

 X-Video Extension version 2.2
   screen #0
   Adaptor #0: "Savage Streams Engine"
     number of ports: 1
     port base: 43
     operations supported: PutImage
     supported visuals:
       depth 16, visualID 0x22
       depth 16, visualID 0x23
     number of attributes: 5
       "XV_COLORKEY" (range 0 to 16777215)
               client settable attribute
               client gettable attribute (current value is 2110)
       "XV_BRIGHTNESS" (range -128 to 127)
               client settable attribute
               client gettable attribute (current value is 0)
       "XV_CONTRAST" (range 0 to 255)
               client settable attribute
               client gettable attribute (current value is 128)
       "XV_SATURATION" (range 0 to 255)
               client settable attribute
               client gettable attribute (current value is 128)
       "XV_HUE" (range -180 to 180)
               client settable attribute
               client gettable attribute (current value is 0)
     maximum XvImage size: 1024 x 1024
     Number of image formats: 7
       id: 0x32595559 (YUY2)
         guid: 59555932-0000-0010-8000-00aa00389b71
         bits per pixel: 16
         number of planes: 1
         type: YUV (packed)
       id: 0x32315659 (YV12)
         guid: 59563132-0000-0010-8000-00aa00389b71
         bits per pixel: 12
         number of planes: 3
         type: YUV (planar)
       id: 0x30323449 (I420)
         guid: 49343230-0000-0010-8000-00aa00389b71
         bits per pixel: 12
         number of planes: 3
         type: YUV (planar)
       id: 0x36315652 (RV16)
         guid: 52563135-0000-0000-0000-000000000000
         bits per pixel: 16
         number of planes: 1
         type: RGB (packed)
         depth: 0
         red, green, blue masks: 0x1f, 0x3e0, 0x7c00
       id: 0x35315652 (RV15)
         guid: 52563136-0000-0000-0000-000000000000
         bits per pixel: 16
         number of planes: 1
         type: RGB (packed)
         depth: 0
         red, green, blue masks: 0x1f, 0x7e0, 0xf800
       id: 0x31313259 (Y211)
         guid: 59323131-0000-0010-8000-00aa00389b71
         bits per pixel: 6
         number of planes: 3
         type: YUV (packed)
       id: 0x0
         guid: 00000000-0000-0000-0000-000000000000
         bits per pixel: 0
         number of planes: 0
         type: RGB (packed)
         depth: 1
         red, green, blue masks: 0x0, 0x0, 0x0

   Os formatos listados, como YUV2 e YUV12, nao estao presentes em todas as
   implementac,oes do XVideo e sua ausencia pode atrapalhar alguns players.

   Se o resultado, ao inves disso, se parecer com:

 X-Video Extension version 2.2
 screen #0
 no adaptors present

   O XVideo provavelmente nao e compativel com a placa. Isso significa que
   sera mais dificil para o monitor atender `as demandas computacionais de
   renderizac,ao de video, dependendo da placa de video e do processador.

  7.4.2. Ports e Pacotes Lidando com Video

   Esta sec,ao apresenta alguns dos softwares disponiveis na Colec,ao de
   Ports do FreeBSD, que podem ser usados para reproduc,ao de video.

    7.4.2.1. MPlayer e MEncoder

   O MPlayer e um reprodutor de video em linha de comando com uma interface
   grafica opcional que visa oferecer velocidade e flexibilidade. Outros
   front-ends graficos para o MPlayer estao disponiveis na Colec,ao de Ports
   do FreeBSD.

   O MPlayer pode ser instalado usando o pacote ou port multimedia/mplayer.
   Varias opc,oes de compilac,ao estao disponiveis e uma variedade de
   verificac,oes de hardware ocorre durante o processo de compilac,ao. Por
   esses motivos, alguns usuarios preferem compilar um port ao inves de
   instalar o pacote.

   Ao compilar o port, as opc,oes do menu devem ser revisadas para determinar
   o tipo de suporte a ser compilado no port. Se uma opc,ao nao estiver
   selecionada, o MPlayer nao podera exibir esse tipo de formato de video.
   Use as setas e a barra de espac,o para selecionar os formatos necessarios.
   Quando terminar, pressione Enter para continuar a compilac,ao e
   instalac,ao do port.

   Por padrao, o pacote ou port construira o utilitario de linha de comando
   mplayer e o utilitario grafico gmplayer. Para codificar videos, compile o
   port multimedia/mencoder. Devido a restric,oes de licenciamento, um pacote
   nao esta disponivel para o MEncoder.

   A primeira vez que o MPlayer for executado, ele criara um arquivo
   ~/.mplayer no diretorio pessoal do usuario. Esse subdiretorio contem
   versoes padroes dos arquivos de configurac,oes especificos do usuario.

   Esta sec,ao descreve apenas alguns usos comuns. Consulte o mplayer(1) para
   uma descric,ao completa de suas inumeras opc,oes.

   Para reproduzir o arquivo testfile.avi, especifique as interfaces de video
   com -vo, conforme mostrado nos exemplos a seguir:

 % mplayer -vo xv testfile.avi

 % mplayer -vo sdl testfile.avi

 % mplayer -vo x11 testfile.avi

 # mplayer -vo dga testfile.avi

 # mplayer -vo 'sdl:dga' testfile.avi

   Vale a pena tentar todas essas opc,oes, pois seu relativo desempenho
   depende de muitos fatores e varia significativamente com o hardware.

   Para reproduzir um DVD, substitua testfile.avi por dvd://N -dvd-device
   DEVICE, em que N e o numero do titulo a ser reproduzido e DEVICE e o no do
   dispositivo para o DVD. Por exemplo, para reproduzir o filme 3 de
   /dev/dvd:

 # mplayer -vo xv dvd://3 -dvd-device /dev/dvd

  Nota:

   O dispositivo padrao de DVD pode ser definido durante a construc,ao do
   port MPlayer incluindo a opc,ao WITH_DVD_DEVICE=/path/to/desired/device.
   Por padrao, o dispositivo e /dev/cd0. Mais detalhes podem ser encontrados
   no Makefile.options do port.

   Para parar, pausar, avanc,ar e assim por diante, use uma tecla de atalho.
   Para ver a lista de atalhos de teclado, execute mplayer -h ou leia o
   mplayer (1).

   Opc,oes de reproduc,ao adicionais incluem -fs -zoom, que ativa o modo de
   tela cheia e -framedrop, o que ajuda no desempenho.

   Cada usuario pode adicionar opc,oes comumente usadas ao seu
   ~/.mplayer/config assim:

 vo=xv
 fs=yes
 zoom=yes

   O mplayer pode ser usado para copiar um filme de DVD para um arquivo .vob.
   Para gravar o filme em um segundo DVD:

 # mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd

   O arquivo de saida, out.vob, estara no formato MPEG.

   Qualquer pessoa que deseje obter um alto nivel de experiencia com video
   UNIX(R) deve consultar mplayerhq.hu/DOCS. Como e tecnicamente informativa,
   esta documentac,ao deve ser considerada como leitura obrigatoria antes de
   enviar qualquer relatorio de bug.

   Antes de usar o mencoder, e interessante familiarizar-se com as opc,oes
   descritas em mplayerhq.hu/DOCS/HTML/en/mencoder.html. Existem inumeras
   maneiras de melhorar a qualidade, diminuir a taxa de bits e alterar os
   formatos, e algumas dessas opc,oes podem fazer a diferenc,a entre bom ou
   mau desempenho. Combinac,oes improprias de opc,oes de linha de comando
   podem produzir arquivos de saida que nao podem ser reproduzidos ate mesmo
   por mplayer.

   Aqui esta um exemplo de uma copia simples:

 % mencoder input.avi -oac copy -ovc copy -o output.avi

   Para copiar para um arquivo, use -dumpfile com o mplayer.

   Para converter input.avi para o codec MPEG4 com codificac,ao de audio
   MPEG3, primeiro instale o port audio/lame. Devido a restric,oes de
   licenciamento, um pacote nao esta disponivel. Uma vez instalado, digite:

 % mencoder input.avi -oac mp3lame -lameopts br=192 \
          -ovc lavc -lavcopts vcodec=mpeg4:vhq -o output.avi

   Isso produzira uma saida reproduzivel por aplicativos como mplayer e xine.

   input.avi pode ser substituido por dvd://1 -dvd-device /dev/dvd e
   executado como root para recodificar um filme de DVD diretamente. Como
   pode levar algumas tentativas para obter o resultado desejado,
   recomenda-se gravar o arquivo de um filme e trabalhar nele.

    7.4.2.2. O Player (reprodutor) de Video xine

   O xine e um reprodutor de video com uma biblioteca base reutilizavel e um
   executavel modular que pode ser estendido com plug-ins. Pode ser instalado
   usando o pacote ou port multimedia/xine.

   Na pratica, o xine requer uma CPU rapida com uma placa de video rapida ou
   suporte para a extensao XVideo. O player de video xine apresenta melhor
   desempenho nas interfaces XVideo.

   Por padrao, o player xine inicia uma interface grafica com o usuario. Os
   menus podem entao ser usados para abrir um arquivo especifico.

   Alternativamente, o xine pode ser executado a partir da linha de comando,
   especificando o nome do arquivo a ser reproduzido:

 % xine -g -p mymovie.avi

   Consulte xine-project.org/faq para mais informac,oes e dicas de soluc,ao
   de problemas.

    7.4.2.3. As Utilidades do Transcode

   O Transcode fornece um conjunto de ferramentas para recodificar arquivos
   de video e audio. O Transcode pode ser usado para mesclar arquivos de
   video ou reparar arquivos quebrados usando ferramentas de linha de comando
   com interfaces de fluxo stdin/stdout.

   No FreeBSD, o Transcode pode ser instalado usando o pacote ou port
   multimedia/transcode. Muitos usuarios preferem compilar o port, pois
   fornece um menu de opc,oes de compilac,ao para especificar o suporte e os
   codecs a serem compilados. Se uma opc,ao nao for selecionada, o Transcode
   nao podera codificar esse formato. Use as setas e a barra de espac,o para
   selecionar os formatos necessarios. Quando terminar, pressione Enter para
   continuar a compilac,ao e instalac,ao do port.

   Este exemplo demonstra como converter um arquivo DivX em um arquivo PAL
   MPEG-1 (PAL VCD):

 % transcode -i input.avi -V --export_prof vcd-pal -o output_vcd
 % mplex -f 1 -o output_vcd.mpg output_vcd.m1v output_vcd.mpa

   O arquivo MPEG resultante, output_vcd.mpg, esta pronto para ser executado
   com o MPlayer. O arquivo pode ser gravado em uma midia (CD), para criar um
   CD de video usando um utilitario como multimedia/vcdimager ou
   sysutils/cdrdao.

   Alem da pagina de manual do transcode, consulte
   transcoding.org/cgi-bin/transcode para mais informac,oes e exemplos.

7.5. Placas de TV

   Contribuic,ao original por Josef El-Rayes.
   Aprimorado e adaptado por Marc Fonvieille.

   As placas de TV podem ser usadas para assistir `a transmissao ou `a TV a
   cabo em um computador. A maioria das placas aceitam video composto por
   meio de uma entrada RCA ou S-video e algumas placas incluem um
   sintonizador de radio FM.

   O FreeBSD fornece suporte para placas de TV baseadas em PCI usando um chip
   de captura de video Brooktree Bt848/849/878/879 com o driver bktr(4). Este
   driver suporta a maioria das placas de video Pinnacle PCTV. Antes de
   comprar uma placa de TV, consulte bktr(4) para obter uma lista dos
   sintonizadores suportados.

  7.5.1. Carregando o Driver

   Para usar a placa, o driver bktr(4) deve ser carregado. Para automatizar
   isso no momento da inicializac,ao, adicione a seguinte linha ao arquivo
   /boot/loader.conf:

 bktr_load="YES"

   Como alternativa, pode-se compilar estaticamente o suporte para a placa de
   TV em um kernel personalizado. Nesse caso, adicione as seguintes linhas ao
   arquivo de configurac,ao do kernel personalizado:

 device   bktr
 device  iicbus
 device  iicbb
 device  smbus

   Esses dispositivos adicionais sao necessarios, pois os componentes da
   placa sao interconectados por meio de um barramento I2C. Em seguida, crie
   e instale um novo kernel.

   Para testar se o sintonizador foi detectado corretamente, reinicialize o
   sistema. A placa de TV deve aparecer nas mensagens de inicializac,ao,
   conforme mostrado neste exemplo:

 bktr0: <BrookTree 848A> mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
 iicbb0: <I2C bit-banging driver> on bti2c0
 iicbus0: <Philips I2C bus> on iicbb0 master-only
 iicbus1: <Philips I2C bus> on iicbb0 master-only
 smbus0: <System Management Bus> on bti2c0
 bktr0: Pinnacle/Miro TV, Philips SECAM tuner.

   As mensagens serao diferentes de acordo com o hardware. Se necessario, e
   possivel substituir alguns dos parametros detectados usando sysctl(8) ou
   opc,oes de configurac,ao de kernel personalizadas. Por exemplo, para
   forc,ar o sintonizador a usar um sintonizador SECAM da Philips, adicione a
   seguinte linha a um arquivo de configurac,ao de kernel personalizado:

 options OVERRIDE_TUNER=6

   ou, use sysctl(8):

 # sysctl hw.bt848.tuner=6

   Consulte bktr(4) para obter uma descric,ao disponivel dos parametros do
   sysctl(8) e opc,oes do kernel.

  7.5.2. Aplicac,oes Uteis

   Para usar a placa de TV, instale um dos seguintes aplicativos:

     * multimedia/fxtv oferece recursos de captura de imagem/audio/video numa
       transmissao de TV no monitor do computador.

     * O multimedia/xawtv e outro aplicativo de TV com recursos semelhantes.

     * O audio/xmradio fornece uma aplicac,ao para usar o sintonizador de
       radio FM de uma placa de TV.

   Mais aplicac,oes estao disponiveis na Colec,ao de Ports do FreeBSD.

  7.5.3. Soluc,ao de problemas

   Se forem encontrados problemas com a placa de TV, verifique se o chip de
   captura de video e o sintonizador sao compativeis com bktr(4) e que as
   opc,oes corretas de configurac,ao foram usadas. Para obter mais suporte ou
   para fazer perguntas sobre as placas de TV suportadas, consulte a lista de
   discussao freebsd-multimedia.

7.6. MythTV

   MythTV e um popular aplicativo de gravac,ao de video pessoal (PVR). Esta
   sec,ao demonstra como instalar e configurar o MythTV no FreeBSD. Consulte
   mythtv.org/wiki para mais informac,oes sobre como usar o MythTV.

   MythTV requer um frontend e um backend. Esses componentes podem ser
   instalados no mesmo sistema ou em maquinas diferentes.

   O frontend pode ser instalado no FreeBSD usando o pacote ou port
   multimedia/mythtv-frontend. O Xorg tambem deve ser instalado e configurado
   conforme descrito em Capitulo 5, O sistema X Window. Idealmente, este
   sistema tem uma placa de video que suporta Compensac,ao de Movimento de
   X-Video (XvMC) e, opcionalmente, um controle remoto compativel com o
   Controle Remoto Infravermelho do Linux (LIRC).

   Para instalar o backend e o frontend no FreeBSD, use o pacote ou port
   multimedia/mythtv. Um servidor de banco de dados MySQL(TM) tambem e
   necessario e deve ser instalado automaticamente como uma dependencia.
   Opcionalmente, este sistema deve ter uma placa sintonizadora e
   armazenamento suficiente para armazenar os dados gravados.

  7.6.1. Hardware

   O MythTV usa o Video for Linux (V4L) para acessar dispositivos de entrada
   de video, como codificadores e sintonizadores. No FreeBSD, o MythTV
   funciona melhor com placas USB DVB-S/C/T, pois sao bem suportadas pelo
   pacote multimedia/webcamd ou pelo port que fornec,a uma aplicac,ao V4L
   userland. Qualquer placa de transmissao de video digital (DVB) suportada
   pelo webcamd deve funcionar com o MythTV. Uma lista de placas suportadas
   conhecidas pode ser encontrada em wiki.freebsd.org/WebcamCompat. Drivers
   tambem estao disponiveis para placas Hauppauge nos ports multimedia/pvr250
   e multimedia/pvrxxx, mas eles fornecem uma interface de driver nao
   padronizados que nao funcionam com versoes do MythTV posteriores `a 0.23.
   Devido a restric,oes de licenciamento, nenhum pacote esta disponivel e
   esses dois ports devem ser compilados.

   A pagina wiki.freebsd.org/HTPC contem uma lista de todos os drivers DVB
   disponiveis.

  7.6.2. Configurando o Backend MythTV

   Para instalar o MythTV usando pacotes binarios:

 # pkg install mythtv

   Como alternativa, para instalar a partir da Colec,ao de Ports:

 # cd /usr/ports/multimedia/mythtv
 # make install

   Uma vez instalado, configure o banco de dados do MythTV:

 # mysql -uroot -p < /usr/local/share/mythtv/database/mc.sql

   Em seguida, configure o backend:

 # mythtv-setup

   Finalmente, inicie o backend:

 # sysrc mythbackend_enable=yes
 # service mythbackend start

7.7. Scanners de Imagem

   Escrito por Marc Fonvieille.

   No FreeBSD, o acesso aos scanners de imagens e fornecido pelo SANE
   (Scanner Access Now Easy), que esta disponivel na Colec,ao de Ports do
   FreeBSD. O SANE tambem usara alguns drivers de dispositivos do FreeBSD
   para fornecer acesso ao hardware do scanner.

   O FreeBSD suporta os scanners SCSI e USB. Dependendo da interface do
   scanner, sao necessarios drivers de dispositivos diferentes. Certifique-se
   de que o scanner seja suportado pelo SANE antes de executar qualquer
   configurac,ao. Consulte
   http://www.sane-project.org/sane-supported-devices.html para obter mais
   informac,oes sobre os scanners suportados.

   Este capitulo descreve como determinar se o scanner foi detectado pelo
   FreeBSD. Em seguida, ele fornece uma visao geral de como configurar e usar
   o SANE em um sistema FreeBSD.

  7.7.1. Verificando o Scanner

   O kernel GENERIC inclui os drivers de dispositivos necessarios para
   suportar scanners USB. Usuarios com um kernel personalizado devem garantir
   que as seguintes linhas estejam presentes no arquivo de configurac,ao do
   kernel personalizado:

 device usb
 device uhci
 device ohci
 device ehci

   Para verificar se o scanner USB foi detectado, conecte-o e execute o
   comando dmesg, sendo entao possivel ver se o scanner aparece no buffer de
   mensagens do sistema. Em caso afirmativo, deve ser exibida uma mensagem
   semelhante a esta:

 ugen0.2: <EPSON> at usbus0

   Neste exemplo, um scanner EPSON Perfection(R) 1650 USB foi detectado em
   /dev/ugen0.2.

   Se o scanner usar uma interface SCSI, e importante saber qual placa
   controladora SCSI sera usada. Dependendo do chipset SCSI, um arquivo de
   configurac,ao do kernel personalizado pode ser necessario. O kernel
   GENERIC suporta os controladores SCSI mais comuns. Consulte
   /usr/src/sys/conf/NOTES para determinar a linha correta a ser adicionada a
   um arquivo de configurac,ao de kernel personalizado. Alem do driver de
   adaptador SCSI, as seguintes linhas sao necessarias em um arquivo de
   configurac,ao de kernel personalizado:

 device scbus
 device pass

   Verifique se o dispositivo e exibido no buffer de mensagens do sistema:

 pass2 at aic0 bus 0 target 2 lun 0
 pass2: <AGFA SNAPSCAN 600 1.10> Fixed Scanner SCSI-2 device
 pass2: 3.300MB/s transfers

   Se o scanner nao foi ligado na inicializac,ao do sistema, ainda e possivel
   forc,ar manualmente a detecc,ao executando uma varredura de barramento
   SCSI com o comando camcontrol:

 # camcontrol rescan all
 Re-scan of bus 0 was successful
 Re-scan of bus 1 was successful
 Re-scan of bus 2 was successful
 Re-scan of bus 3 was successful

   O scanner deve agora aparecer na lista de dispositivos SCSI:

 # camcontrol devlist
 <IBM DDRS-34560 S97B>              at scbus0 target 5 lun 0 (pass0,da0)
 <IBM DDRS-34560 S97B>              at scbus0 target 6 lun 0 (pass1,da1)
 <AGFA SNAPSCAN 600 1.10>           at scbus1 target 2 lun 0 (pass3)
 <PHILIPS CDD3610 CD-R/RW 1.00>     at scbus2 target 0 lun 0 (pass2,cd0)

   Consulte scsi(4) e camcontrol(8) para mais detalhes sobre dispositivos
   SCSI no FreeBSD.

  7.7.2. Configurac,ao do SANE

   O SANE possui um sistema dividido em duas partes: os backends
   (graphics/sane-backends) e os frontends (graphics/sane-frontends ou
   graphics/xsane). Os backends fornecem acesso ao scanner. Consulte
   http://www.sane-project.org/sane-supported-devices.html para determinar
   qual backend suporta o scanner. Os frontends fornecem a interface de
   varredura grafica. graphics/sane-frontends instala o xscanimage enquanto o
   graphics/xsane instala o xsane.

   Para instalar as duas partes de pacotes binarios:

 # pkg install xsane sane-frontends

   Alternativamente, para instalar a partir da Colec,ao de Ports

 # cd /usr/ports/graphics/sane-frontends
 # make install clean
 # cd /usr/ports/graphics/xsane
 # make install clean

   Depois de instalar o pacote ou port graphics/sane-backends, use o comando
   sane-find-scanner para verificar a detecc,ao do scanner pelo sistema SANE:

 # sane-find-scanner -q
 found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/pass3

   A saida deve mostrar o tipo de interface do scanner e o no do dispositivo
   usado para conectar o scanner ao sistema. O fornecedor e o modelo do
   produto podem ou nao aparecer.

  Nota:

   Alguns scanners USB exigem que o firmware seja carregado. Consulte
   sane-find-scanner(1) e sane(7) para mais detalhes.

   Em seguida, verifique se o scanner sera identificado por uma interface de
   digitalizac,ao. Os backends SANE incluem o comando scanimage, que pode ser
   usado para listar os dispositivos e realizar uma aquisic,ao de imagens.
   Use a opc,ao -L para listar os dispositivos do scanner. O primeiro exemplo
   e para um scanner SCSI e o segundo e para um scanner USB:

 # scanimage -L
 device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed scanner
 # scanimage -L
 device 'epson2:libusb:/dev/usb:/dev/ugen0.2' is a Epson GT-8200 flatbed scanner

   Neste segundo exemplo, 'epson2: libusb:/dev/usb:/dev/ugen0.2' e o nome do
   backend (epson2) e /dev/ugen0.2 e o no do dispositivo usado pelo scanner.

   Se o comando scanimage nao conseguir identificar o scanner, esta mensagem
   sera exibida:

 # scanimage -L

 No scanners were identified. If you were expecting something different,
 check that the scanner is plugged in, turned on and detected by the
 sane-find-scanner tool (if appropriate). Please read the documentation
 which came with this software (README, FAQ, manpages).

   Se isso acontecer, edite o arquivo de configurac,ao de backend em
   /usr/local/etc/sane.d/ e defina o dispositivo de scanner usado. Por
   exemplo, se o modelo de scanner nao detectado for um EPSON Perfection(R)
   1650 e usar o backend epson2, edite o arquivo /usr/
   local/etc/sane.d/epson2.conf. Ao editar, adicione uma linha especificando
   a interface e o no do dispositivo usado. Nesse caso, adicione a seguinte
   linha:

 usb /dev/ugen0.2

   Salve as edic,oes e verifique se o scanner esta identificado com o nome do
   back-end correto e com o no do dispositivo:

 # scanimage -L
 device 'epson2:libusb:/dev/usb:/dev/ugen0.2' is a Epson GT-8200 flatbed scanner

   Depois que o comando scanimage -L identificar o scanner, a configurac,ao
   estara completa e o scanner estara pronto para ser usado.

   Embora o scanimage possa ser usado para realizar uma digitalizac,ao de
   imagem a partir da linha de comando, muitas vezes e preferivel usar uma
   interface grafica para executar o escaneamento. O pacote ou port
   graphics/sane-frontends instala uma interface grafica simples, mas
   eficiente, xscanimage.

   Alternativamente, o xsane, que e instalado com o pacote ou port
   graphics/xsane, e outro frontend de digitalizac,ao grafica popular. Ele
   oferece recursos avanc,ados, como varios modos de digitalizac,ao,
   correc,ao de cores e digitalizac,oes em lote. Ambos os aplicativos sao
   utilizaveis como um plugin do GIMP.

  7.7.3. Permissoes do Scanner

   Para ter acesso ao scanner, o usuario precisa ler e gravar as permissoes
   no no do dispositivo usado pelo scanner. No exemplo anterior, o scanner
   USB usa o no do dispositivo /dev/ugen0.2 que e realmente um link simbolico
   para o no do dispositivo real /dev/usb/0.2.0. O link simbolico e o no do
   dispositivo pertencem, respectivamente, aos grupos wheel e operator.
   Adicionando o usuario a esses grupos, sera permitido o acesso ao scanner,
   considera-se inseguro adicionar um usuario a wheel. Uma soluc,ao melhor e
   criar um grupo e tornar o dispositivo de scanner acessivel aos membros
   desse grupo.

   Este exemplo cria um grupo chamado usb:

 # pw groupadd usb

   Entao, crie um link simbolico para /dev/ugen0.2 e o no do dispositivo
   /dev/usb/0.2.0 para ficarem acessiveis ao grupo usb com permissoes de
   gravac,ao 0660 ou 0664 adicionando as seguintes linhas ao
   /etc/devfs.rules:

 [system=5]
 add path ugen0.2 mode 0660 group usb
 add path usb/0.2.0 mode 0666 group usb

   Finalmente, adicione os usuarios a usb para permitir acesso ao scanner:

 # pw groupmod usb -m joe

   Para mais detalhes, consulte pw(8).

Capitulo 8. Configurando o kernel do FreeBSD

   Indice

   8.1. Sinopse

   8.2. Por que compilar um kernel personalizado?

   8.3. Encontrando o hardware do sistema

   8.4. O Arquivo de Configurac,ao

   8.5. Criando e Instalando um Kernel Customizado

   8.6. Se algo der errado

8.1. Sinopse

   O kernel e o nucleo do sistema operacional do FreeBSD. Ele e responsavel
   pelo gerenciamento de memoria, aplicac,ao de controles de seguranc,a,
   rede, acesso ao disco e muito mais. Embora grande parte do FreeBSD seja
   configuravel dinamicamente, ainda e necessario configurar e compilar um
   kernel personalizado ocasionalmente.

   Depois de ler este capitulo, voce sabera:

     * Quando compilar um kernel personalizado.

     * Como obter um inventario do hardware.

     * Como personalizar um arquivo de configurac,ao do kernel.

     * Como usar o arquivo de configurac,ao do kernel para criar e compilar
       um novo kernel.

     * Como instalar o novo kernel.

     * Como solucionar problemas se as coisas derem errado.

   Todos os comandos listados nos exemplos deste capitulo devem ser
   executados como root.

8.2. Por que compilar um kernel personalizado?

   Tradicionalmente, o FreeBSD usava um kernel monolitico. O kernel era um
   grande programa, suportava uma lista fixa de dispositivos e, para mudar o
   comportamento do kernel, era preciso compilar e depois reinicializar em um
   novo kernel.

   Hoje, a maior parte da funcionalidade do kernel do FreeBSD esta contida em
   modulos que podem ser dinamicamente carregados e descarregados do kernel,
   conforme necessario. Isso permite que o kernel em execuc,ao se adapte
   imediatamente ao novo hardware e que novas funcionalidades sejam trazidas
   para o kernel. Isso e conhecido como um kernel modular.

   Ocasionalmente, ainda e necessario executar a configurac,ao do kernel
   estatico. As vezes, a funcionalidade necessaria e tao ligada ao kernel que
   nao pode ser carregada dinamicamente. Alguns ambientes de seguranc,a
   impedem o carregamento e descarregamento de modulos do kernel e exigem que
   apenas a funcionalidade necessaria seja estaticamente compilada no kernel.

   Construir um kernel personalizado e muitas vezes um rito de passagem para
   usuarios avanc,ados do BSD. Este processo, embora consuma tempo, pode
   fornecer beneficios ao sistema FreeBSD. Ao contrario do kernel GENERIC,
   que deve suportar uma ampla gama de hardware, um kernel personalizado pode
   ser reduzido para fornecer suporte apenas para o hardware desse
   computador. Isso tem varios beneficios, tais como:

     * Tempo de inicializac,ao mais rapido. Uma vez que o kernel ira
       verificar apenas o hardware existente no sistema, o tempo que o
       sistema leva para inicializar pode diminuir.

     * Diminuir o uso de memoria. Um kernel personalizado geralmente usa
       menos memoria que o kernel GENERIC ao omitir recursos e drivers de
       dispositivo que nao sao utilizados. Isso e importante porque o codigo
       do kernel permanece residente na memoria fisica o tempo todo,
       impedindo que a memoria seja usada pelos aplicativos. Por esse motivo,
       um kernel personalizado e util em um sistema com uma pequena
       quantidade de RAM.

     * Suporte adicional de hardware. Um kernel personalizado pode adicionar
       suporte para dispositivos que nao estao presentes no kernel GENERIC.

   Antes de criar um kernel personalizado, considere a razao para isso. Se
   houver necessidade de suporte para um hardware especifico, ele ja pode
   existir como um modulo.

   Os modulos do kernel existem em /boot/kernel e podem ser dinamicamente
   carregados no kernel em execuc,ao usando o kldload(8). A maioria dos
   drivers do kernel tem um modulo carregavel e uma pagina de manual. Por
   exemplo, o driver Ethernet sem fio ath(4) tem as seguintes informac,oes em
   sua pagina de manual:

 Como alternativa, para carregar o driver como um modulo no momento da inicializac,ao, coloque o a seguinte linha no loader.conf(5):

     if_ath_load="YES"

   Adicionar if_ath_load="YES" ao /boot/loader.conf carregara este modulo
   dinamicamente no momento da inicializac,ao.

   Em alguns casos, nao ha nenhum modulo associado em /boot/kernel. Isso e
   verdade principalmente para certos subsistemas.

8.3. Encontrando o hardware do sistema

   Antes de editar o arquivo de configurac,ao do kernel, e recomendavel
   realizar um inventario do hardware da maquina. Em um sistema de
   inicializac,ao dupla, o inventario pode ser criado a partir do outro
   sistema operacional. Por exemplo, o Device Manager da Microsoft(R) contem
   informac,oes sobre os dispositivos instalados.

  Nota:

   Algumas versoes do Microsoft (R) Windows(R) tem um icone System que pode
   ser usado para acessar o Device Manager.

   Se o FreeBSD for o unico sistema operacional instalado, use o dmesg(8)
   para determinar o hardware que foi encontrado e listado durante a
   verificac,ao de inicializac,ao. A maioria dos drivers de dispositivos no
   FreeBSD tem uma pagina de manual que lista o hardware suportado pelo
   driver. Por exemplo, as seguintes linhas indicam que o driver psm(4)
   encontrou um mouse:

 psm0: <PS/2 Mouse> irq 12 on atkbdc0
 psm0: [GIANT-LOCKED]
 psm0: [ITHREAD]
 psm0: model Generic PS/2 mouse, device ID 0

   Como esse hardware existe, esse driver nao deve ser removido de um arquivo
   de configurac,ao de kernel personalizado.

   Se a saida do dmesg nao exibir os resultados da saida da verificac,ao de
   inicializac,ao, leia o conteudo do /var/run/dmesg.boot.

   Outra ferramenta para encontrar hardware e o pciconf(8), que fornece uma
   saida mais detalhada. Por exemplo:

 % pciconf -lv
 ath0@pci0:3:0:0:        class=0x020000 card=0x058a1014 chip=0x1014168c rev=0x01 hdr=0x00
     vendor     = 'Atheros Communications Inc.'
     device     = 'AR5212 Atheros AR5212 802.11abg wireless'
     class      = network
     subclass   = ethernet

   Esta saida mostra que o driver ath localizou um dispositivo Ethernet sem
   fio.

   O sinalizador -k do man(1) pode ser usado para fornecer informac,oes
   uteis. Por exemplo, ele pode ser usado para exibir uma lista de paginas de
   manual que contem uma marca ou um nome de dispositivo especifico:

 # man -k Atheros
 ath(4)                   - Atheros IEEE 802.11 wireless network driver
 ath_hal(4)               - Atheros Hardware Access Layer (HAL)

   Depois que a lista de inventario de hardware for criada, consulte-a para
   garantir que os drivers para o hardware instalado nao sejam removidos `a
   medida que a configurac,ao do kernel personalizado e editada.

8.4. O Arquivo de Configurac,ao

   Para criar um arquivo de configurac,ao do kernel personalizado e compilar
   um kernel personalizado, a arvore de codigo-fonte completa do FreeBSD deve
   ser instalada primeira.

   Se o /usr/src/ nao existir ou estiver vazio, o codigo-fonte nao foi
   instalado. O fonte pode ser instalado usando o Subversion e as instruc,oes
   em Sec,ao A.3, "Usando o Subversion".

   Depois que o codigo-fonte for instalado, revise o conteudo do
   /usr/src/sys. Este diretorio contem varios subdiretorios, incluindo
   aqueles que representam as seguintes arquiteturas suportadas: amd64, i386,
   powerpc e sparc64. Tudo dentro do diretorio de uma arquitetura em
   particular lida apenas com essa arquitetura e o restante do codigo e
   codigo independente de maquina comum a todas as plataformas. Cada
   arquitetura suportada tem um subdiretorio conf que contem o arquivo de
   configurac,ao do kernel GENERIC para essa arquitetura.

   Nao fac,a edic,oes no GENERIC. Em vez disso, copie o arquivo para um nome
   diferente e fac,a edic,oes na copia. A convenc,ao e usar um nome do host
   com todas as letras maiusculas. Ao manter varias maquinas FreeBSD com
   hardware diferente, e uma boa ideia nomea-lo com o nome do host da
   maquina. Este exemplo cria uma copia, denominada MYKERNEL, do arquivo de
   configurac,ao GENERIC para a arquitetura amd64:

 # cd /usr/src/sys/amd64/conf
 # cp GENERIC MYKERNEL

   O MYKERNEL agora pode ser personalizado com qualquer editor de texto
   ASCII. O editor padrao e o vi, embora um editor mais facil para
   iniciantes, chamado ee, tambem seja instalado com o FreeBSD.

   O formato do arquivo de configurac,ao do kernel e simples. Cada linha
   contem uma palavra-chave que representa um dispositivo ou subsistema, um
   argumento e uma breve descric,ao. Qualquer texto depois de um # e
   considerado um comentario e ignorado. Para remover o suporte do kernel
   para um dispositivo ou subsistema, coloque um # no inicio da linha que
   representa esse dispositivo ou subsistema. Nao adicione ou remova um #
   para qualquer linha que voce nao entenda.

  Atenc,ao:

   E facil remover o suporte para um dispositivo ou opc,ao e acabar com um
   kernel quebrado. Por exemplo, se o driver ata(4) for removido do arquivo
   de configurac,ao do kernel, um sistema usando os drivers de disco ATA pode
   nao inicializar. Em caso de duvida, basta deixar o suporte no kernel.

   Alem das breves descric,oes fornecidas neste arquivo, descric,oes
   adicionais estao contidas no arquivo NOTES, o qual pode ser encontrado no
   mesmo diretorio que o GENERIC para aquela arquitetura. Para opc,oes
   independentes de arquitetura, consulte /usr/src/sys/conf/NOTES.

  Dica:

   Quando terminar de personalizar o arquivo de configurac,ao do kernel,
   salve uma copia de backup em um local fora do /usr/src.

   Como alternativa, mantenha o arquivo de configurac,ao do kernel em outro
   lugar e crie um link simbolico para o arquivo:

 # cd /usr/src/sys/amd64/conf
 # mkdir /root/kernels
 # cp GENERIC /root/kernels/MYKERNEL
 # ln -s /root/kernels/MYKERNEL

   Uma diretiva include esta disponivel para uso em arquivos de
   configurac,ao. Isso permite que outro arquivo de configurac,ao seja
   incluido no arquivo atual, facilitando a manutenc,ao de pequenas
   alterac,oes em relac,ao a um arquivo existente. Se apenas um pequeno
   numero de opc,oes ou drivers adicionais forem necessarios, isso permitira
   que um delta seja mantido com relac,ao ao GENERIC, conforme mostrado neste
   exemplo:

 include GENERIC
 ident MYKERNEL

 options         IPFIREWALL
 options         DUMMYNET
 options         IPFIREWALL_DEFAULT_TO_ACCEPT
 options         IPDIVER

   Usando este metodo, o arquivo de configurac,ao local expressa as
   diferenc,as locais em relac,ao ao kernel GENERIC. Conforme as
   atualizac,oes sao realizadas, os novos recursos adicionados ao GENERIC
   tambem serao adicionados ao kernel local, a menos que sejam
   especificamente evitados usando nooptions ou nodevice. Uma lista
   abrangente de diretivas de configurac,ao e suas descric,oes pode ser
   encontrada em config(5).

  Nota:

   Para compilar um arquivo que contem todas as opc,oes disponiveis, execute
   o seguinte comando como root:

 # cd /usr/src/sys/arch/conf && make LINT

8.5. Criando e Instalando um Kernel Customizado

   Depois que as edic,oes no arquivo de configurac,ao personalizada forem
   salvas, o codigo-fonte do kernel podera ser compilado usando as seguintes
   etapas:

   Procedimento 8.1. Compilando um Kernel
    1. Mude para este diretorio:

 # cd /usr/src

    2. Compile o novo kernel especificando o nome do arquivo de configurac,ao
       do kernel personalizado:

 # make buildkernel KERNCONF=MYKERNEL

    3. Instale o novo kernel associado ao arquivo de configurac,ao do kernel
       especificado. Este comando ira copiar o novo kernel para
       /boot/kernel/kernel e salvar o kernel antigo para
       /boot/kernel.old/kernel:

 # make installkernel KERNCONF=MYKERNEL

    4. Desligue o sistema e reinicie no novo kernel. Se algo der errado,
       consulte O kernel nao inicializa.

   Por padrao, quando um kernel personalizado e compilado, todos os modulos
   do kernel sao reconstruidos. Para atualizar um kernel mais rapidamente ou
   para construir apenas modulos customizados, edite o /etc/make.conf antes
   de comec,ar a construir o kernel.

   Por exemplo, esta variavel especifica a lista de modulos para compilar em
   vez de usar o padrao de construir todos os modulos:

 MODULES_OVERRIDE = linux acpi

   Como alternativa, essa variavel lista quais modulos excluir do processo de
   criac,ao:

 WITHOUT_MODULES = linux acpi sound

   Variaveis adicionais estao disponiveis. Consulte make.conf(5) para
   detalhes.

8.6. Se algo der errado

   Existem quatro categorias de problemas que podem ocorrer ao criar um
   kernel personalizado:

   falhas na config

           Se o config falhar, ele imprimira o numero da linha que esta
           incorreta. Como exemplo, para a seguinte mensagem, certifique-se
           de que a linha 17 seja digitada corretamente, comparando-a com
           GENERIC ou NOTES:

 config: line 17: syntax error

   falha no make

           Se o make falhar, geralmente e devido a um erro no arquivo de
           configurac,ao do kernel que nao e grave o suficiente para o config
           capturar. Revise a configurac,ao, e se o problema nao for
           aparente, envie um email para a lista de discussao de questoes
           gerais do FreeBSD contendo o arquivo de configurac,ao do kernel.

   O kernel nao inicializa

           Se o novo kernel nao inicializar ou nao reconhecer os
           dispositivos, nao entre em panico! Felizmente, o FreeBSD possui um
           excelente mecanismo para recuperac,ao de kernels incompativeis.
           Simplesmente escolha o kernel para inicializar a partir do
           gerenciador de inicializac,ao do FreeBSD. Isso pode ser acessado
           quando o menu de inicializac,ao do sistema aparecer, selecionando
           a opc,ao "Escape to a loader prompt". No prompt, digite boot
           kernel.old ou o nome de qualquer outro kernel que seja conhecido
           por inicializar corretamente.

           Apos inicializar com um kernel correto, verifique o arquivo de
           configurac,ao e tente construi-lo novamente. Um recurso util e o
           /var/log/messages que registra as mensagens do kernel de cada
           inicializac,ao bem-sucedida. Alem disso, o dmesg(8) imprimira as
           mensagens do kernel a partir da inicializac,ao atual.

  Nota:

           Ao solucionar problemas de um kernel, certifique-se de manter uma
           copia do GENERIC, ou algum outro kernel que funcione, como um nome
           diferente que nao sera apagado na proxima compilac,ao. Isto e
           importante porque toda vez que um novo kernel e instalado, o
           kernel.old e sobrescrito com o ultimo kernel instalado, que pode
           ou nao ser inicializavel. Assim que possivel, mova o kernel
           funcional renomeando o diretorio que contem o kernel correto:

 # mv /boot/kernel /boot/kernel.bad
 # mv /boot/kernel.good /boot/kernel

   O kernel funciona, mas o ps(1) nao

           Se a versao do kernel for diferente daquela com a qual os
           utilitarios do sistema foram construidos, por exemplo, um kernel
           compilado a partir do codigo-fonte do -CURRENT e instalado em um
           sistema -RELEASE, muitos comandos de status do sistema como ps(1)
           e vmstat(8) nao funcionarao. Para corrigir isso, recompile e
           instale o world usando a mesma versao da arvore de codigo-fonte
           que o kernel. Nunca e uma boa ideia usar uma versao diferente do
           kernel do que o resto do sistema operacional.

Capitulo 9. Impressao

   Originalmente contribuido por Warren Block.
   Indice

   9.1. Inicio Rapido

   9.2. Conexoes de Impressora

   9.3. Linguagens de Descric,ao de Pagina Comuns

   9.4. Impressao Direta

   9.5. LPD (Daemon de impressora de linha)

   9.6. Outros sistemas de impressao

   Colocar informac,oes no papel e uma func,ao vital, apesar de muitas
   tentativas de elimina-la. A impressao tem dois componentes basicos. Os
   dados devem ser entregues `a impressora e devem estar em um formato que a
   impressora possa entender.

9.1. Inicio Rapido

   A impressao basica pode ser configurada rapidamente. A impressora deve ser
   capaz de imprimir texto simples ASCII. Para imprimir em outros tipos de
   arquivos, consulte Sec,ao 9.5.3, "Filtros".

    1. Crie um diretorio para armazenar arquivos enquanto eles estao sendo
       impressos:

 # mkdir -p /var/spool/lpd/lp
 # chown daemon:daemon /var/spool/lpd/lp
 # chmod 770 /var/spool/lpd/lp

    2. Como root, crie /etc/printcap com estes conteudos:

 lp:\
         :lp=/dev/unlpt0:\  1
         :sh:\
         :mx#0:\
         :sd=/var/spool/lpd/lp:\
         :lf=/var/log/lpd-errs:

       1 Esta linha e para uma impressora conectada a uma porta USB.          
                                                                              
         Para uma impressora conectada a uma porta paralela ou uma porta de   
         "impressora", use:                                                   
                                                                              
         :lp=/dev/lpt0:\                                                      
                                                                              
         Para uma impressora conectada diretamente a uma rede, use:           
                                                                              
         :lp=:rm=network-printer-name:rp=raw:\                                
                                                                              
         Substitua network-printer-name pelo nome de host DNS da impressora   
         de rede.                                                             

    3. Ative o lpd editando o /etc/rc.conf, adicionando esta linha:

 lpd_enable="YES"

       Inicie o servic,o:

 # service lpd start
 Starting lpd.

    4. Imprima um teste:

 # printf "1. This printer can print.\n2. This is the second line.\n" | lpr

  Dica:

       Se ambas as linhas nao iniciarem na borda esquerda, mas em "degrau",
       consulte Sec,ao 9.5.3.1, "Impedindo degraus em impressoras de texto
       simples".

       Arquivos de texto agora podem ser impressos com lpr. De o nome do
       arquivo na linha de comando ou canalize a saida diretamente no lpr.

 % lpr textfile.txt
 % ls -lh | lpr

9.2. Conexoes de Impressora

   As impressoras sao conectadas a sistemas de computadores de varias
   maneiras. Geralmente, as impressoras desktop pequenas sao conectadas
   diretamente `a porta USB do computador. As impressoras mais antigas sao
   conectadas a uma porta paralela ou a porta de "impressora". Algumas
   impressoras estao diretamente conectadas a uma rede, facilitando o
   compartilhamento com varios computadores. Algumas impressoras usam uma
   rara conexao de porta serial.

   O FreeBSD pode se comunicar com todos esses tipos de impressoras.

   USB

           As impressoras USB podem ser conectadas a qualquer porta USB
           disponivel no computador.

           Quando o FreeBSD detecta uma impressora USB, duas entradas de
           dispositivos sao criadas: /dev/ulpt0 e /dev/unlpt0. Os dados
           enviados para qualquer dispositivo serao retransmitidos para a
           impressora. Apos cada trabalho de impressao, o ulpt0 reseta a
           porta USB. O reset da porta pode causar problemas em algumas
           impressoras, portanto, o dispositivo unlpt0 e normalmente usado em
           seu lugar. O unlpt0 nao reseta a porta USB.

   Paralela (IEEE-1284)

           O dispositivo da porta paralela e o /dev/lpt0. Este dispositivo
           aparece independentemente se uma impressora esta ou nao conectada,
           ela nao e autodetectada.

           A maior parte dos fabricantes se afastou destas portas "legadas" e
           muitos computadores nao as tem mais. Adaptadores podem ser usados
           para conectar uma impressora paralela a uma porta USB. Com este
           tipo de adaptador, a impressora pode ser tratada como se fosse uma
           impressora USB. Dispositivos chamados servidores de impressao
           tambem podem ser usados para conectar impressoras paralelas
           diretamente a uma rede.

   Serial (RS-232)

           Portas seriais sao outro tipo de porta legada, raramente usada
           para impressoras, exceto em determinadas aplicac,oes de nicho. Os
           cabos, os conectores e a fiac,ao necessaria variam muito.

           Para portas seriais incorporadas em uma placa-mae, o nome do
           dispositivo serial e /dev/cuau0 ou /dev/cuau1. Os adaptadores
           Seriais USB tambem podem ser usados, e eles aparecerao como
           /dev/cuaU0.

           Varios parametros de comunicac,ao devem ser conhecidos para se
           comunicar com uma impressora serial. Os mais importantes sao baud
           rate ou BPS (Bits por segundo) e paridade. Os valores variam, mas
           as impressoras seriais tipicas usam uma taxa de transmissao de
           9600 e nenhuma paridade.

   Rede

           As impressoras de rede estao conectadas diretamente `a rede de
           computadores local.

           O nome de host DNS da impressora deve ser conhecido. Se a
           impressora tiver um enderec,o dinamico atribuido por DHCP, o DNS
           devera ser atualizado dinamicamente para que o nome do host tenha
           sempre o enderec,o IP correto. As impressoras de rede geralmente
           recebem enderec,os IP estaticos para evitar esse problema.

           A maioria das impressoras de rede entende os trabalhos de
           impressao enviados com o protocolo LPD. Um nome de fila de
           impressao tambem pode ser especificado. Algumas impressoras
           processam dados de maneira diferente, dependendo de qual fila e
           usada. Por exemplo, uma fila raw imprime os dados inalterados,
           enquanto a fila text adiciona retornos de carro aos textos
           simples.

           Muitas impressoras de rede tambem podem imprimir dados enviados
           diretamente para a porta 9100.

  9.2.1. Resumo

   As conexoes de rede com fio geralmente sao as mais faceis de configurar e
   oferecem a impressao mais rapida. Para conexao direta com o computador, a
   conexao USB e preferida em func,ao da velocidade e da simplicidade. As
   conexoes paralelas funcionam, mas tem limitac,oes no comprimento do cabo e
   na velocidade. Conexoes seriais sao mais dificeis de configurar. A
   configurac,ao do cabo difere entre os modelos, e os parametros de
   comunicac,ao, como taxa de transmissao e bits de paridade, se somam a
   complexidade. Felizmente, as impressoras seriais sao raras.

9.3. Linguagens de Descric,ao de Pagina Comuns

   Os dados enviados a uma impressora devem estar em um idioma que a
   impressora possa entender. Esses idiomas sao chamados de Linguagens de
   Descric,ao de Pagina ou PDLs.

   ASCII

           Texto ASCII simples e a maneira mais simples de enviar dados para
           uma impressora. Os caracteres correspondem um a um com o que sera
           impresso: um A nos dados imprime um A na pagina. Muito pouca
           formatac,ao esta disponivel. Nao ha como selecionar uma fonte ou
           espac,amento proporcional. A simplicidade forc,ada do texto ASCII
           simples significa que o texto pode ser impresso diretamente do
           computador com pouca ou nenhuma codificac,ao ou traduc,ao. A saida
           impressa corresponde diretamente ao que foi enviado.

           Algumas impressoras baratas nao conseguem imprimir texto ASCII
           simples. Isso as torna mais dificeis de configurar, mas geralmente
           ainda e possivel faze-lo.

   PostScript(R)

           O PostScript(R) e quase o oposto do ASCII. Em vez de um texto
           simples, um programa PostScript(R) e um conjunto de instruc,oes
           que desenham o documento final. Fontes e graficos diferentes podem
           ser usados. No entanto, esse poder tem um prec,o. O programa que
           desenha a pagina deve ser escrito. Geralmente este programa e
           gerado pelo software aplicativo, portanto, o processo e invisivel
           para o usuario.

           Impressoras baratas `as vezes deixam de fora a compatibilidade com
           o PostScript(R) como uma medida para economia de custos.

   PCL (linguagem de comando de impressora)

           A PCL e uma extensao do ASCII, adicionando sequencias de escape
           para formatac,ao, selec,ao de fontes e impressao de graficos.
           Muitas impressoras fornecem suporte para PCL5. Algumas suportam o
           mais recente PCL6 ou o PCLXL. Essas versoes posteriores sao
           superconjuntos do PCL5 e podem fornecer uma impressao mais rapida.

   Baseado em Host

           Os fabricantes podem reduzir o custo de uma impressora, oferecendo
           um processador simples e muito pouca memoria. Essas impressoras
           nao sao capazes de imprimir texto simples. Em vez disso, bitmaps
           de texto e graficos sao desenhados por um driver no computador
           host e, em seguida, enviados para a impressora. Estas sao chamadas
           de impressoras baseadas em host.

           A comunicac,ao entre o driver e uma impressora baseada em host
           geralmente ocorre por meio de protocolos proprietarios ou nao
           documentados, tornando-os funcionais apenas nos sistemas
           operacionais mais comuns.

  9.3.1. Convertendo PostScript(R) para outros PDLs

   Muitas aplicac,oes da Colec,ao de Ports e muitos utilitarios do FreeBSD
   produzem uma saida em PostScript(R). Esta tabela mostra os utilitarios
   disponiveis para converter o postscript em outros PDLs comuns:

   Tabela 9.1. Saida PDLs

   Saida PDL     Gerado por         Notas                                     
   PCL ou PCL5   print/ghostscript9 -sDEVICE=ljet4 para monocromatico, e      
                                    -sDEVICE=cljet5 para colorido             
   PCLXL ou PCL6 print/ghostscript9 -sDEVICE=pxlmono para monocromatico,      
                                    -sDEVICE=pxlcolor para colorido           
   ESC/P2        print/ghostscript9 -sDEVICE=uniprint                         
   XQX           print/foo2zjs                                                

  9.3.2. Resumo

   Para facilitar a impressao, escolha uma impressora que suporte
   PostScript(R). Impressoras que suportam PCL sao as proximas preferidas.
   Com o print/ghostscript, essas impressoras podem ser usadas como se
   entendessem nativamente PostScript(R). Impressoras que suportam
   PostScript(R) ou PCL diretamente quase sempre suportam a impressao direta
   de arquivos de texto simples ASCII tambem.

   Impressoras baseadas em linha, como as jatos de tinta comuns, geralmente
   nao suportam PostScript(R) ou PCL. Elas geralmente podem imprimir arquivos
   de texto plano ASCII. O print/ghostscript suporta os PDL usados por
   algumas dessas impressoras. Entretanto, a impressao de uma pagina inteira
   baseada em graficos nessas impressoras costuma ser muito lenta devido `a
   grande quantidade de dados a serem transferidos e impressos.

   Geralmente, as impressoras baseadas em host sao mais dificeis de
   configurar. Algumas nao podem ser usadas por causa de PDLs proprietarios.
   Evite essas impressoras quando possivel.

   Descric,oes de muitos PDLs podem ser encontradas em
   http://www.undocprint.org/formats/page_description_languages. O PDL
   especifico usado por varios modelos de impressoras pode ser encontrado em
   http://www.openprinting.org/printers.

9.4. Impressao Direta

   Para impressao ocasional, os arquivos podem ser enviados diretamente para
   um dispositivo de impressora sem qualquer configurac,ao. Por exemplo, um
   arquivo chamado exemplo.txt pode ser enviado para uma impressora USB:

 # cp sample.txt /dev/unlpt0

   A impressao direta para impressoras de rede depende das capacidades da
   impressora, mas a maioria aceita trabalhos de impressao na porta 9100, e o
   nc(1) pode ser usado com eles. Para imprimir o mesmo arquivo em uma
   impressora com o nome de host DNS de netlaser:

 # nc netlaser 9100 < sample.txt

9.5. LPD (Daemon de impressora de linha)

   A impressao de um arquivo em segundo plano e chamada de spooling. Um
   spooler permite que o usuario continue com outros programas no computador
   sem ter de esperar que a impressora conclua lentamente o trabalho de
   impressao.

   O FreeBSD inclui um spooler chamado lpd(8). Os trabalhos de impressao sao
   enviados com o comando lpr(1).

  9.5.1. Configurac,ao inicial

   Um diretorio para armazenar trabalhos de impressao e criado, a propriedade
   e definida e as permissoes sao definidas para impedir que outros usuarios
   visualizem o conteudo desses arquivos:

 # mkdir -p /var/spool/lpd/lp
 # chown daemon:daemon /var/spool/lpd/lp
 # chmod 770 /var/spool/lpd/lp

   As impressoras sao definidas no /etc/printcap. Uma entrada para cada
   impressora inclui detalhes como um nome, a porta onde ela esta conectada e
   varias outras configurac,oes. Crie /etc/printcap com estes conteudos:

 lp:\                            1
         :lp=/dev/unlpt0:\       2
         :sh:\                   3
         :mx#0:\                 4
         :sd=/var/spool/lpd/lp:\ 5
         :lf=/var/log/lpd-errs:  6

   1 O nome desta impressora. O lpr(1) envia trabalhos de impressao para a    
     impressora lp, a menos que outra impressora seja especificada com -P,    
     portanto, a impressora padrao deve ser denominada lp.                    
   2 O dispositivo em que a impressora esta conectada. Substitua esta linha   
     pela apropriada para o tipo de conexao mostrado aqui.                    
                                                                              
     +----------------------------------------------------------------------+ 
     | Tipo de conexao |      Entrada de Dispositivos no /etc/printcap      | 
     |-----------------+----------------------------------------------------| 
     |                 |:lp=/dev/unlpt0:\                                   | 
     |                 |                                                    | 
     | USB             | Este e o dispositivo de impressora USB que nao     | 
     |                 | reseta. Se houver problemas, use o ulpt0, ele      | 
     |                 | reseta a porta USB apos cada uso.                  | 
     |-----------------+----------------------------------------------------| 
     | Paralelo        |:lp=/dev/lpt0:\                                     | 
     |-----------------+----------------------------------------------------| 
     |                 | Para uma impressora que suporta o protocolo LPD:   | 
     |                 |                                                    | 
     |                 |:lp=:rm=network-printer-name:rp=raw:\               | 
     |                 |                                                    | 
     |                 | Para impressoras que suportam impressao na porta   | 
     | Rede            | 9100:                                              | 
     |                 |                                                    | 
     |                 |:lp=9100@network-printer-name:\                     | 
     |                 |                                                    | 
     |                 | Para ambos os tipos, substitua                     | 
     |                 | network-printer-name pelo nome de host DNS da      | 
     |                 | impressora na rede.                                | 
     |-----------------+----------------------------------------------------| 
     |                 |:lp=/dev/cuau0:br=9600:pa=none:\                    | 
     |                 |                                                    | 
     | Serial          | Esses valores sao para uma impressora serial comum | 
     |                 | conectada a uma porta serial da placa-mae. A taxa  | 
     |                 | de transmissao e 9600 e nenhuma paridade e usada.  | 
     +----------------------------------------------------------------------+ 
   3 Suprimir a impressao de uma pagina de cabec,alho no inicio de um         
     trabalho de impressao.                                                   
   4 Nao limite o tamanho maximo de um trabalho de impressao.                 
   5 O caminho para o diretorio de spooling desta impressora. Cada impressora 
     usa seu proprio diretorio de spooling.                                   
   6 O arquivo de log no qual os erros nesta impressora serao relatados.      

   Depois de criar o /etc/printcap, use chkprintcap(8) para testar se ha
   erros:

 # chkprintcap

   Corrija quaisquer problemas relatados antes de continuar.

   Ative o lpd(8) no /etc/rc.conf:

 lpd_enable="YES"

   Inicie o servic,o:

 # service lpd start

  9.5.2. Imprimindo com o lpr(1)

   Os documentos sao enviados para a impressora com o lpr. Um arquivo a ser
   impresso pode ser nomeado na linha de comando ou canalizado para o lpr.
   Esses dois comandos sao equivalentes, enviando o conteudo de doc.txt para
   a impressora padrao:

 % lpr doc.txt
 % cat doc.txt | lpr

   Impressoras podem ser selecionadas com -P. Para imprimir em uma impressora
   chamada laser:

 % lpr -Plaser doc.txt

  9.5.3. Filtros

   Os exemplos mostrados ate agora enviaram o conteudo de um arquivo de texto
   diretamente para a impressora. Contanto que a impressora entenda o
   conteudo desses arquivos, a saida sera impressa corretamente.

   Algumas impressoras nao sao capazes de imprimir texto simples, e o arquivo
   de entrada pode nem ser texto simples.

   Filtros permitem que os arquivos sejam traduzidos ou processados. O uso
   tipico e traduzir um tipo de entrada, como texto simples, em um formato
   que a impressora possa entender, como PostScript(R) ou PCL. Os filtros
   tambem podem ser usados para fornecer recursos adicionais, como adicionar
   numeros de pagina ou destacar o codigo-fonte para facilitar a leitura.

   Os filtros discutidos aqui sao filtros de entrada ou filtros de texto.
   Esses filtros convertem o arquivo recebido em diferentes formatos. Use
   su(1) para se tornar root antes de criar os arquivos.

   Os filtros sao especificados em /etc/printcap com o identificador if=.
   Para usar /usr/local/libexec/lf2crlf como um filtro, modifique o
   /etc/printcap assim:

 lp:\
         :lp=/dev/unlpt0:\
         :sh:\
         :mx#0:\
         :sd=/var/spool/lpd/lp:\
         :if=/usr/local/libexec/lf2crlf:\   1
         :lf=/var/log/lpd-errs:

   1   if= identifica o filtro de entrada que sera usado no texto recebido.  

  Dica:

   Os caracteres backslash de continuac,ao de linha no final das linhas nas
   entradas do printcap revelam que uma entrada para uma impressora e na
   verdade apenas uma linha longa com entradas delimitadas por dois pontos. O
   exemplo anterior pode ser reescrito como uma unica linha menos legivel:

 lp:lp=/dev/unlpt0:sh:mx#0:sd=/var/spool/lpd/lp:if=/usr/local/libexec/lf2crlf:lf=/var/log/lpd-errs:

    9.5.3.1. Impedindo degraus em impressoras de texto simples

   Os arquivos de texto tipicos do FreeBSD contem apenas um unico caractere
   de feed de linha no final de cada linha. Estas linhas vao ficar em
   "degraus" em uma impressora padrao:

 Um arquivo impresso parece
                     como os degraus de uma escada
                                               espalhados pelo vento

   Um filtro pode converter os caracteres de nova linha em retornos de carro
   e novas linhas. Os retornos de carro fazem a impressora retornar para a
   esquerda apos cada linha. Crie o /usr/local/libexec/lf2crlf com este
   conteudo:

 #!/bin/sh
 CR=$'\r'
 /usr/bin/sed -e "s/$/${CR}/g"

   Defina as permissoes e torne-o executavel:

 # chmod 555 /usr/local/libexec/lf2crlf

   Modifique o /etc/printcap para usar o novo filtro:

 :if=/usr/local/libexec/lf2crlf:\

   Teste o filtro imprimindo o mesmo arquivo de texto simples. O procedimento
   fara com que cada linha comece no lado esquerdo da pagina.

    9.5.3.2. Texto simples chique em impressoras PostScript(R) com
    print/enscript

   O GNUEnscript converte arquivos de texto simples em arquivos formatados
   como PostScript(R) para impressao em impressoras PostScript(R). Ele
   adiciona numeros de pagina, quebra as linhas longas e fornece varios
   outros recursos para facilitar a leitura dos arquivos de texto impressos.
   Dependendo do tamanho do papel local, instale o print/enscript-letter ou o
   print/enscript-a4 da colec,ao Ports.

   Crie o /usr/local/libexec/enscript com este conteudo:

 #!/bin/sh
 /usr/local/bin/enscript -o -

   Defina as permissoes e torne-o executavel:

 # chmod 555 /usr/local/libexec/enscript

   Modifique o /etc/printcap para usar o novo filtro:

 :if=/usr/local/libexec/enscript:\

   Teste o filtro imprimindo um arquivo de texto simples.

    9.5.3.3. Imprimindo PostScript(R) em impressoras PCL

   Muitos programas produzem documentos PostScript(R). No entanto,
   impressoras baratas geralmente so entendem texto simples ou PCL. Este
   filtro converte os arquivos PostScript(R) para o formato PCL antes de
   envia-los para a impressora.

   Instale o interpretador de PostScript(R) Ghostscript, print/ghostscript9,
   atraves da Colec,ao de Ports.

   Crie o /usr/local/libexec/ps2pcl com este conteudo:

 #!/bin/sh
 /usr/local/bin/gs -dSAFER -dNOPAUSE -dBATCH -q -sDEVICE=ljet4 -sOutputFile=- -

   Defina as permissoes e torne-o executavel:

 # chmod 555 /usr/local/libexec/ps2pcl

   A entrada PostScript(R) enviada para este script sera processada e
   convertida em PCL antes de ser enviada para a impressora.

   Modifique o /etc/printcap para usar este novo filtro de entrada:

 :if=/usr/local/libexec/ps2pcl:\

   Teste o filtro enviando um pequeno programa PostScript(R) para ele:

 % printf "%%\!PS \n /Helvetica findfont 18 scalefont setfont \
 72 432 moveto (PostScript printing successful.) show showpage \004" | lpr

    9.5.3.4. Filtros Inteligentes

   Um filtro que detecta o tipo de entrada e converte automaticamente para o
   formato correto da impressora pode ser muito conveniente. Os dois
   primeiros caracteres de um arquivo PostScript(R) sao geralmente %!. Um
   filtro pode detectar esses dois caracteres. Os arquivos PostScript(R)
   podem ser enviados de forma inalterada para uma impressora PostScript(R).
   Arquivos de texto podem ser convertidos para PostScript(R) com o Enscript
   como mostrado anteriormente. Crie o /usr/local/libexec/psif com este
   conteudo:

 #!/bin/sh
 #
 #  psif - Print PostScript or plain text on a PostScript printer
 #
 IFS="" read -r first_line
 first_two_chars=`expr "$first_line" : '\(..\)'`

 case "$first_two_chars" in
 %!)
     # %! : PostScript job, print it.
     echo "$first_line" && cat && exit 0
     exit 2
     ;;
 *)
     # otherwise, format with enscript
     ( echo "$first_line"; cat ) | /usr/local/bin/enscript -o - && exit 0
     exit 2
     ;;
 esac

   Defina as permissoes e torne-o executavel:

 # chmod 555 /usr/local/libexec/psif

   Modifique o /etc/printcap para usar este novo filtro de entrada:

 :if=/usr/local/libexec/psif:\

   Teste o filtro imprimindo PostScript(R) e arquivos de texto simples.

    9.5.3.5. Outros Filtros Inteligentes

   Escrever um filtro que detecte muitos tipos diferentes de entrada e os
   formate corretamente e um desafio. O print/apsfilter da Colec,ao de Ports
   e um filtro "magico" inteligente que detecta dezenas de tipos de arquivos
   e os converte automaticamente para o PDL entendido pela impressora. Veja
   http://www.apsfilter.org para mais detalhes.

  9.5.4. Multiplas filas

   As entradas no /etc/printcap sao na verdade definic,oes de filas. Pode
   haver mais de uma fila para uma unica impressora. Quando combinadas com
   filtros, multiplas filas fornecem aos usuarios um maior controle sobre
   como seus trabalhos sao impressos.

   Por exemplo, considere uma impressora laser PostScript(R) em rede num
   escritorio. A maioria dos usuarios deseja imprimir texto simples, mas
   alguns usuarios avanc,ados querem poder imprimir diretamente os arquivos
   PostScript(R). Duas entradas podem ser criadas para a mesma impressora no
   /etc/printcap:

 textprinter:\
         :lp=9100@officelaser:\
         :sh:\
         :mx#0:\
         :sd=/var/spool/lpd/textprinter:\
         :if=/usr/local/libexec/enscript:\
         :lf=/var/log/lpd-errs:

 psprinter:\
         :lp=9100@officelaser:\
         :sh:\
         :mx#0:\
         :sd=/var/spool/lpd/psprinter:\
         :lf=/var/log/lpd-errs:

   Os documentos enviados para a fila textprinter serao formatados pelo
   filtro /usr/local/libexec/enscript mostrado em um exemplo anterior.
   Usuarios avanc,ados podem imprimir arquivos PostScript(R) em psprinter,
   onde nenhuma filtragem e feita.

   Esta tecnica de multiplas filas pode ser usada para fornecer acesso direto
   a todos os tipos de recursos da impressora. Uma impressora com um
   duplexador pode usar duas filas, uma para impressoes em apenas um lado da
   folha e outra com um filtro que envia a sequ:encia de comandos para
   habilitar a impressao frente e verso e, em seguida, envia o arquivo
   recebido.

  9.5.5. Monitoramento e controle de impressao

   Varios utilitarios estao disponiveis para monitorar trabalhos de impressao
   e verificar e controlar a operac,ao da impressora.

    9.5.5.1. lpq(1)

   O lpq(1) mostra o status das tarefas de impressao de um usuario. Trabalhos
   de impressao de outros usuarios nao sao mostrados.

   Mostra os trabalhos pendentes do usuario atual em uma unica impressora:

 % lpq -Plp
 Rank   Owner      Job  Files                                 Total Size
 1st    jsmith     0    (standard input)                      12792 bytes

   Mostra os trabalhos pendentes do usuario atual em todas as impressoras:

 % lpq -a
 lp:
 Rank   Owner      Job  Files                                 Total Size
 1st    jsmith     1    (standard input)                      27320 bytes

 laser:
 Rank   Owner      Job  Files                                 Total Size
 1st    jsmith     287  (standard input)                      22443 bytes

    9.5.5.2. lprm(1)

   O lprm(1) e usado para remover trabalhos de impressao. Usuarios normais so
   podem remover seus proprios trabalhos. O root pode remover qualquer um ou
   todos os trabalhos.

   Remova todos os trabalhos pendentes de uma impressora:

 # lprm -Plp -
 dfA002smithy dequeued
 cfA002smithy dequeued
 dfA003smithy dequeued
 cfA003smithy dequeued
 dfA004smithy dequeued
 cfA004smithy dequeued

   Remova um unico trabalho de uma impressora. O lpq(1) e usado para
   encontrar o numero do trabalho.

 % lpq
 Rank   Owner      Job  Files                                 Total Size
 1st    jsmith     5    (standard input)                      12188 bytes
 % lprm -Plp 5
 dfA005smithy dequeued
 cfA005smithy dequeued

    9.5.5.3. lpc(8)

   O lpc(8) e usado para verificar e modificar o status da impressora. O lpc
   e seguido por um comando e um nome de impressora opcional. O parametro all
   pode ser usado em vez de um nome de impressora especifico, e o comando
   sera aplicado a todas as impressoras. Usuarios normais podem visualizar o
   status com lpc(8). Somente o class="username"&gt;root pode usar comandos
   que modificam o status da impressora.

   Mostrar o status de todas as impressoras:

 % lpc status all
 lp:
         queuing is enabled
         printing is enabled
         1 entry in spool area
         printer idle
 laser:
         queuing is enabled
         printing is enabled
         1 entry in spool area
         waiting for laser to come up

   Impedindo que uma impressora aceite novos trabalhos e fazendo com que ela
   comece a aceitar novos trabalhos novamente:

 # lpc disable lp
 lp:
         queuing disabled
 # lpc enable lp
 lp:
         queuing enabled

   Pare de imprimir, mas continue aceitando novos trabalhos. Em seguida,
   comece a imprimir novamente:

 # lpc stop lp
 lp:
         printing disabled
 # lpc start lp
 lp:
         printing enabled
         daemon started

   Reinicie uma impressora apos alguma condic,ao de erro:

 # lpc restart lp
 lp:
         no daemon to abort
         printing enabled
         daemon restarted

   Desative a fila de impressao e desative a impressao, com uma mensagem para
   explicar o problema aos usuarios:

 # lpc down lp Repair parts will arrive on Monday
 lp:
         printer and queuing disabled
         status message is now: Repair parts will arrive on Monday

   Reative uma impressora que esteja inativa:

 # lpc up lp
 lp:
         printing enabled
         daemon started

   Veja lpc(8) para mais comandos e opc,oes.

  9.5.6. Impressoras Compartilhadas

   As impressoras costumam ser compartilhadas por varios usuarios em empresas
   e escolas. Recursos adicionais sao fornecidos para tornar as impressoras
   compartilhadas mais convenientes.

    9.5.6.1. Aliases

   O nome da impressora e definido na primeira linha da entrada em
   /etc/printcap. Nomes adicionais, ou aliases, podem ser adicionados apos
   esse nome. Os aliases sao separados do nome e um do outro por barras
   verticais:

 lp|repairsprinter|salesprinter:\

   Os aliases podem ser usados no lugar do nome da impressora. Por exemplo,
   os usuarios do departamento de vendas imprimem em sua impressora com

 % lpr -Psalesprinter sales-report.txt

   Usuarios do departamento de Reparos podem imprimir na sua impressora com

 % lpr -Prepairsprinter repairs-report.txt

   Todos os documentos sao impressos nessa unica impressora. Quando o
   departamento de vendas cresce o suficiente para precisar de sua propria
   impressora, o alias pode ser removido da entrada da impressora
   compartilhada e usado como o nome de uma nova impressora. Os usuarios nos
   dois departamentos continuam usando os mesmos comandos, mas os documentos
   de vendas sao enviados para a nova impressora.

    9.5.6.2. Paginas de cabec,alho

   Pode ser dificil para os usuarios localizarem seus documentos na pilha de
   paginas produzidas por uma impressora compartilhada ocupada. Paginas de
   cabec,alho foram criadas para resolver este problema. Uma pagina de
   cabec,alho com o nome de usuario e o nome do documento e impressa antes de
   cada trabalho de impressao. Estas paginas sao por vezes chamadas de
   paginas banner ou separadoras.

   A ativac,ao das paginas de cabec,alho e diferente, dependendo se a
   impressora esta conectada diretamente ao computador com um cabo USB,
   paralelo ou serial, ou se esta conectada remotamente por uma rede.

   As paginas de cabec,alho em impressoras conectadas diretamente sao
   ativadas removendo-se a linha :sh:\ (Suprimir Cabec,alho) da entrada no
   /etc/printcap. Essas paginas de cabec,alho usam apenas caracteres de feed
   de linha para novas linhas. Algumas impressoras precisarao do filtro
   /usr/share/examples/printing/hpif para evitar imprimir o texto em escada.
   O filtro configura impressoras PCL para imprimir retornos de carro e
   alimentac,oes de linha quando um feed de linha e recebido.

   As paginas de cabec,alho das impressoras de rede devem ser configuradas na
   propria impressora. Entradas de pagina de cabec,alho no /etc/printcap sao
   ignoradas. As configurac,oes geralmente estao disponiveis no painel
   frontal da impressora ou em uma pagina da web de configurac,ao acessivel
   com um navegador da web.

  9.5.7. Referencias

   Arquivos de exemplo:/usr/share/examples/printing/.

   O Manual do Spooler de Impressora de Linha do 4.3BSD,
   /usr/share/doc/smm/07.lpd/paper.ascii.gz.

   Paginas de manual: printcap(5), lpd(8), lpr(1), lpc(8), lprm(1), lpq(1).

9.6. Outros sistemas de impressao

   Varios outros sistemas de impressao estao disponiveis, alem do lpd(8).
   Esses sistemas oferecem suporte para outros protocolos ou recursos
   adicionais.

  9.6.1. CUPS (Sistema de impressao comum UNIX(R))

   O CUPS e um sistema de impressao popular disponivel em muitos sistemas
   operacionais. Usar o CUPS no FreeBSD esta documentado em um artigo
   separado: ../../../../doc/en_US.ISO8859-1/articles/cups

  9.6.2. HPLIP

   A Hewlett Packard fornece um sistema de impressao que suporta muitas de
   suas impressoras a jato de tinta e laser. O port e o print/hplip. A pagina
   principal da web esta em http://hplipopensource.com/hplip-web/index.html.
   O port lida com todos os detalhes de instalac,ao no FreeBSD. As
   informac,oes de configurac,ao sao mostradas em
   http://hplipopensource.com/hplip-web/install/manual/hp_setup.html.

  9.6.3. LPRng

   O LPRng foi desenvolvido como uma alternativa aprimorada para o lpd(8). O
   port e sysutils/LPRng. Para detalhes e documentac,ao, veja
   http://www.lprng.com/.

Capitulo 10. Compatibilidade binaria com o Linux(R)

   Reestruturado e atualizado por Jim Mock.
   Originalmente contribuido por Brian N. Handy e Rich Murphey.
   Indice

   10.1. Sinopse

   10.2. Configurando a compatibilidade binaria com o Linux(R)

   10.3. Topicos Avanc,ados

10.1. Sinopse

   O FreeBSD fornece compatibilidade binaria com o Linux(R), permitindo que
   os usuarios instalem e executem a maioria dos binarios do Linux(R) em um
   sistema FreeBSD sem ter que primeiro modificar o binario. Foi ate relatado
   que, em algumas situac,oes, os binarios Linux(R) tem melhor desempenho no
   FreeBSD do que no Linux(R).

   No entanto, alguns recursos do sistema operacional especificos do Linux(R)
   nao sao suportados no FreeBSD. Por exemplo, os binarios Linux(R) nao
   funcionarao no FreeBSD se usarem chamadas especificas i386(TM), mesmo
   ativando o modo 8086 virtual.

  Nota:

   O suporte para compatibilidade binaria de 64 bits com o Linux(R) foi
   adicionado no FreeBSD 10.3.

   Depois de ler este capitulo, voce sabera:

     * Como habilitar a compatibilidade binaria com o Linux(R) em um sistema
       FreeBSD.

     * Como instalar bibliotecas compartilhadas adicionais do Linux(R).

     * Como instalar aplicativos Linux(R) em um sistema FreeBSD.

     * Os detalhes de implementac,ao da compatibilidade com o Linux(R) no
       FreeBSD.

   Antes de ler este capitulo, voce deve:

     * Saiber como instalar software adicional de terceiros.

10.2. Configurando a compatibilidade binaria com o Linux(R)

   Por padrao, as bibliotecas do Linux(R) nao estao instaladas e a
   compatibilidade binaria com o Linux(R) nao esta ativada. As bibliotecas
   Linux(R) podem ser instaladas manualmente ou a partir da colec,ao de Ports
   do FreeBSD.

   Antes de tentar compilar o port, carregue o modulo de kernel Linux(R),
   caso contrario a compilac,ao ira falhar:

 # kldload linux

   Para compatibilidade com 64 bits:

 # kldload linux64

   Para verificar se o modulo esta carregado:

 % kldstat
       Id Refs Address    Size     Name
       1    2 0xc0100000 16bdb8   kernel
       7    1 0xc24db000 d000     linux.ko

   O pacote ou port emulators/linux_base-c7 e a maneira mais facil de
   instalar um conjunto basico de bibliotecas e binarios do Linux(R) em um
   sistema FreeBSD. Para instalar o port:

 # pkg install emulators/linux_base-c7

   Para que a compatibilidade com o Linux(R) seja ativada durante a
   inicializac,ao, adicione esta linha ao /etc/rc.conf:

 linux_enable="YES"

   Em maquinas de 64 bits, o /etc/rc.d/abi carregara automaticamente o modulo
   para emulac,ao de 64 bits.

   Como a camada de compatibilidade binaria do Linux(R) ganhou suporte para a
   execuc,ao de binarios Linux(R) de 32 e 64 bits (em hosts x86 de 64 bits),
   nao e mais possivel vincular estaticamente a funcionalidade de emulac,ao a
   um kernel personalizado.

  10.2.1. Instalando Bibliotecas Adicionais Manualmente

   Se um aplicativo Linux(R) reclamar sobre a falta de bibliotecas
   compartilhadas apos configurar a compatibilidade binaria do Linux(R),
   determine quais bibliotecas compartilhadas o Linux(R) precisa e instale-as
   manualmente.

   A partir de um sistema Linux(R), o ldd pode ser usado para determinar
   quais bibliotecas compartilhadas o aplicativo precisa. Por exemplo, para
   verificar quais bibliotecas compartilhadas o linuxdoom precisa, execute
   este comando a partir de um sistema Linux(R) que tenha o Doom instalado:

 % ldd linuxdoom
 libXt.so.3 (DLL Jump 3.1) => /usr/X11/lib/libXt.so.3.1.0
 libX11.so.3 (DLL Jump 3.1) => /usr/X11/lib/libX11.so.3.1.0
 libc.so.4 (DLL Jump 4.5pl26) => /lib/libc.so.4.6.29

   Entao, copie todos os arquivos listados na ultima coluna da saida do
   comando no sistema Linux(R) para o diretorio /compat/linux no sistema
   FreeBSD. Depois de copiados, crie links simbolicos para os nomes na
   primeira coluna. Este exemplo ira resultar nos seguintes arquivos no
   sistema FreeBSD:

 /compat/linux/usr/X11/lib/libXt.so.3.1.0
 /compat/linux/usr/X11/lib/libXt.so.3 -> libXt.so.3.1.0
 /compat/linux/usr/X11/lib/libX11.so.3.1.0
 /compat/linux/usr/X11/lib/libX11.so.3 -> libX11.so.3.1.0
 /compat/linux/lib/libc.so.4.6.29
 /compat/linux/lib/libc.so.4 -> libc.so.4.6.29

   Se uma biblioteca compartilhada Linux(R) ja existir com um numero de
   revisao principal correspondente `a primeira coluna da saida do comando
   ldd, ela nao precisara ser copiada para a arquivo nomeado na ultima
   coluna, pois a biblioteca existente deve funcionar. No entanto e
   aconselhavel copiar a biblioteca compartilhada se for uma versao mais
   nova. O arquivo antigo pode ser removido, desde que o link simbolico
   aponte para o novo.

   Por exemplo, essas bibliotecas ja existem no sistema FreeBSD:

 /compat/linux/lib/libc.so.4.6.27
 /compat/linux/lib/libc.so.4 -> libc.so.4.6.27

   e o ldd indica que um binario requer uma versao posterior:

 libc.so.4 (DLL Jump 4.5pl26) -> libc.so.4.6.29

   Como a biblioteca existente tem apenas uma ou duas versoes desatualizadas
   no ultimo digito, o programa ainda deve funcionar com a versao um pouco
   mais antiga. No entanto, e seguro substituir o libc.so existente pela
   versao mais nova:

 /compat/linux/lib/libc.so.4.6.29
 /compat/linux/lib/libc.so.4 -> libc.so.4.6.29

   Geralmente, sera necessario procurar as bibliotecas compartilhadas que os
   binarios do Linux(R) dependem apenas das primeiras vezes que um programa
   Linux(R) e instalado no FreeBSD. Depois de um tempo, havera um conjunto
   suficiente de bibliotecas Linux(R) compartilhadas no sistema para poder
   executar binarios Linux(R) atualizados sem qualquer trabalho extra.

  10.2.2. Instalando os binarios Linux(R) ELF

   Os binarios ELF requerem por vezes um passo extra. Quando um binario ELF
   sem marca for executado, ele gerara uma mensagem de erro:

 % ./my-linux-elf-binary
 ELF binary type not known
 Abort

   Para ajudar o kernel do FreeBSD a distinguir entre um binario do FreeBSD
   ELF e um binario Linux(R), use brandelf(1):

 % brandelf -t Linux my-linux-elf-binary

   Como o conjunto de ferramentas GNU coloca as informac,oes de branding
   apropriadas em binarios ELF automaticamente, essa etapa geralmente nao e
   necessaria.

  10.2.3. Instalando um aplicativo baseado em Linux(R) RPM

   Para instalar um aplicativo baseado em Linux(R) RPM, primeiro instale o
   pacote ou o port archivers/rpm4. Uma vez instalado, o usuario root pode
   usar este comando para instalar um .rpm:

 # cd /compat/linux
 # rpm2cpio < /path/to/linux.archive.rpm | cpio -id

   Se necessario, use o brandelf nos binarios ELF instalados . Observe que
   isso impedira uma desinstalac,ao limpa.

  10.2.4. Configurando o Resolver do Hostname

   Se o DNS nao funcionar ou este erro aparecer:

 resolv+: "bind" is an invalid keyword resolv+:
 "hosts" is an invalid keyword

   configure o /compat/linux/etc/host.conf como segue:

 order hosts, bind
 multi on

   Isso especifica que o /etc/hosts deve ser pesquisado primeiro e o DNS deve
   ser pesquisado em segundo lugar. Quando o /compat/linux/etc/host.conf nao
   existe, os aplicativos Linux(R) usam o /etc/host.conf e avisam sobre a
   sintaxe incompativel do FreeBSD. Remova o bind se um servidor de nomes nao
   estiver configurado usando o /etc/resolv.conf.

10.3. Topicos Avanc,ados

   Esta sec,ao descreve como funciona a compatibilidade binaria com o
   Linux(R) e e baseada em um email escrito para Lista de discussao do chat
   do FreeBSD por Terry Lambert <tlambert@primenet.com> (Message ID:
   <199906020108.SAA07001@usr09.primenet.com>).

   O FreeBSD tem uma abstrac,ao chamada "loader de classes de execuc,ao".
   Esta e uma cunha na chamada de sistema execve(2) .

   Historicamente, o loader UNIX(R) examinava o numero magico (geralmente os
   primeiros 4 ou 8 bytes do arquivo) para ver se era um binario conhecido
   pelo sistema e, em caso afirmativo, invocava o loader binario.

   Se o arquivo nao fosse o tipo binario adequado para o sistema, a chamada
   execve(2) retornava uma falha, e o shell tentava iniciar a execuc,ao do
   mesmo como um comando do shell. A suposic,ao era um padrao de "qualquer
   que seja o shell atual".

   Posteriormente, foi feito um hack para que o sh(1) examinasse os dois
   primeiros caracteres e se eles fossem :\n, ele invocava o shell csh(1) em
   seu lugar.

   O FreeBSD tem uma lista de loaders, em vez de um unico loader, com um
   fallback para o loader #! para executar interpretadores de shell ou
   scripts de shell.

   Para o suporte ao Linux(R) ABI, o FreeBSD ve o numero magico como um
   binario ELF. O loader ELF procura por uma marca especializada, que e uma
   sec,ao de comentarios na imagem ELF e que nao esteja presente nos binarios
   ELF SVR4/Solaris(TM).

   Para que os binarios Linux(R) funcionem, eles devem ser marcados como tipo
   Linux usando o comando brandelf(1):

 # brandelf -t Linux file

   Quando o loader ELF ve a marca Linux, ele substitui um ponteiro na
   estrutura proc. Todas as chamadas do sistema sao indexadas por esse
   ponteiro. Alem disso, o processo e sinalizado para manipulac,ao especial
   do vetor trap para o codigo de trampolim de sinal, e varios outros
   (menores) reparos que sao manipulados pelo modulo do kernel Linux(R).

   O vetor de chamada do sistema Linux(R) contem, entre outras coisas, uma
   lista de entradas sysent[] cujos enderec,os residem no modulo do kernel.

   Quando uma chamada de sistema e acionada pelo binario Linux(R), o codigo
   de interceptac,ao desreferencia o ponteiro de func,ao de chamada do
   sistema da estrutura proc e obtem a classe Linux(R), nao a FreeBSD, como
   ponto de entrada para a chamada do sistema.

   O modo Linux(R) procura fazer reroots dinamicamente. Isso e, na verdade,
   equivalente ao union para montagens de sistema de arquivos. Primeiro, e
   feita uma tentativa de procurar o arquivo em /compat/linux/original-path.
   Se isso falhar, a pesquisa sera feita em /original-path. Isso garante que
   os binarios que exigem outros binarios possam ser executados. Por exemplo,
   o conjunto de ferramentas Linux(R) pode ser executado sob o suporte da
   Linux(R) ABI. Isso tambem significa que os binarios Linux(R) podem
   carregar e executar binarios do FreeBSD, se nao houver binarios Linux(R)
   correspondentes, e que o comando uname(1) pode ser colocado na arvore de
   diretorios /compat/linux para garantir que os binarios Linux(R) nao possam
   dizer que nao estao rodando em Linux(R).

   De fato, existe um kernel Linux(R) no kernel do FreeBSD. As varias
   func,oes subjacentes que implementam todos os servic,os fornecidos pelo
   kernel sao identicas `as entradas da tabela de chamada do sistema FreeBSD,
   e `as entradas da tabela de chamada do sistema Linux(R): operac,oes do
   sistema de arquivos, operac,oes de memoria virtual, entrega de sinal e
   System V IPC. A unica diferenc,a e que os binarios do FreeBSD obtem as
   func,oes de cola do FreeBSD, e os binarios Linux(R) recebem as func,oes de
   cola do Linux(R). As func,oes de cola do FreeBSD estao estaticamente
   ligadas ao kernel, e as func,oes de cola do Linux (R) podem ser
   estaticamente ligadas, ou podem ser acessadas atraves de um modulo do
   kernel.

   Tecnicamente, isso nao e realmente emulac,ao, e uma implementac,ao de ABI.
   As vezes e chamado de " emulac,ao(R) Linux " porque a implementac,ao foi
   feita num momento em que nao havia outra palavra para descrever o que
   estava acontecendo. Dizer que o FreeBSD executava os binarios do Linux(R)
   nao era verdade, ja que o codigo nao era compilado nele.

                      Parte III. Administrac,ao do Sistema

   Os capitulos restantes cobrem todos os aspectos da administrac,ao do
   sistema FreeBSD. Cada capitulo comec,a descrevendo o que sera aprendido
   como resultado da leitura do capitulo e tambem detalha o que o leitor deve
   saber antes de abordar o material.

   Estes capitulos sao projetados para serem lidos conforme as informac,oes
   sao necessarias. Eles nao precisam ser lidos em nenhuma ordem especifica,
   nem todos precisam ser lidos antes de comec,ar a usar o FreeBSD.

   Indice

   11. Configurac,ao e Ajuste

                11.1. Sinopse

                11.2. Inicializac,ao de Servic,os

                11.3. Configurando o cron(8)

                11.4. Gerenciando Servic,os no FreeBSD

                11.5. Configurando Placas de Interface de Rede

                11.6. Hosts Virtuais

                11.7. Configurando o log do sistema

                11.8. Arquivos de Configurac,ao

                11.9. Efetuando ajustes com o sysctl(8)

                11.10. Otimizac,ao de Discos

                11.11. Ajustando os Limites do Kernel

                11.12. Adicionando Espac,o de Swap

                11.13. Gerenciamento de energia e recursos

   12. O processo de inicializac,ao do FreeBSD

                12.1. Sinopse

                12.2. Processo de Inicializac,ao do FreeBSD

                12.3. Configurando telas iniciais de inicializac,ao

                12.4. Sugestoes de dispositivos

                12.5. Sequencia de Desligamento

   13. Seguranc,a

                13.1. Sinopse

                13.2. Introduc,ao

                13.3. Senhas de Uso Unico

                13.4. TCP Wrapper

                13.5. Kerberos

                13.6. OpenSSL

                13.7. VPN Sobre IPsec

                13.8. OpenSSH

                13.9. Listas de Controle de Acesso

                13.10. Monitorando Problemas de Seguranc,a de Terceiros

                13.11. Avisos de Seguranc,a do FreeBSD

                13.12. Auditoria de Processo

                13.13. Limites de Recursos

                13.14. Administrac,ao Compartilhada com Sudo

   14. Jails

                14.1. Sinopse

                14.2. Termos Relacionados `a Jails

                14.3. Criando e Controlando Jails

                14.4. Tuning e Administrac,ao

                14.5. Atualizando Multiplas Jails

                14.6. Gerenciando Jails com o ezjail

   15. Controle de acesso obrigatorio

                15.1. Sinopse

                15.2. Termos chave

                15.3. Entendendo os rotulos MAC

                15.4. Planejando a configurac,ao de seguranc,a

                15.5. Politicas MAC Disponiveis

                15.6. Bloqueio do Usuario

                15.7. Nagios em Jail MAC

                15.8. Soluc,ao de problemas do framework MAC

   16. Auditoria de Evento de Seguranc,a

                16.1. Sinopse

                16.2. Termos chave

                16.3. Configurac,ao de Auditoria

                16.4. Trabalhando com Trilhas de Auditoria

   17. Armazenamento

                17.1. Sinopse

                17.2. Adicionando Discos

                17.3. Redimensionando e Ampliando Discos

                17.4. Dispositivos de Armazenamento USB

                17.5. Criando e Usando Midia em CD

                17.6. Criando e Usando Midia de DVD

                17.7. Criando e Usando Disquetes

                17.8. Noc,oes Basicas de Backup

                17.9. Discos de Memoria

                17.10. Snapshots de Sistemas de Arquivos

                17.11. Cotas de Disco

                17.12. Criptografando Partic,oes de Disco

                17.13. Criptografando Swap

                17.14. Alta Disponibilidade de Armazenamento (HAST)

   18. GEOM: Framework de Transformac,ao de Disco Modular

                18.1. Sinopse

                18.2. RAID0 - Striping

                18.3. RAID1 - Espelhamento

                18.4. RAID3 - Distribuic,ao em Nivel de Byte com Paridade
                Dedicada

                18.5. Dispositivos RAID por Software

                18.6. GEOM Network Gate

                18.7. Rotulando Dispositivos de Disco

                18.8. Journaling UFS atraves do GEOM

   19. O sistema de arquivos Z (ZFS)

                19.1. O que torna o ZFS diferente

                19.2. Guia de Inicio Rapido

                19.3. Administrac,ao zpool

                19.4. Administrac,ao do zfs

                19.5. Administrac,ao Delegada

                19.6. Topicos Avanc,ados

                19.7. Recursos adicionais

                19.8. Recursos e terminologia do ZFS

   20. Outros Sistemas de Arquivos

                20.1. Sinopse

                20.2. Sistemas de arquivos do Linux(R)

   21. Virtualizac,ao

                21.1. Sinopse

                21.2. FreeBSD como Sistema Operacional Convidado no Parallels
                para Mac OS(R) X

                21.3. FreeBSD como sistema convidado no Virtual PC para
                Windows(R)

                21.4. FreeBSD como Sistema Operacional Convidado no VMware
                Fusion para Mac OS(R)

                21.5. FreeBSD como Sistema Operacional Convidado no
                VirtualBox(TM)

                21.6. FreeBSD como Host com VirtualBox(TM)

                21.7. FreeBSD como um Host bhyve

                21.8. FreeBSD como Host Xen(TM)

   22. Localizac,ao - Uso e Configurac,ao do i18n/L10n

                22.1. Sinopse

                22.2. Usando Localizac,ao

                22.3. Encontrando Aplicac,oes i18n

                22.4. Configurac,ao de Localizac,ao para Idiomas Especificos

   23. Atualizac,ao e Upgrade do FreeBSD

                23.1. Sinopse

                23.2. Atualizac,ao do FreeBSD

                23.3. Atualizando o Conjunto de Documentac,ao

                23.4. Acompanhando um ramo de desenvolvimento

                23.5. Atualizando o FreeBSD a partir do codigo fonte

                23.6. Atualizac,ao de varias maquinas

   24. DTrace

                24.1. Sinopse

                24.2. Diferenc,as de Implementac,ao

                24.3. Ativando o Suporte do DTrace

                24.4. Usando o DTrace

   25. Modo de dispositivo USB/USB OTG

                25.1. Sinopse

                25.2. Portas Seriais Virtuais USB

                25.3. Interfaces de rede do modo de dispositivo USB

                25.4. Dispositivo de armazenamento virtual USB

Capitulo 11. Configurac,ao e Ajuste

   Escrito porChern Lee.
   Baseado em um tutorial escrito porMike Smith.
   Tambem baseado em tuning (7) escrito porMatt Dillon.
   Indice

   11.1. Sinopse

   11.2. Inicializac,ao de Servic,os

   11.3. Configurando o cron(8)

   11.4. Gerenciando Servic,os no FreeBSD

   11.5. Configurando Placas de Interface de Rede

   11.6. Hosts Virtuais

   11.7. Configurando o log do sistema

   11.8. Arquivos de Configurac,ao

   11.9. Efetuando ajustes com o sysctl(8)

   11.10. Otimizac,ao de Discos

   11.11. Ajustando os Limites do Kernel

   11.12. Adicionando Espac,o de Swap

   11.13. Gerenciamento de energia e recursos

11.1. Sinopse

   Um dos aspectos importantes do FreeBSD e a configurac,ao adequada do
   sistema. Este capitulo explica muito do processo de configurac,ao do
   FreeBSD, incluindo alguns dos parametros que podem ser configurados para
   ajustar um sistema FreeBSD.

   Depois de ler este capitulo, voce sabera:

     * O basico da configurac,ao do rc.conf e dos scripts de inicializac,ao
       /usr/local/etc/rc.d.

     * Como configurar e testar uma placa de rede.

     * Como configurar hosts virtuais em dispositivos de rede.

     * Como usar os varios arquivos de configurac,ao em /etc.

     * Como ajustar o FreeBSD usando variaveis sysctl(8).

     * Como ajustar o desempenho do disco e modificar as limitac,oes do
       kernel.

   Antes de ler este capitulo, voce deve:

     * Entender os fundamentos do UNIX(R) e do FreeBSD (Capitulo 3,
       Fundamentos do FreeBSD).

     * Estar familiarizado com os conceitos basicos de configurac,ao e
       compilac,ao do kernel (Capitulo 8, Configurando o kernel do FreeBSD).

11.2. Inicializac,ao de Servic,os

   Contribuido por Tom Rhodes.

   Muitos usuarios instalam software de terceiros no FreeBSD a partir da
   colec,ao de Ports e precisam que os servic,os instalados sejam iniciados
   durante a inicializac,ao do sistema. Servic,os como mail/postfix ou
   www/apache22 sao apenas dois dos muitos pacotes de software que podem ser
   iniciados durante a inicializac,ao do sistema. Esta sec,ao explica os
   procedimentos disponiveis para iniciar o software de terceiros.

   No FreeBSD, a maioria dos servic,os incluidos, como o cron(8), sao
   iniciados atraves dos scripts de inicializac,ao do sistema.

  11.2.1. Configurac,ao Estendida dos Aplicativos

   Agora que o FreeBSD inclui o rc.d, a configurac,ao da inicializac,ao do
   aplicativo e mais facil e fornece mais recursos. Usando as palavras-chave
   discutidas em Sec,ao 11.4, "Gerenciando Servic,os no FreeBSD", os
   aplicativos podem ser configurados para iniciar depois de certos outros
   servic,os e flags extras poderem ser passadas atraves do /etc/rc.conf no
   lugar de sinalizadores codificados no script de inicializac,ao. Um script
   basico pode ser semelhante ao seguinte:

 #!/bin/sh
 #
 # PROVIDE: utility
 # REQUIRE: DAEMON
 # KEYWORD: shutdown

 . /etc/rc.subr

 name=utility
 rcvar=utility_enable

 command="/usr/local/sbin/utility"

 load_rc_config $name

 #
 # DO NOT CHANGE THESE DEFAULT VALUES HERE
 # SET THEM IN THE /etc/rc.conf FILE
 #
 utility_enable=${utility_enable-"NO"}
 pidfile=${utility_pidfile-"/var/run/utility.pid"}

 run_rc_command "$1"

   Este script ira garantir que o utilitario fornecido sera iniciado apos o
   pseudo-servic,o DAEMON. Ele tambem fornece um metodo para definir e
   rastrear o ID do processo (PID).

   Esta aplicac,ao poderia entao ter a seguinte linha colocada no
   /etc/rc.conf:

 utility_enable="YES"

   Este metodo permite a manipulac,ao mais facil de argumentos de linha de
   comando, inclusao das func,oes padroes fornecidas em /etc/rc.subr,
   compatibilidade com o rcorder(8), e fornece uma configurac,ao mais facil
   via rc.conf.

  11.2.2. Usando o Services para Inicializar Servic,os

   Outros servic,os podem ser iniciados usando o inetd(8). O uso do inetd(8)
   e sua configurac,ao e descrita em profundidade em Sec,ao 29.2, "O
   super-servidor inetd".

   Em alguns casos, pode fazer mais sentido usar o cron(8) para iniciar os
   servic,os do sistema. Esta abordagem tem varias vantagens, pois o cron(8)
   executa estes processos como o proprietario do crontab(5). Isto permite
   que usuarios regulares iniciem e mantenham seus proprios aplicativos.

   O recurso @reboot do cron(8), pode ser usado no lugar da especificac,ao de
   hora. Isso faz com que o job seja executado quando cron(8) e iniciado,
   normalmente durante a inicializac,ao do sistema.

11.3. Configurando o cron(8)

   Contribuido por Tom Rhodes.

   Um dos utilitarios mais uteis no FreeBSD e o cron. Este utilitario e
   executado em segundo plano e verifica regularmente o /etc/crontab para que
   as tarefas sejam executadas e procura /var/cron/tabs para arquivos crontab
   personalizados. Estes arquivos sao usados para planejar tarefas que o cron
   executa nos horarios especificados. Cada entrada em um crontab define uma
   tarefa para ser executada e e conhecida como uma tarefa do cron.

   Dois tipos diferentes de arquivos de configurac,ao sao usados: o crontab
   do sistema, que nao deve ser modificado, e crontabs de usuario, que podem
   ser criados e editados conforme necessario. O formato usado por esses
   arquivos esta documentado em crontab(5). O formato do sistema crontab,
   /etc/crontab inclui uma coluna who que nao existe nos crontabs de usuario.
   No crontab do sistema , o cron executa o comando como o usuario
   especificado nesta coluna. Em um crontab de usuario, todos os comandos sao
   executados como o usuario que criou o crontab.

   Os crontabs de usuario permitem que usuarios individuais programem suas
   proprias tarefas. O usuario root tambem pode ter um crontab de usuario que
   pode ser usado para agendar tarefas que nao existem no crontab do sistema
   .

   Aqui esta uma entrada de amostra do crontab do sistema, /etc/crontab:

 # /etc/crontab - root's crontab for FreeBSD
 #
 # $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
 # 1
 SHELL=/bin/sh
 PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin 2
 #
 #minute hour    mday    month   wday    who     command 3
 #
 */5     *       *       *       *       root    /usr/libexec/atrun 4

   1 Linhas que comec,am com o caractere # sao comentarios. Um comentario     
     pode ser colocado no arquivo como um lembrete do que uma ac,ao faz e do  
     porque a sua execuc,ao e desejada. Comentarios nao podem estar na mesma  
     linha que um comando ou entao serao interpretados como parte do comando; 
     eles devem estar em uma nova linha. Linhas em branco sao ignoradas.      
   2 O caractere igual (=) e usado para definir qualquer configurac,ao de     
     ambiente. Neste exemplo, ele e usado para definir o SHELL e o PATH. Se o 
     SHELL for omitido, o cron usara o shell Bourne padrao. Se o PATH for     
     omitido, o caminho completo devera ser fornecido ao comando ou script a  
     ser executado.                                                           
   3 Esta linha define os sete campos usados em um crontab do sistema:        
     minute, hora, mday, month, wday, who e command. O campo minute e o tempo 
     em minutos quando o comando especificado sera executado, a hour e a hora 
     em que o comando especificado sera executado, o mday e o dia do mes,     
     month e o mes e wday e o dia da semana. Estes campos devem ser valores   
     numericos, representando o relogio de vinte e quatro horas, ou um *,     
     representando todos os valores desse campo. O campo who existe somente   
     no crontab do sistema e especifica com qual usuario o comando deve ser   
     executado. O ultimo campo e o comando a ser executado.                   
   4 Esta entrada define os valores para este trabalho do cron. O */5,        
     seguido por varios outros caracteres *, especifica que                   
     /usr/libexec/atrun e invocado pelo root a cada cinco minutos de cada     
     hora, de cada dia e dia da semana, de cada mes.                          
                                                                              
     Comandos podem incluir qualquer numero de opc,oes. No entanto, os        
     comandos que se estendem a varias linhas precisam ser quebrados com o    
     caractere de continuac,ao da barra invertida "\".                        

  11.3.1. Criando um Crontab de Usuario

   Para criar um crontab de usuario, invoque o crontab no modo editor:

 % crontab -e

   Isto ira abrir o crontab do usuario usando o editor de texto padrao. A
   primeira vez que um usuario executa este comando, ele abre um arquivo
   vazio. Depois que um usuario cria um crontab, esse comando abrira este
   arquivo para edic,ao.

   E util adicionar estas linhas a parte superior do arquivo crontab para
   configurar as variaveis de ambiente e lembrar os significados dos campos
   no crontab:

 SHELL=/bin/sh
 PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin
 # Order of crontab fields
 # minute        hour    mday    month   wday    command

   Em seguida, adicione uma linha para cada comando ou script a ser
   executado, especificando o horario para executar o comando. Este exemplo
   executa o script de shell Bourne personalizado especificado todos os dias
   `as duas da tarde. Como o caminho para o script nao esta especificado em
   PATH, o caminho completo para o script e fornecido:

 0       14      *       *       *       /usr/home/dru/bin/mycustomscript.sh

  Dica:

   Antes de usar um script personalizado, verifique se ele e executavel e
   teste-o com o conjunto limitado de variaveis de ambiente definidas pelo
   cron. Para replicar o ambiente que seria usado para executar a entrada do
   cron acima, use:

 env -i SHELL=/bin/sh PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin HOME=/home/dru LOGNAME=dru /usr/home/dru/bin/mycustomscript.sh

   O ambiente definido pelo cron e discutido em crontab(5). Verificar se os
   scripts operam corretamente em um ambiente cron e especialmente importante
   se incluirem quaisquer comandos que excluam arquivos usando curingas.

   Quando terminar de editar o crontab, salve o arquivo. Ele sera instalado
   automaticamente e o cron lera o crontab e executara seus cron jobs nos
   horarios especificados. Para listar as tarefas agendadas em um crontab,
   use este comando:

 % crontab -l
 0       14      *       *       *       /usr/home/dru/bin/mycustomscript.sh

   Para remover todas as tarefas cron em um crontab de usuario:

 % crontab -r
 remove crontab for dru? y

11.4. Gerenciando Servic,os no FreeBSD

   Contribuido por Tom Rhodes.

   O FreeBSD usa o sistema rc(8) de scripts de inicializac,ao durante a
   inicializac,ao do sistema e para gerenciar servic,os. Os scripts listados
   em /etc/rc.d fornecem servic,os basicos que podem ser controlados com
   start, stop e restart opc,oes para service(8). Por exemplo, sshd(8) pode
   ser reiniciado com o seguinte comando:

 # service sshd restart

   Este procedimento pode ser usado para iniciar servic,os em um sistema em
   execuc,ao. Os servic,os serao iniciados automaticamente no momento da
   inicializac,ao, conforme especificado em rc.conf(5). Por exemplo, para
   ativar o natd(8) na inicializac,ao do sistema, adicione a seguinte linha
   ao /etc/rc.conf:

 natd_enable="YES"

   Se uma linha natd_enable="NO" ja estiver presente, altere o NO para YES.
   Os scripts rc(8) carregarao automaticamente todos os servic,os dependentes
   durante a proxima inicializac,ao, conforme descrito abaixo.

   Como o sistema rc(8) e destinado principalmente a iniciar e parar
   servic,os na inicializac,ao do sistema e no tempo de desligamento, o
   start, as opc,oes stop e restart somente executarao suas ac,oes se a
   variavel apropriada estiver configurada no /etc/rc.conf. Por exemplo, o
   sshd restart so funcionara se sshd_enable estiver definido como YES em
   /etc/rc.conf. Para iniciar, parar ou reiniciar um servic,o independente
   das configurac,oes em /etc/rc.conf, estes comandos deve ser prefixado com
   "one". Por exemplo, para reiniciar sshd(8) independentemente da
   configurac,ao atual do /etc/rc.conf, execute o seguinte comando:

 # service sshd onerestart

   Para verificar se um servic,o esta habilitado em /etc/rc.conf, execute o
   script apropriado rc(8) com rcvar. Este exemplo verifica se o sshd(8) esta
   habilitado no /etc/rc.conf:

 # service sshd rcvar
 # sshd
 #
 sshd_enable="YES"
 #   (default: "")

  Nota:

   A linha # sshd e gerada pelo comando acima, nao pelo console do root.

   Para determinar se um servic,o esta ou nao em execuc,ao, use status. Por
   exemplo, para verificar se o sshd(8) esta em execuc,ao:

 # service sshd status
 sshd is running as pid 433.

   Em alguns casos, tambem e possivel fazer o reload denum servic,o. Isso
   tenta enviar um sinal para um servic,o individual, forc,ando o servic,o a
   recarregar seus arquivos de configurac,ao. Na maioria dos casos, isso
   significa enviar ao servic,o um sinal SIGHUP. O suporte para esse recurso
   nao esta incluido para todos os servic,os.

   O sistema rc(8) e usado para servic,os de rede e tambem contribui para a
   maior parte da inicializac,ao do sistema. Por exemplo, quando o script
   /etc/rc.d/bgfsck e executado, ele imprime a seguinte mensagem:

 Starting background file system checks in 60 seconds.

   Esse script e usado para verificac,oes do sistema de arquivos em segundo
   plano, que ocorrem apenas durante a inicializac,ao do sistema.

   Muitos servic,os do sistema dependem de outros servic,os para funcionar
   corretamente. Por exemplo, o yp(8) e outros servic,os baseados em RPC
   podem falhar ao iniciar ate que o rpcbind(8) seja iniciado. Para resolver
   esse problema, informac,oes sobre dependencias e outros meta-dados sao
   incluidas nos comentarios na parte superior de cada script de
   inicializac,ao. O programa rcorder(8) e usado para analisar esses
   comentarios durante a inicializac,ao do sistema para determinar a ordem na
   qual os servic,os do sistema devem ser invocados para satisfazer as
   dependencias.

   A seguinte palavra-chave deve ser incluida em todos os scripts de
   inicializac,ao, conforme exigido pelo rc.subr(8) para "habilitar" o script
   de inicializac,ao:

     * PROVIDE: Especifica os servic,os que este arquivo fornece.

   As seguintes palavras-chave podem ser incluidas na parte superior de cada
   script de inicializac,ao. Eles nao sao estritamente necessarias, mas sao
   uteis como sugestoes para rcorder(8):

     * REQUIRE: lista os servic,os necessarios para este servic,o. O script
       que contem esta palavra chave sera executado apos os servic,os
       especificados.

     * BEFORE: lista os servic,os que dependem deste servic,o. O script que
       contem esta palavra chave sera executado antes dos servic,os
       especificados.

   Ao definir cuidadosamente essas palavras-chave para cada script de
   inicializac,ao, um administrador passa a ter um nivel refinado de controle
   da ordem de inicializac,ao dos scripts, sem a necessidade dos "runlevels"
   usados por alguns sistemas operacionais UNIX(R).

   Informac,oes adicionais podem ser encontradas em rc(8) e rc.subr(8).
   Consulte este artigo para obter instruc,oes sobre como criar um script
   rc(8) personalizado.

  11.4.1. Gerenciando a configurac,ao especifica do sistema

   A localizac,ao principal das informac,oes de configurac,ao do sistema e
   arquivo /etc/rc.conf. Este arquivo contem uma ampla gama de informac,oes
   de configurac,ao e e lido na inicializac,ao do sistema para configurar o
   sistema. Ele fornece as informac,oes de configurac,ao para os arquivos
   rc*.

   As entradas em /etc/rc.conf substituem as configurac,oes padroes em
   /etc/defaults/rc.conf. O arquivo contendo as configurac,oes padroes nao
   deve ser editado. Ao inves disso, todas as alterac,oes especificas do
   sistema devem ser feitas em /etc/rc.conf.

   Varias estrategias podem ser aplicadas em aplicativos em cluster para
   separar as configurac,oes que afetam todo o site da configurac,ao
   especifica do sistema para reduzir a sobrecarga de administrac,ao. A
   abordagem recomendada e colocar a configurac,ao especifica do sistema em
   /etc/rc.conf.local. Por exemplo, estas entradas em /etc/rc.conf aplicam-se
   a todos os sistemas:

 sshd_enable="YES"
 keyrate="fast"
 defaultrouter="10.1.1.254"

   Considerando que estas entradas em /etc/rc.conf.local se aplicam somente a
   este sistema:

 hostname="node1.example.org"
 ifconfig_fxp0="inet 10.1.1.1/8"

   Distribua o /etc/rc.conf para cada sistema usando um aplicativo como o
   rsync ou o puppet, enquanto o /etc/rc.conf.local permanece unico.

   A atualizac,ao do sistema nao sobrescrevera o /etc/rc.conf, portanto as
   informac,oes de configurac,ao do sistema nao serao perdidas.

  Dica:

   Ambos /etc/rc.conf e /etc/rc.conf.local sao analisados pelo sh(1). Isto
   permite que os operadores do sistema criem cenarios de configurac,ao
   complexos. Consulte rc.conf(5) para obter mais informac,oes sobre este
   topico.

11.5. Configurando Placas de Interface de Rede

   Contribuido por Marc Fonvieille.

   Adicionar e configurar uma placa de interface de rede (NIC) e uma tarefa
   comum para qualquer administrador do FreeBSD.

  11.5.1. Localizando o Driver Correto

   Primeiro, determine o modelo da NIC e o chip utilizado. O FreeBSD suporta
   uma ampla variedade de NICs. Verifique a lista de compatibilidade de
   hardware para a release do FreeBSD para ver se a NIC e suportada.

   Se a NIC e suportada, determine o nome do driver do FreeBSD para a NIC.
   Consulte /usr/src/sys/conf/NOTES e /usr/src/sys/arch/conf/NOTES para a
   lista de Drivers NIC com algumas informac,oes sobre os chipsets
   suportados. Em caso de duvida, leia a pagina de manual do driver, pois ele
   fornecera mais informac,oes sobre o hardware suportado e quaisquer
   limitac,oes conhecidas do driver.

   Os drivers para as NICs comuns ja estao presentes no kernel GENERIC, o que
   significa que a NIC deve ser verificada durante a inicializac,ao. As
   mensagens de inicializac,ao do sistema podem ser visualizadas digitando
   more /var/run/dmesg.boot e usando a barra de espac,o para percorrer o
   texto. Neste exemplo, duas NICs Ethernet que utilizam o driver dc(4) estao
   presentes no sistema:

 dc0: <82c169 PNIC 10/100BaseTX> port 0xa000-0xa0ff mem 0xd3800000-0xd38
 000ff irq 15 at device 11.0 on pci0
 miibus0: <MII bus> on dc0
 bmtphy0: <BCM5201 10/100baseTX PHY> PHY 1 on miibus0
 bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
 dc0: Ethernet address: 00:a0:cc:da:da:da
 dc0: [ITHREAD]
 dc1: <82c169 PNIC 10/100BaseTX> port 0x9800-0x98ff mem 0xd3000000-0xd30
 000ff irq 11 at device 12.0 on pci0
 miibus1: <MII bus> on dc1
 bmtphy1: <BCM5201 10/100baseTX PHY> PHY 1 on miibus1
 bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
 dc1: Ethernet address: 00:a0:cc:da:da:db
 dc1: [ITHREAD]

   Se o driver da NIC nao estiver presente em GENERIC, mas houver um driver
   disponivel, o driver precisara ser carregado antes que a NIC possa ser
   configurada e usada. Isso pode ser feito de duas maneiras:

     * A maneira mais facil e carregar um modulo do kernel para a NIC usando
       o kldload(8). Para carregar automaticamente o driver no momento da
       inicializac,ao, adicione a linha apropriada ao /boot/loader.conf. Nem
       todos os drivers NIC estao disponiveis como modulos.

     * Como alternativa, compile estaticamente o suporte para a NIC em um
       kernel personalizado. Consulte /usr/src/sys/conf/NOTES,
       /usr/src/sys/arch/conf/NOTES e a pagina de manual do driver para
       determinar qual linha adicionar ao arquivo de configurac,ao do kernel
       personalizado. Para mais informac,oes sobre como recompilar o kernel,
       consulte Capitulo 8, Configurando o kernel do FreeBSD. Se a NIC foi
       detectada na inicializac,ao, o kernel nao precisa ser recompilado.

    11.5.1.1. Utilizando os Drivers Windows(R) NDIS

   Infelizmente, ainda existem muitos fornecedores que nao fornecem esquemas
   para seus drivers para a comunidade de codigo aberto porque consideram
   essas informac,oes como segredos comerciais. Consequentemente, os
   desenvolvedores do FreeBSD e de outros sistemas operacionais sao deixados
   com duas opc,oes: desenvolver os drivers por um processo longo e complexo
   de engenharia reversa ou usar os binarios de drivers existentes
   disponiveis para plataforma Microsoft(R) Windows(R).

   O FreeBSD fornece suporte "nativo" para a especificac,ao de interface de
   driver de rede (NDIS). Ele inclui o ndisgen(8) que pode ser utilizado para
   converter um driver Windows(R) XP num formato que pode ser usado no
   FreeBSD. Como o driver ndis(4) usa um binario Windows(R) XP, ele so e
   executado em sistemas i386(TM) e amd64. Dispositivos PCI, CardBus, PCMCIA
   e USB sao suportados.

   Para usar o ndisgen(8), tres coisas sao necessarias:

    1. Codigo-fonte do kernel do FreeBSD.

    2. Um binario do driver do Windows(R) XP com uma extensao .SYS.

    3. Um arquivo de configurac,ao do driver do Windows(R) XP com uma
       extensao .INF.

   Fac,a o download dos arquivos .SYS e .INF para a NIC especifica.
   Geralmente, eles podem ser encontrados no CD do driver ou no site do
   fornecedor. Os exemplos a seguir usam o W32DRIVER.SYS e o W32DRIVER.INF.

   A largura do bit do driver deve corresponder `a versao do FreeBSD. Para
   FreeBSD/i386, use um driver de 32 bits Windows(R). Para o FreeBSD/amd64, e
   necessario um driver de 64 bits do Windows(R).

   O proximo passo e compilar o binario do driver em um modulo do kernel
   carregavel. Como root, use ndisgen(8):

 # ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS

   Este comando e interativo e solicita qualquer informac,ao extra
   necessaria. Um novo modulo do kernel sera gerado no diretorio atual. Use
   kldload(8) para carregar o novo modulo:

 # kldload ./W32DRIVER_SYS.ko

   Alem do modulo do kernel gerado, os modulos ndis.ko e if_ndis.ko devem ser
   carregados. Isso deve acontecer automaticamente quando qualquer modulo que
   dependa do ndis(4) for carregado. Caso contrario, carregue-os manualmente,
   usando os seguintes comandos:

 # kldload ndis
 # kldload if_ndis

   O primeiro comando carrega o wrapper do driver da miniporta ndis(4) e o
   segundo carrega o driver NIC gerado.

   Execute o comando dmesg(8) para ver se houve algum erro de carregamento.
   Se tudo correu bem, a saida deve ser semelhante `a seguinte:

 ndis0: <Wireless-G PCI Adapter> mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
 ndis0: NDIS API version: 5.0
 ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
 ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
 ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps

   A partir daqui, o ndis0 pode ser configurado como qualquer outra NIC.

   Para configurar o sistema para carregar os modulos ndis(4) no momento da
   inicializac,ao, copie o modulo gerado, W32DRIVER_SYS.ko, para
   /boot/modules. Em seguida, adicione a seguinte linha ao /boot/loader.conf:

 W32DRIVER_SYS_load="YES"

  11.5.2. Configurando a placa de rede

   Quando o driver correto e carregado para a NIC, a placa precisa ser
   configurada. Ele pode ter sido configurado no momento da instalac,ao por
   bsdinstall(8).

   Para exibir a configurac,ao da NIC, digite o seguinte comando:

 % ifconfig
 dc0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
         options=80008<VLAN_MTU,LINKSTATE>
         ether 00:a0:cc:da:da:da
         inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
         media: Ethernet autoselect (100baseTX <full-duplex>)
         status: active
 dc1: flags=8802<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
         options=80008<VLAN_MTU,LINKSTATE>
         ether 00:a0:cc:da:da:db
         inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
         media: Ethernet 10baseT/UTP
         status: no carrier
 lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> metric 0 mtu 16384
         options=3<RXCSUM,TXCSUM>
         inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
         inet6 ::1 prefixlen 128
         inet 127.0.0.1 netmask 0xff000000
         nd6 options=3<PERFORMNUD,ACCEPT_RTADV>

   Neste exemplo, os seguintes dispositivos foram exibidos:

     * dc0: A primeira interface Ethernet.

     * dc1: A segunda interface Ethernet.

     * lo0: o dispositivo de loopback.

   O FreeBSD usa o nome do driver seguido da ordem em que a placa e detectada
   na inicializac,ao para nomear a NIC. Por exemplo, sis2 e a terceira NIC no
   sistema usando driver sis(4).

   Neste exemplo, o dc0 esta ativo e em execuc,ao. Os principais indicadores
   sao:

    1. UP significa que a placa esta configurada e pronta.

    2. A placa tem um enderec,o da Internet (inet), 192.168.1.3.

    3. Ela tem uma mascara de sub-rede valida (netmask), onde 0xffffff00 e o
       mesmo que 255.255.255.0 .

    4. Tem um enderec,o de broadcast valido, 192.168.1.255.

    5. O enderec,o MAC da placa (ether) e 00:a0:cc:da:da:da.

    6. A selec,ao de midia fisica esta no modo de selec,ao automatica
       (media:Ethernet autoselect (100baseTX <full-duplex>)). Neste exemplo,
       o dc1 esta configurado para ser executado com a midia 10baseT/UTP.
       Para obter mais informac,oes sobre tipos de midia disponiveis para um
       driver, consulte sua pagina de manual.

    7. O status do link (status) e active, indicando que o sinal da portadora
       foi detectado. Para dc1, o status status: no carrier e normal quando
       um cabo Ethernet nao esta conectado `a placa.

   Se a saida ifconfig(8) tivesse mostrado algo semelhante a:

 dc0: flags=8843<BROADCAST,SIMPLEX,MULTICAST> metric 0 mtu 1500
         options=80008<VLAN_MTU,LINKSTATE>
         ether 00:a0:cc:da:da:da
         media: Ethernet autoselect (100baseTX <full-duplex>)
         status: active

   isso indicaria que a placa nao foi configurada.

   A placa deve ser configurada como root. A configurac,ao da NIC pode ser
   realizada a partir da linha de comando com o ifconfig(8), mas nao
   persistira apos uma reinicializac,ao, a menos que a configurac,ao tambem
   seja adicionada ao /etc/rc.conf. Se um servidor DHCP estiver presente na
   LAN, basta adicionar esta linha:

 ifconfig_dc0="DHCP"

   Substitua dc0 com o valor correto para o sistema.

   A linha adicionada, entao, segue as instruc,oes dadas em Sec,ao 11.5.3,
   "Teste e soluc,ao de problemas".

  Nota:

   Se a rede foi configurada durante a instalac,ao, algumas entradas para a
   NIC podem ja estar presentes. Verifique novamente o /etc/rc.conf antes de
   adicionar novas linhas.

   Se nao existir um servidor DHCP, a NIC deve ser configurada manualmente.
   Adicione uma linha para cada NIC presente no sistema, conforme mostrado
   neste exemplo:

 ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
 ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"

   Substitua dc0 e dc1 e as informac,oes de enderec,o IP com os valores
   corretos para o sistema. Consulte a man page do driver, ifconfig(8) e
   rc.conf(5) para maiores detalhes sobre as opc,oes permitidas e a sintaxe
   de /etc/rc.conf.

   Se a rede nao estiver usando DNS, edite o /etc/hosts para adicionar os
   nomes e enderec,os IP dos hosts na LAN, se eles ainda nao estiverem la.
   Para maiores informac,oes, consulte hosts(5) e
   /usr/share/examples/etc/hosts.

  Nota:

   Se nao houver um servidor DHCP e o acesso `a Internet for necessario,
   configure manualmente o gateway padrao e o nameserver:

 # echo 'defaultrouter="your_default_router"' >> /etc/rc.conf
 # echo 'nameserver your_DNS_server' >> /etc/resolv.conf

  11.5.3. Teste e soluc,ao de problemas

   Uma vez que as alterac,oes necessarias no /etc/rc.conf sejam salvas, uma
   reinicializac,ao pode ser usada para testar a configurac,ao de rede e
   verificar se o sistema e reiniciado sem nenhum erro. Como alternativa,
   aplique as configurac,oes ao sistema de rede com este comando:

 # service netif restart

  Nota:

   Se um gateway padrao foi configurado no /etc/rc.conf, tambem execute este
   comando:

 # service routing restart

   Uma vez que o sistema de rede tiver sido reiniciado, teste as NIC.

    11.5.3.1. Testando uma placa Ethernet

   Para verificar se uma placa Ethernet esta configurada corretamente,
   execute um ping(8) na propria interface e, em seguida, ping(8) outra
   maquina na LAN:

 % ping -c5 192.168.1.3
 PING 192.168.1.3 (192.168.1.3): 56 data bytes
 64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
 64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
 64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
 64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
 64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

 --- 192.168.1.3 ping statistics ---
 5 packets transmitted, 5 packets received, 0% packet loss
 round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms

 % ping -c5 192.168.1.2
 PING 192.168.1.2 (192.168.1.2): 56 data bytes
 64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
 64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
 64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
 64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
 64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

 --- 192.168.1.2 ping statistics ---
 5 packets transmitted, 5 packets received, 0% packet loss
 round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms

   Para testar a resoluc,ao da rede, use o nome do host em vez do enderec,o
   IP. Se nao houver nenhum servidor DNS na rede, o /etc/hosts deve ser
   configurado primeiro. Para este proposito, edite o /etc/hosts para
   adicionar os nomes e os enderec,os IP dos hosts na LAN, se eles ainda nao
   estiverem la . Para maiores informac,oes, consulte hosts(5) e
   /usr/share/examples/etc/hosts.

    11.5.3.2. Soluc,ao de problemas

   Ao solucionar problemas de configurac,oes de hardware e software,
   verifique primeiro as coisas simples. O cabo de rede esta conectado? Os
   servic,os de rede estao configurados corretamente? O firewall esta
   configurado corretamente? A NIC e suportada pelo FreeBSD? Antes de enviar
   um relatorio de bug, sempre verifique as Notas de Hardware, atualize a
   versao do FreeBSD para a versao mais recente do STABLE, verifique os
   arquivos da lista de discussao e pesquise na Internet.

   Se a placa funcionar, mas o desempenho for ruim, leia tuning(7). Alem
   disso, verifique a configurac,ao da rede, pois configurac,oes de rede
   incorretas podem causar conexoes lentas.

   Alguns usuarios experimentam uma ou duas mensagens de device timeout, o
   que e normal para algumas placas. Se eles continuarem ou forem incomodos,
   verifique se o dispositivo esta em conflito com outro. Verifique novamente
   as conexoes dos cabos. Considere tentar outra placa.

   Para resolver erros de watchdog timeout, primeiro verifique o cabo de
   rede. Muitas placas requerem um slot PCI que suporte a masterizac,ao de
   barramento. Em algumas placas-mae antigas, apenas um slot PCI permite,
   normalmente o slot 0. Verifique a NIC e a documentac,ao da placa-mae para
   determinar se esse pode ser o problema.

   As mensagens No route to host ocorrem se o sistema nao puder rotear um
   pacote para o host de destino. Isso pode acontecer se nenhuma rota padrao
   for especificada ou se um cabo for desconectado. Verifique a saida do
   netstat -rn e certifique-se de que haja uma rota valida para o host. Se
   nao houver, leia Sec,ao 31.2, "Gateways e Rotas".

   As mensagens de erro ping: sendto: Permission denied sao geralmente
   causadas por um firewall mal configurado. Se um firewall esta habilitado
   no FreeBSD, mas nenhuma regra foi definida, a politica padrao e negar todo
   o trafego, mesmo o ping(8). Consulte Capitulo 30, Firewalls para maiores
   informac,oes.

   As vezes, o desempenho da placa e ruim ou abaixo da media. Nesses casos,
   tente configurar o modo de selec,ao de midia de autoselect para a selec,ao
   de midia correta. Embora isso funcione para a maioria dos hardwares, isso
   pode ou nao resolver o problema. Novamente, verifique todas as
   configurac,oes de rede e consulte tuning(7).

11.6. Hosts Virtuais

   Um uso comum do FreeBSD e a hospedagem de sites virtuais, onde um servidor
   aparece na rede como muitos servidores. Isso e conseguido atribuindo
   varios enderec,os de rede a uma unica interface.

   Uma determinada interface de rede tem um enderec,o "real" e pode ter
   qualquer numero de enderec,os "alias". Esses aliases sao normalmente
   adicionados colocando entradas de alias no /etc/rc.conf, como mostrado
   neste exemplo:

 ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"

   As entradas de alias devem comec,ar com alias0 usando um numero sequencial
   como alias0, alias1 e assim por diante. O processo de configurac,ao sera
   interrompido no primeiro numero ausente.

   O calculo de mascaras de alias e importante. Para uma determinada
   interface, deve haver um enderec,o que represente corretamente a mascara
   de rede da rede. Qualquer outro enderec,o dentro dessa rede deve ter uma
   mascara de rede toda de 1s, expressa como 255.255.255.255 ou 0xffffffff.

   Por exemplo, considere o caso em que a interface fxp0 esta conectada a
   duas redes: 10.1.1.0 com uma mascara de rede de 255.255.255.0 e
   202.0.75.16 com uma mascara de rede de 255.255.255.240. O sistema deve ser
   configurado para aparecer nos intervalos 10.1.1.1 ate 10.1.1.5 e
   202.0.75.17 ate 202.0.75.20. Somente o primeiro enderec,o em um
   determinado intervalo de rede deve ter uma mascara de rede real. Todo o
   resto de (10.1.1.2 ate 10.1.1.5 e de 202.0.75.18 ate 202.0.75.20) deve ser
   configurado com uma mascara de rede 255.255.255.255.

   As seguintes entradas /etc/rc.conf configuram o adaptador corretamente
   para este cenario:

 ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
 ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
 ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
 ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
 ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
 ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
 ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
 ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
 ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"

   Uma maneira mais simples de expressar isso e com uma lista separada por
   espac,o de intervalos de enderec,os IP. O primeiro enderec,o recebera a
   mascara de sub-rede indicada e os enderec,os adicionais terao uma mascara
   de sub-rede 255.255.255.255.

 ifconfig_fxp0_aliases="inet 10.1.1.1-5/24 inet 202.0.75.17-20/28"

11.7. Configurando o log do sistema

   Contribuido por Niclas Zeising .

   Gerar e ler logs do sistema e um aspecto importante da administrac,ao do
   sistema. As informac,oes nos registros do sistema podem ser usadas para
   detectar problemas de hardware e software, bem como erros de configurac,ao
   dos aplicativos e do sistema. Essas informac,oes tambem desempenham um
   papel importante na auditoria de seguranc,a e na resposta a incidentes. A
   maioria dos daemons e aplicativos do sistema geram entradas de log.

   O FreeBSD fornece um registrador de sistema, o syslogd, para gerenciar o
   registro. Por padrao, o syslogd e iniciado quando o sistema e
   inicializado. Isto e controlado pela variavel syslogd_enable no
   /etc/rc.conf. Existem varios argumentos de aplicac,ao que podem ser
   definidos usando syslogd_flags no /etc/rc.conf. Consulte syslogd(8) para
   obter maiores informac,oes sobre os argumentos disponiveis.

   Esta sec,ao descreve como configurar o criador de logs do sistema FreeBSD
   para log local e remoto e como executar a rotac,ao de log e o
   gerenciamento de log.

  11.7.1. Configurando os logs locais

   O arquivo de configurac,ao, /etc/syslog.conf, controla o que o syslogd faz
   com as entradas de log `a medida que sao recebidas. Existem varios
   parametros para controlar o tratamento de eventos recebidos. O facility
   descreve qual subsistema gerou a mensagem, como o kernel ou um daemon, e o
   level descreve a gravidade do evento que ocorreu. Isso possibilita
   configurar onde uma mensagem de log e registrada, dependendo da
   instalac,ao e do nivel. Tambem e possivel executar uma ac,ao dependendo do
   aplicativo que enviou a mensagem e, no caso de log remoto, o nome do host
   da maquina que gera o evento de log.

   Este arquivo de configurac,ao contem uma linha por ac,ao, em que a sintaxe
   de cada linha e um campo seletor seguido por um campo de ac,ao. A sintaxe
   do campo seletor e facility.level, que correspondera `as mensagens de log
   de facility no nivel level ou superior. Tambem e possivel adicionar um
   sinalizador de comparac,ao opcional antes do nivel para especificar mais
   precisamente o que esta registrado. Varios campos seletores podem ser
   usados para a mesma ac,ao e sao separados por um ponto-e-virgula (;). Usar
   * ira corresponder a tudo. O campo de ac,ao indica para onde enviar a
   mensagem de log, como para um arquivo ou host de log remoto. Por exemplo,
   aqui esta o syslog.conf padrao do FreeBSD:

 # $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
 #
 #       Spaces ARE valid field separators in this file. However,
 #       other *nix-like systems still insist on using tabs as field
 #       separators. If you are sharing this file between systems, you
 #       may want to use only tabs as field separators here.
 #       Consult the syslog.conf(5) manpage.
 *.err;kern.warning;auth.notice;mail.crit                /dev/console
 *.notice;authpriv.none;kern.debug;lpr.info;mail.crit;news.err   /var/log/messages
 security.*                                      /var/log/security
 auth.info;authpriv.info                         /var/log/auth.log
 mail.info                                       /var/log/maillog
 lpr.info                                        /var/log/lpd-errs
 ftp.info                                        /var/log/xferlog
 cron.*                                          /var/log/cron
 !-devd
 *.=debug                                        /var/log/debug.log
 *.emerg                                         *
 # uncomment this to log all writes to /dev/console to /var/log/console.log
 #console.info                                   /var/log/console.log
 # uncomment this to enable logging of all log messages to /var/log/all.log
 # touch /var/log/all.log and chmod it to mode 600 before it will work
 #*.*                                            /var/log/all.log
 # uncomment this to enable logging to a remote loghost named loghost
 #*.*                                            @loghost
 # uncomment these if you're running inn
 # news.crit                                     /var/log/news/news.crit
 # news.err                                      /var/log/news/news.err
 # news.notice                                   /var/log/news/news.notice
 # Uncomment this if you wish to see messages produced by devd
 # !devd
 # *.>=info
 !ppp
 *.*                                             /var/log/ppp.log
 !*

   Neste exemplo:

     * A linha 8 combina todas as mensagens com um nivel de err ou superior,
       bem como kern.warning, auth.notice e mail.crit, e envia essas
       mensagens de log para o console (/dev/console).

     * A linha 12 combina todas as mensagens do recurso mail no nivel info ou
       acima e registra as mensagens em /var/log/maillog.

     * A linha 17 usa um sinalizador de comparac,ao (=) para corresponder
       apenas as mensagens no nivel debug e registra-las em
       /var/log/debug.log.

     * A linha 33 e um exemplo de uso de uma especificac,ao de programa. Isso
       faz com que as regras que a seguem apenas sejam validas para o
       programa especificado. Neste caso, somente as mensagens geradas pelo
       ppp sao registradas em /var/log/ppp.log.

   Os niveis disponiveis, na ordem dos mais para o menos criticos, sao emerg,
   alert, crit, err, warning, notice, info, and debug.

   As facilities, em nenhuma ordem particular, sao auth, authpriv, console,
   cron, daemon, ftp, kern, lpr, mail, mark, news, security, syslog, user,
   uucp, and local0 through local7. Esteja ciente de que outros sistemas
   operacionais podem ter recursos diferentes.

   Para registrar tudo do nivel notice e superior para /var/log/daemon.log,
   adicione a seguinte entrada:

 daemon.notice                                        /var/log/daemon.log

   Para obter mais informac,oes sobre os diferentes niveis e facilities,
   consulte syslog(3) e syslogd(8). Para maiores informac,oes sobre
   /etc/syslog.conf, sua sintaxe e exemplos de uso mais avanc,ados, veja
   syslog.conf(5).

  11.7.2. Gerenciamento de log e rotac,ao

   Os arquivos de log podem crescer rapidamente, ocupando espac,o em disco e
   dificultando a localizac,ao de informac,oes uteis. O gerenciamento de log
   tenta atenuar isso. No FreeBSD, o newsyslog e usado para gerenciar
   arquivos de log. Este programa interno rotaciona e comprime periodicamente
   arquivos de log e, opcionalmente, cria arquivos de log ausentes e sinaliza
   os programas quando os arquivos de log sao movidos. Os arquivos de log
   podem ser gerados pelo syslogd ou por qualquer outro programa que gere
   arquivos de log. Enquanto o newsyslog e normalmente executado a partir do
   cron(8), ele nao e um daemon do sistema. Na configurac,ao padrao, ele e
   executado a cada hora.

   Para saber quais ac,oes executar, o newsyslog le seu arquivo de
   configurac,ao, /etc/newsyslog.conf. Este arquivo contem uma linha para
   cada arquivo de log que o newsyslog gerencia. Cada linha indica o
   proprietario do arquivo, suas permissoes, quando rotacionar esse arquivo,
   flags opcionais que afetam a rotac,ao do log, como compactac,ao, e
   programas para sinalizar quando o log e rotacionado. Aqui esta a
   configurac,ao padrao no FreeBSD:

 # configuration file for newsyslog
 # $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
 #
 # Entries which do not specify the '/pid_file' field will cause the
 # syslogd process to be signalled when that log file is rotated.  This
 # action is only appropriate for log files which are written to by the
 # syslogd process (ie, files listed in /etc/syslog.conf).  If there
 # is no process which needs to be signalled when a given log file is
 # rotated, then the entry for that file should include the 'N' flag.
 #
 # The 'flags' field is one or more of the letters: BCDGJNUXZ or a '-'.
 #
 # Note: some sites will want to select more restrictive protections than the
 # defaults.  In particular, it may be desirable to switch many of the 644
 # entries to 640 or 600.  For example, some sites will consider the
 # contents of maillog, messages, and lpd-errs to be confidential.  In the
 # future, these defaults may change to more conservative ones.
 #
 # logfilename          [owner:group]    mode count size when  flags [/pid_file] [sig_num]
 /var/log/all.log                        600  7     *    @T00  J
 /var/log/amd.log                        644  7     100  *     J
 /var/log/auth.log                       600  7     100  @0101T JC
 /var/log/console.log                    600  5     100  *     J
 /var/log/cron                           600  3     100  *     JC
 /var/log/daily.log                      640  7     *    @T00  JN
 /var/log/debug.log                      600  7     100  *     JC
 /var/log/kerberos.log                   600  7     100  *     J
 /var/log/lpd-errs                       644  7     100  *     JC
 /var/log/maillog                        640  7     *    @T00  JC
 /var/log/messages                       644  5     100  @0101T JC
 /var/log/monthly.log                    640  12    *    $M1D0 JN
 /var/log/pflog                          600  3     100  *     JB    /var/run/pflogd.pid
 /var/log/ppp.log        root:network    640  3     100  *     JC
 /var/log/devd.log                       644  3     100  *     JC
 /var/log/security                       600  10    100  *     JC
 /var/log/sendmail.st                    640  10    *    168   B
 /var/log/utx.log                        644  3     *    @01T05 B
 /var/log/weekly.log                     640  5     1    $W6D0 JN
 /var/log/xferlog                        600  7     100  *     JC

   Cada linha comec,a com o nome do log a ser rotacionado, seguido
   opcionalmente por um proprietario e um grupo para arquivos rotacionados e
   recem-criados. O campo mode define as permissoes no arquivo de log e count
   indica quantos arquivos de log rotacionados devem ser mantidos. Os campos
   size e when informam o newsyslog quando rotacionar o arquivo. Um arquivo
   de log e rotacionado quando seu tamanho e maior que o campo size ou quando
   o tempo no campo when tiver terminado. Um asterisco (*) significa que este
   campo e ignorado. O campo flags fornece instruc,oes adicionais, por
   exemplo, como compactar o arquivo rotacionado ou criar o arquivo de log se
   ele estiver ausente. Os dois ultimos campos sao opcionais e especificam o
   nome do arquivo de ID de Processo (PID) e um numero de sinal para enviar a
   esse processo quando o arquivo e rotacionado.

   Para obter maiores informac,oes sobre todos os campos, sinalizadores
   validos e como sobre especificar o tempo de rotac,ao, consulte
   newsyslog.conf(5). Como o newsyslog e executado a partir do cron(8), ele
   nao pode rotacionar arquivos com mais frequencia do que a que esta
   planejada para ser executada no cron(8).

  11.7.3. Configurando o log remoto

   Contribuido por Tom Rhodes.

   Monitorar os arquivos de log de varios hosts pode se tornar dificil `a
   medida que o numero de sistemas aumenta. Configurar o log centralizado
   pode reduzir parte da carga administrativa da administrac,ao dos arquivos
   de log.

   No FreeBSD, a agregac,ao, a fusao e a rotac,ao centralizada de arquivos de
   log podem ser configuradas usando o syslogd e o newsyslog. Esta sec,ao
   demonstra um exemplo de configurac,ao, em que host o A, chamado
   logserv.example.com, coletara informac,oes de log para a rede local. O
   host B, denominado logclient.example.com, sera configurado para transmitir
   informac,oes de log para o servidor de registro em log.

    11.7.3.1. Configurac,ao do servidor de log

   Um servidor de log e um sistema que foi configurado para aceitar
   informac,oes de log de outros hosts. Antes de configurar um servidor de
   log, verifique o seguinte:

     * Se houver um firewall entre o servidor de log e qualquer cliente de
       log, certifique-se de que o conjunto de regras do firewall permita a
       porta 514 do UDP para os clientes e o servidor.

     * O servidor de log e todas as maquinas clientes devem ter entradas de
       nome diretas e reversas no DNS local. Se a rede nao tiver um servidor
       DNS, crie entradas no /etc/hosts de cada sistema. A resoluc,ao
       adequada de nomes e necessaria para que as entradas de log nao sejam
       rejeitadas pelo servidor de log.

   No servidor de log, edite o /etc/syslog.conf para especificar o nome do
   cliente para receber as entradas de log, o recurso de log a ser usado e o
   nome do log para armazenar as entradas de log do host. Este exemplo
   adiciona o nome do host de B, registra todos os recursos e armazena as
   entradas de log em /var/log/logclient.log.

   Exemplo 11.1. Configurac,ao do servidor de log de exemplo

 +logclient.example.com
 *.*     /var/log/logclient.log

   Ao adicionar varios clientes de log, adicione uma entrada semelhante de
   duas linhas para cada cliente. Maiores informac,oes sobre os recursos
   disponiveis podem ser encontradas em syslog.conf(5).

   Em seguida, configure o /etc/rc.conf:

 syslogd_enable="YES"
 syslogd_flags="-a logclient.example.com -v -v"

   A primeira entrada inicia o syslogd na inicializac,ao do sistema. A
   segunda entrada permite entradas de log do cliente especificado. A opc,ao
   -v -v aumenta a verbosidade das mensagens registradas. Isso e util para
   ajustar os recursos, pois os administradores podem ver o tipo de mensagens
   que estao sendo registradas em cada facility.

   Multiplas opc,oes -a podem ser especificadas para permitir o registro de
   multiplos clientes. Enderec,os IP e netblocks inteiros tambem podem ser
   especificados. Consulte syslogd(8) para obter uma lista completa de
   opc,oes possiveis.

   Finalmente, crie o arquivo de log:

 # touch /var/log/logclient.log

   Neste ponto, o syslogd deve ser reiniciado e verificado:

 # service syslogd restart
 # pgrep syslog

   Se um PID for retornado, o servidor sera reiniciado com exito e a
   configurac,ao do cliente podera ser iniciada. Se o servidor nao reiniciar,
   consulte /var/log/messages para visualizar o erro.

    11.7.3.2. Configurac,ao do cliente de log

   Um cliente de log envia entradas de log para um servidor de log na rede. O
   cliente tambem mantem uma copia local de seus proprios logs.

   Uma vez que o servidor de log foi configurado, edite o /etc/rc.conf no
   cliente de registro:

 syslogd_enable="YES"
 syslogd_flags="-s -v -v"

   A primeira entrada ativa o syslogd na inicializac,ao. A segunda entrada
   impede que os logs sejam aceitos por esse cliente de outros hosts (-s) e
   aumenta a verbosidade das mensagens registradas.

   Em seguida, defina o servidor de log no /etc/syslog.conf do cliente. Neste
   exemplo, todos os facilities registrados sao enviados para um sistema
   remoto, indicado pelo simbolo @, com o nome do host especificado:

 *.*             @logserv.example.com

   Depois de salvar a edic,ao, reinicie o syslogd para que as alterac,oes
   entrem em vigor:

 # service syslogd restart

   Para testar se as mensagens de log estao sendo enviadas pela rede, use o
   logger(1) no cliente para enviar uma mensagem para syslogd:

 # logger "Test message from logclient"

   Esta mensagem agora deve existir tanto no /var/log/messages do cliente e
   no /var/log/logclient.log do servidor de log.

    11.7.3.3. Debugando servidores de log

   Se nenhuma mensagem estiver sendo recebida no servidor de log, a causa
   provavelmente e um problema de conectividade de rede, um problema de
   resoluc,ao de nome de host ou um erro de digitac,ao em um arquivo de
   configurac,ao. Para isolar a causa, certifique-se de que o servidor de log
   e o cliente de log sejam capazes de comunicarem atraves do ping usando o
   nome do host especificado em seu /etc/rc.conf. Se isso falhar, verifique o
   cabeamento da rede, o conjunto de regras do firewall e as entradas de nome
   de host no servidor DNS ou /etc/hosts no servidor de log e nos clientes.
   Repita ate que o ping seja bem-sucedido em ambos os hosts.

   Se o ping for bem-sucedido em ambos os hosts, mas as mensagens de log
   ainda nao estiverem sendo recebidas, aumente temporariamente o
   detalhamento do log para diminuir o problema de configurac,ao. No exemplo
   a seguir, o /var/log/logclient.log no servidor de log esta vazio e o
   /var/log/messages no cliente de log nao indica uma razao para a falha.
   Para aumentar a saida de debug, edite a entrada syslogd_flags no servidor
   de log e execute uma reinicializac,ao:

 syslogd_flags="-d -a logclient.example.com -v -v"

 # service syslogd restart

   Dados de debug semelhantes aos seguintes irao aparecer no console
   imediatamente apos a reinicializac,ao:

 logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
 syslogd: restarted
 logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
 Logging to FILE /var/log/messages
 syslogd: kernel boot file is /boot/kernel/kernel
 cvthname(192.168.1.10)
 validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com;
 rejected in rule 0 due to name mismatch.

   Neste exemplo, as mensagens de log estao sendo rejeitadas devido a um erro
   de digitac,ao que resulta em uma incompatibilidade de nome de host. O nome
   do host do cliente deve ser logclient, nao logclien. Corrija o erro de
   digitac,ao, execute uma reinicializac,ao e verifique os resultados:

 # service syslogd restart
 logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
 syslogd: restarted
 logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
 syslogd: kernel boot file is /boot/kernel/kernel
 logmsg: pri 166, flags 17, from logserv.example.com,
 msg Dec 10 20:55:02 <syslog.err> logserv.example.com syslogd: exiting on signal 2
 cvthname(192.168.1.10)
 validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com;
 accepted in rule 0.
 logmsg: pri 15, flags 0, from logclient.example.com, msg Dec 11 02:01:28 trhodes: Test message 2
 Logging to FILE /var/log/logclient.log
 Logging to FILE /var/log/messages

   Neste ponto, as mensagens estao sendo recebidas e colocadas corretamente
   no arquivo correto.

    11.7.3.4. Considerac,oes de seguranc,a

   Como com qualquer servic,o de rede, os requisitos de seguranc,a devem ser
   considerados antes de implementar um servidor de log. Os arquivos de log
   podem conter dados confidenciais sobre servic,os ativados no host local,
   contas de usuario e dados de configurac,ao. Os dados enviados pela rede do
   cliente para o servidor nao serao criptografados nem protegidos por senha.
   Se houver necessidade de criptografia, considere o uso do
   security/stunnel, que transmitira os dados de log em um tunel
   criptografado.

   A seguranc,a local tambem e um problema. Os arquivos de log nao sao
   criptografados durante o uso ou apos a rotac,ao do log. Usuarios locais
   podem acessar arquivos de log para obter informac,oes adicionais sobre a
   configurac,ao do sistema. Definir permissoes adequadas nos arquivos de log
   e critico. O rotacionador de log integrado, newsyslog, suporta a
   configurac,ao de permissoes em arquivos de log recem-criados e
   rotacionados. A configurac,ao de arquivos de log no modo 600 deve impedir
   o acesso indesejado por usuarios locais. Consulte newsyslog.conf(5) para
   obter informac,oes adicionais.

11.8. Arquivos de Configurac,ao

  11.8.1. Layout do /etc

   Existem varios diretorios nos quais as informac,oes de configurac,ao sao
   mantidas. Estes incluem:

   /etc                Informac,oes de configurac,ao especifica do sistema    
                       generico.                                              
   /etc/defaults       Versoes padrao dos arquivos de configurac,ao do        
                       sistema.                                               
   /etc/mail           Configurac,ao extra do sendmail(8) e outros arquivos   
                       de configurac,ao MTA.                                  
   /etc/ppp            Configurac,ao para ambos os programas, user- e         
                       kernel-ppp.                                            
   /usr/local/etc      Arquivos de configurac,ao para aplicativos instalados. 
                       Pode conter subdiretorios para cada aplicativo.        
   /usr/local/etc/rc.d scripts rc(8) para os aplicativos instalados.          
                       Arquivos de banco de dados especificos do sistema      
   /var/db             gerados automaticamente, como o banco de dados de      
                       pacotes e o banco de dados locate(1).                  

  11.8.2. Hostnames

    11.8.2.1. /etc/resolv.conf

   Como um sistema FreeBSD acessa o Sistema de Nomes de Dominio da Internet
   (Internet Domain Name System - DNS) e controlado por resolv.conf(5).

   As entradas mais comuns para o /etc/resolv.conf sao:

              O enderec,o IP de um servidor de nomes que o resolvedor deve    
   nameserver consultar. Os servidores sao consultados na ordem listada com   
              um maximo de tres.                                              
   search     Lista de pesquisa, para busca de nomes de host. Isso e          
              normalmente determinado pelo dominio do nome do host local.     
   domain     O nome do dominio local.                                        

   Um tipico /etc/resolv.conf e assim:

 search example.com
 nameserver 147.11.1.11
 nameserver 147.11.100.30

  Nota:

   Apenas uma das opc,oes search e domain deve ser usada.

   Ao usar o DHCP, o dhclient(8) geralmente reescreve o /etc/resolv.conf com
   informac,oes recebidas do servidor DHCP.

    11.8.2.2. /etc/hosts

   O /etc/hosts e um banco de dados de texto simples que funciona em conjunto
   com o DNS e o NIS para fornecer o nome do host aos mapeamentos de
   enderec,os IP. Entradas para computadores locais conectados atraves de uma
   LAN podem ser adicionadas a este arquivo para propositos simplistas de
   nomeac,ao em vez de configurar um servidor named(8). Alem disso, o
   /etc/hosts pode ser usado para fornecer um registro local de nomes da
   Internet, reduzindo a necessidade de consultar servidores DNS externos
   para nomes comumente acessados.

 # $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
 #
 #
 # Host Database
 #
 # This file should contain the addresses and aliases for local hosts that
 # share this file.  Replace 'my.domain' below with the domainname of your
 # machine.
 #
 # In the presence of the domain name service or NIS, this file may
 # not be consulted at all; see /etc/nsswitch.conf for the resolution order.
 #
 #
 ::1                     localhost localhost.my.domain
 127.0.0.1               localhost localhost.my.domain
 #
 # Imaginary network.
 #10.0.0.2               myname.my.domain myname
 #10.0.0.3               myfriend.my.domain myfriend
 #
 # According to RFC 1918, you can use the following IP networks for
 # private nets which will never be connected to the Internet:
 #
 #       10.0.0.0        -   10.255.255.255
 #       172.16.0.0      -   172.31.255.255
 #       192.168.0.0     -   192.168.255.255
 #
 # In case you want to be able to connect to the Internet, you need
 # real official assigned numbers.  Do not try to invent your own network
 # numbers but instead get one from your network provider (if any) or
 # from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
 #

   O formato do /etc/hosts e o seguinte:

 [Internet address] [official hostname] [alias1] [alias2] ...

   Por exemplo:

 10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2

   Consulte hosts(5) para obter maiores informac,oes.

11.9. Efetuando ajustes com o sysctl(8)

   O sysctl(8) e usado para fazer mudanc,as em um sistema FreeBSD em
   execuc,ao. Isso inclui muitas opc,oes avanc,adas da stack TCP/IP e do
   sistema de memoria virtual as quais podem melhorar drasticamente o
   desempenho do FreeBSD para um administrador de sistema experiente. Mais de
   quinhentas variaveis do sistema podem ser lidas e definidas usando o
   sysctl(8).

   Em sua essencia, o sysctl(8) serve duas func,oes: ler e modificar as
   configurac,oes do sistema.

   Para ver todas as variaveis legiveis:

 % sysctl -a

   Para ler uma variavel especifica, especifique seu nome:

 % sysctl kern.maxproc
 kern.maxproc: 1044

   Para definir uma variavel especifica, use a sintaxe variable=value:

 # sysctl kern.maxfiles=5000
 kern.maxfiles: 2088 -> 5000

   As configurac,oes das variaveis sysctl sao geralmente strings, numeros ou
   booleanos, onde um booleano e 1 para sim 0 para nao.

   Para definir automaticamente algumas variaveis sempre que a maquina
   inicializar, adicione-as ao /etc/sysctl.conf. Para maiores informac,oes,
   consulte sysctl.conf(5) e Sec,ao 11.9.1, "sysctl.conf".

  11.9.1. sysctl.conf

   O arquivo de configurac,ao para o sysctl(8), /etc/sysctl.conf, se parece
   muito com o /etc /rc.conf. Os valores sao definidos na forma
   variable=value. Os valores especificados sao definidos apos o sistema
   entrar no modo multiusuario. Nem todas as variaveis sao configuraveis
   neste modo.

   Por exemplo, para desativar o log de saidas de sinais fatais e impedir que
   os usuarios vejam processos iniciados por outros usuarios, os seguintes
   ajustes podem ser configurados em /etc/sysctl.conf:

 # Do not log fatal signal exits (e.g., sig 11)
 kern.logsigexit=0

 # Prevent users from seeing information about processes that
 # are being run under another UID.
 security.bsd.see_other_uids=0

  11.9.2. Variaveis sysctl(8) apenas de leitura

   Contribuido por Tom Rhodes.

   Em alguns casos, pode ser desejavel modificar os valores de variaveis do
   sysctl(8) que sao somente de leitura, o que exigira uma reinicializac,ao
   do sistema.

   Por exemplo, em alguns modelos de laptops, o dispositivo cardbus(4) nao
   examinara os intervalos de memoria e falhara com erros semelhantes a:

 cbb0: Could not map register memory
 device_probe_and_attach: cbb0 attach returned 12

   A correc,ao requer a modificac,ao de uma configurac,ao definida por uma
   variavel do sysctl(8) que e somente de leitura. Adicione
   hw.pci.allow_unsupported_io_range=1 ao arquivo /boot/loader.conf e
   reinicie. Agora o cardbus(4) deve funcionar corretamente.

11.10. Otimizac,ao de Discos

   A sec,ao a seguir discutira varios mecanismos e opc,oes de ajuste que
   podem ser aplicados a dispositivos de disco. Em muitos casos, discos com
   partes mecanicas, como unidades SCSI, serao o gargalo que reduz o
   desempenho geral do sistema. Embora a soluc,ao seja instalar uma unidade
   sem pec,as mecanicas, como uma unidade de estado solido, as unidades
   mecanicas nao irao desaparecer num futuro proximo. Quando estiver
   otimizando discos, e aconselhavel utilizar os recursos do comando
   iostat(8) para testar varias mudanc,as no sistema. Este comando permitira
   ao usuario obter informac,oes valiosas sobre o sistema IO.

  11.10.1. Variaveis Sysctl

    11.10.1.1. vfs.vmiodirenable

   A variavel vfs.vmiodirenable sysctl(8) pode ser definida como 0 (off ) ou
   1 (on). Esta definida para 1 por padrao. Esta variavel controla como os
   diretorios sao armazenados em cache pelo sistema. A maioria dos diretorios
   e pequena, usando apenas um unico fragmento (normalmente 1K) no sistema de
   arquivos e, normalmente, 512 bytes no cache de buffer. Com esta variavel
   desativada, o cache de buffer armazenara apenas um numero fixo de
   diretorios, mesmo que o sistema tenha uma quantidade enorme de memoria.
   Quando ativado, este sysctl(8) permite que o cache de buffer use o cache
   de pagina VM para armazenar em cache os diretorios, disponibilizando toda
   a memoria para fazer cache dos diretorios. No entanto, a memoria minima no
   nucleo usada para armazenar em cache um diretorio e o tamanho da pagina
   fisica (geralmente 4K) em vez de 512 bytes. Manter esta opc,ao ativada e
   recomendado se o sistema estiver executando quaisquer servic,os que
   manipulem um grande numero de arquivos. Esses servic,os podem incluir
   caches da web, grandes sistemas de correio e sistemas de noticias. Manter
   essa opc,ao geralmente nao reduz o desempenho, mesmo com a memoria
   desperdic,ada, mas deve-se experimentar para descobrir.

    11.10.1.2. vfs.write_behind

   A variavel vfs.write_behind sysctl(8) e padronizada para 1 (ligada). Isso
   informa ao sistema de arquivos para emitir gravac,oes de midia `a medida
   que clusters completos sao coletados, o que normalmente ocorre ao gravar
   arquivos sequenciais grandes. Isso evita saturar o cache de buffer com
   buffers sujos quando nao beneficia o desempenho de I/O. No entanto, isso
   pode atrasar os processos e, sob certas circunstancias, deve ser
   desativado.

    11.10.1.3. vfs.hirunningspace

   A variavel vfs.hirunningspace sysctl(8) determina quanto de I/O de
   gravac,ao pendente pode ser enfileirado no sistema de controladores de
   disco como um todo em qualquer instancia. O padrao e geralmente
   suficiente, mas em maquinas com muitos discos, tente aumentar para quatro
   ou cinco megabytes. Definir um valor muito alto, que exceda o limite de
   gravac,ao do cache de buffer, pode levar a um mau desempenho de cluster.
   Nao defina esse valor arbitrariamente alto, pois valores de gravac,ao mais
   altos podem adicionar latencia a leituras que ocorrem ao mesmo tempo.

   Ha varios outros caches de buffer e valores de cache de pagina VM
   relacionados a sysctl(8). Modificar esses valores nao e recomendado, pois
   o sistema VM faz um bom trabalho de ajuste automatico.

    11.10.1.4. vm.swap_idle_enabled

   A variavel vm.swap_idle_enabled sysctl(8) e util em grandes sistemas
   multiusuarios com muitos usuarios ativos, e muitos processos ociosos. Tais
   sistemas tendem a gerar pressao continua nas reservas de memoria livre.
   Ativar esse recurso e aprimorar a histerese de troca (em segundos ociosos)
   por meio de vm.swap_idle_threshold1 e vm.swap_idle_threshold2 reduz a
   prioridade das paginas de memoria associadas aos processos inativos mais
   rapidamente do que no algoritmo de pageout normal. Isso da uma ajuda ao
   daemon de pageout. Apenas ative essa opc,ao se necessario, porque a
   compensac,ao e essencialmente fazer o pre-page da memoria mais cedo, o que
   consome mais swap e largura de banda de disco. Em um sistema pequeno, esta
   opc,ao tera um efeito determinavel, mas em um sistema grande que ja esta
   paginando moderadamente, esta opc,ao permite que o sistema VM instale
   processos inteiros dentro e fora da memoria facilmente.

    11.10.1.5. hw.ata.wc

   Desativar o cache de gravac,ao IDE reduz a largura de banda de gravac,ao
   em discos IDE, mas `as vezes pode ser necessario devido a problemas de
   consistencia de dados introduzidos por fornecedores de disco rigido. O
   problema e que algumas unidades IDE mentem sobre quando uma gravac,ao e
   concluida. Com o cache de gravac,ao IDE ativado, os discos rigidos IDE
   gravam os dados fora de ordem e `as vezes atrasam a gravac,ao de alguns
   blocos indefinidamente quando estao sob carga pesada de disco. Uma falha
   ou falha de energia pode causar corrupc,ao seria do sistema de arquivos.
   Verifique o padrao no sistema observando a variavel hw.ata.wc sysctl(8).
   Se o cache de gravac,ao IDE estiver desativado, pode-se definir essa
   variavel somente leitura como 1 em /boot/loader.conf para ativar no
   momento da inicializac,ao.

   Para maiores informac,oes, consulte ata(4).

    11.10.1.6. SCSI_DELAY (kern.cam.scsi_delay)

   A opc,ao de configurac,ao do kernel SCSI_DELAY pode ser usada para reduzir
   os tempos de inicializac,ao do sistema. Os padroes sao razoavelmente altos
   e podem ser responsaveis por 15 segundos de atraso no processo de
   inicializac,ao. Reduzindo-o para 5 segundos geralmente funciona com
   unidades modernas. A variavel de tempo de inicializac,ao
   kern.cam.scsi_delay deve ser usada. A opc,ao de configurac,ao ajustavel e
   a configurac,ao do kernel aceitam valores em termos de milissegundos e nao
   segundos.

  11.10.2. Soft Updates

   Para ajustar um sistema de arquivos, use tunefs(8). Este programa tem
   muitas opc,oes diferentes. Para ativar e desativar o Soft Updates, use:

 # tunefs -n enable /filesystem
 # tunefs -n disable /filesystem

   Um sistema de arquivos nao pode ser modificado com tunefs(8) enquanto
   estiver montado. Um bom momento para ativar o Soft Updates e antes que
   qualquer partic,ao tenha sido montada, no modo de single-user.

   O Soft Updates e recomendado para sistemas de arquivos UFS, pois melhora
   drasticamente o desempenho de metadados, principalmente a criac,ao e
   exclusao de arquivos, atraves do uso de um cache em memoria. Ha duas
   desvantagens no Soft Updates que voce deve conhecer. Primeiro, o Soft
   Updates garante a consistencia do sistema de arquivos no caso de uma
   falha, mas pode facilmente levar varios segundos ou ate um minuto para
   atualizar o disco fisico. Se o sistema falhar, os dados nao gravados
   poderao ser perdidos. Em segundo lugar, os Soft Updates atrasam a
   liberac,ao de blocos do sistema de arquivos. Se o sistema de arquivos raiz
   estiver quase cheio, a execuc,ao de uma atualizac,ao importante, como make
   installworld, podera causar a falta de espac,o do sistema de arquivos e a
   atualizac,ao falhara.

    11.10.2.1. Mais detalhes sobre soft updates

   As atualizac,oes de metadados sao atualizac,oes para dados que nao sao de
   conteudo, como inodes ou diretorios. Existem duas abordagens tradicionais
   para gravar os metadados de um sistema de arquivos em disco.

   Historicamente, o comportamento padrao era gravar atualizac,oes de
   metadados de forma sincrona. Se um diretorio fosse alterado, o sistema
   aguardava ate que a alterac,ao fosse gravada no disco. Os buffers de dados
   do arquivo (conteudo do arquivo) foram passados pelo cache de buffer e
   foram copiados para o disco posteriormente de maneira assincrona. A
   vantagem dessa implementac,ao e que ela opera com seguranc,a. Se houver
   uma falha durante uma atualizac,ao, os metadados estarao sempre em um
   estado consistente. Um arquivo e criado completamente ou nao e de todo. Se
   os blocos de dados de um arquivo nao encontrarem saida do cache de buffer
   para o disco no momento da falha, o fsck(8) reconhece isso e repara o
   sistema de arquivos definindo o comprimento do arquivo como 0. Alem disso,
   a implementac,ao e clara e simples. A desvantagem e que as alterac,oes nos
   metadados sao lentas. Por exemplo, rm -r toca todos os arquivos em um
   diretorio sequencialmente, mas cada alterac,ao de diretorio sera gravada
   de forma sincrona no disco. Isso inclui atualizac,oes para o proprio
   diretorio, para a tabela de inode e possivelmente para blocos indiretos
   alocados pelo arquivo. Considerac,oes semelhantes aplicam-se ao desenrolar
   hierarquias grandes usando tar -x.

   A segunda abordagem e usar atualizac,oes de metadados assincronas. Este e
   o padrao para um sistema de arquivos UFS montado com mount -o async. Como
   todas as atualizac,oes de metadados tambem sao passadas pelo cache de
   buffer, elas serao mescladas com as atualizac,oes dos dados de conteudo do
   arquivo. A vantagem dessa implementac,ao e que nao ha necessidade de
   esperar ate que cada atualizac,ao de metadados seja gravada no disco,
   portanto, todas as operac,oes que causam grandes quantidades de
   atualizac,oes de metadados funcionam muito mais rapido do que no caso
   sincrono. Essa implementac,ao ainda e clara e simples, portanto, ha um
   baixo risco de erros se infiltrarem no codigo. A desvantagem e que nao ha
   garantia para um estado consistente do sistema de arquivos. Se houver uma
   falha durante uma operac,ao que atualizou grandes quantidades de
   metadados, como uma falha de energia ou alguem pressionando o botao de
   reinicializac,ao, o sistema de arquivos sera deixado em um estado
   imprevisivel. Nao ha oportunidade de examinar o estado do sistema de
   arquivos quando o sistema e reativado, pois os blocos de dados de um
   arquivo ja podem ter sido gravados no disco enquanto as atualizac,oes da
   tabela de inodes ou do diretorio associado nao foram. E impossivel
   implementar um fsck(8) que e capaz de limpar o caos resultante porque as
   informac,oes necessarias nao estao disponiveis no disco. Se o sistema de
   arquivos foi danificado alem do reparo, a unica opc,ao e reformata-lo e
   restaura-lo a partir do backup.

   A soluc,ao usual para este problema e implementar dirty region logging,
   que tambem e chamado de journaling. As atualizac,oes de metadados ainda
   sao gravadas de forma sincrona, mas apenas em uma pequena regiao do disco.
   Mais tarde, eles sao movidos para o local apropriado. Como a area de
   registro e uma regiao pequena e contigua no disco, nao ha longas
   distancias para as cabec,as de disco se moverem, mesmo durante operac,oes
   pesadas, portanto, essas operac,oes sao mais rapidas do que as
   atualizac,oes sincronas. Alem disso, a complexidade da implementac,ao e
   limitada, portanto, o risco de erros estarem presentes e baixo. Uma
   desvantagem e que todos os meta-dados sao gravados duas vezes, uma vez na
   regiao de registro e uma vez no local apropriado, portanto, pode resultar
   em "piora" na performance. Por outro lado, em caso de falha, todas as
   operac,oes de metadados pendentes podem ser rapidamente recuperadas ou
   concluidas a partir da area de registro depois que o sistema for ativado
   novamente, resultando em uma inicializac,ao rapida do sistema de arquivos.

   Kirk McKusick, o desenvolvedor do Berkeley FFS, resolveu esse problema com
   o Soft Updates. Todas as atualizac,oes de meta-dados pendentes sao
   mantidas na memoria e gravadas no disco em uma sequencia ordenada
   ("atualizac,oes de metadados ordenadas"). Isso tem o efeito de que, no
   caso de operac,oes pesadas de meta-dados, atualizac,oes posteriores em um
   item "catch" as anteriores que ainda estao na memoria e ainda nao foram
   gravadas no disco. Todas as operac,oes sao geralmente executadas na
   memoria antes da atualizac,ao ser gravada no disco e os blocos de dados
   sao classificados de acordo com sua posic,ao, de modo que nao estarao no
   disco antes de seus meta-dados. Se o sistema travar, um "reenvio de log"
   implicito faz com que todas as operac,oes que nao foram gravadas no disco
   aparec,am como se nunca tivessem acontecido. Um estado consistente do
   sistema de arquivos e mantido e parece ser o de 30 a 60 segundos antes. O
   algoritmo usado garante que todos os recursos em uso sejam marcados como
   tal em seus blocos e inodes. Apos uma falha, o unico erro de alocac,ao de
   recursos que ocorre e que os recursos sao marcados como "used", que sao,
   na verdade, "free". O fsck(8) reconhece essa situac,ao e libera os
   recursos que nao sao mais usados. E seguro ignorar o estado sujo do
   sistema de arquivos apos uma falha forc,ando a montagem com mount -f. Para
   liberar recursos que podem nao ser utilizados, O fsck(8) precisa ser
   executado posteriormente. Esta e a ideia por tras do fsck(8) em
   background: no momento da inicializac,ao do sistema, apenas um snapshot do
   sistema de arquivos e gravado e o fsck(8) e executado posteriormente.
   Todos os sistemas de arquivos podem ser montados "sujos", para que a
   inicializac,ao do sistema prossiga no modo multiusuario. Em seguida, o
   fsck(8) em background e planejado para todos os sistemas de arquivos em
   que isso e necessario, para liberar recursos que podem nao ser utilizados.
   Os sistemas de arquivos que nao usam Soft Updates ainda precisam executar
   o fsck(8) em primeiro plano de forma usual .

   A vantagem e que as operac,oes de meta-dados sao quase tao rapidas quanto
   as atualizac,oes assincronas e sao mais rapidas que o logging, que precisa
   escrever os meta-dados duas vezes. As desvantagens sao a complexidade do
   codigo, um maior consumo de memoria e algumas idiosincrasias. Depois de
   uma falha, o estado do sistema de arquivos parece ser um pouco mais
   "velho". Em situac,oes onde a abordagem sincrona padrao teria causado a
   existencia de alguns arquivos de comprimento zero apos o fsck(8), esses
   arquivos sequer chegam a existir com Soft Updates porque nem os metadados
   e nem o conteudo do arquivo foram gravados no disco. O espac,o em disco
   nao e liberado ate que as atualizac,oes tenham sido gravadas no disco, o
   que pode ocorrer algum tempo depois de executar rm(1). Isso pode causar
   problemas ao instalar grandes quantidades de dados em um sistema de
   arquivos que nao tenha espac,o livre suficiente para armazenar todos os
   arquivos duas vezes.

11.11. Ajustando os Limites do Kernel

  11.11.1. Limites de arquivos/processos

    11.11.1.1. kern.maxfiles

   A variavel kern.maxfiles sysctl(8) pode ser aumentada ou diminuida com
   base nos requisitos do sistema. Essa variavel indica o numero maximo de
   descritores de arquivos no sistema. Quando a tabela do descritor de
   arquivos estiver cheia, o erro file: table is full aparecera repetidamente
   no buffer de mensagem do sistema, que pode ser visualizado usando
   dmesg(8).

   Cada arquivo aberto, socket ou fifo usa um descritor de arquivo. Um
   servidor de produc,ao em larga escala pode facilmente exigir muitos
   milhares de descritores de arquivos, dependendo do tipo e numero de
   servic,os executados simultaneamente.

   Em versoes mais antigas do FreeBSD, o valor padrao de kern.maxfiles e
   derivado do maxusers no arquivo de configurac,ao do kernel. O
   kern.maxfiles cresce proporcionalmente ao valor do maxusers. Ao compilar
   um kernel personalizado, considere configurar esta opc,ao de configurac,ao
   do kernel de acordo com o uso do sistema. A partir desse numero, o kernel
   recebe a maioria dos seus limites predefinidos. Mesmo que uma maquina de
   produc,ao nao tenha 256 usuarios simultaneos, os recursos necessarios
   podem ser semelhantes a um servidor da Web de alta escala.

   A variavel read-only sysctl(8)kern.maxusers e dimensionada automaticamente
   na inicializac,ao com base na quantidade de memoria disponivel no sistema,
   e pode ser determinado em tempo de execuc,ao, inspecionando o valor de
   kern.maxusers. Alguns sistemas requerem valores maiores ou menores de
   kern.maxusers e valores de 64, 128, e 256 nao sao incomuns. Ir acima de
   256 nao e recomendado, a menos que seja necessario um grande numero de
   descritores de arquivos. Muitos dos valores ajustaveis definidos para seus
   padroes por kern.maxusers podem ser individualmente sobrescritos no tempo
   de inicializac,ao ou em tempo de execuc,ao no /boot/loader.conf. Consulte
   loader.conf( 5 ) e /boot/defaults/loader.conf para mais detalhes e algumas
   dicas.

   Em versoes mais antigas, o sistema ajustara automaticamente o maxusers se
   ele estiver definido como 0. [2]. Ao configurar esta opc,ao, configure o
   maxusers para pelo menos 4, especialmente se o sistema executar o Xorg ou
   se for usado para compilar software. A tabela mais importante definida por
   maxusers e o numero maximo de processos, que e definido como 20 + 16 *
   maxusers. Se maxusers for definido como 1, so podem existir 36 processos
   simultaneos, incluindo 18 ou mais para que o sistema seja iniciado no boot
   ou 15 usado pelo Xorg. Ate mesmo uma tarefa simples, como ler uma pagina
   de manual, iniciara nove processos para filtrar, descompactar e
   visualizar. Configurar o maxusers para 64 permite ate 1044 processos
   simultaneos, o que deve ser suficiente para quase todos os usos. Se, no
   entanto, o erro proc table full for exibido ao tentar iniciar outro
   programa ou se um servidor estiver sendo executado com um grande numero de
   usuarios simultaneos, aumente o numero e recompile.

  Nota:

   O maxusers nao limita o numero de usuarios que podem logar na maquina. Em
   vez disso, ele configura varios tamanhos de tabela para valores razoaveis,
   considerando o numero maximo de usuarios no sistema e quantos processos
   cada usuario executara.

    11.11.1.2. kern.ipc.soacceptqueue

   A variavel kern.ipc.soacceptqueue do sysctl(8) limita o tamanho da fila de
   escuta para aceitar novas conexoes TCP. O valor padrao de 128 e
   normalmente muito baixo para o manuseio robusto de novas conexoes em um
   servidor Web com carga pesada. Para tais ambientes, recomenda-se aumentar
   este valor para 1024 ou superior. Um servic,o como o sendmail(8), ou
   Apache pode limitar por ele mesmo o tamanho da fila de escuta, mas
   frequentemente tera uma diretiva em seu arquivo de configurac,ao para
   ajustar o tamanho da fila. Filas de escuta grandes fazem um trabalho
   melhor evitando ataques de negac,ao de servic,o (Denial of Service - DoS).

  11.11.2. Limites de rede

   A opc,ao de configurac,ao do kernel NMBCLUSTERS determina a quantidade de
   Mbufs de rede disponivel para o sistema. Um servidor com muito trafego e
   um baixo numero de Mbufs prejudicara o desempenho. Cada cluster representa
   aproximadamente 2K de memoria, portanto, um valor de 1024 representa 2
   megabytes de memoria do kernel reservada para buffers de rede. Um calculo
   simples pode ser feito para descobrir quantos sao necessarios. Um servidor
   web que suporte um maximo de 1000 conexoes simultaneas onde cada conexao
   usa um buffer de envio de 16K e recebe 6K, requer aproximadamente 32 MB de
   buffers de rede para cobrir o servidor web. Uma boa regra e multiplicar
   por 2, entao 2x32MB / 2KB = 64MB / 2kB = 32768. Valores entre 4096 e 32768
   sao recomendados para maquinas com maiores quantidades de memoria. Nunca
   especifique um valor arbitrariamente alto para este parametro, pois isso
   pode levar a uma falha no tempo de inicializac,ao. Para observar o uso do
   cluster de rede, use a opc,ao -m com o netstat(1).

   A variavel kern.ipc.nmbclusters deve ser usada para configurar isso no
   momento da inicializac,ao. Apenas as versoes mais antigas do FreeBSD irao
   requerer o uso da opc,ao NMBCLUSTERS no config(8) do kernel.

   Para servidores ocupados que fazem uso extensivo da chamada de sistema
   sendfile(2), pode ser necessario aumentar o numero de buffers sendfile(2)
   atraves da opc,ao de configurac,ao do kernel NSFBUFS ou definindo seu
   valor no /boot/loader.conf (veja loader(8) para detalhes). Um indicador
   comum de que esse parametro precisa ser ajustado e quando os processos sao
   vistos no estado sfbufa. A variavel sysctl(8) kern.ipc.nsfbufs e somente
   de leitura. Este parametro nominalmente escala com o kern.maxusers, no
   entanto, pode ser necessario ajustar de acordo.

  Importante:

   Mesmo que um socket tenha sido marcado como non-blocking, chamar o
   sendfile(2) em um socket non-blocking pode resultar no bloqueio do
   sendfile(2) ate que sejam disponibilizados struct sf_buf suficientes.

    11.11.2.1. net.inet.ip.portrange.*

   As variaveis net.inet.ip.portrange.* do sysctl(8) controlam os intervalos
   de numeros de porta automaticamente ligados a sockets TCP e UDP. Existem
   tres intervalos: um intervalo baixo, um intervalo padrao e um intervalo
   alto. A maioria dos programas de rede usam o intervalo padrao que e
   controlado por net.inet.ip.portrange.first e net.inet.ip.portrange.last,
   cujo padrao e 1024 e 5000, respectivamente. Intervalos de porta ligados
   sao usados para conexoes de saida e e possivel executar o sistema fora das
   portas sob certas circunstancias. Isso ocorre mais comumente ao executar
   um proxy web com muita carga. O intervalo de portas nao e um problema ao
   executar um servidor que lida principalmente com conexoes de entrada, como
   um servidor Web, ou que tenha um numero limitado de conexoes de saida,
   como um mail relay. Para situac,oes em que ha falta de portas, e
   recomendado aumentar modestamente o net.inet.ip.portrange.last. Um valor
   de 10000, 20000 ou 30000 pode ser razoavel. Considere os efeitos do
   firewall ao alterar o intervalo de portas. Alguns firewalls podem bloquear
   grandes intervalos de portas, geralmente portas de numerac,ao baixa, e
   esperam que os sistemas usem intervalos mais altos de portas para conexoes
   de saida. Por esta razao, nao e recomendado que o valor de
   net.inet.ip.portrange.first seja diminuido.

    11.11.2.2. Produto de atraso de largura de banda TCP

   A limitac,ao do produto de atraso de largura de banda TCP pode ser ativada
   configurando a variavel net.inet.tcp.inflight.enable do sysctl(8) para 1.
   Isso instrui o sistema a tentar calcular o produto de atraso de largura de
   banda para cada conexao e a limitar a quantidade de dados na fila para
   envio `a rede para a quantidade necessaria para manter o rendimento ideal.

   Esse recurso e util ao servir dados sobre modems, Gigabit Ethernet, links
   WAN de alta velocidade ou qualquer outro link com um produto de atraso de
   largura de banda alta, especialmente quando tambem estiver usando
   dimensionamento de janela ou quando uma janela de envio grande tiver sido
   configurado. Ao habilitar essa opc,ao, defina tambem a variavel
   net.inet.tcp.inflight.debug para 0 para desabilitar a depurac,ao. Para uso
   em produc,ao, definir a variavel net.inet.tcp.inflight.min para pelo menos
   6144 pode ser benefico. Definir valores minimos altos pode efetivamente
   desabilitar a limitac,ao de largura de banda, dependendo do link. O
   recurso de limitac,ao reduz a quantidade de dados acumulados nas rotas
   intermediarias e nas filas de pacotes de switchs e reduz a quantidade de
   dados acumulados na fila de interface do host local. Com menos pacotes
   enfileirados, as conexoes interativas, especialmente os modems lentos,
   funcionarao com menores Round Trip Times. Esse recurso afeta apenas a
   transmissao de dados do lado do servidor, como o upload. Nao tem efeito na
   recepc,ao ou download de dados.

   Ajustar o valor da variavel net.inet.tcp.inflight.stab nao e recomendado.
   Este parametro e padronizado para 20, representando 2 pacotes maximos
   adicionados ao calculo da janela de produto de atraso de largura de banda.
   A janela adicional e necessaria para estabilizar o algoritmo e melhorar a
   capacidade de resposta `as mudanc,as de condic,oes, mas tambem pode
   resultar em um ping(8) mais alto em links lentos , embora ainda muito
   menor do que sem o algoritmo inflight. Nesses casos, tente reduzir esse
   parametro para 15, 10 ou 5 e reduza a variavel net.inet.tcp.inflight.min
   para um valor como 3500 para obter o efeito desejado. A reduc,ao desses
   parametros deve ser feita apenas como ultimo recurso.

  11.11.3. Memoria virtual

    11.11.3.1. kern.maxvnodes

   Um vnode e a representac,ao interna de um arquivo ou diretorio. Aumentar o
   numero de vnodes disponiveis para o sistema operacional reduz a I/O do
   disco. Normalmente, isso e tratado pelo sistema operacional e nao precisa
   ser alterado. Em alguns casos em que o I/O de disco e um gargalo e o
   sistema esta ficando sem vnodes, essa configurac,ao precisa ser aumentada.
   A quantidade de RAM inativa e livre precisara ser levada em conta.

   Para ver o numero atual de vnodes em uso:

 # sysctl vfs.numvnodes
 vfs.numvnodes: 91349

   Para ver o maximo de vnodes:

 # sysctl kern.maxvnodes
 kern.maxvnodes: 100000

   Se o uso atual do vnode estiver proximo do maximo, tente aumentar o
   kern.maxvnodes por um valor de 1000. Fique de olho no numero de
   vfs.numvnodes. Se subir ate o maximo novamente, o kern.maxvnodes precisara
   ser aumentado ainda mais. Caso contrario, uma mudanc,a no uso da memoria
   como reportado pelo top(1) deve estar visivel e mais memoria deve estar
   ativa.

11.12. Adicionando Espac,o de Swap

   As vezes, um sistema requer mais espac,o de swap. Esta sec,ao descreve
   dois metodos para aumentar o espac,o de troca: adicionar swap a uma
   partic,ao existente ou em um novo disco rigido e criar um arquivo de swap
   em uma partic,ao existente.

   Para obter informac,oes sobre como criptografar o espac,o de swap, quais
   opc,oes existem e por que isso deve ser feito, consulte Sec,ao 17.13,
   "Criptografando Swap".

  11.12.1. Swap em um novo disco rigido ou partic,ao existente

   Adicionar um novo disco rigido para swap resulta em um melhor desempenho
   do que usando uma partic,ao em uma unidade existente. A configurac,ao de
   partic,oes e discos rigidos e explicada em Sec,ao 17.2, "Adicionando
   Discos" enquanto Sec,ao 2.6.1, "Criando o layout da partic,ao" discute
   layouts de partic,oes e considerac,oes sobre o tamanho de partic,oes de
   swap.

   Use o swapon para adicionar uma partic,ao swap ao sistema. Por exemplo:

 # swapon /dev/ada1s1b

  Atenc,ao:

   E possivel usar qualquer partic,ao que nao esteja atualmente montada,
   mesmo que ja contenha dados. O uso do swapon em uma partic,ao que contem
   dados sobrescrevera e destruira esses dados. Certifique-se de que a
   partic,ao a ser incluida como swap seja realmente a partic,ao pretendida
   antes de executar o swapon.

   Para adicionar automaticamente essa partic,ao swap na inicializac,ao,
   adicione uma entrada ao /etc/fstab:

 /dev/ada1s1b    none    swap    sw      0       0

   Veja fstab(5) para uma explicac,ao das entradas do /etc/fstab. Maiores
   informac,oes sobre swapon podem ser encontradas em swapon(8).

  11.12.2. Criando um arquivo de swap

   Esses exemplos criam um arquivo de troca de 64M chamado /usr/swap0 em vez
   de usar uma partic,ao.

   O uso de arquivos de swap requer que o modulo necessario pelo md(4) tenha
   sido embutido no kernel ou tenha sido carregado antes do swap ser ativado.
   Veja Capitulo 8, Configurando o kernel do FreeBSD para informac,oes sobre
   como compilar um kernel customizado.

   Exemplo 11.2. Criando um arquivo de swap
    1. Crie o arquivo de swap:

 # dd if=/dev/zero of=/usr/swap0 bs=1m count=64

    2. Defina as permissoes adequadas no novo arquivo:

 # chmod 0600 /usr/swap0

    3. Informe o sistema sobre o arquivo de swap adicionando uma linha ao
       /etc/fstab:

 md99    none    swap    sw,file=/usr/swap0,late 0       0

       O dispositivo md99 do md(4) e usado, deixando numeros de dispositivos
       inferiores disponiveis para uso interativo.

    4. O espac,o de swap sera adicionado na inicializac,ao do sistema. Para
       adicionar espac,o de swap imediatamente, use o swapon(8):

 # swapon -aL

11.13. Gerenciamento de energia e recursos

   Escrito por Hiten Pandya e Tom Rhodes .

   E importante utilizar recursos de hardware de maneira eficiente. O
   gerenciamento de energia e recursos permite que o sistema operacional
   monitore os limites do sistema e, possivelmente, fornec,a um alerta se a
   temperatura do sistema aumentar inesperadamente. Uma especificac,ao
   anterior para fornecer gerenciamento de energia foi o recurso
   Gerenciamento Avanc,ado de Energia (Advanced Power Management - APM). O
   APM controla o uso de energia de um sistema com base em sua atividade. No
   entanto, era dificil e inflexivel para os sistemas operacionais gerenciar
   o uso de energia e as propriedades termicas de um sistema. O hardware era
   gerenciado pelo BIOS e o usuario tinha configurac,ao e visibilidade
   limitadas nas configurac,oes de gerenciamento de energia. O APM BIOS
   fornecido e especifico da plataforma de hardware. Um driver APM no sistema
   operacional intermedia o acesso `a interface do software APM, que permite
   o gerenciamento dos niveis de energia.

   Existem quatro problemas principais no APM. Primeiro, o gerenciamento de
   energia e feito pelo BIOS especifico do fornecedor, separado do sistema
   operacional. Por exemplo, o usuario pode definir valores de tempo ocioso
   para um disco rigido no APM BIOS para que, quando excedido, o BIOS diminua
   o disco rigido sem o consentimento do sistema operacional. Segundo, a
   logica do APM e incorporada no BIOS e opera fora do escopo do sistema
   operacional. Isso significa que os usuarios so podem corrigir problemas no
   APM BIOS, fazendo o flash de um novo ROM, que e um procedimento perigoso
   com potencial para deixar o sistema em um estado irrecuperavel se falhar.
   Terceiro, o APM e uma tecnologia especifica do fornecedor, o que significa
   que ha muita duplicidade de esforc,os e que os erros encontrados no BIOS
   de um fornecedor podem nao serem resolvidos em outros. Por fim, o APM BIOS
   nao tinha espac,o suficiente para implementar uma politica de energia
   sofisticada ou que pudesse se adaptar bem ao proposito da maquina.

   O BIOS plug and play (PNPBIOS) nao era confiavel em muitas situac,oes. O
   PNPBIOS e uma tecnologia de 16 bits, portanto, o sistema operacional
   precisa usar a emulac,ao de 16 bits para fazer interface com os metodos
   PNPBIOS. O FreeBSD fornece um driver APM, pois o APM ainda deve ser usado
   para sistemas fabricados antes do ano 2000. O driver esta documentado em
   apm(4).

   O sucessor do APM e a Interface Avanc,ada de Configurac,ao e Energia
   (Advanced Configuration and Power Interface - ACPI). O ACPI e um padrao
   escrito por uma alianc,a de fornecedores para fornecer uma interface para
   recursos de hardware e gerenciamento de energia. E um elemento-chave na
   configurac,ao direcionada do sistema operacional e gerenciamento de
   energia, pois proporciona mais controle e flexibilidade ao sistema
   operacional.

   Este capitulo demonstra como configurar o ACPI no FreeBSD. Em seguida, ele
   oferece algumas dicas sobre como depurar o ACPI e como enviar um relatorio
   de problemas contendo informac,oes de depurac,ao para que os
   desenvolvedores possam diagnosticar e corrigir problemas no ACPI.

  11.13.1. Configurando o ACPI

   No FreeBSD, o driver acpi(4) e carregado por padrao na inicializac,ao do
   sistema e nao deve ser compilado no kernel. Este driver nao pode ser
   descarregado apos a inicializac,ao porque o barramento do sistema o
   utiliza para varias interac,oes de hardware. No entanto, se o sistema
   estiver com problemas, o ACPI pode ser desativado completamente ao
   reinicializar apos a configurar hint.acpi.0.disabled="1" no
   /boot/loader.conf ou definindo esta variavel no prompt do loader, como
   descrito em Sec,ao 12.2.3, "Estagio tres".

  Nota:

   O ACPI e o APM nao podem coexistir e devem ser usados separadamente. O
   ultimo a ser carregado terminara se o driver perceber que o outro ja esta
   sendo executado.

   O ACPI pode ser usado para colocar o sistema em modo de suspensao com o
   acpiconf, a opc,ao -s e um numero de 1 a 5. A maioria dos usuarios so
   precisa de 1 (suspensao rapida para RAM) ou 3 (suspender para RAM). A
   opc,ao 5 executa um soft-off que e o mesmo que executar halt -p.

   Outras opc,oes estao disponiveis usando o sysctl. Consulte acpi(4) e
   acpiconf(8) para maiores informac,oes.

  11.13.2. Problemas comuns

   O ACPI esta presente em todos os computadores modernos que estao em
   conformidade com as arquiteturas ia32 (x86) e amd64 (AMD). O padrao
   completo tem muitos recursos, incluindo gerenciamento de desempenho da
   CPU, controle de planos de energia, zonas termicas, varios sistemas de
   bateria, controladores incorporados e enumerac,ao de barramento. A maioria
   dos sistemas implementa menos que o padrao completo. Por exemplo, um
   sistema de desktop geralmente so implementa a enumerac,ao de barramento,
   enquanto um laptop tambem pode ter suporte a refrigerac,ao e gerenciamento
   de bateria. Os laptops tambem tem suspensao e retomada, com sua propria
   complexidade associada.

   Um sistema compativel com ACPI possui varios componentes. Os fornecedores
   de BIOS e chipset fornecem varias tabelas fixas, como FADT, na memoria que
   especificam coisas como o mapa APIC (usado para SMP), registros de
   configurac,ao e valores simples de configurac,ao. Alem disso, uma tabela
   de bytecode, a Tabela de Descric,ao de Sistema Diferenciada DSDT,
   especifica um espac,o de nome de dispositivos e metodos em forma de
   arvore.

   O driver ACPI deve analisar as tabelas fixas, implementar um interpretador
   para o bytecode e modificar os drivers de dispositivos e o kernel para
   aceitar informac,oes do subsistema ACPI. Para o FreeBSD, a Intel(R)
   forneceu um interpretador (ACPI-CA) que e compartilhado com o Linux(R) e o
   NetBSD. O caminho para o codigo-fonte ACPI-CA e
   src/sys/contrib/dev/acpica. O codigo especifico que permite que o ACPI-CA
   funcione no FreeBSD esta em src/sys/dev/acpica/Osd. Finalmente, drivers
   que implementam varios dispositivos ACPI sao encontrados em
   src/sys/dev/acpica.

   Para que o ACPI funcione corretamente, todas as partes devem funcionar
   corretamente. Aqui estao alguns problemas comuns, em ordem de frequ:encia
   em que ocorrem, e algumas possiveis soluc,oes ou correc,oes. Se uma
   correc,ao nao resolver o problema, consulte Sec,ao 11.13.4, "Obtendo e
   enviando informac,oes de depurac,ao" para obter instruc,oes sobre como
   enviar um relatorio de bug.

    11.13.2.1. Problemas do mouse

   Em alguns casos, retomar a partir de uma operac,ao de suspensao fara com
   que o mouse falhe. Um work around conhecido e adicionar
   hint.psm.0.flags="0x3000" ao /boot/loader.conf.

    11.13.2.2. Suspend/Resume

   O ACPI tem tres estados de suspensao para RAM (STR), S1-S3, e um de
   suspensao de estado para disco (STD), chamado S4. O STD pode ser
   implementado de duas maneiras separadas. O S4BIOS e uma suspensao para
   disco auxiliada pelo BIOSe o S4OS e implementado inteiramente pelo sistema
   operacional. O estado normal em que o sistema se encontra quando
   conectado, mas nao ligado, e "soft off" (S5).

   Use o sysctl hw.acpi para verificar os itens relacionados `a suspensao.
   Estes resultados de exemplo sao de um Thinkpad:

 hw.acpi.supported_sleep_state: S3 S4 S5
 hw.acpi.s4bios: 0

   Use o acpiconf -s para testar os estados S3, S4 e S5. Um s4bios de um (1)
   indica suporte ao S4BIOS em vez do S4 suportado pelo sistema operacional.

   Ao testar as ac,oes de suspend/resume, inicie com o S1, se suportado. E
   mais provavel que esse estado funcione, pois nao requer muito suporte ao
   driver. Ninguem implementou S2, que e similar ao S1. Em seguida, tente o
   S3. Este e o estado mais profundo do STR e requer muito suporte ao driver
   para reinicializar corretamente o hardware.

   Um problema comum com suspend/resume e que muitos drivers de dispositivo
   nao salvam, restauram ou reinicializam seu firmware, registros ou memoria
   do dispositivo adequadamente. Como primeira tentativa de depurac,ao do
   problema, tente:

 # sysctl debug.bootverbose=1
 # sysctl debug.acpi.suspend_bounce=1
 # acpiconf -s 3

   Esse teste emula o ciclo de suspend/resume de todos os drivers de
   dispositivo sem entrar realmente no estado S3. Em alguns casos, problemas
   como perder o estado do firmware, tempo limite do watchdog do dispositivo
   e tentar novamente para sempre podem ser capturados com esse metodo. Note
   que o sistema nao entrara realmente no estado S3, o que significa que os
   dispositivos nao perderao energia, e muitos funcionarao bem mesmo se os
   metodos suspend/resume estiverem totalmente ausentes, ao contrario do real
   estado S3.

   Casos mais dificeis requerem hardware adicional, como uma porta serial e
   um cabo para depurac,ao atraves de um console serial, uma porta Firewire e
   um cabo para o uso do dcons(4) e habilidades de depurac,ao do kernel.

   Para ajudar a isolar o problema, descarregue o maior numero possivel de
   drivers. Se funcionar, diminua o driver que e o problema carregando os
   drivers ate que ele falhe novamente. Normalmente, drivers binarios como
   nvidia.ko, drivers de exibic,ao e USB terao mais problemas, enquanto as
   interfaces Ethernet normalmente funcionam bem. Se os drivers puderem ser
   carregados e descarregados adequadamente, automatize isso colocando os
   comandos apropriados em /etc/rc.suspend e /etc/rc.resume. Tente configurar
   o hw.acpi.reset_video para 1 se a tela estiver desarrumada apos a
   retomada. Tente definir valores mais longos ou mais curtos para
   hw.acpi.sleep_delay para ver se isso ajuda.

   Tente carregar uma distribuic,ao recente do Linux(R) para ver se o
   suspend/resume funciona no mesmo hardware. Se funciona no Linux(R), e
   provavel que seja um problema no driver do FreeBSD. Descobrir qual driver
   causa o problema ajudara os desenvolvedores a corrigir o problema. Como os
   mantenedores do ACPI raramente mantem outros drivers, como som ou ATA,
   qualquer problema de driver tambem deve ser postado na lista
   freebsd-current e enviada para o mantenedor do driver. Os usuarios
   avanc,ados podem incluir os printf(3)s de debug do driver problematico
   para rastrear onde, em sua func,ao de reinicio, ele e interrompido.

   Por fim, tente desativar o ACPI e ativar o APM. Se o comando
   suspend/resume funcionar com APM, use o APM, especialmente em hardware
   mais antigo (anterior a 2000). Demorou algum tempo para que os
   fornecedores obtivessem suporte ACPI correto e os hardwares antigos sao
   mais provaveis de terem problemas de BIOS com ACPI.

    11.13.2.3. Travamentos do sistema

   A maioria dos travamentos do sistema e resultado de interrupc,oes perdidas
   ou de uma tempestade de interrupc,oes. Chipsets podem ter problemas com
   base na inicializac,ao, como o BIOS configura as interrupc,oes antes da
   correc,ao da tabela APIC (MADT) e o roteamento do sistema de controle de
   interrupc,oes (SCI).

   Tempestades de interrupc,ao podem ser distinguidas de interrupc,oes
   perdidas, verificando a saida do vmstat -i e observando a linha que possui
   acpi0. Se o contador esta aumentando em mais de um par por segundo, ha uma
   tempestade de interrupc,ao. Se o sistema parece travado, tente acessar o
   DDB (CTRL+ALT+ESC no console) e digite show interrupts.

   Ao lidar com problemas de interrupc,ao, tente desativar o suporte ao APIC
   com hint.apic.0.disabled="1" no /boot/loader.conf .

    11.13.2.4. Panics

   Os panics sao relativamente raros para ACPI e sao a prioridade maxima a
   ser corrigida. O primeiro passo e isolar as etapas para reproduzir o
   panic, se possivel, e obter um backtrace. Siga as instruc,oes para
   habilitar options DDB e configurar um console serial em Sec,ao 26.6.4,
   "Entrando no Depurador DDB da Linha Serial" ou configurar uma partic,ao de
   despejo. Para obter um backtrace no DDB, use tr. Ao escrever o backtrace,
   obtenha pelo menos as cinco ultimas e as cinco principais linhas do
   rastro.

   Em seguida, tente isolar o problema inicializando com ACPI desabilitado.
   Se isso funcionar, isole o subsistema ACPI usando varios valores de
   debug.acpi.disable. Veja acpi(4) para alguns exemplos.

    11.13.2.5. O sistema e ativado apos a sua suspensao ou desligamento

   Primeiro, tente definir hw.acpi.disable_on_poweroff="0" no
   /boot/loader.conf. Isso impede que a ACPI desative varios eventos durante
   o processo de desligamento. Alguns sistemas precisam desse valor definido
   como 1 (o padrao) pelo mesmo motivo. Isso geralmente corrige o problema de
   um sistema ser ativado espontaneamente apos uma suspensao ou desligamento.

    11.13.2.6. BIOS contem Bytecode com bugs

   Alguns fornecedores de BIOS fornecem bytecode incorreto ou com bugs. Isso
   geralmente e manifestado por mensagens do console do kernel como esta:

 ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
 (Node 0xc3f6d160), AE_NOT_FOUND

   Geralmente, esses problemas podem ser resolvidos com a atualizac,ao do
   BIOS para a revisao mais recente. A maioria das mensagens do console e
   inofensiva, mas se houver outros problemas, como o status da bateria nao
   estar funcionando, essas mensagens sao um bom lugar para comec,ar a
   procurar por problemas.

  11.13.3. Substituindo o padrao AML

   O bytecode do BIOS, conhecido como ACPI Machine Language (AML), e
   compilado de uma linguagem de origem chamada ACPI Source Language (ASL). O
   AML e encontrado na tabela conhecida como Tabela de Descric,ao do Sistema
   Diferenciado (Differentiated System Description Table - DSDT).

   O objetivo do FreeBSD e que todos trabalhem com ACPI sem qualquer
   intervenc,ao do usuario. Soluc,oes alternativas ainda estao sendo
   desenvolvidas para erros comuns feitos pelos fornecedores de BIOS. O
   interpretador Microsoft(R) (acpi.sys e acpiec.sys) nao verifica
   rigorosamente a conformidade com o padrao e, portanto, muitos fornecedores
   de BIOS que testam apenas ACPI sob Windows(R) nunca corrigem seu ASL. Os
   desenvolvedores do FreeBSD continuam a identificar e documentar qual
   comportamento nao padrao e permitido pelo interpretador da Microsoft(R)
   para replica-lo para que o FreeBSD possa funcionar sem forc,ar os usuarios
   a corrigir o ASL.

   Para ajudar a identificar o comportamento de bugs e possivelmente
   corrigi-lo manualmente, uma copia pode ser feita do ASL do sistema. Para
   copiar o ASL do sistema para um nome de arquivo especificado, use acpidump
   com -t, para mostrar o conteudo das tabelas fixas e -d, para desmontar o
   AML:

 # acpidump -td > my.asl

   Algumas versoes de AML assumem que o usuario esta executando o Windows(R).
   Para sobrescrever isto, defina hw.acpi.osname="Windows 2009" no
   /boot/loader.conf, usando a mais recente versao do Windows(R) listada no
   ASL.

   Outras soluc,oes alternativas podem exigir que o my.asl seja
   personalizado. Se este arquivo for editado, compile o novo ASL usando o
   seguinte comando. Os avisos geralmente podem ser ignorados, mas erros sao
   bugs que geralmente impedem que o ACPI funcione corretamente.

 # iasl -f my.asl

   Incluir -f forc,a a criac,ao do AML, mesmo que haja erros durante a
   compilac,ao. Alguns erros, como a falta de declarac,oes de retorno, sao
   automaticamente contornados pelo interpretador do FreeBSD.

   O nome do arquivo de saida padrao para iasl e DSDT.aml. Carregue este
   arquivo em vez da copia com bugs do BIOS, que ainda esta presente na
   memoria flash, editando o /boot/loader.conf como segue:

 acpi_dsdt_load="YES"
 acpi_dsdt_name="/boot/DSDT.aml"

   Certifique-se de copiar o DSDT.aml para /boot e, em seguida, reinicialize
   o sistema. Se isso resolver o problema, envie um diff(1) do antigo e novo
   ASL para a lista freebsd-acpi para que os desenvolvedores possam contornar
   o comportamento de bugs no acpica.

  11.13.4. Obtendo e enviando informac,oes de depurac,ao

   Escrito por Nate Lawson .
   com contribuic,oes de Pedro Schultz e Tom Rhodes .

   O driver ACPI possui um recurso de depurac,ao flexivel. Um conjunto de
   subsistemas e o nivel de detalhamento podem ser especificados. Os
   subsistemas a serem depurados sao especificados como camadas e sao
   divididos em componentes (ACPI_ALL_COMPONENTS) e suporte de hardware ACPI
   (ACPI_ALL_DRIVERS). O detalhamento da saida de depurac,ao e especificado
   como o nivel e varia de apenas erros de relatorio (ACPI_LV_ERROR) para
   tudo (ACPI_LV_VERBOSE). O nivel e uma mascara de bits, por isso, varias
   opc,oes podem ser definidas de uma so vez, separadas por espac,os. Na
   pratica, um console serial deve ser usado para registrar a saida para que
   ela nao seja perdida quando o buffer de mensagem do console for liberado.
   Uma lista completa das camadas e niveis individuais e encontrada em
   acpi(4).

   A saida de depurac,ao nao esta ativada por padrao. Para ativa-la, adicione
   as opc,oes ACPI_DEBUG ao arquivo de configurac,ao do kernel personalizado
   se ACPI estiver compilado no kernel. Adicione ACPI_DEBUG=1 ao
   /etc/make.conf para ativa-lo globalmente. Se um modulo for usado em vez de
   um kernel personalizado, recompile apenas o modulo acpi.ko como segue:

 # cd /sys/modules/acpi/acpi && make clean && make ACPI_DEBUG=1

   Copie o acpi.ko compilado para /boot/kernel e adicione o nivel e camada
   desejados ao /boot/loader.conf. As entradas neste exemplo permitem
   mensagens de depurac,ao para todos os componentes e drivers de hardware
   ACPI e mensagens de erro de saida no nivel menos detalhado:

 debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS"
 debug.acpi.level="ACPI_LV_ERROR"

   Se as informac,oes necessarias forem acionadas por um evento especifico,
   como suspend e resume, nao modifique o /boot/loader.conf. Em vez disso,
   use o sysctl para especificar o layer e o nivel apos inicializar e
   preparar o sistema para o evento especifico. As variaveis que podem ser
   definidas usando sysctl sao nomeadas da mesma forma que os parametros no
   /boot/loader.conf.

   Depois que as informac,oes de depurac,ao forem coletadas, elas podem ser
   enviadas para a lista freebsd-acpi para que possam ser usadas pelos
   mantenedores do FreeBSD ACPI para identificar a causa raiz do problema e
   desenvolver uma soluc,ao.

  Nota:

   Antes de enviar as informac,oes de depurac,ao para esta lista,
   certifique-se de que a versao mais recente do BIOS esteja instalada e, se
   disponivel, a versao do firmware do controlador incorporado.

   Ao enviar um relatorio de problemas, inclua as seguintes informac,oes:

     * Descric,ao do comportamento de bugs, incluindo tipo de sistema, modelo
       e qualquer coisa que fac,a com que o erro aparec,a. Explique com a
       maior precisao possivel quando o bug comec,ou a ocorrer se for novo.

     * A saida do dmesg apos executar boot -v, incluindo quaisquer mensagens
       de erro geradas pelo bug.

     * A saida dmesg do boot -v com o ACPI desabilitado, se a desativac,ao do
       ACPI ajudar a corrigir o problema.

     * Saida do sysctl hw.acpi. Isso lista quais recursos o sistema oferece.

     * A URL para uma versao do ASL do sistema hospedada na web. Nao envie o
       ASL diretamente para a lista, pois pode ser muito grande. Gere uma
       copia do ASL executando este comando:

 # acpidump -dt > name-system.asl

       Substitua o nome de login para name e fabricante/modelo para system.
       Por exemplo, use njl-FooCo6000.asl.

   A maioria dos desenvolvedores do FreeBSD assina a lista de discussao
   FreeBSD-CURRENT, mas deve-se enviar os problemas para a lista freebsd-acpi
   para ter certeza de que ele sera visto. Seja paciente ao esperar por uma
   resposta. Se o bug nao for imediatamente aparente, envie um relatorio de
   bug. Ao inserir um PR, inclua as mesmas informac,oes solicitadas acima.
   Isso ajuda os desenvolvedores a rastrear o problema e resolve-lo. Nao
   envie um PR sem enviar primeiro um e-mail para a lista freebsd-acpi pois e
   provavel que o problema ja tenha sido relatado antes.

  11.13.5. Referencias

   Mais informac,oes sobre ACPI podem ser encontradas nos seguintes locais:

     * Arquivos da lista de e-mail do FreeBSD ACPI
       (https://lists.freebsd.org/pipermail/freebsd-acpi/)

     * A especificac,ao ACPI 2.0 (http://acpi.info/spec.htm)

     * acpi(4), acpi_thermal(4), acpidump(8), iasl(8), e acpidb(8)

     ----------------------------------------------------------------------

   [2] O algoritmo de ajuste automatico define o maxusers igual `a quantidade
   de memoria no sistema, com um minimo de 32 e um maximo de 384.

Capitulo 12. O processo de inicializac,ao do FreeBSD

   Indice

   12.1. Sinopse

   12.2. Processo de Inicializac,ao do FreeBSD

   12.3. Configurando telas iniciais de inicializac,ao

   12.4. Sugestoes de dispositivos

   12.5. Sequencia de Desligamento

12.1. Sinopse

   O processo de iniciar um computador e carregar o sistema operacional e
   chamado de "processo de bootstrap", ou de "inicializac,ao". O processo de
   boot do FreeBSD fornece uma grande flexibilidade na personalizac,ao do que
   acontece quando o sistema e iniciado, incluindo a capacidade de selecionar
   diferentes sistemas operacionais instalados no mesmo computador,
   diferentes versoes do mesmo sistema operacional ou um kernel instalado
   diferente.

   Este capitulo detalha as opc,oes de configurac,ao que podem ser definidas.
   Ele demonstra como personalizar o processo de inicializac,ao do FreeBSD,
   incluindo tudo o que acontece ate que o kernel do FreeBSD tenha iniciado,
   procurado por dispositivos e iniciado o init(8). Isso ocorre quando a cor
   do texto das mensagens de inicializac,ao muda de branco brilhante para
   cinza.

   Depois de ler este capitulo, voce reconhecera:

     * Os componentes do sistema de boot do FreeBSD e como eles interagem.

     * As opc,oes que podem ser passadas para os componentes no bootstrap do
       FreeBSD para controlar o processo de inicializac,ao.

     * Como configurar uma tela personalizada de inicializac,ao.

     * O basico da configurac,ao de device hints.

     * Como inicializar no modo de usuario unico e multiusuario e como
       encerrar corretamente um sistema FreeBSD.

  Nota:

   Este capitulo descreve apenas o processo de inicializac,ao do FreeBSD
   rodando em sistemas x86 e amd64.

12.2. Processo de Inicializac,ao do FreeBSD

   Ligar um computador e iniciar o sistema operacional representa um dilema
   interessante. Por definic,ao, o computador nao sabe como fazer nada ate
   que o sistema operacional seja iniciado. Isso inclui executar programas a
   partir do disco. Se o computador nao pode executar um programa a partir do
   disco sem o sistema operacional e os programas do sistema operacional
   estao no disco, como o sistema operacional e iniciado?

   Este problema e semelhante ao do livro As Aventuras do Barao de
   Munchausen. Um personagem tinha caido no meio de um bueiro, e se retirou
   agarrando suas botas e levantando. Nos primeiros dias da computac,ao, o
   termo bootstrap era aplicado ao mecanismo usado para carregar o sistema
   operacional. Desde entao, foi encurtado para "booting".

   No hardware x86, o Sistema Basico de Entrada/Saida (BIOS) e responsavel
   por carregar o sistema operacional. O BIOS procura no disco rigido pelo
   Master Boot Record (MBR), que deve estar localizado em um local especifico
   do disco. O BIOS tem conhecimento suficiente para carregar e executar o
   MBR, e assume que o MBR pode entao executar o restante das tarefas
   envolvidas no carregamento do sistema operacional, possivelmente com a
   ajuda do BIOS.

  Nota:

   O FreeBSD permite inicializar a partir do padrao mais antigo do MBR e da
   nova Tabela de Partic,ao GUID (GPT). O particionamento GPT geralmente e
   encontrado em computadores com a Interface de Firmware Unificada e
   Extensivel (UEFI). No entanto, o FreeBSD pode inicializar a partir de
   partic,oes de GPT mesmo em maquinas com apenas BIOS legado com o gptboot(
   8). O trabalho esta em andamento para fornecer a inicializac,ao direta a
   partir do UEFI.

   O codigo dentro do MBR e normalmente chamado de gerenciador de
   inicializac,ao, especialmente quando ele interage com o usuario. O
   gerenciador de inicializac,ao geralmente tem mais codigo na primeira faixa
   do disco ou dentro do sistema de arquivos. Exemplos de gerenciadores de
   inicializac,ao incluem o gerenciador de boot padrao do FreeBSD boot0,
   tambem chamado Boot Easy, e o Grub, que e usado por muitas distribuic,oes
   Linux(R).

   Se apenas um sistema operacional estiver instalado, o MBR procura pelo
   primeiro slice inicializavel (ativo) no disco e, em seguida, executa o
   codigo nesse slice para carregar o restante do sistema operacional. Quando
   varios sistemas operacionais estao presentes, um gerenciador de
   inicializac,ao diferente pode ser instalado para exibir uma lista de
   sistemas operacionais para que o usuario possa selecionar um para
   inicializar.

   O restante do sistema de boot do FreeBSD e dividido em tres estagios. O
   primeiro estagio sabe apenas o suficiente para colocar o computador em um
   estado especifico e executar o segundo estagio. O segundo estagio pode
   fazer um pouco mais, antes de executar o terceiro estagio. O terceiro
   estagio termina a tarefa de carregar o sistema operacional. O trabalho e
   dividido em tres etapas porque o MBR coloca limites no tamanho dos
   programas que podem ser executados nos estagios um e dois. Encadear as
   tarefas juntas permite que o FreeBSD fornec,a um carregador mais flexivel.

   O kernel e entao iniciado e comec,a a sondar os dispositivos e
   inicializa-los para uso. Quando o processo de inicializac,ao do kernel e
   finalizado, o kernel passa o controle para o processo de usuario init(8),
   que garante que os discos estejam em estado utilizavel, inicia a
   configurac,ao de recursos no nivel de usuario que monta sistemas de
   arquivos, configura placas de rede para se comunicar na rede e inicia os
   processos que foram configurados para serem executados na inicializac,ao.

   Esta sec,ao descreve esses estagios em mais detalhes e demonstra como
   interagir com o processo de inicializac,ao do FreeBSD.

  12.2.1. O gerenciador de inicializac,ao

   O codigo do gerenciador de inicializac,ao no MBR e `as vezes chamado de
   estagio zero do processo de inicializac,ao. Por padrao, o FreeBSD usa o
   gerenciador de boot boot0.

   O MBR instalado pelo instalador do FreeBSD e baseado no /boot/boot0. O
   tamanho e a capacidade do boot0 sao restritos a 446 bytes devido `a tabela
   de slices e ao identificador 0x55AA no final do MBR. Se o boot0 e varios
   sistemas operacionais estiverem instalados, uma mensagem semelhante a este
   exemplo sera exibida no momento da inicializac,ao:

   Exemplo 12.1. Captura de tela do boot0

 F1 Win
 F2 FreeBSD

 Default: F2

   Outros sistemas operacionais sobrescreverao um MBR existente se forem
   instalados apos o FreeBSD. Se isto acontecer, ou para substituir o MBR
   existente com o MBR do FreeBSD, use o seguinte comando:

 # fdisk -B -b /boot/boot0 device

   onde device e o disco de inicializac,ao, como ad0 para o primeiro disco
   IDE, ad2 para o primeiro disco IDE em um segundo controlador IDE, ou da0
   para o primeiro disco SCSI. Para criar uma configurac,ao personalizada do
   MBR, consulte boot0cfg(8).

  12.2.2. Estagio Um e Estagio Dois

   Conceitualmente, o primeiro e o segundo estagios fazem parte do mesmo
   programa na mesma area do disco. Por causa das restric,oes de espac,o,
   eles foram divididos em dois, mas sao sempre instalados juntos. Eles sao
   copiados do combinado /boot/boot pelo instalador do FreeBSD ou pelo
   bsdlabel.

   Estes dois estagios estao localizados fora do sistema de arquivos, na
   primeira trilha do slice de inicializac,ao, comec,ando pelo primeiro
   setor. E ali onde o boot0, ou qualquer outro gerenciador de
   inicializac,ao, espera encontrar um programa para executar, o qual
   continuara o processo de inicializac,ao.

   O primeiro estagio, boot1, e muito simples, pois pode ter apenas 512 bytes
   de tamanho. Ele sabe o suficiente sobre o FreeBSD bsdlabel, que armazena
   informac,oes sobre o slice, para localizar e executar o boot2.

   O estagio dois, boot2, e um pouco mais sofisticado, e entende o sistema de
   arquivos do FreeBSD o suficiente para encontrar arquivos. Ele pode
   fornecer uma interface simples para escolher o kernel ou loader para ser
   executado. Ele executa o loader, que e muito mais sofisticado e fornece um
   arquivo de configurac,ao de inicializac,ao. Se o processo de
   inicializac,ao for interrompido no estagio dois, a seguinte tela
   interativa sera exibida:

   Exemplo 12.2. Captura de tela do boot2

 >> FreeBSD/i386 BOOT
 Default: 0:ad(0,a)/boot/loader
 boot:

   Para substituir o boot1 e boot2 instalados, use o bsdlabel, onde diskslice
   e o disco e o slice para inicializar, como ad0s1 para o primeiro slice no
   primeiro disco IDE:

 # bsdlabel -B diskslice

  Atenc,ao:

   Se apenas o nome do disco for usado, como ad0, o bsdlabel criara o disco
   no "modo perigosamente dedicado", sem slices. Esta provavelmente nao e a
   ac,ao desejada, entao verifique novamente o diskslice antes de pressionar
   Return.

  12.2.3. Estagio tres

   O loader e o estagio final do processo de bootstrap de tres estagios. Ele
   esta localizado no sistema de arquivos, geralmente como /boot/loader.

   O loader e projetado como um metodo interativo para configurac,ao, usando
   um conjunto de comandos embutidos, auxiliado por um interpretador mais
   poderoso que possui um conjunto de comandos mais complexo.

   Durante a inicializac,ao, o loader procurara por um console e por discos,
   e descobrira de qual disco esta sendo inicializado. Ele ira definir as
   variaveis de acordo, e um interpretador e iniciado onde os comandos do
   usuario podem ser passados a partir de um script ou usados
   interativamente.

   O loader entao lera o /boot/loader.rc, que por padrao le o
   /boot/defaults/loader.conf que define padroes razoaveis para variaveis e
   le o /boot/loader.conf para mudanc,as locais nessas variaveis. O loader.rc
   entao age sobre essas variaveis, carregando os modulos e o kernel
   selecionados.

   Finalmente, por padrao, o loader realiza uma espera de 10 segundos por
   pressionamentos de teclas, e inicializa o kernel se nao for interrompido.
   Se interrompido, o usuario e apresentado a um prompt que compreende o
   conjunto de comandos, no qual o usuario pode ajustar variaveis,
   descarregar todos os modulos, carregar modulos e finalmente inicializar ou
   reinicializar. Tabela 12.1, "Comandos Internos do Loader" lista os
   comandos do loader mais usados. Para uma discussao completa de todos os
   comandos disponiveis, consulte loader(8).

   Tabela 12.1. Comandos Internos do Loader

           Variavel                            Descric,ao                     
                            Prossegue para inicializar o kernel se nao for    
   autoboot segundos        interrompido dentro do intervalo de tempo dado,   
                            em segundos. Ele exibe uma contagem regressiva e  
                            o intervalo de tempo padrao e de 10 segundos.     
                            Imediatamente prossegue a inicializac,ao do       
                            kernel, com qualquer opc,ao especificada ou nome  
                            do kernel. Fornecer um nome de kernel na linha de 
   boot [-options]          comando so e aplicavel depois que um unload foi   
   [kernelname]             emitido. Caso contrario, o kernel previamente     
                            carregado sera usado. Se o nomedokernel nao       
                            estiver qualificado, ele sera pesquisado em       
                            /boot/kernel e /boot/modules.                     
                            Passa pela mesma configurac,ao automatica de      
                            modulos baseada em variaveis especificadas, mais  
   boot-conf                comumente kernel. Isso so faz sentido se unload   
                            for usado primeiro, antes de alterar algumas      
                            variaveis.                                        
                            Mostra mensagens de ajuda lidas de                
   help [topico]            /boot/loader.help. Se o topico fornecido for      
                            index, a lista de topicos disponiveis sera        
                            exibida.                                          
                            Le o arquivo especificado e interpreta-o linha    
   include nomedoarquivo... por linha. Um erro interrompe imediatamente o     
                            include.                                          
                            Carrega o kernel, modulo do kernel ou arquivo do  
                            tipo especificado, com o nome de arquivo          
   load [-t type] filename  especificado. Quaisquer argumentos apos o         
                            nomedoarquivo sao passados para o arquivo. Se     
                            nomedoarquivo nao estiver qualificado, ele sera   
                            pesquisado em /boot/kernel e /boot/modules.       
                            Exibe uma listagem de arquivos do caminho         
   ls [-l] [path]           fornecido ou do diretorio raiz, se o caminho nao  
                            for especificado. Se -l for especificado, os      
                            tamanhos dos arquivos tambem serao mostrados.     
                            Lista todos os dispositivos dos quais e possivel  
   lsdev [-v]               carregar modulos. Se -v for especificado, mais    
                            detalhes serao impressos.                         
   lsmod [-v]               Exibe os modulos carregados. Se -v for            
                            especificado, mais detalhes serao mostrados.      
   more nomedoarquivo       Exibe os arquivos especificados, com uma pausa em 
                            cada LINES exibidas.                              
   reboot                   Reinicia imediatamente o sistema.                 
   set variable, set        Define as variaveis de ambiente especificadas.    
   variable=value           
   unload                   Remove todos os modulos carregados.               

   Aqui estao alguns exemplos praticos de uso do loader. Para inicializar o
   kernel usual no modo single-user :

 boot -s

   Para descarregar o kernel e os modulos usuais e, em seguida, carregar o
   kernel anterior ou outro especificado:

 unload
 load kernel.old

   Use o kernel.GENERIC para se referir ao kernel padrao que vem com uma
   instalac,ao, ou kernel.old, para se referir ao kernel previamente
   instalado antes de uma atualizac,ao do sistema ou antes de configurar um
   kernel personalizado.

   Use o seguinte para carregar os modulos usuais com outro kernel:

 unload
 set kernel="kernel.old"
 boot-conf

   Para carregar um script de configurac,ao do kernel automatizado:

 load -t userconfig_script /boot/kernel.conf

  12.2.4. Ultimo estagio

   Quando o kernel e carregado pelo loader ou pelo boot2, que ignora o
   loader, ele examina qualquer flag de inicializac,ao e ajusta seu
   comportamento conforme necessario. Tabela 12.2, "Interac,ao do Kernel
   durante o Boot" lista os flags de inicializac,ao comumente usados.
   Consulte boot(8) para obter mais informac,oes sobre os outros
   sinalizadores de inicializac,ao.

   Tabela 12.2. Interac,ao do Kernel durante o Boot

   Opc,ao                             Descric,ao                              
   -a     Durante a inicializac,ao do kernel, solicita que o dispositivo seja 
          montado como o sistema de arquivos raiz.                            
   -C     Inicialize o sistema de arquivos raiz a partir de um CDROM.         
   -s     Inicialize no modo single-user.                                     
   -v     Seja mais detalhado durante a inicializac,ao do kernel.             

   Uma vez que o kernel terminou a inicializac,ao, ele passa o controle para
   o processo de usuario init(8), localizado em /sbin/init, ou o caminho do
   programa especificado na variavel init_path no loader. Este e o ultimo
   estagio do processo de inicializac,ao.

   A sequencia de inicializac,ao garante que os sistemas de arquivos
   disponiveis no sistema estejam consistentes. Se um sistema de arquivos UFS
   nao estiver e o fsck nao puder corrigir as inconsistencias, o init jogara
   o sistema no modo single-user para que o administrador do sistema possa
   resolver o problema diretamente. Caso contrario, o sistema e inicializado
   no modo multi-user.

    12.2.4.1. Modo Single-User

   Um usuario pode especificar este modo inicializando com -s ou definindo a
   variavel boot_single no loader. Ele tambem pode ser alcanc,ado executando
   o shutdown now do modo multi-user. O modo single-user comec,a com esta
   mensagem:

 Enter full pathname of shell or RETURN for /bin/sh:

   Se o usuario pressionar Enter, o sistema entrara no Bourne shell padrao.
   Para especificar um shell diferente, insira o caminho completo para o
   shell.

   O modo single-user e geralmente usado para reparar um sistema que nao
   inicializa devido a um sistema de arquivos inconsistente ou a um erro em
   um arquivo de configurac,ao de inicializac,ao. Ele tambem pode ser usado
   para redefinir a senha do root quando ela e desconhecida. Essas ac,oes sao
   possiveis porque o prompt do modo single-user fornece acesso local
   completo ao sistema e seus arquivos de configurac,ao. Nao ha rede neste
   modo.

   Embora o modo single-user seja util para reparar um sistema, ele
   representa um risco de seguranc,a, a menos que o sistema esteja em um
   local fisicamente seguro. Por padrao, qualquer usuario que possa obter
   acesso fisico a um sistema tera controle total desse sistema apos a
   inicializac,ao no modo single-user.

   Se o console do sistema for alterado para insecure em /etc/ttys, o sistema
   solicitara primeiro a senha do root antes de iniciar o modo single-user.
   Isso adiciona uma medida de seguranc,a ao remover a capacidade de
   redefinir a senha do root quando ela e desconhecida.

   Exemplo 12.3. Configurando um Console Inseguro em /etc/ttys

 # name  getty                           type    status          comments
 #
 # If console is marked "insecure", then init will ask for the root password
 # when going to single-user mode.
 console none                            unknown off insecure

   Um console inseguro significa que a seguranc,a fisica para o console e
   considerada insegura, portanto, apenas alguem que conhec,a a senha do root
   pode usar o modo single-user.

    12.2.4.2. Modo Multi-User

   Se o init encontrar os sistemas de arquivos em ordem, ou quando o usuario
   tiver concluido seus comandos no modo de usuario unico e tiver digitado
   exit para deixar o modo single-user, o sistema entra no modo multi-user,
   no qual inicia a configurac,ao de recursos do sistema.

   O sistema de configurac,ao de recursos le os padroes de configurac,ao do
   /etc/defaults/rc.conf e detalhes especificos do sistema a partir do
   /etc/rc.conf. Em seguida, ele monta os sistemas de arquivos do sistema
   listados em /etc/fstab. Ele inicia servic,os de rede, daemons diversos do
   sistema e, em seguida, os scripts de inicializac,ao dos pacotes instalados
   localmente.

   Para saber mais sobre o sistema de configurac,ao de recursos, consulte
   rc(8) e examine os scripts localizados em /etc/rc.d.

12.3. Configurando telas iniciais de inicializac,ao

   Contribuido por Joseph J. Barbish.

   Normalmente, quando um sistema FreeBSD inicializa, ele exibe seu progresso
   com uma serie de mensagens no console. Uma tela inicial de inicializac,ao
   cria uma tela de inicializac,ao alternativa que oculta todo o probe de
   inicializac,ao e as mensagens de inicializac,ao de servic,os. Algumas
   mensagens do boot loader, incluindo o menu de opc,oes de inicializac,ao e
   um prompt de contagem regressiva de espera, sao exibidas no momento da
   inicializac,ao, mesmo quando a tela inicial esta ativada. A exibic,ao da
   tela inicial pode ser desativada pressionando qualquer tecla do teclado
   durante o processo de inicializac,ao.

   Existem dois ambientes basicos disponiveis no FreeBSD. O primeiro e o
   ambiente padrao de linha de comando do console virtual legado. Depois que
   o sistema conclui a inicializac,ao, e exibido um prompt de login do
   console. O segundo ambiente e um ambiente grafico configurado. Consulte
   Capitulo 5, O sistema X Window para obter maiores informac,oes sobre como
   instalar e configurar um gerenciador grafico de tela e um gerenciador
   grafico de login.

   Depois que o sistema inicializa, a tela inicial e definida como protec,ao
   de tela. Apos um periodo sem uso, a tela inicial sera exibida e passara
   por etapas de mudanc,a de intensidade da imagem, de brilhante a muito
   escuro e vice-versa. A configurac,ao do protetor de tela inicial pode ser
   sobrescrita, adicionando-se uma linha saver= ao /etc/rc.conf. Varios
   protetores de tela embutidos estao disponiveis e descritos em splash(4). A
   opc,ao saver= aplica-se apenas aos consoles virtuais e nao tem efeito nos
   gerenciadores graficos de telas.

   Ao instalar o pacote ou port sysutils/bsd-splash-changer, uma imagem
   inicial aleatoria de uma colec,ao sera exibida na inicializac,ao. A
   func,ao tela inicial suporta 256 cores nos formatos bitmap (.bmp), ZSoft
   PCX (.pcx), ou TheDraw (.bin). A imagem .bmp, .pcx, ou .bin tem que ser
   colocada na partic,ao root, em /boot por exemplo. Os arquivos de imagens
   iniciais tem que ter a resoluc,ao de 320 por 200 pixels ou menos para
   funcionarem em adaptadores VGA padrao. Para a tela inicial padrao de 256
   cores e 320 por 200 pixels ou menos, adicione as seguintes linhas ao
   /boot/loader.conf. Substitua splash.bmp com o nome do arquivo bitmap a ser
   utilizado:

 splash_bmp_load="YES"
 bitmap_load="YES"
 bitmap_name="/boot/splash.bmp"

   Para usar um arquivo PCX em vez de um arquivo bitmap:

 splash_pcx_load="YES"
 bitmap_load="YES"
 bitmap_name="/boot/splash.pcx"

   Em vez disso, use ASCII art no formato
   https://en.wikipedia.org/wiki/TheDraw:

 splash_txt="YES"
 bitmap_load="YES"
 bitmap_name="/boot/splash.bin"

   Outras opc,oes interessantes do arquivo loader.conf incluem:

   beastie_disable="YES"

           Isso impedira que o menu de opc,oes de inicializac,ao seja
           exibido, mas o prompt de contagem regressiva da espera programada
           ainda estara presente. Mesmo com a exibic,ao do menu de opc,oes de
           inicializac,ao desabilitada, entrar com uma selec,ao de opc,ao no
           prompt de contagem decrescente de tempo programado ativara a
           opc,ao de inicializac,ao correspondente.

   loader_logo="beastie"

           Isso substituira as palavras padrao "FreeBSD", que sao exibidas `a
           direita do menu de opc,oes de inicializac,ao, com o logotipo
           colorido do beastie.

   Para maiores informac,oes, consulte splash(4), loader.conf(5), and vga(4).

12.4. Sugestoes de dispositivos

   Contribuido por Tom Rhodes.

   Durante o comec,o da inicializac,ao do sistema, o boot loader(8) le o
   device.hints(5). Este arquivo armazena informac,oes de inicializac,ao do
   kernel conhecidas como variaveis, algumas vezes referenciadas como
   "sugestao de devices". Estas "sugestoes de devices" sao usados pelos
   drivers de dispositivo para configurac,ao do dispositivo.

   As sugestoes de dispositivos tambem sao especificadas no estagio 3 do
   prompt do boot loader, conforme demonstrado em Sec,ao 12.2.3, "Estagio
   tres". As variaveis podem ser adicionadas usando set, removidas com unset
   e visualizadas show. Variaveis configuradas no arquivo /boot/device.hints
   tambem podem ser sobrescritas. As sugestoes de dispositivos inseridas no
   boot loader nao sao permanentes e nao serao aplicadas na proxima
   reinicializac,ao.

   Uma vez que o sistema e inicializado, kenv(1) pode ser usado para despejar
   todas as variaveis.

   A sintaxe para o arquivo /boot/device.hints e uma variavel por linha,
   usando o hash "#" como marcadores de comentario. As linhas sao construidas
   da seguinte forma:

 hint.driver.unit.keyword="value"

   A sintaxe para o estagio 3 do boot loader e:

 set hint.driver.unit.keyword=value

   onde driver e o nome do driver de dispositivo, unit e o numero da unidade
   de driver do dispositivo, e keyword e a palavra-chave sugerida. A
   palavra-chave pode consistir das seguintes opc,oes:

     * at: especifica o barramento ao qual o dispositivo esta conectado.

     * port: especifica o enderec,o inicial de I/O a ser usado.

     * irq: especifica o numero da requisic,ao de interrupc,ao a ser usada.

     * drq: especifica o numero do canal DMA.

     * maddr: especifica o enderec,o de memoria fisica ocupado pelo
       dispositivo.

     * flags: define varios bits de flags para o dispositivo.

     * disabled: se definido como 1, o dispositivo e desativado.

   Como os drivers de dispositivo podem aceitar ou exigir mais sugestoes nao
   listadas aqui, e recomendavel exibir uma pagina de manual do driver. Para
   obter mais informac,oes, consulte device.hints(5), kenv(1),
   loader.conf(5), e loader(8).

12.5. Sequencia de Desligamento

   Apos desligamento controlado usando shutdown(8), o init(8) tentara
   executar o script /etc/rc.shutdown e, em seguida, enviara a todos os
   processos o sinal TERM e, subsequentemente, o sinal KILL para qualquer um
   que nao termine em tempo habil.

   Para desligar uma maquina FreeBSD em arquiteturas e sistemas que suportam
   gerenciamento de energia, use o shutdown -p now para desligar a energia
   imediatamente. Para reinicializar um sistema FreeBSD, use o shutdown -r
   now. E preciso ser root ou um membro de operator para executar
   shutdown(8). Tambem e possivel usar halt(8) e reboot(8). Consulte as
   paginas de manual e o shutdown(8) para obter mais informac,oes.

   Modifique a associac,ao ao grupo referindo-se a Sec,ao 3.3, "Usuarios e
   Gerenciamento Basico de Contas".

  Nota:

   O gerenciamento de energia requer que o acpi(4) seja carregado como um
   modulo ou estaticamente compilado em um kernel personalizado.

Capitulo 13. Seguranc,a

   Reescrito por Tom Rhodes.
   Indice

   13.1. Sinopse

   13.2. Introduc,ao

   13.3. Senhas de Uso Unico

   13.4. TCP Wrapper

   13.5. Kerberos

   13.6. OpenSSL

   13.7. VPN Sobre IPsec

   13.8. OpenSSH

   13.9. Listas de Controle de Acesso

   13.10. Monitorando Problemas de Seguranc,a de Terceiros

   13.11. Avisos de Seguranc,a do FreeBSD

   13.12. Auditoria de Processo

   13.13. Limites de Recursos

   13.14. Administrac,ao Compartilhada com Sudo

13.1. Sinopse

   A seguranc,a, seja fisica ou virtual, e um topico tao amplo que todo um
   setor evoluiu em torno dele. Centenas de praticas padrao foram criadas
   sobre como proteger sistemas e redes e, como usuario do FreeBSD, e
   essencial entender como se proteger contra ataques e intrusos.

   Neste capitulo, varios fundamentos e tecnicas serao discutidos. O sistema
   FreeBSD vem com multiplas camadas de seguranc,a, e muitos outros
   utilitarios de terceiros podem ser adicionados para aumentar a seguranc,a.

   Depois de ler este capitulo, voce sabera:

     * Conceitos basicos de seguranc,a do sistema FreeBSD.

     * Os varios mecanismos de criptografia disponiveis no FreeBSD.

     * Como configurar a autenticac,ao de senha unica.

     * Como configurar o TCP Wrapper para uso com o inetd(8).

     * Como configurar o Kerberos no FreeBSD.

     * Como configurar o IPsec e criar uma VPN.

     * Como configurar e usar o OpenSSH no FreeBSD.

     * Como usar ACLs para o sistema de arquivos .

     * Como usar o pkg para auditar pacotes de software de terceiros
       instalados a partir da Colec,ao de Ports.

     * Como utilizar os alertas de seguranc,a do FreeBSD.

     * O que e Auditoria de Processos e como ativa-la no FreeBSD.

     * Como controlar os recursos do usuario usando classes de login ou o
       banco de dados de limites de recursos.

   Antes de ler este capitulo, voce deve:

     * Entender os conceitos basicos do FreeBSD e de Internet.

   Topicos de seguranc,a adicionais sao abordados em outras partes deste
   Manual. Por exemplo, o Controle de Acesso Obrigatorio e discutido em
   Capitulo 15, Controle de acesso obrigatorio e os firewalls da Internet sao
   discutidos em Capitulo 30, Firewalls.

13.2. Introduc,ao

   Seguranc,a e responsabilidade de todos. Um ponto de entrada fraco em
   qualquer sistema pode permitir que intrusos obtenham acesso a informac,oes
   criticas e causem estragos em toda a rede. Um dos principios centrais da
   seguranc,a da informac,ao e a triade CIA, que significa Confidencialidade,
   Integridade e Disponibilidade dos sistemas de informac,ao.

   A triade CIA e um conceito basico de seguranc,a de computadores, pois os
   clientes e usuarios esperam que seus dados sejam protegidos. Por exemplo,
   um cliente espera que as informac,oes do cartao de credito sejam
   armazenadas com seguranc,a (confidencialidade), que os pedidos nao sejam
   alterados nos bastidores (integridade) e que tenham acesso `as
   informac,oes do pedido em todos os momentos (disponibilidade).

   Para fornecer CIA, os profissionais de seguranc,a aplicam uma estrategia
   de defesa em profundidade. A ideia de defesa em profundidade e adicionar
   varias camadas de seguranc,a para evitar que uma falha em uma unica camada
   e fac,a com que todo o sistema de seguranc,a entre em colapso. Por
   exemplo, um administrador do sistema nao pode simplesmente ativar um
   firewall e considerar a rede ou o sistema seguro. E preciso tambem auditar
   contas, verificar a integridade dos binarios e garantir que ferramentas
   maliciosas nao estejam instaladas. Para implementar uma estrategia de
   seguranc,a eficaz, e preciso entender as ameac,as e como se defender
   delas.

   O que e uma ameac,a no que se refere `a seguranc,a do computador? As
   ameac,as nao se limitam a invasores remotos que tentam acessar um sistema
   sem permissao de um local remoto. As ameac,as tambem incluem funcionarios,
   softwares mal-intencionados, dispositivos de rede nao autorizados,
   desastres naturais, vulnerabilidades de seguranc,a e ate corporac,oes
   concorrentes.

   Sistemas e redes podem ser acessados sem permissao, `as vezes por
   acidente, ou por atacantes remotos e, em alguns casos, por meio de
   espionagem corporativa ou ex-funcionarios. Como usuario, e importante se
   preparar e admitir quando um erro levou a uma violac,ao de seguranc,a e
   relatar possiveis problemas `a equipe de seguranc,a. Como administrador, e
   importante conhecer as ameac,as e estar preparado para mitiga-las.

   Ao aplicar a seguranc,a aos sistemas, recomenda-se comec,ar protegendo as
   contas basicas e a configurac,ao do sistema e, em seguida, proteger a
   camada de rede de modo a aderir `a politica do sistema e aos procedimentos
   de seguranc,a da organizac,ao. Muitas organizac,oes ja possuem uma
   politica de seguranc,a que abrange a configurac,ao de dispositivos de
   tecnologia. A politica deve incluir a configurac,ao de seguranc,a de
   estac,oes de trabalho, desktops, dispositivos moveis, telefones,
   servidores de produc,ao e servidores de desenvolvimento. Em muitos casos,
   procedimentos operacionais padrao (SOPs) ja existem. Em caso de duvida,
   pergunte `a equipe de seguranc,a.

   O restante desta introduc,ao descreve como algumas dessas configurac,oes
   basicas de seguranc,a sao executadas em um sistema FreeBSD. O restante
   deste capitulo descreve algumas ferramentas especificas que podem ser
   usadas ao implementar uma politica de seguranc,a em um sistema FreeBSD.

  13.2.1. Prevenindo Logins

   Ao garantir a seguranc,a de um sistema, um bom ponto de partida e uma
   auditoria de contas. Assegure-se de que o root tenha uma senha forte e que
   essa senha nao seja compartilhada. Desabilite todas as contas que nao
   precisam de acesso de para logar.

   Para negar acesso de login a contas, existem dois metodos. O primeiro e
   bloquear a conta. Este exemplo bloqueia a conta toor:

 # pw lock toor

   O segundo metodo e impedir o acesso ao login alterando o shell para
   /usr/sbin/nologin. Apenas o superusuario pode alterar o shell para outros
   usuarios:

 # chsh -s /usr/sbin/nologin toor

   O shell /usr/sbin/nologin impede que o sistema atribua um shell ao usuario
   quando ele tenta efetuar login.

  13.2.2. Escalonamento de Contas Permitido

   Em alguns casos, a administrac,ao do sistema precisa ser compartilhada com
   outros usuarios. O FreeBSD tem dois metodos para lidar com isso. O
   primeiro, que nao e recomendado, e uma senha de root compartilhada usada
   por membros do grupo wheel. Com esse metodo, um usuario digita su e insere
   a senha para wheel sempre que o acesso do superusuario for necessario. O
   usuario deve entao digitar exit para deixar o acesso privilegiado apos
   terminar os comandos que requereram acesso administrativo. Para adicionar
   um usuario a este grupo, edite /etc/group e adicione o usuario ao final da
   entrada wheel. O usuario deve ser separado por um caractere virgula sem
   espac,o.

   O segundo e recomendado metodo para permitir o escalonamento de
   privilegios e instalar o pacote ou port security/sudo. Este software
   fornece auditoria adicional, controle de usuario mais refinado e pode ser
   configurado para bloquear os usuarios para que executem apenas os comandos
   privilegiados especificados.

   Apos a instalac,ao, use o visudo para editar o /usr/local/etc/sudoers.
   Este exemplo cria um novo grupo webadmin, adiciona a conta trhodes a esse
   grupo e configura esse acesso de grupo para reiniciar o apache24:

 # pw groupadd webadmin -M trhodes -g 6000
 # visudo
 %webadmin ALL=(ALL) /usr/sbin/service apache24 *

  13.2.3. Hashes de Senhas

   As senhas sao um mal necessario da tecnologia. Quando elas devem ser
   usadas, elas devem ser complexas e um poderoso mecanismo de hash deve ser
   usado para criptografar a versao armazenada no banco de dados de senhas. O
   FreeBSD suporta os algoritmos de DES, MD5, SHA256, SHA512 e Blowfish na
   sua biblioteca crypt(). O padrao de SHA512 nao deve ser alterado para um
   algoritmo hash menos seguro, mas pode ser alterado para o algoritmo
   Blowfish mais seguro.

  Nota:

   O Blowfish nao faz parte do AES e nao e considerado compativel com nenhum
   Federal Information Processing Standard (FIPS). Seu uso pode nao ser
   permitido em alguns ambientes.

   Para determinar qual algoritmo de hash e usado para criptografar a senha
   de um usuario, o superusuario pode visualizar o hash do usuario no banco
   de dados de senhas do FreeBSD. Cada hash comec,a com um simbolo que indica
   o tipo de mecanismo de hash usado para criptografar a senha. Se DES for
   usado, nao havera simbolo de inicio. Para MD5, o simbolo e $. Para SHA256
   e SHA512, o simbolo e $6$. Para o Blowfish, o simbolo e $2a$. Neste
   exemplo, a senha para dru e criptografada usando o algoritmo SHA512 padrao
   quando o hash comec,a com $6$. Observe que o hash criptografado, nao a
   senha em si, e armazenado no banco de dados de senhas:

 # grep dru /etc/master.passwd
 dru:$6$pzIjSvCAn.PBYQBA$PXpSeWPx3g5kscj3IMiM7tUEUSPmGexxta.8Lt9TGSi2lNQqYGKszsBPuGME0:1001:1001::0:0:dru:/usr/home/dru:/bin/csh

   O mecanismo de hash e definido na classe de login do usuario. Para este
   exemplo, o usuario esta na classe de login default e o algoritmo de hash e
   definido com esta linha em /etc/login.conf:

         :passwd_format=sha512:\

   Para alterar o algoritmo para Blowfish, modifique a linha para ficar
   assim:

         :passwd_format=blf:\

   Em seguida, execute cap_mkdb /etc/login.conf conforme descrito em
   Sec,ao 13.13.1, "Configurando Classes de Login". Observe que essa
   alterac,ao nao afetara os hashes de senha existentes. Isso significa que
   todas as senhas devem ser refeitas pedindo aos usuarios que executem
   passwd para alterar sua senha.

   Para logins remotos, a autenticac,ao de dois fatores deve ser usada. Um
   exemplo de autenticac,ao de dois fatores e "algo que voce tem", como uma
   chave, e "algo que voce conhece", como a senha para essa chave. Como o
   OpenSSH e parte do sistema basico do FreeBSD, todos os logins de rede
   devem ser sobre uma conexao criptografada e usar autenticac,ao baseada em
   chave em vez de senhas. Para mais informac,oes, consulte Sec,ao 13.8,
   "OpenSSH". Os usuarios do Kerberos podem precisar fazer alterac,oes
   adicionais para implementar o OpenSSH em sua rede. Essas alterac,oes sao
   descritas em Sec,ao 13.5, "Kerberos".

  13.2.4. Aplicac,ao de Politica de Senha

   Aplicar uma politica de senha forte para contas locais e um aspecto
   fundamental da seguranc,a do sistema. No FreeBSD, o tamanho da senha, a
   forc,a da senha e a complexidade da senha podem ser implementados usando
   os Modulos de Autenticac,ao Conectaveis (PAM).

   Esta sec,ao demonstra como configurar o tamanho minimo e maximo da senha e
   a imposic,ao de caracteres mistos usando o modulo pam_passwdqc.so. Este
   modulo e aplicado quando um usuario altera sua senha.

   Para configurar este modulo, torne-se o superusuario e remova o comentario
   da linha contendo pam_passwdqc.so em /etc/pam.d/passwd. Em seguida, edite
   essa linha para corresponder `a politica de senha:

 password        requisite       pam_passwdqc.so         min=disabled,disabled,disabled,12,10 similar=deny retry=3 enforce=users

   Este exemplo define varios requisitos para novas senhas. A configurac,ao
   min controla o tamanho minimo da senha. Ele tem cinco valores porque este
   modulo define cinco tipos diferentes de senhas com base em sua
   complexidade. Complexidade e definida pelo tipo de caracteres que devem
   existir em uma senha, como letras, numeros, simbolos e maiusculas e
   minusculas. Os tipos de senhas sao descritos em pam_passwdqc(8). Neste
   exemplo, os tres primeiros tipos de senha sao desativados, o que significa
   que as senhas que atendem a esses requisitos de complexidade nao serao
   aceitas, independentemente da sua durac,ao. O 12 define uma politica de
   senha minima de pelo menos doze caracteres, se a senha tambem contiver
   caracteres com tres tipos de complexidade. O 10 define a politica de senha
   para tambem permitir senhas de pelo menos dez caracteres, se a senha
   contiver caracteres com quatro tipos de complexidade.

   A configurac,ao similar nega senhas semelhantes `a senha anterior do
   usuario. A configurac,ao retry fornece ao usuario tres oportunidades para
   inserir uma nova senha.

   Depois que este arquivo for salvo, um usuario que alterar sua senha vera
   uma mensagem semelhante a seguinte:

 % passwd
 Changing local password for trhodes
 Old Password:

 You can now choose the new password.
 A valid password should be a mix of upper and lower case letters,
 digits and other characters.  You can use a 12 character long
 password with characters from at least 3 of these 4 classes, or
 a 10 character long password containing characters from all the
 classes.  Characters that form a common pattern are discarded by
 the check.
 Alternatively, if no one else can see your terminal now, you can
 pick this as your password: "trait-useful&knob".
 Enter new password:

   Se uma senha que nao corresponde `a politica for inserida, ela sera
   rejeitada com um aviso e o usuario tera a oportunidade de tentar
   novamente, ate o numero configurado de novas tentativas.

   A maioria das politicas de senha exige que as senhas expirem depois de
   tantos dias. Para definir um tempo de expirac,ao da senha no FreeBSD,
   defina passwordtime para a classe de login do usuario em /etc/login.conf.
   A classe de login default contem um exemplo:

 #       :passwordtime=90d:\

   Portanto, para definir uma expirac,ao de 90 dias para esta classe de
   login, remova o simbolo de comentario (#), salve a edic,ao e execute o
   cap_mkdb /etc/login.conf.

   Para definir a expirac,ao em usuarios individuais, passe uma data de
   expirac,ao ou o numero de dias para expirar e um nome de usuario para o
   comando pw:

 # pw usermod -p 30-apr-2015 -n trhodes

   Como visto aqui, uma data de expirac,ao e definida na forma de dia, mes e
   ano. Para obter maiores informac,oes, consulte pw(8).

  13.2.5. Detectando Rootkits

   Um rootkit e qualquer software nao autorizado que tente obter acesso como
   root a um sistema. Uma vez instalado, esse software mal-intencionado
   normalmente abrira outro caminho de entrada para um invasor.
   Realisticamente, uma vez que um sistema foi comprometido por um rootkit e
   uma investigac,ao foi realizada, o sistema deve ser reinstalado do zero.
   Existe um tremendo risco de que mesmo o engenheiro de sistemas ou
   seguranc,a mais prudente perca algo que um invasor deixou para tras.

   Um rootkit faz uma coisa util para administradores: uma vez detectado, e
   um sinal de que um comprometimento aconteceu em algum momento. Mas, esses
   tipos de aplicativos tendem a ser muito bem ocultos. Esta sec,ao demonstra
   uma ferramenta que pode ser usada para detectar rootkits,
   security/rkhunter.

   Apos a instalac,ao deste pacote ou port, o sistema pode ser verificado
   usando o seguinte comando. Ele produzira muitas informac,oes e exigira uma
   entrada manual da tecla ENTER:

 # rkhunter -c

   Depois que o processo for concluido, uma mensagem de status sera impressa
   na tela. Esta mensagem incluira a quantidade de arquivos verificados,
   arquivos suspeitos, possiveis rootkits e mais. Durante a verificac,ao,
   alguns avisos de seguranc,a genericos podem ser produzidos sobre arquivos
   ocultos, a selec,ao do protocolo OpenSSH e versoes vulneraveis conhecidas
   do software instalado. Estes podem ser tratados agora ou apos uma analise
   mais detalhada ter sido realizada.

   Todo administrador deve saber o que esta sendo executado nos sistemas
   pelos quais e responsavel. Ferramentas de terceiros como o rkhunter e o
   sysutils/lsof e comandos nativos como o netstat e o ps, podem mostrar uma
   grande quantidade de informac,oes sobre o sistema. Fac,a anotac,oes sobre
   o que e normal, fac,a perguntas quando algo parecer fora do lugar e seja
   paranoico. Embora evitar um comprometimento seja ideal, detectar um
   comprometimento e imprescindivel.

  13.2.6. Verificac,ao Binaria

   A verificac,ao de arquivos e binarios do sistema e importante porque
   fornece `as equipes de administrac,ao e seguranc,a do sistema informac,oes
   sobre alterac,oes no sistema. Uma aplicac,ao de software que monitora o
   sistema para alterac,oes e chamado de Sistema de Detecc,ao de Intrusao
   (IDS).

   O FreeBSD fornece suporte nativo para um sistema de IDS basico. Embora os
   emails de seguranc,a noturnos notifiquem o administrador sobre
   alterac,oes, as informac,oes sao armazenadas localmente e ha uma chance de
   que um usuario mal-intencionado modifique essas informac,oes para ocultar
   suas alterac,oes no sistema. Como tal, recomenda-se criar um conjunto
   separado de assinaturas binarias e armazena-las em um diretorio de
   read-only, propriedade do root ou, de preferencia, em um disco USB
   removivel ou servidor rsync remoto.

   O utilitario mtree embutido pode ser usado para gerar uma especificac,ao
   do conteudo de um diretorio. Um seed, ou uma constante numerica, e usada
   para gerar a especificac,ao e e necessaria para verificar se a
   especificac,ao nao foi alterada. Isso possibilita determinar se um arquivo
   ou binario foi modificado. Como o valor inicial do seed e desconhecido por
   um invasor, disfarc,ar ou impossibilitar a verificac,ao dos valores de
   checksum dos arquivos sera dificil ou impossivel. O exemplo a seguir gera
   um conjunto de hashes SHA256, um para cada sistema binario no diretorio
   /bin e salva esses valores em um arquivo oculto no diretorio inicial do
   root, /root/.bin_chksum_mtree:

 # mtree -s 3483151339707503 -c -K cksum,sha256digest -p /bin > /root/.bin_chksum_mtree
 # mtree: /bin checksum: 3427012225

   O 3483151339707503 representa o seed. Este valor deve ser lembrado, mas
   nao compartilhado.

   Visualizar o arquivo /root/.bin_cksum_mtree deve produzir uma saida
   semelhante `a seguinte:

 #          user: root
 #       machine: dreadnaught
 #          tree: /bin
 #          date: Mon Feb  3 10:19:53 2014

 # .
 /set type=file uid=0 gid=0 mode=0555 nlink=1 flags=none
 .               type=dir mode=0755 nlink=2 size=1024 \
                 time=1380277977.000000000
     \133        nlink=2 size=11704 time=1380277977.000000000 \
                 cksum=484492447 \
                 sha256digest=6207490fbdb5ed1904441fbfa941279055c3e24d3a4049aeb45094596400662a
     cat         size=12096 time=1380277975.000000000 cksum=3909216944 \
                 sha256digest=65ea347b9418760b247ab10244f47a7ca2a569c9836d77f074e7a306900c1e69
     chflags     size=8168 time=1380277975.000000000 cksum=3949425175 \
                 sha256digest=c99eb6fc1c92cac335c08be004a0a5b4c24a0c0ef3712017b12c89a978b2dac3
     chio        size=18520 time=1380277975.000000000 cksum=2208263309 \
                 sha256digest=ddf7c8cb92a58750a675328345560d8cc7fe14fb3ccd3690c34954cbe69fc964
     chmod       size=8640 time=1380277975.000000000 cksum=2214429708 \
                 sha256digest=a435972263bf814ad8df082c0752aa2a7bdd8b74ff01431ccbd52ed1e490bbe7

   O nome do host da maquina, a data e a hora em que a especificac,ao foi
   criada e o nome do usuario que criou a especificac,ao sao incluidos neste
   relatorio. Ha um checksum, tamanho, hora e um digest SHA256 para cada
   binario no diretorio.

   Para verificar se as assinaturas binarias nao foram alteradas, compare o
   conteudo atual do diretorio com a especificac,ao gerada anteriormente e
   salve os resultados em um arquivo. Este comando requer o seed que foi
   usado para gerar a especificac,ao original:

 # mtree -s 3483151339707503 -p /bin < /root/.bin_chksum_mtree >> /root/.bin_chksum_output
 # mtree: /bin checksum: 3427012225

   Isso deve produzir o mesmo checksum para /bin que foi produzido quando a
   especificac,ao foi criada. Se nenhuma alterac,ao tiver ocorrido nos
   binarios nesse diretorio, o arquivo de saida /root/.bin_chksum_output
   estara vazio. Para simular uma alterac,ao, altere a data no arquivo
   /bin/cat usando o touch e execute o comando de verificac,ao novamente:

 # touch /bin/cat
 # mtree -s 3483151339707503 -p /bin < /root/.bin_chksum_mtree >> /root/.bin_chksum_output
 # more /root/.bin_chksum_output
 cat changed
         modification time expected Fri Sep 27 06:32:55 2013 found Mon Feb  3 10:28:43 2014

   Recomenda-se criar especificac,oes para os diretorios que contem binarios
   e arquivos de configurac,ao, bem como quaisquer diretorios que contenham
   dados sensiveis. Normalmente, as especificac,oes sao criadas para /bin,
   /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /etc e /usr/local/etc.

   Existem sistemas de IDS mais avanc,ados, como o security/aide. Na maioria
   dos casos, o mtree fornece a funcionalidade que os administradores
   precisam. E importante manter o valor inicial e a saida do checksum oculta
   de usuarios mal-intencionados. Maiores informac,oes sobre o mtree podem
   ser encontradas em mtree(8).

  13.2.7. Otimizando o Sistema para Seguranc,a

   No FreeBSD, muitos recursos do sistema podem ser ajustados usando o
   sysctl. Alguns dos recursos de seguranc,a que podem ser ajustados para
   impedir ataques de negac,ao de servic,o (DoS) serao abordados nesta
   sec,ao. Mais informac,oes sobre o uso do sysctl, incluindo como alterar
   temporariamente os valores e como tornar as alterac,oes permanentes apos o
   teste, podem ser encontradas em Sec,ao 11.9, "Efetuando ajustes com o
   sysctl(8)".

  Nota:

   Sempre que uma configurac,ao e alterada com o sysctl, a chance de causar
   danos indesejados e aumentada, afetando a disponibilidade do sistema.
   Todas as alterac,oes devem ser monitoradas e, se possivel, testadas em um
   sistema de teste antes de serem usadas em um sistema de produc,ao.

   Por padrao, o kernel do FreeBSD e inicializado com um nivel de seguranc,a
   -1 . Isso e chamado de "modo inseguro" porque as flags de arquivos
   imutaveis podem ser desativadas e todos os dispositivos podem ser lidos ou
   gravados. O nivel de seguranc,a permanecera em -1, a menos que seja
   alterado atraves do sysctl ou por uma configurac,ao nos scripts de
   inicializac,ao. O nivel de seguranc,a pode ser aumentado durante a
   inicializac,ao do sistema, definindo kern_securelevel_enable para YES no
   arquivo /etc/rc.conf, e o valor de kern_securelevel para o nivel de
   seguranc,a desejado. Veja security(7) e init(8) para maiores informac,oes
   sobre essas configurac,oes e os niveis de seguranc,a disponiveis.

  Atenc,ao:

   Aumentar o valor da variavel securelevel pode quebrar o Xorg e causar
   outros problemas. Esteja preparado para fazer alguma depurac,ao.

   As configurac,oes da variavel net.inet.tcp.blackhole e
   net.inet.udp.blackhole podem ser usadas para descartar pacotes SYN de
   entrada em portas fechadas sem enviar uma resposta RST. O comportamento
   padrao e retornar um RST para mostrar que uma porta esta fechada. A
   alterac,ao do padrao fornece algum nivel de protec,ao contra varreduras de
   portas, que sao usadas para determinar quais aplicativos estao sendo
   executados em um sistema. Defina net.inet.tcp.blackhole para 2 e
   net.inet.udp.blackhole para 1. Consulte blackhole(4) para obter maiores
   informac,oes sobre essas configurac,oes.

   As configurac,oes das variaveis net.inet.icmp.drop_redirect e
   net.inet.ip.redirect ajudam a evitar ataques de redirecionamento. Um
   ataque de redirecionamento e um tipo de DoS que envia um grande numero de
   pacotes ICMP tipo 5. Como esses pacotes nao sao necessarios, configure
   net.inet.icmp.drop_redirect para 1 e configure net.inet.ip.redirect para
   0.

   O roteamento de origem e um metodo para detectar e acessar enderec,os nao
   roteaveis na rede interna. Isso deve ser desativado, pois enderec,os nao
   roteaveis normalmente nao sao roteaveis de proposito. Para desativar este
   recurso, defina net.inet.ip.sourceroute e net.inet.ip.accept_sourceroute
   como 0.

   Quando uma maquina na rede precisa enviar mensagens para todos os hosts em
   uma sub-rede, uma mensagem de solicitac,ao echo do ICMP e enviada para o
   enderec,o de broadcast. No entanto, nao ha motivo para um host externo
   executar essa ac,ao. Para rejeitar todas as solicitac,oes externas de
   transmissao, defina net.inet.icmp.bmcastecho como 0.

   Algumas configurac,oes adicionais estao documentadas em security(7).

13.3. Senhas de Uso Unico

   Por padrao, o FreeBSD inclui suporte para senhas de uso unico em tudo
   (OPIE). O OPIE e projetado para evitar ataques repetidos, nos quais um
   atacante descobre a senha de um usuario e a usa para acessar um sistema.
   Como uma senha e usada apenas uma vez em OPIE, uma senha descoberta e de
   pouca utilidade para um invasor. O OPIE usa um hash seguro e um sistema de
   desafio/resposta para gerenciar senhas. A implementac,ao do FreeBSD usa o
   hash MD5 por padrao.

   O OPIE usa tres tipos diferentes de senhas. A primeira e a senha usual
   UNIX(R) ou Kerberos. A segunda e a senha unica que e gerada pelo opiekey.
   O terceiro tipo de senha e a "senha secreta" que e usada para gerar senhas
   de uso unico. A senha secreta nao tem nada a fazer com ela e deve ser
   diferente da senha UNIX(R).

   Existem duas outras partes de dados importantes para o OPIE. Uma e o
   "seed" ou "chave", composta por duas letras e cinco digitos. A outra e a
   "contagem de iterac,ao", um numero entre 1 e 100. O OPIE cria a senha
   unica concatenando o seed e a senha secreta, aplicando o hash MD5 quantas
   vezes forem especificadas pela contagem de iterac,oes e transformando o
   resultado em seis palavras inglesas curtas que representam a senha de uso
   unico. O sistema de autenticac,ao controla a ultima senha descartavel
   usada e o usuario e autenticado se o hash da senha fornecida pelo usuario
   for igual `a senha anterior. Como um hash unidirecional e usado, e
   impossivel gerar futuras senhas de uso unico se uma senha usada com exito
   for capturada. A contagem de iterac,ao e diminuida apos cada login
   bem-sucedido para manter o usuario e o programa de login em sincronia.
   Quando a contagem de iterac,oes descer para 1, o OPIE deve ser
   reinicializado.

   Existem alguns programas envolvidos neste processo. Uma senha de uso
   unico, ou uma lista consecutiva de senhas de uso unico, e gerada passando
   uma contagem de iterac,ao, um seed e uma senha secreta para o opiekey(1).
   Alem de inicializar o OPIE, o opiepasswd(1) e usado para alterar senhas,
   contagens de iterac,ao ou seeds. Os arquivos de credenciais relevantes em
   /etc/opiekeys sao examinados pelo opieinfo(1) o qual imprime a iterac,ao
   atual e o seed do usuario solicitante atual.

   Esta sec,ao descreve quatro tipos diferentes de operac,oes. A primeira e
   como configurar senhas de uso unico pela primeira vez em uma conexao
   segura. A segunda e como usar o opiepasswd em uma conexao insegura. A
   terceira e como efetuar login em uma conexao insegura. A quarta e como
   gerar um numero de chaves que podem ser escritas ou impressas para uso em
   locais inseguros.

  13.3.1. Inicializando o OPIE

   Para inicializar o OPIE pela primeira vez, execute este comando a partir
   de um local seguro:

 % opiepasswd -c
 Adding unfurl:
 Only use this method from the console; NEVER from remote. If you are using
 telnet, xterm, or a dial-in, type ^C now or exit with no password.
 Then run opiepasswd without the -c parameter.
 Using MD5 to compute responses.
 Enter new secret pass phrase:
 Again new secret pass phrase:

 ID unfurl OTP key is 499 to4268
 MOS MALL GOAT ARM AVID COED

   A opc,ao -c define o modo de console que assume que o comando esta sendo
   executado de um local seguro, como um computador sob o controle do usuario
   ou uma sessao SSH para um computador sob o controle do usuario.

   Quando solicitado, insira a senha secreta que sera usada para gerar as
   chaves de login de uso unico. Essa senha deve ser dificil de adivinhar e
   deve ser diferente da senha associada `a conta de login do usuario. Deve
   ter entre 10 e 127 caracteres. Lembre-se desta senha.

   A linha ID lista o nome de login (unfurl), a contagem de iterac,oes padrao
   (499) e o seed padrao (to4268). Ao efetuar o login, o sistema lembrara
   esses parametros e os exibira, o que significa que eles nao precisam ser
   memorizados. A ultima linha lista a senha unica gerada que corresponde a
   esses parametros e a senha secreta. No proximo login, use essa senha
   unica.

  13.3.2. Inicializac,ao de uma Conexao Insegura

   Para inicializar ou alterar a senha secreta em um sistema inseguro, e
   necessaria uma conexao segura em algum lugar onde o opiekey possa ser
   executado. Isso pode ser um prompt de shell em uma maquina confiavel. Uma
   contagem de iterac,ao e necessaria, em que 100 e provavelmente um bom
   valor, e o seed pode ser especificado ou a gerado aleatoriamente. Na
   conexao insegura, a maquina sendo inicializada, use opiepasswd(1):

 % opiepasswd

 Updating unfurl:
 You need the response from an OTP generator.
 Old secret pass phrase:
         otp-md5 498 to4268 ext
         Response: GAME GAG WELT OUT DOWN CHAT
 New secret pass phrase:
         otp-md5 499 to4269
         Response: LINE PAP MILK NELL BUOY TROY

 ID mark OTP key is 499 gr4269
 LINE PAP MILK NELL BUOY TROY

   Para aceitar o seed padrao, pressione Return. Antes de inserir uma senha
   de acesso, passe para a conexao segura e fornec,a os mesmos parametros:

 % opiekey 498 to4268
 Using the MD5 algorithm to compute response.
 Reminder: Do not use opiekey from telnet or dial-in sessions.
 Enter secret pass phrase:
 GAME GAG WELT OUT DOWN CHAT

   Volte para a conexao insegura e copie a senha unica gerada para o programa
   relevante.

  13.3.3. Gerando uma Senha de Uso Unico

   Depois de inicializar o OPIE e efetuar login, um prompt como este sera
   exibido:

 % telnet example.com
 Trying 10.0.0.1...
 Connected to example.com
 Escape character is '^]'.

 FreeBSD/i386 (example.com) (ttypa)

 login: <username>
 otp-md5 498 gr4269 ext
 Password:

   Os prompts do OPIE fornecem um recurso util. Se o Enter for pressionado no
   prompt de senha, o prompt ativara o echo e exibira o que foi digitado.
   Isso pode ser util ao tentar digitar uma senha manualmente a partir de uma
   impressao.

   Neste ponto, gere a senha de uso unico para responder a este aviso de
   login. Isso deve ser feito em um sistema confiavel em que seja seguro
   executar o opiekey(1). Existem versoes deste comando para Windows(R), Mac
   OS(R) e FreeBSD. Esse comando precisa da contagem de iterac,ao e do seed
   como opc,oes da linha de comandos. Use recortar e colar no prompt de login
   da maquina que esta sendo conectada.

   No sistema confiavel:

 % opiekey 498 to4268
 Using the MD5 algorithm to compute response.
 Reminder: Do not use opiekey from telnet or dial-in sessions.
 Enter secret pass phrase:
 GAME GAG WELT OUT DOWN CHAT

   Depois que a senha descartavel for gerada, continue a logar.

  13.3.4. Gerando Multiplas Senhas de Uso Unico

   As vezes, nao ha acesso a uma maquina confiavel ou conexao segura. Neste
   caso, e possivel usar o opiekey(1) para gerar algumas de senhas de uso
   unico antecipadamente. Por exemplo:

 % opiekey -n 5 30 zz99999
 Using the MD5 algorithm to compute response.
 Reminder: Do not use opiekey from telnet or dial-in sessions.
 Enter secret pass phrase: <secret password>
 26: JOAN BORE FOSS DES NAY QUIT
 27: LATE BIAS SLAY FOLK MUCH TRIG
 28: SALT TIN ANTI LOON NEAL USE
 29: RIO ODIN GO BYE FURY TIC
 30: GREW JIVE SAN GIRD BOIL PHI

   A opc,ao -n 5 solicita cinco chaves em sequ:encia e 30 especifica qual
   deve ser o ultimo numero de iterac,ao. Note que estes sao impressos na
   ordem reversa de uso. O usuario realmente paranoico pode querer escrever
   os resultados manualmente; caso contrario, imprima a lista. Cada linha
   mostra a contagem de iterac,ao e a senha de uso unico. Risque as senhas
   conforme elas forem usadas.

  13.3.5. Restringindo o Uso de Senhas UNIX(R)

   O OPIE pode restringir o uso de senhas UNIX(R) com base no enderec,o IP de
   uma sessao de login. O arquivo relevante e o /etc/opieaccess, que esta
   presente por padrao. Consulte opieaccess(5) para obter maiores
   informac,oes sobre esse arquivo e sobre quais considerac,oes de seguranc,a
   voce deve estar ciente ao usa-lo.

   Aqui esta um exemplo do arquivo opieaccess:

 permit 192.168.0.0 255.255.0.0

   Esta linha permite que os usuarios cujo enderec,o de origem IP (que e
   vulneravel a spoofing) corresponda ao valor e `a mascara especificados,
   para usar as senhas UNIX(R) a qualquer momento.

   Se nenhuma regra do arquivo opieaccess for correspondida, o padrao e negar
   logins que nao sejam OPIE.

13.4. TCP Wrapper

   Escrito por Tom Rhodes.

   O TCP Wrapper e um sistema de controle de acesso baseado em host que
   estende as habilidades do Sec,ao 29.2, "O super-servidor inetd". Ele pode
   ser configurado para fornecer suporte de registro, mensagens de retorno e
   restric,oes de conexao para os daemons do servidor sob o controle do
   inetd. Consulte tcpd(8) para obter maiores informac,oes sobre o TCP
   Wrapper e seus recursos.

   O TCP Wrapper nao deve ser considerado um substituto para um firewall
   configurado adequadamente. Em vez disso, TCP Wrapper deve ser usado em
   conjunto com um firewall e outros aprimoramentos de seguranc,a para
   fornecer outra camada de protec,ao na implementac,ao de uma politica de
   seguranc,a.

  13.4.1. Configurac,ao Inicial

   Para ativar o TCP Wrapper no FreeBSD, adicione as seguintes linhas ao
   arquivo /etc/rc.conf:

 inetd_enable="YES"
 inetd_flags="-Ww"

   Entao, configure corretamente o arquivo /etc/hosts.allow.

  Nota:

   Ao contrario de outras implementac,oes do TCP Wrapper, o uso do arquivo
   hosts.deny foi preterido no FreeBSD. Todas as opc,oes de configurac,ao
   devem ser colocadas no arquivo /etc/hosts.allow.

   Na configurac,ao mais simples, as politicas de conexao do daemon sao
   configuradas para permitir ou bloquear, dependendo das opc,oes no arquivo
   /etc/hosts.allow. A configurac,ao padrao no FreeBSD e permitir todas as
   conexoes para os daemons iniciados com o inetd.

   A configurac,ao basica geralmente assume a forma de daemon : address :
   action, onde daemon e o daemon que o inetd iniciou, address e um nome de
   host valido ou um enderec,o IP ou um enderec,o IPv6 entre colchetes ([]) e
   action e allow ou deny. O TCP Wrapper usa uma semantica de correspondencia
   de primeira regra, o que significa que o arquivo de configurac,ao e
   varrido desde o inicio para uma regra correspondente. Quando uma
   correspondencia e encontrada, a regra e aplicada e o processo de pesquisa
   e interrompido.

   Por exemplo, para permitir conexoes POP3 atraves do daemon mail/qpopper,
   as seguintes linhas devem ser anexadas ao arquivo hosts.allow:

 # This line is required for POP3 connections:
 qpopper : ALL : allow

   Sempre que este arquivo for editado, reinicie o inetd:

 # service inetd restart

  13.4.2. Configurac,ao Avanc,ada

   O TCP Wrapper fornece opc,oes avanc,adas para permitir mais controle sobre
   o modo como as conexoes sao tratadas. Em alguns casos, pode ser apropriado
   retornar um comentario para determinados hosts ou conexoes de daemon. Em
   outros casos, uma entrada de log deve ser registrada ou um email enviado
   ao administrador. Outras situac,oes podem exigir o uso de um servic,o
   apenas para conexoes locais. Isso tudo e possivel atraves do uso de
   opc,oes de configurac,ao conhecidas como wildcards, caracteres de expansao
   e execuc,ao de comandos externos.

   Suponha que uma situac,ao ocorra onde uma conexao deva ser negada, mas uma
   razao deve ser enviada ao host que tentou estabelecer essa conexao. Essa
   ac,ao e possivel com a opc,ao twist. Quando uma tentativa de conexao e
   feita, o twist executa um comando ou script shell. Existe um exemplo no
   arquivo hosts.allow:

 # The rest of the daemons are protected.
 ALL : ALL \
         : severity auth.info \
         : twist /bin/echo "You are not welcome to use %d from %h."

   Neste exemplo, a mensagem "You are not allowed to use daemon name from
   hostname." sera retornada para qualquer daemon nao configurado no
   hosts.allow . Isso e util para enviar uma resposta de volta ao
   inicializador de conexao logo apos a conexao estabelecida ser descartada.
   Qualquer mensagem a ser retornada deve ser delimitada por caracteres de
   aspas duplas (").

  Atenc,ao:

   Pode ser possivel iniciar um ataque de negac,ao de servic,o no servidor se
   um invasor inunda esses daemons com solicitac,oes de conexao.

   Outra possibilidade e usar a opc,ao spawn. Como a opc,ao twist, a
   opc,aospawn implicitamente nega a conexao e pode ser usado para executar
   comandos ou scripts externos do shell. Ao contrario da twist, a spawn nao
   enviara uma resposta ao host que estabeleceu a conexao. Por exemplo,
   considere a seguinte configurac,ao:

 # We do not allow connections from example.com:
 ALL : .example.com \
         : spawn (/bin/echo %a from %h attempted to access %d >> \
           /var/log/connections.log) \
         : deny

   Isso negara todas as tentativas de conexao de *.example.com e registrara o
   nome do host, enderec,o IP e o daemon ao qual o acesso foi tentado no
   arquivo /var/log/connections.log. Este exemplo usa os caracteres de
   substituic,ao %a e %h. Consulte hosts_access(5) para a lista completa.

   Para corresponder a cada instancia de um daemon, dominio ou enderec,o IP,
   use ALL. Outro wildcard e o PARANOID, que pode ser usado para corresponder
   a qualquer host que fornec,a um enderec,o IP que possa ser forjado, porque
   o enderec,o IP difere do nome resolvido para o host. Neste exemplo, todas
   as solicitac,oes de conexao para o Sendmail que possuem um enderec,o IP
   que varia de seu nome de host serao negadas:

 # Block possibly spoofed requests to sendmail:
 sendmail : PARANOID : deny

  Cuidado:

   Usar o wildcard PARANOID resultara em conexoes negadas se o cliente ou
   servidor tiver uma configurac,ao de DNS incorreta.

   Para saber mais sobre wildcards e sua funcionalidade associada, consulte
   hosts_access(5).

  Nota:

   Ao adicionar novas linhas de configurac,ao, certifique-se de que quaisquer
   entradas desnecessarias para esse daemon sejam comentadas no arquivo
   hosts.allow.

13.5. Kerberos

   Contribuido por Tillman Hodgson.
   Baseado em uma contribuic,ao de Mark Murray.

   O Kerberos e um protocolo de autenticac,ao de rede que foi originalmente
   criado pelo Instituto de Tecnologia de Massachusetts (MIT) como uma
   maneira segura de fornecer autenticac,ao em uma rede potencialmente
   hostil. O protocolo Kerberos usa criptografia robusta para que tanto um
   cliente quanto um servidor possam provar sua identidade sem enviar nenhum
   segredo nao criptografado pela rede. O Kerberos pode ser descrito como um
   sistema proxy de verificac,ao de identidade e como um sistema confiavel de
   autenticac,ao de terceiros. Depois que um usuario autentica com Kerberos,
   suas comunicac,oes podem ser criptografadas para garantir privacidade e
   integridade dos dados.

   A unica func,ao do Kerberos e fornecer a autenticac,ao segura de usuarios
   e servidores na rede. Ele nao fornece func,oes de autorizac,ao ou
   auditoria. Recomenda-se que o Kerberos seja usado com outros metodos de
   seguranc,a que fornec,am servic,os de autorizac,ao e auditoria.

   A versao atual do protocolo e a versao 5, descrita na RFC 4120. Varias
   implementac,oes gratuitas deste protocolo estao disponiveis, abrangendo
   uma ampla gama de sistemas operacionais. O MIT continua desenvolvendo o
   pacote Kerberos. E comumente usado no US como um produto de criptografia
   e, historicamente, esta sujeito aos regulamentos de exportac,ao dos US. No
   FreeBSD, o MIT Kerberos esta disponivel como o pacote ou port
   security/krb5. A implementac,ao do Kerberos do Heimdal foi explicitamente
   desenvolvida fora do US para evitar regulamentac,oes de exportac,ao. A
   distribuic,ao Kerberos do Heimdal esta incluida na instalac,ao base do
   FreeBSD, e outra distribuic,ao com opc,oes mais configuraveis esta
   disponivel como security/heimdal na Colec,ao de Ports.

   No Kerberos, os usuarios e servic,os sao identificados como "principals",
   que estao contidos em um agrupamento administrativo chamado de "realm". Um
   usuario principal tipico teria o formato user@REALM (os realms sao
   tradicionalmente em caracteres maiusculos).

   Esta sec,ao fornece um guia sobre como configurar o Kerberos usando a
   distribuic,ao Heimdal incluida no FreeBSD.

   Para fins de demonstrac,ao de uma instalac,ao do Kerberos , os namespaces
   serao os seguintes:

     * O dominio (zona) de dominio DNS sera example.org.

     * O realm Kerberos sera EXAMPLE.ORG.

  Nota:

   Use nomes de dominio reais ao configurar o Kerberos, mesmo que ele seja
   executado internamente. Isso evita problemas de DNS e garante a
   interoperabilidade com outros realms do Kerberos.

  13.5.1. Configurando um KDC do Heimdal

   O Centro de Distribuic,ao de Chaves (KDC) e o servic,o de autenticac,ao
   centralizada que o Kerberos fornece, a "a parte de terceiros confiaveis"
   do sistema. E o computador que emite os tiquetes Kerberos, que sao usados
   para autenticac,ao dos clientes nos servidores. Como o KDC e considerado
   confiavel por todos os outros computadores no realm do Kerberos, isso
   aumenta as preocupac,oes com a seguranc,a. O acesso direto ao KDC deve ser
   limitado.

   Embora a execuc,ao de um KDC exija poucos recursos de computac,ao, uma
   maquina dedicada que atua apenas como um KDC e recomendada por motivos de
   seguranc,a.

   Para comec,ar a configurar um KDC, adicione estas linhas ao arquivo
   /etc/rc.conf:

 kdc_enable="YES"
 kadmind_enable="YES"

   Em seguida, edite o arquivo /etc/krb5.conf como a seguir:

 [libdefaults]
     default_realm = EXAMPLE.ORG
 [realms]
     EXAMPLE.ORG = {
         kdc = kerberos.example.org
         admin_server = kerberos.example.org
     }
 [domain_realm]
     .example.org = EXAMPLE.ORG

   Neste exemplo, o KDC usara o nome completo do host kerberos.example.org. O
   nome do host do KDC precisa ser resolvido no DNS.

   O Kerberos tambem pode usar o DNS para localizar os KDCs, em vez de uma
   sec,ao [realms] no arquivo /etc/krb5.conf. Para grandes organizac,oes que
   possuem seus proprios servidores DNS, o exemplo acima pode ser reduzido
   para:

 [libdefaults]
       default_realm = EXAMPLE.ORG
 [domain_realm]
     .example.org = EXAMPLE.ORG

   Com as seguintes linhas sendo incluidas no arquivo de zona do dominio
   example.org:

 _kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
 _kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
 _kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
 _kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
 _kerberos           IN  TXT     EXAMPLE.ORG

  Nota:

   Para que os clientes possam encontrar os servic,os Kerberos, eles devem
   ter um /etc/krb5.conf totalmente configurado ou um /etc/krb5.conf
   minimamente configurado e um servidor DNS corretamente configurado.

   Em seguida, crie o banco de dados do Kerberos que contem as chaves de
   todos os principals (usuarios e hosts) criptografados com uma senha
   master. Nao e necessario lembrar essa senha, pois ela sera armazenada no
   arquivo /var/heimdal/m-key; Seria razoavel usar uma senha aleatoria de 45
   caracteres para essa finalidade. Para criar a chave master, execute kstash
   e digite uma senha:

 # kstash
 Master key: xxxxxxxxxxxxxxxxxxxxxxx
 Verifying password - Master key: xxxxxxxxxxxxxxxxxxxxxxx

   Depois que a chave master e criada, o banco de dados deve ser
   inicializado. A ferramenta administrativa do Kerberos kadmin(8) pode ser
   usada no KDC em um modo que opera diretamente no banco de dados, sem usar
   o servic,o de rede kadmind(8), como kadmin -l. Isso resolve o problema do
   ovo e da galinha de tentar se conectar ao banco de dados antes de cria-lo.
   No prompt do kadmin, use o init para criar o banco de dados inicial do
   realm:

 # kadmin -l
 kadmin> init EXAMPLE.ORG
 Realm max ticket life [unlimited]:

   Por fim, enquanto ainda estiver no kadmin, crie o primeiro principal
   usando add. Atenha-se `as opc,oes padrao para o principal por enquanto,
   pois elas podem ser alteradas posteriormente com modify. Digite ? no
   prompt para ver as opc,oes disponiveis.

 kadmin> add tillman
 Max ticket life [unlimited]:
 Max renewable life [unlimited]:
 Attributes []:
 Password: xxxxxxxx
 Verifying password - Password: xxxxxxxx

   Em seguida, inicie os servic,os do KDC executando service kdc start e
   service kadmind start. Embora nao haja daemons kerberizados em execuc,ao
   neste momento, e possivel confirmar que o KDC esta funcionando obtendo um
   ticket para o principal que acabou de ser criado:

 % kinit tillman
 tillman@EXAMPLE.ORG's Password:

   Confirme se um ticket foi obtido com sucesso usando klist:

 % klist
 Credentials cache: FILE:/tmp/krb5cc_1001
         Principal: tillman@EXAMPLE.ORG

   Issued                Expires               Principal
 Aug 27 15:37:58 2013  Aug 28 01:37:58 2013  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG

   O ticket temporario pode ser destruido quando o teste terminar:

 % kdestroy

  13.5.2. Configurando um Servidor para Usar o Kerberos

   A primeira etapa na configurac,ao de um servidor para usar a autenticac,ao
   Kerberos e garantir que ele tenha a configurac,ao correta no arquivo
   /etc/krb5.conf. A versao do KDC pode ser usada como esta, ou pode ser
   regenerada no novo sistema.

   Em seguida, crie o arquivo /etc/krb5.keytab no servidor. Esta e a parte
   principal de "Kerberizar" um servic,o - ele corresponde a gerar uma chave
   secreta compartilhada entre o servic,o e o KDC. O segredo e uma chave
   criptografica, armazenada em um "keytab". O keytab contem a chave do host
   do servidor, que permite que ele e o KDC verifiquem a identidade um do
   outro. Ele deve ser transmitido para o servidor de maneira segura, pois a
   seguranc,a do servidor pode ser quebrada se a chave for tornada publica.
   Normalmente, o keytab e gerado na maquina confiavel de um administrador
   usando o kadmin, e entao transferido com seguranc,a para o servidor, por
   exemplo, com scp(1); Ele tambem pode ser criado diretamente no servidor,
   se isso for consistente com a politica de seguranc,a desejada. E muito
   importante que o keytab seja transmitido para o servidor de forma segura:
   se a chave for conhecida por outra parte, essa parte pode representar
   qualquer usuario para o servidor! Usar o kadmin diretamente no servidor e
   conveniente, porque a entrada para o principal do host no banco de dados
   do KDC tambem e criada usando o kadmin.

   Naturalmente, o kadmin e um servic,o kerberizado; um tiquete Kerberos e
   necessario para autenticar-se no servic,o de rede, mas para garantir que o
   usuario que esta executando o kadmin esteja presente (e sua sessao nao
   tenha sido invadida), o kadmin solicitara a senha para obter um novo
   ticket. O principal autenticando no servic,o kadmin deve ter permissao
   para usar a interface kadmin, conforme especificado no arquivo
   kadmind.acl. Veja a sec,ao intitulada "Administrac,ao Remota" em info
   heimdal para detalhes sobre a criac,ao de listas de controle de acesso. Em
   vez de ativar o acesso remoto ao kadmin, o administrador pode conectar-se
   com seguranc,a ao KDC atraves do console local ou por ssh() e executar a
   administrac,ao localmente usando o kadmin -l.

   Depois de instalar o arquivo /etc/krb5.conf, use o add --random-key no
   kadmin. Isso adiciona o principal do host do servidor ao banco de dados,
   mas nao extrai uma copia da chave principal do host para um keytab. Para
   gerar o keytab, use ext para extrair a chave principal do host do servidor
   para seu proprio keytab:

 # kadmin
 kadmin> add --random-key host/myserver.example.org
 Max ticket life [unlimited]:
 Max renewable life [unlimited]:
 Principal expiration time [never]:
 Password expiration time [never]:
 Attributes []:
 kadmin> ext_keytab host/myserver.example.org
 kadmin> exit

   Note que o ext_keytab por padrao armazena a chave extraida no arquivo
   /etc/krb5.keytab. Isso e bom quando executado no servidor que esta sendo
   kerberizado, mas o argumento --keytab path/to/file deve ser usado quando o
   keytab estiver sendo extraido em outro lugar:

 # kadmin
 kadmin> ext_keytab --keytab=/tmp/example.keytab host/myserver.example.org
 kadmin> exit

   O keytab pode entao ser copiado com seguranc,a para o servidor usando o
   scp(1) ou uma midia removivel. Certifique-se de especificar um nome de
   keytab nao padrao para evitar a inserc,ao de chaves desnecessarias na
   keytab do sistema.

   Neste ponto, o servidor pode ler mensagens criptografadas do KDC usando
   sua chave compartilhada, armazenada no arquivo krb5.keytab. Agora ele esta
   pronto para ativar os servic,os de uso do Kerberos. Um dos servic,os mais
   comuns e o sshd(8), que suporta o Kerberos atraves do GSS-API. No arquivo
   /etc/ssh/sshd_config, adicione a linha:

 GSSAPIAuthentication yes

   Depois de fazer essa alterac,ao, o sshd(8) deve ser reiniciado para que a
   nova configurac,ao tenha efeito: service sshd restart.

  13.5.3. Configurando um cliente para usar o Kerberos

   Assim como foi no servidor, o cliente requer configurac,ao no arquivo
   /etc/krb5.conf. Copie o arquivo no local (com seguranc,a) ou insira-o
   novamente conforme necessario.

   Teste o cliente usando o kinit, klist e kdestroy a partir do cliente para
   obter, mostrar e excluir um ticket para um principal existente. Os
   aplicativos Kerberos tambem devem poder se conectar a servidores
   habilitados pelo Kerberos. Se isso nao funcionar, mas a obtenc,ao de um
   ticket ocorrer, provavelmente o problema esta no servidor e nao no cliente
   ou no KDC. No caso do ssh(1) kerberizado, o GSS-API esta desabilitado por
   padrao, portanto teste usando ssh -o GSSAPIAuthentication=yes hostname.

   Ao testar um aplicativo Kerberizado, tente usar um sniffer de pacote, como
   o tcpdump, para confirmar que nenhuma informac,ao confidencial e enviada
   sem protec,ao.

   Varias aplicac,oes Kerberos cliente estao disponiveis. Com o advento de
   uma ponte para que aplicac,oes usando SASL para autenticac,ao possam usar
   mecanismos GSS-API, grandes classes de aplicativos clientes podem usar o
   Kerberos para autenticac,ao, de clientes Jabber a clientes IMAP.

   Os usuarios em um realm geralmente tem seu principal Kerberos mapeado para
   uma conta de usuario local. Ocasionalmente, e necessario conceder acesso a
   uma conta de usuario local a alguem que nao tenha um principal Kerberos
   correspondente. Por exemplo, tillman@EXAMPLE.ORG pode precisar de acesso
   `a conta de usuario local webdevelopers. Outros diretores tambem podem
   precisar de acesso a essa conta local.

   Os arquivos .k5login e .k5users, colocados no diretorio home de um
   usuario, podem ser usados para resolver este problema. Por exemplo, se o
   seguinte .k5login for colocado no diretorio inicial de webdevelopers, os
   dois principals listados terao acesso a essa conta sem exigir uma senha
   compartilhada:

 tillman@example.org
 jdoe@example.org

   Consulte ksu(1) para obter maiores informac,oes sobre o .k5users.

  13.5.4. Diferenc,as com a implementac,ao do MIT

   A principal diferenc,a entre as implementac,oes do MIT e a Heimdal e que o
   kadmin tem um conjunto de comandos diferente, mas equivalente, e usa um
   protocolo diferente. Se o KDC for MIT, a versao Heimdal do kadmin nao
   podera ser usada para administrar o KDC remotamente, e vice versa.

   Aplicac,oes cliente tambem podem usar opc,oes de linha de comando
   ligeiramente diferentes para realizar as mesmas tarefas. Seguir as
   instruc,oes em http://web.mit.edu/Kerberos/www/ e recomendado. Cuidado com
   os problemas de caminho: o port MIT e instalado em /usr/local/ por padrao,
   e os aplicativos do sistema FreeBSD serao executados em vez das versoes do
   MIT se o PATH listar os diretorios do sistema primeiro.

   Ao usar o MIT Kerberos como um KDC no FreeBSD, as seguintes edic,oes
   tambem devem ser feitas no rc.conf:

 kerberos5_server="/usr/local/sbin/krb5kdc"
 kadmind5_server="/usr/local/sbin/kadmind"
 kerberos5_server_flags=""
 kerberos5_server_enable="YES"
 kadmind5_server_enable="YES"

  13.5.5. Dicas, Truques e Soluc,ao de Problemas do Kerberos

   Ao configurar e solucionar problemas do Kerberos, tenha em mente os
   seguintes pontos:

     * Ao usar o Heimdal ou MIT Kerberos do ports, certifique-se de que o
       PATH liste as versoes do port dos aplicativos clientes antes das
       versoes do sistema.

     * Se todos os computadores no realm nao tiverem configurac,oes de
       horario sincronizadas, a autenticac,ao podera falhar. Sec,ao 29.11,
       "Sincronizac,ao de Relogio com NTP" descreve como sincronizar os
       relogios usando o NTP.

     * Se o nome do host for alterado, o host/ principal deve ser alterado e
       o keytab atualizado. Isso tambem se aplica a entradas de keytab
       especiais como o HTTP/ principal usado para o www/mod_auth_kerb do
       Apache.

     * Todos os hosts no realm devem ser resolvidos tanto de forma direta
       quanto reversa no DNS ou, no minimo, no arquivo /etc/hosts. Os CNAMEs
       funcionarao, mas os registros A e PTR devem estar corretos e no lugar.
       A mensagem de erro para hosts nao resolvidos nao e intuitiva:
       Kerberos5 refuses authentication because Read req failed: Key table
       entry not found.

     * Alguns sistemas operacionais que agem como clientes para o KDC nao
       definem as permissoes para o ksu para serem setuid root. Isso
       significa que o ksu nao funciona. Este e um problema de permissoes,
       nao um erro do KDC.

     * Com o MIT Kerberos, para permitir que um principal tenha uma durac,ao
       de ticket maior que a durac,ao padrao de dez horas, use
       modify_principal no kadmin(8) para alterar o maxlife do principal em
       questao e do krbtgt principal. O principal pode entao usar o kinit -l
       para solicitar um ticket com uma vida util mais longa.

     * Ao executar um sniffer de pacotes no KDC para auxiliar na soluc,ao de
       problemas enquanto executa kinit de uma estac,ao de trabalho, o Ticket
       de Concessao de Tickets (TGT) e enviado imediatamente, mesmo antes da
       digitac,ao da senha. Isso ocorre porque o servidor Kerberos transmite
       livremente um TGT para qualquer solicitac,ao nao autorizada. No
       entanto, cada TGT e criptografado em uma chave derivada da senha do
       usuario. Quando um usuario digita sua senha, ela nao e enviada para o
       KDC, ela e usada para descriptografar o TGT que o kinit ja obteve. Se
       o processo de descriptografia resultar em um tiquete valido com um
       registro de data e hora valido, o usuario tera credenciais do Kerberos
       validas. Essas credenciais incluem uma chave de sessao para
       estabelecer comunicac,oes seguras com o servidor Kerberos no futuro,
       bem como o TGT, que e criptografado com a chave do proprio servidor
       Kerberos. Essa segunda camada de criptografia permite que o servidor
       Kerberos verifique a autenticidade de cada TGT.

     * Os principals do host podem ter uma vida util maior do ticket. Se o
       usuario do principal tiver uma vida util de uma semana, mas o host ao
       qual esta conectado tiver uma vida util de nove horas, o cache do
       usuario tera um host principal expirado e o cache do ticket nao
       funcionara como esperado.

     * Ao configurar o arquivo krb5.dict para evitar que senhas incorretas
       especificas sejam usadas, conforme descrito em kadmind(8), lembre-que
       so se aplica a entidades que tenham uma politica de senha atribuida a
       elas. O formato usado em krb5.dict e uma string por linha. Criar um
       link simbolico para /usr/share/dict/words pode ser util.

  13.5.6. Atenuando as Limitac,oes do Kerberos

   Uma vez que com o Kerberos a abordagem e tudo ou nada, cada servic,o
   habilitado na rede deve ser modificado para funcionar com o Kerberos ou
   ser protegido contra ataques de rede. Isso impede que as credenciais do
   usuario sejam roubadas e reutilizadas. Um exemplo e quando o Kerberos esta
   habilitado em todos os shells remotos, mas o servidor de email POP3
   nao-Kerberizado envia senhas em texto simples.

   O KDC e um ponto unico de falha. Por design, o KDC deve ser tao seguro
   quanto seu banco de dados de senhas master. O KDC nao deve ter
   absolutamente nenhum outro servic,o sendo executado e deve estar
   fisicamente seguro. O perigo e alto porque o Kerberos armazena todas as
   senhas criptografadas com a mesma chave mestra que e armazenada como um
   arquivo no KDC.

   Uma chave mestra comprometida nao e tao ruim quanto se pode temer. A chave
   mestra e usada apenas para criptografar o banco de dados do Kerberos e
   como um seed para o gerador de numeros aleatorios. Desde que o acesso ao
   KDC seja seguro, um invasor nao podera fazer muito com a chave mestra.

   Se o KDC nao estiver disponivel, os servic,os de rede nao poderao ser
   utilizados, pois a autenticac,ao nao podera ser executada. Isso pode ser
   mitigado com um unico KDC master e um ou mais slaves, e com a
   implementac,ao cuidadosa da autenticac,ao secundaria ou de fallback usando
   PAM.

   O Kerberos permite que usuarios, hosts e servic,os se autentiquem entre
   si. Ele nao possui um mecanismo para autenticar o KDC para os usuarios,
   hosts ou servic,os. Isso significa que um kinit infectado por um trojan
   pode registrar todos os nomes de usuario e senhas. As ferramentas de
   verificac,ao de integridade do sistema de arquivos, como
   security/tripwire, podem mitigar isso.

  13.5.7. Recursos e Outras Informac,oes

     * A FAQ do Kerberos

     * Criando um Sistema de Autenticac,ao: um Dialogo em Quatro Cenas

     * RFC 4120, O Servic,o de Autenticac,ao em Rede (V5) do Kerberos

     * Pagina Web do Kerberos MIT

     * Pagina Web do Kerberos Heimdal

13.6. OpenSSL

   Escrito por Tom Rhodes.

   O OpenSSL e uma implementac,ao de software livre dos protocolos SSL e TLS.
   Ele fornece uma camada de transporte de criptografia sobre a camada de
   comunicac,ao normal, permitindo que ela seja entrelac,ada com muitos
   aplicativos e servic,os de rede.

   A versao do OpenSSL incluida no FreeBSD suporta os protocolos de
   seguranc,a de redes Secure Sockets Layer 3.0 (SSLv3) e Transport Layer
   Security 1.0/1.1/1.2 (TLSv1/TLSv1.1/TLSv1.2) e pode ser usado como uma
   biblioteca de criptografia geral. No FreeBSD 12.0-RELEASE e posterior,
   OpenSSL tambem suporta Transport Layer Security 1.3 (TLSv1.3).

   O OpenSSL e muitas vezes usado para encriptar a autenticac,ao de clientes
   de email e proteger transac,oes baseadas na web como pagamentos com
   cartoes de credito. Alguns ports, como o www/apache24 e
   databases/postgresql11-server, incluem uma opc,ao de compilac,ao para
   inserir o OpenSSL. Se selecionado, o port vai adicionar suporte ao OpenSSL
   da base do sistema. Para ter o port compilado com o suporte do OpenSSL do
   port security/openssl, adicione o seguinte ao arquivo /etc/make.conf:

 DEFAULT_VERSIONS+= ssl=openssl

   Outro uso comum do OpenSSL e fornecer certificados para uso com aplicac,oe
   de software. Os certificados podem ser usados para verificar as
   credenciais de uma empresa ou individuo. Se um certificado nao tiver sido
   assinado por uma Autoridade de Certificac,ao externa ( CA ), como
   http://www.verisign.com, o aplicativo que usa o certificado produzira um
   aviso. Ha um custo associado `a obtenc,ao de um certificado assinado e o
   uso de um certificado assinado nao e obrigatorio, pois os certificados
   podem ser auto-assinados. No entanto, o uso de uma autoridade externa
   evitara avisos e podera deixar os usuarios mais `a vontade.

   Esta sec,ao demonstra como criar e usar certificados em um sistema
   FreeBSD. Consulte Sec,ao 29.5.2, "Configurando um servidor LDAP" para um
   exemplo de como criar uma CA para assinar seus proprios certificados.

   Para obter maiores informac,oes sobre o SSL, leia o OpenSSL Cookbook
   gratuito.

  13.6.1. Gerando Certificados

   Para gerar um certificado que sera assinado por uma CA externa, emita o
   seguinte comando e insira as informac,oes solicitadas nos prompts. Esta
   informac,ao de entrada sera gravada no certificado. No prompt Common Name,
   insira o nome completo para o sistema que usara o certificado. Se esse
   nome nao corresponder ao servidor, a aplicac,ao que estiver verificando o
   certificado emitira um aviso para o usuario, tornando a verificac,ao
   provida pelo certificado inutil.

 # openssl req -new -nodes -out req.pem -keyout cert.key -sha256 -newkey rsa:2048
 Generating a 2048 bit RSA private key
 ..................+++
 .............................................................+++
 writing new private key to 'cert.key'
 -----
 You are about to be asked to enter information that will be incorporated
 into your certificate request.
 What you are about to enter is what is called a Distinguished Name or a DN.
 There are quite a few fields but you can leave some blank
 For some fields there will be a default value,
 If you enter '.', the field will be left blank.
 -----
 Country Name (2 letter code) [AU]:US
 State or Province Name (full name) [Some-State]:PA
 Locality Name (eg, city) []:Pittsburgh
 Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Company
 Organizational Unit Name (eg, section) []:Systems Administrator
 Common Name (eg, YOUR name) []:localhost.example.org
 Email Address []:trhodes@FreeBSD.org

 Please enter the following 'extra' attributes
 to be sent with your certificate request
 A challenge password []:
 An optional company name []:Another Name

   Outras opc,oes, como o tempo de expirac,ao e algoritmos de criptografia
   alternativos, estao disponiveis ao criar um certificado. Uma lista
   completa de opc,oes e descrita em openssl(1).

   Este comando ira criar dois arquivos no diretorio atual. A solicitac,ao de
   certificado, req.pem, pode ser enviada para uma CA que validara as
   credenciais inseridas, assinara a solicitac,ao e retornara o certificado
   assinado. O segundo arquivo, cert.key, e a chave privada do certificado e
   deve ser armazenado em um local seguro. Se ele cair nas maos de outros,
   ele pode ser usado para representar o usuario ou o servidor.

   Como alternativa, se uma assinatura de uma CA nao for necessaria, um
   certificado auto-assinado podera ser criado. Primeiro, gere a chave RSA:

 # openssl genrsa -rand -genkey -out cert.key 2048
 0 semi-random bytes loaded
 Generating RSA private key, 2048 bit long modulus
 .............................................+++
 .................................................................................................................+++
 e is 65537 (0x10001)

   Use essa chave para criar um certificado auto-assinado. Siga os prompts
   usuais para criar um certificado:

 # openssl req -new -x509 -days 365 -key cert.key -out cert.crt -sha256
 You are about to be asked to enter information that will be incorporated
 into your certificate request.
 What you are about to enter is what is called a Distinguished Name or a DN.
 There are quite a few fields but you can leave some blank
 For some fields there will be a default value,
 If you enter '.', the field will be left blank.
 -----
 Country Name (2 letter code) [AU]:US
 State or Province Name (full name) [Some-State]:PA
 Locality Name (eg, city) []:Pittsburgh
 Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Company
 Organizational Unit Name (eg, section) []:Systems Administrator
 Common Name (e.g. server FQDN or YOUR name) []:localhost.example.org
 Email Address []:trhodes@FreeBSD.org

   Isso criara dois novos arquivos no diretorio atual: um arquivo de chave
   privada cert.key e o proprio certificado, cert.crt. Estes devem ser
   colocados em um diretorio, preferencialmente sob /etc/ssl/, que e legivel
   somente pelo root. As permissoes de 0700 sao apropriadas para esses
   arquivos e podem ser definidas usando o chmod.

  13.6.2. Usando Certificados

   Um uso para um certificado e criptografar conexoes do servidor de email
   Sendmail para evitar o trafego de informac,oes de autenticac,ao em texto
   nao criptografado.

  Nota:

   Alguns clientes de email exibirao um erro se o usuario nao tiver instalado
   uma copia local do certificado. Consulte a documentac,ao incluida com o
   software para obter maiores informac,oes sobre a instalac,ao do
   certificado.

   No FreeBSD 10.0-RELEASE e posterior, e possivel criar um certificado
   auto-assinado para o Sendmail automaticamente. Para habilitar isso,
   adicione as seguintes linhas ao arquivo /etc/rc.conf:

 sendmail_enable="YES"
 sendmail_cert_create="YES"
 sendmail_cert_cn="localhost.example.org"

   Isso criara automaticamente um certificado auto-assinado,
   /etc/mail/certs/host.cert, uma chave de assinatura,
   /etc/mail/certs/host.key, e um certificado CA, /etc/mail/certs/cacert.pem.
   O certificado usara o Common Name especificado em sendmail_cert_cn. Depois
   de salvar as edic,oes, reinicie o Sendmail:

 # service sendmail restart

   Se tudo correr bem, nao havera mensagens de erro no arquivo
   /var/log/maillog. Para um teste simples, conecte-se `a porta de escuta do
   servidor de correio usando o telnet:

 # telnet example.com 25
 Trying 192.0.34.166...
 Connected to example.com.
 Escape character is '^]'.
 220 example.com ESMTP Sendmail 8.14.7/8.14.7; Fri, 18 Apr 2014 11:50:32 -0400 (EDT)
 ehlo example.com
 250-example.com Hello example.com [192.0.34.166], pleased to meet you
 250-ENHANCEDSTATUSCODES
 250-PIPELINING
 250-8BITMIME
 250-SIZE
 250-DSN
 250-ETRN
 250-AUTH LOGIN PLAIN
 250-STARTTLS
 250-DELIVERBY
 250 HELP
 quit
 221 2.0.0 example.com closing connection
 Connection closed by foreign host.

   Se a linha STARTTLS aparecer na saida, tudo esta funcionando corretamente.

13.7. VPN Sobre IPsec

   Escrito por Nik Clayton.
   Escrito por Hiten M. Pandya.

   O Protocolo de Seguranc,a da Internet (IPsec) e um conjunto de protocolos
   que se situam no topo da camada do Protocolo da Internet (IP). Ele permite
   que dois ou mais hosts se comuniquem de maneira segura, autenticando e
   criptografando cada pacote IP de uma sessao de comunicac,ao. A pilha de
   rede IPsec do FreeBSD e baseada na implementac,ao do http://www.kame.net/
   e suporta as sessoes IPv4 e IPv6.

   O IPsec e composto pelos seguintes sub-protocolos:

     * Encapsulated Securtity Payload (ESP): este protocolo protege os dados
       do pacote IP da interferencia de terceiros, criptografando o conteudo
       usando algoritmos de criptografia simetricos, como Blowfish e 3DES.

     * Authentication Header (AH) : este protocolo protege o cabec,alho do
       pacote IP da interferencia e spoofing de terceiros calculando um
       checksum criptografico e gerando o hash dos campos de cabec,alho do
       pacote IP com uma func,ao de hash segura. Isso e seguido por um
       cabec,alho adicional que contem o hash, para permitir que as
       informac,oes no pacote sejam autenticadas.

     * IP Payload Compression Protocol (IPComp): este protocolo tenta
       aumentar o desempenho da comunicac,ao comprimindo o payload IP para
       reduzir a quantidade de dados enviados .

   Esses protocolos podem ser usados juntos ou separadamente, dependendo do
   ambiente.

   O IPsec suporta dois modos de operac,ao. O primeiro modo, Modo de
   Transporte, protege as comunicac,oes entre dois hosts. O segundo modo,
   Modo de tunel, e usado para construir tuneis virtuais, comumente
   conhecidos como redes privadas virtuais (VPNs). Consulte ipsec(4) para
   obter informac,oes detalhadas sobre o subsistema IPsec no FreeBSD.

   O suporte a IPsec e ativado por padrao no FreeBSD 11 e posteriores. Para
   versoes anteriores do FreeBSD, adicione estas opc,oes a um arquivo de
   configurac,ao de kernel personalizado e recompile o kernel usando as
   instruc,oes em Capitulo 8, Configurando o kernel do FreeBSD:

 options   IPSEC        #IP security
 device    crypto

   Se o suporte a depurac,ao do IPsec for desejado, a seguinte opc,ao de
   kernel tambem deve ser adicionada:

 options   IPSEC_DEBUG  #debug for IP security

   Este restante deste capitulo demonstra o processo de configurac,ao de uma
   VPN IPsec entre uma rede domestica e uma rede corporativa. No cenario de
   exemplo:

     * Ambos os sites estao conectados `a Internet atraves de um gateway que
       esta executando o FreeBSD.

     * O gateway em cada rede tem pelo menos um enderec,o IP externo. Neste
       exemplo, o enderec,o IP externo da LAN corporativa e 172.16.5.4 e o IP
       externo da LAN domestica e 192.168.1.12.

     * Os enderec,os internos das duas redes podem ser enderec,os IP publicos
       ou privados. No entanto, o espac,o de enderec,o nao deve colidir. Por
       exemplo, ambas as redes nao podem usar 192.168.1.x. Neste exemplo, o
       enderec,o IP interno da LAN corporativa e 10.246.38.1 e o enderec,o do
       IP interno da LAN domestica e 10.0.0.5.

  13.7.1. Configurando uma VPN no FreeBSD

   Escrito por Tom Rhodes.

   Para comec,ar, o security/ipsec-tools deve ser instalado a partir da
   Colec,ao de Ports. Este software fornece varias aplicac,oes que suportam a
   configurac,ao.

   O proximo requisito e criar dois pseudo-dispositivos gif(4) que serao
   usados para encapsular pacotes e permitir que ambas as redes se comuniquem
   adequadamente. Como root, execute os seguintes comandos, substituindo
   internal e external pelos enderec,os IP reais das interfaces internas e
   externas dos dois gateways:

 # ifconfig gif0 create
 # ifconfig gif0 internal1 internal2
 # ifconfig gif0 tunnel external1 external2

   Verifique a configurac,ao em cada gateway, usando o ifconfig. Aqui esta a
   saida do Gateway 1:

 gif0: flags=8051 mtu 1280
 tunnel inet 172.16.5.4 --> 192.168.1.12
 inet6 fe80::2e0:81ff:fe02:5881%gif0 prefixlen 64 scopeid 0x6
 inet 10.246.38.1 --> 10.0.0.5 netmask 0xffffff00

   Aqui esta a saida do Gateway 2:

 gif0: flags=8051 mtu 1280
 tunnel inet 192.168.1.12 --> 172.16.5.4
 inet 10.0.0.5 --> 10.246.38.1 netmask 0xffffff00
 inet6 fe80::250:bfff:fe3a:c1f%gif0 prefixlen 64 scopeid 0x4

   Depois de concluidos, os dois enderec,os de IP internos devem ser
   acessados usando ping(8):

 priv-net# ping 10.0.0.5
 PING 10.0.0.5 (10.0.0.5): 56 data bytes
 64 bytes from 10.0.0.5: icmp_seq=0 ttl=64 time=42.786 ms
 64 bytes from 10.0.0.5: icmp_seq=1 ttl=64 time=19.255 ms
 64 bytes from 10.0.0.5: icmp_seq=2 ttl=64 time=20.440 ms
 64 bytes from 10.0.0.5: icmp_seq=3 ttl=64 time=21.036 ms
 --- 10.0.0.5 ping statistics ---
 4 packets transmitted, 4 packets received, 0% packet loss
 round-trip min/avg/max/stddev = 19.255/25.879/42.786/9.782 ms

 corp-net# ping 10.246.38.1
 PING 10.246.38.1 (10.246.38.1): 56 data bytes
 64 bytes from 10.246.38.1: icmp_seq=0 ttl=64 time=28.106 ms
 64 bytes from 10.246.38.1: icmp_seq=1 ttl=64 time=42.917 ms
 64 bytes from 10.246.38.1: icmp_seq=2 ttl=64 time=127.525 ms
 64 bytes from 10.246.38.1: icmp_seq=3 ttl=64 time=119.896 ms
 64 bytes from 10.246.38.1: icmp_seq=4 ttl=64 time=154.524 ms
 --- 10.246.38.1 ping statistics ---
 5 packets transmitted, 5 packets received, 0% packet loss
 round-trip min/avg/max/stddev = 28.106/94.594/154.524/49.814 ms

   Como esperado, ambos os lados tem a capacidade de enviar e receber pacotes
   ICMP dos enderec,os configurados de forma privada. Em seguida, os dois
   gateways devem ser informados sobre como rotear pacotes para enviar
   corretamente o trafego de qualquer rede. Os seguintes comandos atingirao
   esse objetivo:

 corp-net# route add 10.0.0.0 10.0.0.5 255.255.255.0
 corp-net# route add net 10.0.0.0: gateway 10.0.0.5
 priv-net# route add 10.246.38.0 10.246.38.1 255.255.255.0
 priv-net# route add host 10.246.38.0: gateway 10.246.38.1

   Neste ponto, as maquinas internas devem ser alcanc,adas de cada gateway,
   bem como das maquinas atras dos gateways. Novamente, use o ping(8) para
   confirmar:

 corp-net# ping 10.0.0.8
 PING 10.0.0.8 (10.0.0.8): 56 data bytes
 64 bytes from 10.0.0.8: icmp_seq=0 ttl=63 time=92.391 ms
 64 bytes from 10.0.0.8: icmp_seq=1 ttl=63 time=21.870 ms
 64 bytes from 10.0.0.8: icmp_seq=2 ttl=63 time=198.022 ms
 64 bytes from 10.0.0.8: icmp_seq=3 ttl=63 time=22.241 ms
 64 bytes from 10.0.0.8: icmp_seq=4 ttl=63 time=174.705 ms
 --- 10.0.0.8 ping statistics ---
 5 packets transmitted, 5 packets received, 0% packet loss
 round-trip min/avg/max/stddev = 21.870/101.846/198.022/74.001 ms

 priv-net# ping 10.246.38.107
 PING 10.246.38.1 (10.246.38.107): 56 data bytes
 64 bytes from 10.246.38.107: icmp_seq=0 ttl=64 time=53.491 ms
 64 bytes from 10.246.38.107: icmp_seq=1 ttl=64 time=23.395 ms
 64 bytes from 10.246.38.107: icmp_seq=2 ttl=64 time=23.865 ms
 64 bytes from 10.246.38.107: icmp_seq=3 ttl=64 time=21.145 ms
 64 bytes from 10.246.38.107: icmp_seq=4 ttl=64 time=36.708 ms
 --- 10.246.38.107 ping statistics ---
 5 packets transmitted, 5 packets received, 0% packet loss
 round-trip min/avg/max/stddev = 21.145/31.721/53.491/12.179 ms

   Configurar os tuneis e a parte facil. Configurar um link seguro e um
   processo mais aprofundado. A seguinte configurac,ao usa chaves RSA
   pre-compartilhadas (PSK). Alem dos enderec,os IP, o arquivo
   /usr/local/etc/racoon/racoon.conf em ambos os gateways sera identico e
   sera semelhante a:

 path    pre_shared_key  "/usr/local/etc/racoon/psk.txt"; #location of pre-shared key file
 log     debug;  #log verbosity setting: set to 'notify' when testing and debugging is complete

 padding # options are not to be changed
 {
         maximum_length  20;
         randomize       off;
         strict_check    off;
         exclusive_tail  off;
 }

 timer   # timing options. change as needed
 {
         counter         5;
         interval        20 sec;
         persend         1;
 #       natt_keepalive  15 sec;
         phase1          30 sec;
         phase2          15 sec;
 }

 listen  # address [port] that racoon will listen on
 {
         isakmp          172.16.5.4 [500];
         isakmp_natt     172.16.5.4 [4500];
 }

 remote  192.168.1.12 [500]
 {
         exchange_mode   main,aggressive;
         doi             ipsec_doi;
         situation       identity_only;
         my_identifier   address 172.16.5.4;
         peers_identifier        address 192.168.1.12;
         lifetime        time 8 hour;
         passive         off;
         proposal_check  obey;
 #       nat_traversal   off;
         generate_policy off;

                         proposal {
                                 encryption_algorithm    blowfish;
                                 hash_algorithm          md5;
                                 authentication_method   pre_shared_key;
                                 lifetime time           30 sec;
                                 dh_group                1;
                         }
 }

 sainfo  (address 10.246.38.0/24 any address 10.0.0.0/24 any)    # address $network/$netmask $type address $network/$netmask $type ( $type being any or esp)
 {                                                               # $network must be the two internal networks you are joining.
         pfs_group       1;
         lifetime        time    36000 sec;
         encryption_algorithm    blowfish,3des;
         authentication_algorithm        hmac_md5,hmac_sha1;
         compression_algorithm   deflate;
 }

   Para descric,oes de cada opc,ao disponivel, consulte a pagina de manual do
   racoon.conf.

   O Banco de Dados da Politica de Seguranc,a (SPD) precisa ser configurado
   para que o FreeBSD e o racoon consigam criptografar e descriptografar o
   trafego de rede entre os hosts.

   Isso pode ser obtido com um shell script, semelhante ao seguinte, no
   gateway corporativo. Este arquivo sera usado durante a inicializac,ao do
   sistema e deve ser salvo como /usr/local/etc/racoon/setkey.conf.

 flush;
 spdflush;
 # To the home network
 spdadd 10.246.38.0/24 10.0.0.0/24 any -P out ipsec esp/tunnel/172.16.5.4-192.168.1.12/use;
 spdadd 10.0.0.0/24 10.246.38.0/24 any -P in ipsec esp/tunnel/192.168.1.12-172.16.5.4/use;

   Uma vez que o arquivo estiver no seu lugar, o racoon pode ser iniciado em
   ambos os gateways usando o seguinte comando:

 # /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf -l /var/log/racoon.log

   A saida deve ser semelhante `a seguinte:

 corp-net# /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf
 Foreground mode.
 2006-01-30 01:35:47: INFO: begin Identity Protection mode.
 2006-01-30 01:35:48: INFO: received Vendor ID: KAME/racoon
 2006-01-30 01:35:55: INFO: received Vendor ID: KAME/racoon
 2006-01-30 01:36:04: INFO: ISAKMP-SA established 172.16.5.4[500]-192.168.1.12[500] spi:623b9b3bd2492452:7deab82d54ff704a
 2006-01-30 01:36:05: INFO: initiate new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
 2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]->172.16.5.4[0] spi=28496098(0x1b2d0e2)
 2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]->192.168.1.12[0] spi=47784998(0x2d92426)
 2006-01-30 01:36:13: INFO: respond new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
 2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]->172.16.5.4[0] spi=124397467(0x76a279b)
 2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]->192.168.1.12[0] spi=175852902(0xa7b4d66)

   Para garantir que o tunel esteja funcionando corretamente, mude para outro
   console e use o tcpdump(1) para exibir o trafego de rede usando o comando
   a seguir. Substitua em0 pela placa de interface de rede conforme
   necessario:

 # tcpdump -i em0 host 172.16.5.4 and dst 192.168.1.12

   Dados semelhantes aos seguintes devem aparecer no console. Caso contrario,
   ha um problema e a depurac,ao dos dados retornados sera necessaria.

 01:47:32.021683 IP corporatenetwork.com > 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xa)
 01:47:33.022442 IP corporatenetwork.com > 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xb)
 01:47:34.024218 IP corporatenetwork.com > 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xc)

   Neste ponto, as duas redes devem estar disponiveis e parecem fazer parte
   da mesma rede. Muito provavelmente ambas as redes estao protegidas por um
   firewall. Para permitir que o trafego flua entre elas, regras precisam ser
   adicionadas para liberar a passagem dos pacotes. Para o firewall ipfw(8),
   adicione as seguintes linhas ao arquivo de configurac,ao do firewall:

 ipfw add 00201 allow log esp from any to any
 ipfw add 00202 allow log ah from any to any
 ipfw add 00203 allow log ipencap from any to any
 ipfw add 00204 allow log udp from any 500 to any

  Nota:

   Os numeros das regras podem precisar ser alterados dependendo da
   configurac,ao atual do host.

   Para usuarios do pf(4) ou do ipf(8) , as seguintes regras devem fazer o
   truque:

 pass in quick proto esp from any to any
 pass in quick proto ah from any to any
 pass in quick proto ipencap from any to any
 pass in quick proto udp from any port = 500 to any port = 500
 pass in quick on gif0 from any to any
 pass out quick proto esp from any to any
 pass out quick proto ah from any to any
 pass out quick proto ipencap from any to any
 pass out quick proto udp from any port = 500 to any port = 500
 pass out quick on gif0 from any to any

   Finalmente, para permitir que a maquina inicie o suporte para a VPN
   durante a inicializac,ao do sistema, adicione as seguintes linhas ao
   arquivo /etc/rc.conf:

 ipsec_enable="YES"
 ipsec_program="/usr/local/sbin/setkey"
 ipsec_file="/usr/local/etc/racoon/setkey.conf" # allows setting up spd policies on boot
 racoon_enable="yes"

13.8. OpenSSH

   Contribuido por Chern Lee.

   O OpenSSH e um conjunto de ferramentas de conectividade de rede usadas
   para fornecer acesso seguro a maquinas remotas. Alem disso, as conexoes
   TCP/IP podem ser encapsuladas ou encaminhadas com seguranc,a atraves de
   conexoes SSH. O OpenSSH criptografa todo o trafego para eliminar
   efetivamente a interceptac,ao, o sequestro de conexao e outros ataques no
   nivel da rede.

   O OpenSSH e mantido pelo projeto OpenBSD e e instalado por padrao no
   FreeBSD. E compativel com os protocolos de versao 1 e 2 do SSH.

   Quando os dados sao enviados pela rede em um formato nao criptografado,
   sniffers de rede posicionados em qualquer lugar entre o cliente e o
   servidor podem roubar as informac,oes do usuario/senha ou os dados
   transferidos durante a sessao. O OpenSSH oferece uma variedade de metodos
   de autenticac,ao e criptografia para evitar que isso acontec,a. Mais
   informac,oes sobre o OpenSSH estao disponiveis em http://www.openssh.com/.

   Esta sec,ao fornece uma visao geral dos utilitarios embutidos de cliente
   para acessar com seguranc,a outros sistemas e transferir arquivos com
   seguranc,a de um sistema FreeBSD. Em seguida, descreve como configurar um
   servidor SSH em um sistema FreeBSD. Maiores informac,oes estao disponiveis
   nas paginas man mencionadas neste capitulo.

  13.8.1. Usando os Utilitarios de Cliente SSH

   Para logar em um servidor SSH, use ssh e especifique um nome de usuario
   que exista naquele servidor e o enderec,o IP ou nome de host do servidor.
   Se esta for a primeira vez que uma conexao foi feita ao servidor
   especificado, o usuario sera solicitado a primeiro verificar a impressao
   digital do servidor:

 # ssh user@example.com
 The authenticity of host 'example.com (10.0.0.1)' can't be established.
 ECDSA key fingerprint is 25:cc:73:b5:b3:96:75:3d:56:19:49:d2:5c:1f:91:3b.
 Are you sure you want to continue connecting (yes/no)? yes
 Permanently added 'example.com' (ECDSA) to the list of known hosts.
 Password for user@example.com: user_password

   O SSH utiliza um sistema de impressao digital de chaves para verificar a
   autenticidade do servidor quando o cliente se conecta. Quando o usuario
   aceita a impressao digital da chave digitando yes ao conectar-se pela
   primeira vez, uma copia da chave e salva em .ssh/known_hosts no diretorio
   pessoal do usuario. Futuras tentativas de login sao verificadas em
   relac,ao `a chave salva e o ssh exibira um alerta se a chave do servidor
   nao corresponder `a chave salva. Se isso ocorrer, o usuario deve primeiro
   verificar por que a chave foi alterada antes de continuar com a conexao.

   Por padrao, versoes recentes do OpenSSH aceitam apenas conexoes SSH v2.
   Por padrao, o cliente usara a versao 2 se possivel e voltara para a versao
   1 se o servidor nao suportar a versao 2. Para forc,ar o ssh a usar somente
   o protocolo especificado, inclua -1 ou -2. Opc,oes adicionais sao
   descritas em ssh(1).

   Use o scp(1) para copiar com seguranc,a um arquivo para ou de uma maquina
   remota. Este exemplo copia o arquivo COPYRIGHT do sistema remoto para um
   arquivo com o mesmo nome no diretorio atual do sistema local:

 # scp user@example.com:/COPYRIGHT COPYRIGHT
 Password for user@example.com: *******
 COPYRIGHT            100% |*****************************|  4735
 00:00
 #

   Como a impressao digital ja foi verificada para esse host, a chave do
   servidor e verificada automaticamente antes de solicitar a senha do
   usuario.

   Os argumentos passados para o scp sao semelhantes ao comando cp. O arquivo
   ou arquivos para copiar e o primeiro argumento e o destino para copiar e o
   segundo. Como o arquivo e buscado pela rede, um ou mais dos argumentos do
   arquivo assumem o formato user@host:<path_to_remote_file>. Esteja ciente
   ao copiar recursivamente diretorios que o scp usa a opc,ao -r, enquanto cp
   usa a -R.

   Para abrir uma sessao interativa para copiar arquivos, use o sftp.
   Consulte sftp(1) para obter uma lista de comandos disponiveis enquanto
   estiver em uma sessao sftp.

    13.8.1.1. Autenticac,ao Baseada em Chave

   Em vez de usar senhas, um cliente pode ser configurado para se conectar `a
   maquina remota usando chaves. Para gerar chaves de autenticac,ao RSA, use
   o ssh-keygen. Para gerar um par de chaves publica e privada, especifique o
   tipo de chave e siga os prompts. Recomenda-se proteger as chaves com uma
   senha memoravel, mas dificil de se adivinhar.

 % ssh-keygen -t rsa
 Generating public/private rsa key pair.
 Enter file in which to save the key (/home/user/.ssh/id_rsa):
 Enter passphrase (empty for no passphrase):  1
 Enter same passphrase again:                 2
 Your identification has been saved in /home/user/.ssh/id_rsa.
 Your public key has been saved in /home/user/.ssh/id_rsa.pub.
 The key fingerprint is:
 SHA256:54Xm9Uvtv6H4NOo6yjP/YCfODryvUU7yWHzMqeXwhq8 user@host.example.com
 The key's randomart image is:
 +---[RSA 2048]----+
 |                 |
 |                 |
 |                 |
 |        . o..    |
 |       .S*+*o    |
 |      . O=Oo . . |
 |       = Oo= oo..|
 |      .oB.* +.oo.|
 |       =OE**.o..=|
 +----[SHA256]-----+

   1   Digite uma senha aqui. Pode conter espac,os e simbolos.  
   2   Digite novamente a senha para verifica-la.               

   A chave privada e armazenada no arquivo ~/.ssh/id_rsa e a chave publica e
   armazenada no arquivo ~/.ssh/id_rsa.pub. A chave publica deve ser copiada
   para ~/.ssh/ authorized_keys na maquina remota para que a autenticac,ao
   baseada em chave funcione.

  Atenc,ao:

   Muitos usuarios acreditam que as chaves sao seguras por design e usarao
   uma chave sem uma senha. Este e um comportamento perigoso. Um
   administrador pode verificar se um par de chaves esta protegido por uma
   senha, visualizando a chave privada manualmente. Se o arquivo de chave
   privada contiver a palavra ENCRYPTED, o dono da chave esta usando uma
   senha. Alem disso, para proteger melhor os usuarios finais, o termo from
   pode ser colocado no arquivo de chave publica. Por exemplo, adicionar from
   "192.168.10.5" na frente do prefixo ssh-rsa so permitira que esse usuario
   especifico efetue login a partir desse enderec,o IP.

   As opc,oes e arquivos variam de acordo com as diferentes versoes do
   OpenSSH. Para evitar problemas, consulte ssh-keygen(1).

   Se uma senha for usada, o usuario sera solicitado a inserir a senha toda
   vez que uma conexao for feita ao servidor. Para carregar as chaves de SSH
   na memoria e remover a necessidade de digitar a senha toda vez, use o
   ssh-agent(1) e o ssh-add(1).

   A autenticac,ao e feita pelo ssh-agent, usando as chaves privadas que
   estao carregadas nele. O ssh-agent pode ser usado para iniciar outro
   aplicativo como um shell ou um gerenciador de janelas.

   Para usar o ssh-agent em um shell, inicie-o com um shell como um
   argumento. Adicione a identidade executando ssh-add e inserindo a senha
   para a chave privada. O usuario entao podera executar o ssh para se
   conectar em qualquer host que tenha a chave publica correspondente
   instalada. Por exemplo:

 % ssh-agent csh
 % ssh-add
 Enter passphrase for key '/usr/home/user/.ssh/id_rsa':  1
 Identity added: /usr/home/user/.ssh/id_rsa (/usr/home/user/.ssh/id_rsa)
 %

   1   Digite a senha para a chave.  

   Para usar o ssh-agent no Xorg, adicione uma entrada para ele em
   ~/.xinitrc. Isso fornece os servic,os do ssh-agent para todos os programas
   iniciados no Xorg. Um exemplo do arquivo ~/.xinitrc pode ter esta
   aparencia:

 exec ssh-agent startxfce4

   Isso inicia o ssh-agent, que, por sua vez, ativa o XFCE, sempre que o Xorg
   e iniciado. Uma vez que o Xorg tenha sido reiniciado para que as mudanc,as
   entrem em vigor, execute ssh-add para carregar todas as chaves SSH.

    13.8.1.2. Tunelamento SSH

   O OpenSSH tem a capacidade de criar um tunel para encapsular outro
   protocolo em uma sessao criptografada.

   O comando a seguir informa ao ssh para criar um tunel para o telnet:

 % ssh -2 -N -f -L 5023:localhost:23 user@foo.example.com
 %

   Este exemplo usa as seguintes opc,oes:

   -2

           Forc,a o comando ssh a usar a versao 2 para conectar-se ao
           servidor.

   -N

           Indica nenhum comando ou apenas tunel. Se omitido, o ssh inicia
           uma sessao normal.

   -f

           Forc,a o comando ssh a ser executado em segundo plano.

   -L

           Indica um tunel local no formato localport:remotehost:remoteport.

   user@foo.example.com

           O nome de login para usar no servidor SSH remoto especificado.

   Um tunel SSH funciona criando um socket de escuta em localhost na
   localport especificada. Em seguida, ele encaminha quaisquer conexoes
   recebidas em localport por meio da conexao SSH com o remotehost:remoteport
   especificado. No exemplo, a porta 5023 no cliente e encaminhada para a
   porta 23 na maquina remota. Como a porta 23 e usada pelo telnet, isso cria
   uma sessao telnet criptografada atraves de um tunel SSH.

   Esse metodo pode ser usado para agrupar qualquer numero de protocolos TCP
   inseguros, como SMTP, POP3 e FTP, como visto nos exemplos a seguir.

   Exemplo 13.1. Criar um Tunel Seguro para SMTP

 % ssh -2 -N -f -L 5025:localhost:25 user@mailserver.example.com
 user@mailserver.example.com's password: *****
 % telnet localhost 5025
 Trying 127.0.0.1...
 Connected to localhost.
 Escape character is '^]'.
 220 mailserver.example.com ESMTP

   Isso pode ser usado em conjunto com ssh-keygen e contas de usuario
   adicionais para criar um ambiente de encapsulamento SSH mais uniforme. As
   chaves podem ser usadas no lugar de digitar uma senha e os tuneis podem
   ser executados como um usuario separado.

   Exemplo 13.2. Acesso Seguro de um Servidor POP3

   Neste exemplo, ha um servidor SSH que aceita conexoes de fora. Na mesma
   rede, existe um servidor de email que executa um servidor POP3. Para
   verificar o e-mail de maneira segura, crie uma conexao SSH com o servidor
   SSH e encaminhe para o servidor de e-mail:

 % ssh -2 -N -f -L 2110:mail.example.com:110 user@ssh-server.example.com
 user@ssh-server.example.com's password: ******

   Quando o tunel estiver ativo e em execuc,ao, aponte o cliente de e-mail
   para enviar solicitac,oes POP3 para localhost na porta 2110. Essa conexao
   sera encaminhada com seguranc,a pelo encapsulamento para mail.example.com.

   Exemplo 13.3. Ignorando um Firewall

   Alguns firewalls filtram as conexoes de entrada e saida. Por exemplo, um
   firewall pode limitar o acesso de maquinas remotas `as portas 22 e 80 para
   permitir apenas o SSH e navegac,ao na web. Isso impede o acesso a qualquer
   outro servic,o que use uma porta diferente de 22 ou 80.

   A soluc,ao e criar uma conexao SSH com uma maquina fora do firewall da
   rede e usa-la para encapsular o servic,o desejado:

 % ssh -2 -N -f -L 8888:music.example.com:8000 user@unfirewalled-system.example.org
 user@unfirewalled-system.example.org's password: *******

   Neste exemplo, um cliente Ogg Vorbis de streaming pode agora ser apontado
   para localhost na porta 8888, que sera encaminhado para music.example.com
   na porta 8000, ignorando com exito o firewall.

  13.8.2. Ativando o Servidor SSH

   Alem de fornecer utilitarios de cliente SSH embutidos, um sistema FreeBSD
   pode ser configurado como um servidor SSH, aceitando conexoes de outros
   clientes SSH.

   Para ver se o sshd esta operando, use o comando service(8):

 # service sshd status

   Se o servic,o nao estiver em execuc,ao, adicione a seguinte linha ao
   arquivo /etc/rc.conf.

 sshd_enable="YES"

   Isso iniciara o sshd, o programa daemon para o OpenSSH, na proxima vez que
   o sistema for inicializado. Para inicia-lo agora:

 # service sshd start

   A primeira vez que o sshd inicia em um sistema FreeBSD, as chaves de host
   do sistema serao criadas automaticamente e a impressao digital sera
   exibida no console. Fornec,a aos usuarios a impressao digital para que
   eles possam verifica-la na primeira vez que se conectarem ao servidor.

   Consulte o sshd(8) para obter a lista de opc,oes disponiveis ao iniciar o
   sshd e uma discussao mais completa sobre autenticac,ao, processo de login
   e os varios arquivos de configurac,ao.

   Neste ponto, o sshd deve estar disponivel para todos os usuarios com um
   nome de usuario e senha no sistema.

  13.8.3. Seguranc,a do Servidor SSH

   Enquanto o sshd e o recurso de administrac,ao remota mais usado para o
   FreeBSD, a forc,a bruta e o drive por ataques sao comuns a qualquer
   sistema exposto a redes publicas. Varios parametros adicionais estao
   disponiveis para evitar o sucesso desses ataques e serao descritos nesta
   sec,ao.

   E uma boa ideia limitar quais usuarios podem efetuar login no servidor SSH
   e de onde usar a palavra-chave AllowUsers no arquivo de configurac,ao do
   servidor OpenSSH. Por exemplo, para permitir que somente o root efetue
   login de 192.168.1.32, inclua esta linha no arquivo /etc/ssh/sshd_config:

 AllowUsers root@192.168.1.32

   Para permitir que o usuario admin efetue login de qualquer lugar, liste
   esse usuario sem especificar um enderec,o IP:

 AllowUsers admin

   Multiplos usuarios devem ser listados na mesma linha, assim:

 AllowUsers root@192.168.1.32 admin

   Depois de fazer alterac,oes no arquivo /etc/ssh/sshd_config, informe o
   sshd para recarregar seu arquivo de configurac,ao executando:

 # service sshd reload

  Nota:

   Quando essa palavra-chave e usada, e importante listar cada usuario que
   precisa efetuar login nesta maquina. Qualquer usuario que nao esteja
   especificado nessa linha sera bloqueado. Alem disso, as palavras-chave
   usadas no arquivo de configurac,ao do servidor OpenSSH fazem distinc,ao
   entre maiusculas e minusculas. Se a palavra-chave nao estiver escrita
   corretamente, incluindo esse detalhe, ela sera ignorada. Sempre teste as
   alterac,oes neste arquivo para garantir que as edic,oes estejam
   funcionando conforme o esperado. Consulte o sshd_config(5) para verificar
   a ortografia e o uso das palavras-chave disponiveis.

   Alem disso, os usuarios podem ser forc,ados a usar a autenticac,ao de dois
   fatores por meio do uso de uma chave publica e privada. Quando necessario,
   o usuario pode gerar um par de chaves usando o ssh-keygen(1) e enviar ao
   administrador a chave publica. Este arquivo de chave sera colocado no
   arquivo authorized_keys como descrito acima na sec,ao cliente. Para
   forc,ar os usuarios a usar apenas as chaves, a seguinte opc,ao pode ser
   configurada:

 AuthenticationMethods publickey

  Dica:

   Nao confunda o arquivo /etc/ssh/sshd_config com /etc/ssh/ssh_config
   (observe o d extra no primeiro nome do arquivo). O primeiro arquivo
   configura o servidor e o segundo arquivo configura o cliente. Consulte o
   ssh_config(5) para obter uma listagem das configurac,oes do cliente
   disponiveis.

13.9. Listas de Controle de Acesso

   Contribuido por Tom Rhodes.

   As Listas de Controle de Acesso (ACLs) estendem o modelo de permissao
   padrao do UNIX(R) em um compativel com o modo POSIX(R).1e. Isso permite
   que um administrador aproveite um modelo de permissoes mais refinado.

   O kernel FreeBSD GENERIC fornece suporte a ACL para sistemas de arquivos
   UFS. Usuarios que preferem compilar um kernel personalizado devem incluir
   a seguinte opc,ao em seu arquivo de configurac,ao do kernel personalizado:

 options UFS_ACL

   Se esta opc,ao nao for ativada na compilac,ao, uma mensagem de aviso sera
   exibida ao tentar montar um sistema de arquivos com o suporte a ACL. As
   ACLs dependem de atributos estendidos que sao suportados nativamente pelo
   UFS2.

   Este capitulo descreve como ativar o suporte a ACL e fornece alguns
   exemplos de uso.

  13.9.1. Ativando o Suporte a ACL

   As ACLs sao habilitadas pela flag administrativa de tempo de montagem,
   acls, que podem ser adicionadas ao arquivo /etc/fstab. As flags de tempo
   de montagem tambem podem ser configuradas automaticamente de forma
   persistente usando-se o tunefs(8) para modificar um superbloco de flags
   ACLs no cabec,alho do sistema de arquivos. Em geral, e preferivel usar
   flags de superbloco por varios motivos:

     * A flag de superbloco nao pode ser alterada por um remount usando mount
       -u, pois requer um umount completo e um mount completo. Isso significa
       que as ACLs nao podem ser ativadas no sistema de arquivos raiz apos a
       inicializac,ao. Isso tambem significa que o suporte a ACL em um
       sistema de arquivos nao pode ser alterado enquanto o sistema estiver
       em uso.

     * Definir a flag de superbloco faz com que o sistema de arquivos seja
       sempre montado com a ACL ativada, mesmo que nao haja uma entrada no
       fstab ou se os dispositivos forem reordenados. Isso evita a montagem
       acidental do sistema de arquivos sem o suporte a ACL.

  Nota:

   E desejavel desencorajar a montagem acidental sem que a ACL esteja
   habilitada porque coisas desagradaveis podem acontecer se ACLs estiverem
   habilitadas, e entao desabilitadas e entao reativadas sem limpar os
   atributos estendidos. Em geral, uma vez que as ACLs forem habilitadas em
   um sistema de arquivos, elas nao devem ser desabilitadas, pois as
   protec,oes de arquivos resultantes podem nao ser compativeis com aquelas
   pretendidas pelos usuarios do sistema e ACLs reativadas podem reconectar
   as ACLs anteriores aos arquivos que tiveram suas permissoes alteradas,
   resultando em um comportamento imprevisivel.

   Os sistemas de arquivos com a ACL ativada exibirao um sinal de mais (+)
   nas configurac,oes de permissao:

 drwx------  2 robert  robert  512 Dec 27 11:54 private
 drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
 drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
 drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
 drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html

   Neste exemplo, o directory1, directory2 e directory3 estao todos fazendo
   uso de ACLs, enquanto public_html nao esta.

  13.9.2. Usando ACLs

   As ACLs de um sistema de arquivos podem ser visualizadas usando getfacl.
   Por exemplo, para visualizar as configurac,oes de ACL no arquivo test:

 % getfacl test
         #file:test
         #owner:1001
         #group:1001
         user::rw-
         group::r--
         other::r--

   Para alterar as configurac,oes de ACL neste arquivo, use setfacl. Para
   remover todos os ACLs atualmente definidos de um arquivo ou sistema de
   arquivos, inclua -k. No entanto, o metodo preferido e usar -b, pois ela
   deixa os campos basicos necessarios para que as ACLs funcionem.

 % setfacl -k test

   Para modificar as entradas padroes das ACLs, use -m:

 % setfacl -m u:trhodes:rwx,group:web:r--,o::--- test

   Neste exemplo, nao havia entradas predefinidas, pois elas foram removidas
   pelo comando anterior. Este comando restaura as opc,oes padroes e atribui
   as opc,oes listadas. Se um usuario ou grupo for adicionado e nao existir
   no sistema, um erro de Invalid argument sera exibido.

   Consulte getfacl(1) e setfacl(1) para maiores informac,oes sobre as
   opc,oes disponiveis para esses comandos.

13.10. Monitorando Problemas de Seguranc,a de Terceiros

   Contribuido por Tom Rhodes.

   Nos ultimos anos, o mundo da seguranc,a fez muitas melhorias em como a
   avaliac,ao de vulnerabilidades e tratada. A ameac,a de invasao do sistema
   aumenta `a medida que utilitarios de terceiros sao instalados e
   configurados para praticamente qualquer sistema operacional disponivel
   atualmente.

   A avaliac,ao de vulnerabilidade e um fator importante na seguranc,a.
   Enquanto o FreeBSD libera avisos para o sistema base, faze-lo para cada
   utilitario de terceiros esta alem da capacidade do Projeto FreeBSD. Existe
   uma maneira de mitigar vulnerabilidades de terceiros e avisar os
   administradores sobre problemas de seguranc,a conhecidos. Um utilitario do
   FreeBSD conhecido como pkg inclui opc,oes explicitamente para este
   proposito.

   O pkg pesquisa um banco de dados em busca de problemas de seguranc,a. O
   banco de dados e atualizado e mantido pela equipe de seguranc,a do FreeBSD
   e pelos desenvolvedores de ports.

   Por favor, consulte as instruc,oes para instalar o pkg.

   A instalac,ao fornece arquivos de configurac,ao do periodic(8) para manter
   o banco de dados de auditoria do pkg e fornece um metodo programatico para
   mante-lo atualizado . Esta funcionalidade e ativada se
   daily_status_security_pkgaudit_enable estiver definido como YES em
   periodic.conf(5) . Certifique-se de que os e-mails de execuc,ao de
   seguranc,a diarios, que sao enviados para a conta de e-mail do root,
   estejam sendo lidos.

   Apos a instalac,ao e para auditar utilitarios de terceiros como parte da
   Colec,ao de Ports a qualquer momento, um administrador pode optar por
   atualizar o banco de dados e visualizar as vulnerabilidades conhecidas dos
   pacotes instalados, invocando:

 # pkg audit -F

   O pkg exibe as vulnerabilidades publicadas dos pacotes instalados:

 Affected package: cups-base-1.1.22.0_1
 Type of problem: cups-base -- HPGL buffer overflow vulnerability.
 Reference: <https://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html>

 1 problem(s) in your installed packages found.

 You are advised to update or deinstall the affected package(s) immediately.

   Ao apontar um navegador da web para a URL exibida, um administrador pode
   obter mais informac,oes sobre a vulnerabilidade. Isto incluira as versoes
   afetadas, pela versao do port do FreeBSD, juntamente com outros sites que
   podem conter avisos de seguranc,a.

   O pkg e um poderoso utilitario e e extremamente util quando acoplado com o
   ports-mgmt/portmaster.

13.11. Avisos de Seguranc,a do FreeBSD

   Contribuido por Tom Rhodes.

   Como muitos produtores de sistemas operacionais de qualidade, o Projeto
   FreeBSD tem uma equipe de seguranc,a responsavel por determinar a data de
   fim de vida (EoL) para cada versao do FreeBSD e para fornecer
   atualizac,oes de seguranc,a para versoes suportadas que ainda nao
   atingiram sua EoL. Mais informac,oes sobre a equipe de seguranc,a do
   FreeBSD e as versoes suportadas estao disponiveis na pagina de seguranc,a
   do FreeBSD.

   Uma tarefa da equipe de seguranc,a e responder `as vulnerabilidades de
   seguranc,a reportadas no sistema operacional FreeBSD. Quando uma
   vulnerabilidade e confirmada, a equipe de seguranc,a verifica as etapas
   necessarias para corrigir a vulnerabilidade e atualiza o codigo-fonte com
   a correc,ao. Em seguida, publica os detalhes como um "Aviso de
   Seguranc,a". Os avisos de seguranc,a sao publicados no site do FreeBSD e
   enviados para as listas de discussao freebsd-security-notifications,
   freebsd-security, e freebsd-announce.

   Esta sec,ao descreve o formato de um alerta de seguranc,a do FreeBSD.

  13.11.1. Formato de um Comunicado de Seguranc,a

   Aqui esta um exemplo de um aviso de seguranc,a do FreeBSD:

 =============================================================================
 -----BEGIN PGP SIGNED MESSAGE-----
 Hash: SHA512

 =============================================================================
 FreeBSD-SA-14:04.bind                                       Security Advisory
                                                           The FreeBSD Project

 Topic:          BIND remote denial of service vulnerability

 Category:       contrib
 Module:         bind
 Announced:      2014-01-14
 Credits:        ISC
 Affects:        FreeBSD 8.x and FreeBSD 9.x
 Corrected:      2014-01-14 19:38:37 UTC (stable/9, 9.2-STABLE)
                 2014-01-14 19:42:28 UTC (releng/9.2, 9.2-RELEASE-p3)
                 2014-01-14 19:42:28 UTC (releng/9.1, 9.1-RELEASE-p10)
                 2014-01-14 19:38:37 UTC (stable/8, 8.4-STABLE)
                 2014-01-14 19:42:28 UTC (releng/8.4, 8.4-RELEASE-p7)
                 2014-01-14 19:42:28 UTC (releng/8.3, 8.3-RELEASE-p14)
 CVE Name:       CVE-2014-0591

 For general information regarding FreeBSD Security Advisories,
 including descriptions of the fields above, security branches, and the
 following sections, please visit <URL:http://security.FreeBSD.org/>.

 I.   Background

 BIND 9 is an implementation of the Domain Name System (DNS) protocols.
 The named(8) daemon is an Internet Domain Name Server.

 II.  Problem Description

 Because of a defect in handling queries for NSEC3-signed zones, BIND can
 crash with an "INSIST" failure in name.c when processing queries possessing
 certain properties.  This issue only affects authoritative nameservers with
 at least one NSEC3-signed zone.  Recursive-only servers are not at risk.

 III. Impact

 An attacker who can send a specially crafted query could cause named(8)
 to crash, resulting in a denial of service.

 IV.  Workaround

 No workaround is available, but systems not running authoritative DNS service
 with at least one NSEC3-signed zone using named(8) are not vulnerable.

 V.   Solution

 Perform one of the following:

 1) Upgrade your vulnerable system to a supported FreeBSD stable or
 release / security branch (releng) dated after the correction date.

 2) To update your vulnerable system via a source code patch:

 The following patches have been verified to apply to the applicable
 FreeBSD release branches.

 a) Download the relevant patch from the location below, and verify the
 detached PGP signature using your PGP utility.

 [FreeBSD 8.3, 8.4, 9.1, 9.2-RELEASE and 8.4-STABLE]
 # fetch http://security.FreeBSD.org/patches/SA-14:04/bind-release.patch
 # fetch http://security.FreeBSD.org/patches/SA-14:04/bind-release.patch.asc
 # gpg --verify bind-release.patch.asc

 [FreeBSD 9.2-STABLE]
 # fetch http://security.FreeBSD.org/patches/SA-14:04/bind-stable-9.patch
 # fetch http://security.FreeBSD.org/patches/SA-14:04/bind-stable-9.patch.asc
 # gpg --verify bind-stable-9.patch.asc

 b) Execute the following commands as root:

 # cd /usr/src
 # patch < /path/to/patch

 Recompile the operating system using buildworld and installworld as
 described in <URL:https://www.FreeBSD.org/handbook/makeworld.html>.

 Restart the applicable daemons, or reboot the system.

 3) To update your vulnerable system via a binary patch:

 Systems running a RELEASE version of FreeBSD on the i386 or amd64
 platforms can be updated via the freebsd-update(8) utility:

 # freebsd-update fetch
 # freebsd-update install

 VI.  Correction details

 The following list contains the correction revision numbers for each
 affected branch.

 Branch/path                                                      Revision
 - -------------------------------------------------------------------------
 stable/8/                                                         r260646
 releng/8.3/                                                       r260647
 releng/8.4/                                                       r260647
 stable/9/                                                         r260646
 releng/9.1/                                                       r260647
 releng/9.2/                                                       r260647
 - -------------------------------------------------------------------------

 To see which files were modified by a particular revision, run the
 following command, replacing NNNNNN with the revision number, on a
 machine with Subversion installed:

 # svn diff -cNNNNNN --summarize svn://svn.freebsd.org/base

 Or visit the following URL, replacing NNNNNN with the revision number:

 <URL:https://svnweb.freebsd.org/base?view=revision&revision=NNNNNN>

 VII. References

 <URL:https://kb.isc.org/article/AA-01078>

 <URL:http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0591>

 The latest revision of this advisory is available at
 <URL:http://security.FreeBSD.org/advisories/FreeBSD-SA-14:04.bind.asc>
 -----BEGIN PGP SIGNATURE-----

 iQIcBAEBCgAGBQJS1ZTYAAoJEO1n7NZdz2rnOvQP/2/68/s9Cu35PmqNtSZVVxVG
 ZSQP5EGWx/lramNf9566iKxOrLRMq/h3XWcC4goVd+gZFrvITJSVOWSa7ntDQ7TO
 XcinfRZ/iyiJbs/Rg2wLHc/t5oVSyeouyccqODYFbOwOlk35JjOTMUG1YcX+Zasg
 ax8RV+7Zt1QSBkMlOz/myBLXUjlTZ3Xg2FXVsfFQW5/g2CjuHpRSFx1bVNX6ysoG
 9DT58EQcYxIS8WfkHRbbXKh9I1nSfZ7/Hky/kTafRdRMrjAgbqFgHkYTYsBZeav5
 fYWKGQRJulYfeZQ90yMTvlpF42DjCC3uJYamJnwDIu8OhS1WRBI8fQfr9DRzmRua
 OK3BK9hUiScDZOJB6OqeVzUTfe7MAA4/UwrDtTYQ+PqAenv1PK8DZqwXyxA9ThHb
 zKO3OwuKOVHJnKvpOcr+eNwo7jbnHlis0oBksj/mrq2P9m2ueF9gzCiq5Ri5Syag
 Wssb1HUoMGwqU0roS8+pRpNC8YgsWpsttvUWSZ8u6Vj/FLeHpiV3mYXPVMaKRhVm
 067BA2uj4Th1JKtGleox+Em0R7OFbCc/9aWC67wiqI6KRyit9pYiF3npph+7D5Eq
 7zPsUdDd+qc+UTiLp3liCRp5w6484wWdhZO6wRtmUgxGjNkxFoNnX8CitzF8AaqO
 UWWemqWuz3lAZuORQ9KX
 =OQzQ
 -----END PGP SIGNATURE-----

   Todo comunicado de seguranc,a usa o seguinte formato:

     * Cada aviso de seguranc,a e assinado pela chave PGP do Oficial de
       Seguranc,a. A chave publica para o Oficial de Seguranc,a pode ser
       verificada em Apendice D, Chaves OpenPGP.

     * O nome do alerta de seguranc,a sempre comec,a com FreeBSD-SA- (para o
       FreeBSD Security Advisory), seguido pelo ano em formato de dois
       digitos (14:), seguido pelo numero de aviso para aquele ano (04.),
       seguido pelo nome do aplicativo ou subsistema afetado (bind). O
       comunicado mostrado aqui e o quarto comunicado de 2014 e afeta o BIND.

     * O campo Topic resume a vulnerabilidade.

     * O campo Category refere-se `a parte afetada do sistema, que pode ser
       uma de core, contrib, ou ports. A categoria core significa que a
       vulnerabilidade afeta um componente principal do sistema operacional
       FreeBSD. A categoria contrib significa que a vulnerabilidade afeta um
       software incluido no FreeBSD, como o BIND. A categoria ports indica
       que a vulnerabilidade afeta um software disponivel atraves da colec,ao
       de ports.

     * O campo Module refere-se ao local do componente. Neste exemplo, o
       modulo bind e afetado; Portanto, essa vulnerabilidade afeta um
       aplicativo instalado com o sistema operacional.

     * O campo Announced reflete a data em que o comunicado de seguranc,a foi
       publicado. Isto significa que a equipe de seguranc,a verificou que o
       problema existe e que um patch foi disponibilizado no repositorio do
       codigo fonte do FreeBSD.

     * O campo Credits da credito ao individuo ou organizac,ao que encontrou
       a vulnerabilidade e a relatou.

     * O campo Affects explica quais versoes do FreeBSD sao afetadas por esta
       vulnerabilidade.

     * O campo Corrected indica a data, a hora, o deslocamento do horario e
       as releases que foram corrigidas. A sec,ao entre parenteses mostra
       cada branch para a qual a correc,ao foi mesclada e o numero de versao
       da liberac,ao correspondente dessa branch. O proprio identificador de
       release inclui o numero da versao e, se apropriado, o nivel do patch.
       O nivel de correc,ao e a letra p seguida de um numero, indicando o
       numero de sequ:encia do patch, permitindo que os usuarios controlem
       quais patches ja foram aplicados ao sistema.

     * O campo CVE Name lista o numero de aviso, se existir, no banco de
       dados publico cve.mitre.org de vulnerabilidades de seguranc,a.

     * O campo Background fornece uma descric,ao do modulo afetado.

     * O campo Problem Description explica a vulnerabilidade. Isso pode
       incluir informac,oes sobre o codigo defeituoso e como o utilitario
       pode ser usado de maneira mal-intencionada.

     * O campo Impact descreve o tipo de impacto que o problema pode ter em
       um sistema.

     * O campo Workaround indica se uma soluc,ao alternativa esta disponivel
       para os administradores do sistema que nao podem corrigir
       imediatamente o sistema.

     * O campo Solution fornece as instruc,oes para corrigir o sistema
       afetado. Este e um metodo testado e verificado passo a passo para
       obter um sistema corrigido e funcionando com seguranc,a.

     * O campo Correction Details exibe cada branch do Subversion afetada com
       o numero de revisao que contem o codigo corrigido.

     * O campo References oferece fontes de informac,oes adicionais sobre a
       vulnerabilidade.

13.12. Auditoria de Processo

   Contribuido por Tom Rhodes.

   A auditoria de processos e um metodo de seguranc,a no qual um
   administrador pode controlar os recursos do sistema utilizados e sua
   alocac,ao entre os usuarios, fornecer monitoramento do sistema e controlar
   minimamente os comandos de um usuario.

   A auditoria de processos tem pontos positivos e negativos. Um dos pontos
   positivos e que uma intrusao pode ser rastreada ao ponto de entrada. Um
   valor negativo e a quantidade de logs gerados pela contabilidade do
   processo e o espac,o em disco necessario. Esta sec,ao conduz um
   administrador pelos fundamentos da contabilidade de processo.

  Nota:

   Se uma auditoria mais detalhada for necessaria, consulte Capitulo 16,
   Auditoria de Evento de Seguranc,a.

  13.12.1. Ativando e Utilizando a Auditoria de Processos

   Antes de usar a auditoria de processos, ela deve ser ativada usando os
   seguintes comandos:

 # sysrc accounting_enable=yes
 # service accounting start

   As informac,oes de auditoria sao armazenadas em arquivos localizados em
   /var/account, que sao criados automaticamente, se necessario, na primeira
   vez em que o servic,o de auditoria e iniciado. Esses arquivos contem
   informac,oes confidenciais, incluindo todos os comandos executados por
   todos os usuarios. O acesso de escrita aos arquivos e limitado ao root e o
   acesso de leitura e limitado ao root e aos membros do grupo wheel. Para
   tambem impedir que membros do grupo wheel leiam os arquivos, altere a
   permissao do diretorio /var/account para permitir acesso apenas de root.

   Uma vez ativada, a auditoria comec,ara a rastrear informac,oes, como
   estatisticas de CPU e comandos executados. Todos os logs auditados estao
   em um formato nao legivel que pode ser visualizado usando sa. Se executado
   sem nenhuma opc,ao, o sa imprime informac,oes relacionadas ao numero de
   chamadas por usuario, o tempo total decorrido em minutos, o total de CPU e
   o tempo do usuario em minutos, e o numero medio de operac,oes de I/O.
   Consulte sa(8) para obter a lista de opc,oes disponiveis que controlam a
   saida.

   Para exibir os comandos emitidos pelos usuarios, use o lastcomm. Por
   exemplo, este comando imprime todo o uso do comando ls pelo usuario
   trhodes no terminal ttyp1:

 # lastcomm ls trhodes ttyp1

   Muitas outras opc,oes uteis existem e sao explicadas em lastcomm(1),
   acct(5) e sa(8).

13.13. Limites de Recursos

   Contribuido por Tom Rhodes.

   O FreeBSD fornece varios metodos para um administrador limitar a
   quantidade de recursos do sistema que um individuo pode usar. As cotas de
   disco limitam a quantidade de espac,o em disco disponivel para os
   usuarios. As cotas sao discutidas em Sec,ao 17.11, "Cotas de Disco".

   Limites para outros recursos, como CPU e memoria, podem ser definidos
   usando um arquivo simples ou um comando para configurar um banco de dados
   de limites de recursos. O metodo tradicional define classes de login
   editando o arquivo /etc/login.conf. Embora esse metodo ainda seja
   suportado, qualquer alterac,ao requer um processo de varias etapas para
   editar esse arquivo, reconstruir o banco de dados de recursos, fazer as
   alterac,oes necessarias no arquivo /etc/master.passwd e reconstruir o
   banco de dados de senhas. Isso pode se tornar demorado, dependendo do
   numero de usuarios a serem configurados.

   O comando rctl pode ser usado para fornecer um metodo mais refinado para
   controlar limites de recursos. Esse comando suporta mais que limites de
   usuario, ja que tambem pode ser usado para definir restric,oes de recursos
   em processos e jails.

   Esta sec,ao demonstra os dois metodos para controlar recursos, comec,ando
   com o metodo tradicional.

  13.13.1. Configurando Classes de Login

   No metodo tradicional, as classes de login e os limites de recursos a
   serem aplicados a uma classe de login sao definidos no arquivo
   /etc/login.conf. Cada conta de usuario pode ser atribuida a uma classe de
   login, onde default e a classe de login padrao. Cada classe de login
   possui um conjunto de recursos de login associados a ele. Um recurso de
   login e um par name=value, em que name e um identificador conhecido e
   value e uma string arbitraria que e processada de acordo, dependendo do
   name.

  Nota:

   Sempre que o arquivo /etc/login.conf for editado, o /etc/login.conf.db
   deve ser atualizado executando o seguinte comando:

 # cap_mkdb /etc/login.conf

   Os limites de recursos diferem dos recursos de login padrao de duas
   maneiras. Primeiro, para cada limite, existe um limite soft e um hard. Um
   limite soft pode ser ajustado pelo usuario ou aplicativo, mas nao pode ser
   definido como superior ao limite hard. O limite hard pode ser baixado pelo
   usuario, mas so pode ser aumentado pelo root. Segundo, a maioria dos
   limites de recursos se aplica por processo a um usuario especifico.

   Tabela 13.1, "Limites de Recursos de Classe de Login" lista os limites de
   recursos mais usados. Todos os limites de recursos disponiveis e
   capabilities sao descritos em detalhes em login.conf(5).

   Tabela 13.1. Limites de Recursos de Classe de Login

   Limite de Recurso                        Descric,ao                        
                     O limite do tamanho de um arquivo core gerado por um     
                     programa e subordinado a outros limites de uso do disco, 
                     como filesize ou cotas de disco. Esse limite e           
                     frequentemente usado como um metodo menos severo de      
   coredumpsize      controle do consumo de espac,o em disco. Como os         
                     usuarios nao geram arquivos core e geralmente nao os     
                     excluem, essa configurac,ao pode evitar que eles fiquem  
                     sem espac,o em disco caso ocorra um grande travamento de 
                     programa.                                                
                     A quantidade maxima de tempo de CPU que o processo de um 
                     usuario pode consumir. Os processos ofensivos serao      
   cputime           eliminados pelo kernel. Este e um limite no tempo de CPU 
                     consumido, nao a porcentagem do CPU como exibido em      
                     alguns dos campos gerados pelo top e ps.                 
                     O tamanho maximo de um arquivo que o usuario pode        
                     possuir. Ao contrario das cotas de disco (Sec,ao 17.11,  
   filesize          "Cotas de Disco"), esse limite e imposto em arquivos     
                     individuais, nao no conjunto de todos os arquivos que um 
                     usuario possui.                                          
                     O numero maximo de processos de primeiro plano e de      
                     plano de fundo que um usuario pode executar. Esse limite 
                     pode nao ser maior que o limite do sistema especificado  
   maxproc           pela variavel kern.maxproc. Definir um limite muito      
                     pequeno pode prejudicar a produtividade de um usuario,   
                     pois algumas tarefas, como compilar um programa grande,  
                     iniciam muitos processos.                                
                     A quantidade maxima de memoria que um processo pode      
                     solicitar para ser bloqueado na memoria principal usando 
   memorylocked      o mlock(2). Alguns programas criticos do sistema, como   
                     amd(8), se bloqueiam na memoria principal para que, se o 
                     sistema comec,ar a fazer swap, eles nao contribuam para  
                     surrar o disco.                                          
                     A quantidade maxima de memoria que um processo pode      
                     consumir a qualquer momento. Inclui tanto a memoria      
   memoryuse         principal quanto o uso de swap. Este nao e um limite     
                     geral para restringir o consumo de memoria, mas e um bom 
                     comec,o.                                                 
                     O numero maximo de arquivos que um processo pode ter     
                     aberto. No FreeBSD, os arquivos sao usados para          
   openfiles         representar sockets e canais IPC, entao tome cuidado     
                     para nao definir isso muito baixo. O limite de todo o    
                     sistema para isso e definido por pela variavel           
                     kern.maxfiles.                                           
                     O limite na quantidade de memoria de rede que um usuario 
   sbsize            pode consumir. Isso geralmente pode ser usado para       
                     limitar as comunicac,oes da rede.                        
                     O tamanho maximo de uma pilha de processos. Isso por si  
   stacksize         so nao e suficiente para limitar a quantidade de memoria 
                     que um programa pode usar, por isso deve ser usado em    
                     conjunto com outros limites.                             

   Existem algumas outras coisas para se lembrar ao definir limites de
   recursos:

     * Os processos iniciados na inicializac,ao do sistema pelo /etc/rc sao
       atribuidos `a classe daemon de login.

     * Embora o arquivo /etc/login.conf padrao seja uma boa fonte de valores
       razoaveis para a maioria dos limites, eles podem nao ser apropriados
       para todos os sistemas. Definir um limite muito alto pode abrir o
       sistema para uso abusivo, enquanto que defini-lo como muito baixo pode
       prejudicar a produtividade.

     * O Xorg utiliza muitos recursos e incentiva os usuarios a executarem
       mais programas simultaneamente.

     * Muitos limites se aplicam a processos individuais, nao ao usuario como
       um todo. Por exemplo, definir a variavel openfiles como 50 significa
       que cada processo que o usuario executa pode abrir ate 50 arquivos. A
       quantidade total de arquivos que um usuario pode abrir e o valor de
       openfiles multiplicado pelo valor de maxproc. Isso tambem se aplica ao
       consumo de memoria.

   Para mais informac,oes sobre limites de recursos e classes de login e
   capacidades em geral, consulte cap_mkdb(1), getrlimit(2) e login.conf(5).

  13.13.2. Ativando e Configurando Limites de Recursos

   A variavel configuravel kern.racct.enable deve ser configurada para um
   valor diferente de zero. Kernels personalizados requerem configurac,ao
   especifica:

 options         RACCT
 options         RCTL

   Depois que o sistema for reinicializado no novo kernel, o rctl podera ser
   usado para definir regras para o sistema.

   A sintaxe da regra e controlada por meio do uso de um subject, subject-id,
   resource e action, conforme visto nesta regra de exemplo:

 user:trhodes:maxproc:deny=10/user

   Nesta regra, o subject e user, o subject-id e trhodes, o resource,
   maxproc, e o numero maximo de processos, e a action e deny, que bloqueia a
   criac,ao de novos processos. Isso significa que o usuario, trhodes, sera
   restrito a execuc,ao de no maximo 10 processos. Outras ac,oes possiveis
   incluem o registro no console, passando uma notificac,ao para o devd(8) ou
   enviando um sigterm para o processo.

   Algum cuidado deve ser tomado ao adicionar regras. Como esse usuario esta
   restrito a 10 processos, este exemplo impedira que o usuario execute
   outras tarefas depois de efetuar login e executar uma sessao screen.
   Quando um limite de recurso for atingido, um erro sera impresso, como
   neste exemplo:

 % man test
     /usr/bin/man: Cannot fork: Resource temporarily unavailable
 eval: Cannot fork: Resource temporarily unavailable

   Como outro exemplo, uma jail pode ser impedida de exceder um limite de
   memoria. Esta regra pode ser escrita como:

 # rctl -a jail:httpd:memoryuse:deny=2G/jail

   As regras persistirao durante as reinicializac,oes se tiverem sido
   adicionadas ao arquivo /etc/rctl.conf. O formato e uma regra, sem o
   comando anterior. Por exemplo, a regra anterior pode ser adicionada como:

 # Block jail from using more than 2G memory:
 jail:httpd:memoryuse:deny=2G/jail

   Para remover uma regra, use o rctl para remove-la da lista:

 # rctl -r user:trhodes:maxproc:deny=10/user

   Um metodo para remover todas as regras e documentado em rctl(8). No
   entanto, se for necessario remover todas as regras para um unico usuario,
   esse comando podera ser emitido:

 # rctl -r user:trhodes

   Existem muitos outros recursos que podem ser usados para exercer controle
   adicional sobre varios subjects. Veja rctl(8) para aprender sobre eles.

13.14. Administrac,ao Compartilhada com Sudo

   Contribuido por Tom Rhodes.

   Os administradores do sistema geralmente precisam conceder permissoes
   avanc,adas aos usuarios para que eles possam executar tarefas
   privilegiadas. A ideia de que os membros da equipe tenham acesso a um
   sistema FreeBSD para executar suas tarefas especificas abre desafios
   unicos para cada administrador. Esses membros da equipe precisam apenas de
   um subconjunto de acesso alem dos niveis normais de usuario final; no
   entanto, eles quase sempre dizem ao gerenciadores que eles sao incapazes
   de executar suas tarefas sem acesso de superusuario. Felizmente, nao ha
   motivo para fornecer tal acesso aos usuarios finais porque existem
   ferramentas para gerenciar esse exato requisito.

   Ate este ponto, o capitulo de seguranc,a cobriu o acesso a usuarios
   autorizados e a tentativa de impedir o acesso nao autorizado. Outro
   problema surge quando os usuarios autorizados tem acesso aos recursos do
   sistema. Em muitos casos, alguns usuarios podem precisar acessar os
   scripts de inicializac,ao do aplicativo ou uma equipe de administradores
   precisa manter o sistema. Tradicionalmente, os usuarios e grupos padrao,
   as permissoes de arquivo e ate mesmo o comando su() gerenciariam esse
   acesso. E como os aplicativos exigiam mais acesso, `a medida que mais
   usuarios precisavam usar recursos do sistema, era necessaria uma soluc,ao
   melhor. A aplicac,ao mais usada atualmente e o Sudo.

   O Sudo permite que os administradores configurem um acesso mais rigido aos
   comandos do sistema e fornec,am alguns recursos avanc,ados de log. Como
   uma ferramenta, ele esta disponivel na colec,ao de ports como
   security/sudo ou usando o utilitario pkg(8). Para usar a ferramenta
   pkg(8):

 # pkg install sudo

   Apos a conclusao da instalac,ao, o visudo instalado abrira o arquivo de
   configurac,ao com um editor de texto. O uso do visudo e altamente
   recomendado, pois vem com um verificador de sintaxe incorporado para
   verificar se nao ha erros antes que o arquivo seja salvo.

   O arquivo de configurac,ao e composto de varias sec,oes pequenas que
   permitem uma configurac,ao extensiva. No exemplo a seguir, o mantenedor do
   aplicativo da web, user1, precisa iniciar, parar e reiniciar o aplicativo
   da web conhecido como webservice. Para conceder a este usuario permissao
   para executar estas tarefas, adicione esta linha ao final do arquivo
   /usr/local/etc/sudoers:

 user1   ALL=(ALL)       /usr/sbin/service webservice *

   O usuario pode agora iniciar o webservice usando este comando:

 % sudo /usr/sbin/service webservice start

   Embora essa configurac,ao permita que um unico usuario acesse o servic,o
   webservice; No entanto, na maioria das organizac,oes, existe uma equipe
   inteira da Web encarregada de gerenciar o servic,o. Uma unica linha tambem
   pode dar acesso a um grupo inteiro. Essas etapas criarao um grupo da Web,
   adicionarao um usuario a esse grupo e permitirao que todos os membros do
   grupo gerenciem o servic,o:

 # pw groupadd -g 6001 -n webteam

   Usando o mesmo comando pw(8), o usuario e adicionado ao grupo webteam:

 # pw groupmod -m user1 -n webteam

   Finalmente, esta linha no arquivo /usr/local/etc/sudoers permite que
   qualquer membro do grupo webteam gerencie o webservice:

 %webteam   ALL=(ALL)       /usr/sbin/service webservice *

   Ao contrario do su(1), o Sudo requer apenas a senha do usuario final. Isso
   adiciona uma vantagem em que os usuarios nao precisarao de senhas
   compartilhadas, uma descoberta na maioria das auditorias de seguranc,a e o
   que por si so ja ruins em todos os aspectos.

   Os usuarios autorizados a executar aplicativos com o Sudo so inserem suas
   proprias senhas. Isso e mais seguro e oferece melhor controle do que o
   su(1), onde a senha de root e inserida e o usuario adquire todas as
   permissoes de root.

  Dica:

   A maioria das organizac,oes esta se movendo ou migrou para um modelo de
   autenticac,ao de dois fatores. Nestes casos, o usuario pode nao ter uma
   senha para entrar. O Sudo resolve estes casos com a variavel NOPASSWD.
   Adiciona-lo `a configurac,ao acima permitira que todos os membros do grupo
   webteam gerenciem o servic,o sem o requisito de senha:

 %webteam   ALL=(ALL)       NOPASSWD: /usr/sbin/service webservice *

  13.14.1. Logando a Saida

   Uma vantagem para implementar o Sudo e a capacidade de ativar o log de
   sessao. Usando os mecanismos de log integrados e o comando sudoreplay
   incluido, todos os comandos iniciados por meio de Sudo sao registrados
   para verificac,ao posterior. Para ativar esse recurso, adicione uma
   entrada de diretorio de log padrao, este exemplo usa uma variavel de
   usuario. Existem varias outras convenc,oes de nome de arquivo de log,
   consulte a pagina de manual do sudoreplay para obter informac,oes
   adicionais.

 Defaults iolog_dir=/var/log/sudo-io/%{user}

  Dica:

   Este diretorio sera criado automaticamente apos o logging ser configurado.
   E melhor deixar o sistema criar o diretorio com permissoes padrao apenas
   para estar seguro. Alem disso, essa entrada tambem registra os
   administradores que usam o comando sudoreplay. Para alterar esse
   comportamento, leia e descomente as opc,oes de log dentro do arquivo
   sudoers.

   Uma vez que esta diretiva tenha sido adicionada ao arquivo sudoers,
   qualquer configurac,ao de usuario pode ser atualizada com a solicitac,ao
   para acessar o log. No exemplo mostrado, a entrada webteam atualizada
   teria as seguintes alterac,oes adicionais:

 %webteam ALL=(ALL) NOPASSWD: LOG_INPUT: LOG_OUTPUT: /usr/sbin/service webservice *

   Deste ponto em diante, todos os membros do grupo webteam que alteram o
   status do aplicativo webservice serao registrados. A lista de sessoes
   anteriores e atuais pode ser exibida com:

 # sudoreplay -l

   Na saida, para reproduzir uma sessao especifica, procure a entrada TSID= e
   passe-a para o sudoreplay sem outras opc,oes para reproduzir a sessao na
   velocidade normal. Por exemplo:

 # sudoreplay user1/00/00/02

  Atenc,ao:

   Enquanto as sessoes sao registradas, qualquer administrador pode remover
   as sessoes e deixar apenas uma questao de por que elas fizeram isso. Vale
   a pena adicionar uma verificac,ao diaria por meio de um sistema de
   detecc,ao de intrusao (IDS) ou software semelhante para que outros
   administradores sejam alertados sobre alterac,oes manuais.

   O sudoreplay e extremamente extensivel. Consulte a documentac,ao para mais
   informac,oes.

Capitulo 14. Jails

   Contribuido por Matteo Riondato.
   Indice

   14.1. Sinopse

   14.2. Termos Relacionados `a Jails

   14.3. Criando e Controlando Jails

   14.4. Tuning e Administrac,ao

   14.5. Atualizando Multiplas Jails

   14.6. Gerenciando Jails com o ezjail

14.1. Sinopse

   Como a administrac,ao de sistemas e uma tarefa dificil, muitas ferramentas
   foram desenvolvidas para facilitar a vida do administrador. Essas
   ferramentas geralmente aprimoram a maneira como os sistemas sao
   instalados, configurados e mantidos. Uma das ferramentas que podem ser
   usadas para melhorar a seguranc,a de um sistema FreeBSD e jails. Jails
   estao disponiveis desde o FreeBSD 4.X e continuam sendo aprimoradas em sua
   utilidade, desempenho, confiabilidade e seguranc,a.

   Jails sao construidas em cima do conceito de chroot(2), que e usado para
   mudar o diretorio raiz de um conjunto de processos. Isso cria um ambiente
   seguro, separado do resto do sistema. Os processos criados no ambiente
   chroot nao podem acessar arquivos ou recursos fora dele. E por esse
   motivo, comprometer um servic,o em execuc,ao em um ambiente chroot nao
   deve permitir que o invasor comprometa todo o sistema. No entanto, um
   chroot tem varias limitac,oes. E adequado para tarefas faceis que nao
   exigem muita flexibilidade ou recursos complexos e avanc,ados. Ao longo do
   tempo, foram descobertas muitas maneiras de escapar de um ambiente chroot,
   tornando essa soluc,ao como nao sendo a melhor para proteger os servic,os.

   As jails aprimoram o conceito do ambiente chroot tradicional de varias
   maneiras. Em um ambiente chroot tradicional, os processos sao limitados
   apenas na parte do sistema de arquivos que eles podem acessar. O restante
   dos recursos do sistema, os usuarios, os processos em execuc,ao e o
   subsistema de rede sao compartilhados pelos processos chroot e pelos
   processos do sistema host. As jails expandem esse modelo virtualizando o
   acesso ao sistema de arquivos, ao conjunto de usuarios e ao subsistema de
   rede. Controles mais refinados estao disponiveis para ajustar o acesso de
   um ambiente em jail. As jails podem ser consideradas como um tipo de
   virtualizac,ao no nivel do sistema operacional.

   Uma jail e caracterizada por quatro elementos:

     * Uma subarvore de diretorios: o ponto de partida a partir do qual uma
       jail e inserida. Uma vez dentro da jail, nao e permitido que um
       processo escape fora dessa subarvore.

     * Um nome de host: que sera usado pela jail.

     * Um enderec,o IP: atribuido `a jail. O enderec,o IP de uma jail e
       geralmente um enderec,o de alias de uma interface de rede existente.

     * Um comando: o nome do caminho de um executavel para ser executado
       dentro da jail. O caminho e relativo ao diretorio raiz do ambiente da
       jail.

   As Jails possuem seu proprio conjunto de usuarios e sua propria conta de
   root que sao limitados ao ambiente da jail. A conta root de uma jail nao
   tem permissao para executar operac,oes no sistema fora do ambiente da jail
   associada.

   Este capitulo fornece uma visao geral da terminologia e dos comandos para
   gerenciar as jail do FreeBSD. As jails sao uma ferramenta poderosa para
   administradores de sistemas e usuarios avanc,ados.

   Depois de ler este capitulo, voce sabera:

     * O que e uma jail e qual finalidade ela pode servir nas instalac,oes do
       FreeBSD.

     * Como compilar, iniciar e parar uma jail.

     * Os fundamentos da administrac,ao de jails, tanto de dentro como fora
       da jail.

  Importante:

   As jails sao uma ferramenta poderosa, mas nao sao uma panaceia de
   seguranc,a. Embora nao seja possivel que um processo rodando em jail burle
   a seguranc,a por conta propria, existem varias maneiras pelas quais um
   usuario nao privilegiado fora da jail pode cooperar com um usuario
   privilegiado dentro da jail para obter privilegios elevados no ambiente
   host.

   A maioria desses ataques podem ser mitigados apenas garantindo que o root
   da jail nao seja acessivel a usuarios nao privilegiados no ambiente host.
   Como regra geral, usuarios nao confiaveis com acesso privilegiado a uma
   jail nao devem ter acesso ao ambiente do host.

14.2. Termos Relacionados `a Jails

   Para facilitar a compreensao de partes do sistema FreeBSD relacionadas a
   jails, seus componentes internos e a maneira como eles interagem com o
   resto do FreeBSD, os seguintes termos sao usados mais adiante neste
   capitulo:

   chroot(8) (comando)

           Utilitario, que usa a chamada de sistema chroot(2) do FreeBSD para
           alterar o diretorio raiz de um processo e todos os seus
           descendentes.

   chroot(2) (ambiente)

           O ambiente dos processos em execuc,ao em um "chroot". Isso inclui
           recursos como a parte do sistema de arquivos que e visivel, IDs de
           usuario e grupo que estao disponiveis, interfaces de rede e outros
           mecanismos de IPC, etc.

   jail(8) (comando)

           O utilitario de administrac,ao do sistema que permite o
           lanc,amento de processos dentro de um ambiente jail.

   host (sistema, processo, usuario, etc.)

           O sistema de controle de um ambiente jail. O sistema host tem
           acesso a todos os recursos de hardware disponiveis e pode
           controlar processos fora e dentro de um ambiente jail. Uma das
           diferenc,as importantes do sistema host de uma jail e que as
           limitac,oes que se aplicam aos processos de super-usuario dentro
           de uma jail nao sao aplicadas aos processos do sistema host.

   hosted (sistema, processo, usuario, etc.)

           Um processo, usuario ou outra entidade, cujo acesso a recursos e
           restrito por uma jail do FreeBSD.

14.3. Criando e Controlando Jails

   Alguns administradores dividem as jails nos dois seguintes tipos: jails
   "completa", que se assemelham a um sistema real do FreeBSD, e jails de
   "servic,o", dedicados a um aplicativo ou servic,o, possivelmente
   executando com privilegios. Esta e apenas uma divisao conceitual e o
   processo de criac,ao de uma jail nao e afetado por ela. Ao criar uma jail
   "completa", ha duas opc,oes para a origem do userland: usar binarios
   pre-compilados (como aqueles fornecidos em uma midia de instalac,ao) ou
   compila-los a partir do codigo fonte.

   Para instalar o userland da midia de instalac,ao, primeiro crie o
   diretorio raiz da jail. Isso pode ser feito definindo a variavel DESTDIR
   para o local adequado.

   Inicie um shell e defina a variavel DESTDIR:

 # sh
 # export DESTDIR=/here/is/the/jail

   Monte a midia de instalac,ao como abordado em mdconfig(8) ao usar a ISO de
   instalac,ao:

 # mount -t cd9660 /dev/`mdconfig -f cdimage.iso` /mnt
 # cd /mnt/usr/freebsd-dist/

   Como alternativa, baixe os tarballs de um mirror:

 # sh
 # export DESTRELEASE=12.0-RELEASE
 # export DESTARCH=`uname -m`
 # export SOURCEURL=http://ftp.freebsd.org/pub/FreeBSD/releases/$DESTARCH/$DESTRELEASE/
 # for set in base ports; do fetch $SOURCEURL/$set.txz ; done

   Extraia os binarios dos tarballs na midia de instalac,ao dentro do destino
   declarado. Minimamente, apenas o conjunto base precisa ser extraido, mas
   uma instalac,ao completa pode ser executada quando preferida.

   Para instalar apenas o sistema basico:

 # tar -xf /mnt/usr/freebsd-dist/base.txz -C $DESTDIR

   Para instalar tudo, exceto o kernel:

 # for set in base ports; do tar -xf /mnt/usr/freebsd-dist/$set.txz -C $DESTDIR ; done

   A pagina de manual jail(8) explica o procedimento para compilar uma jail:

 # setenv D /here/is/the/jail
 # mkdir -p $D      1
 # cd /usr/src
 # make buildworld  2
 # make installworld DESTDIR=$D  3
 # make distribution DESTDIR=$D  4
 # mount -t devfs devfs $D/dev   5

   1 Selecionar um local para uma jail e o melhor ponto de partida. E aqui    
     que a jail residira fisicamente no sistema de arquivos do host da jail.  
     Uma boa opc,ao pode ser /usr/jail/jailname, onde jailname e o nome do    
     host que identifica a jail. Normalmente, /usr/ tem espac,o suficiente    
     para o sistema de arquivos da jail, onde para jails "completa" e,        
     essencialmente, uma replicac,ao de todos os arquivos presentes em uma    
     instalac,ao padrao do sistema basico do FreeBSD.                         
   2 Se voce ja tiver recompilado seu userland usando make world ou make      
     buildworld, voce pode pular esta etapa e instalar seu userland existente 
     na nova jail.                                                            
   3 Esse comando preenchera a sub-arvore de diretorios escolhida como o      
     local fisico da jail no sistema de arquivos com os binarios,             
     bibliotecas, paginas de manual e assim por diante.                       
   4 O target distribuic,ao do make instala todos os arquivos de              
     configurac,ao necessarios. Em palavras simples, ele instala cada arquivo 
     instalavel de /usr/src/etc/ no diretorio /etc do ambiente jail: $D/etc/. 
   5 A montagem do sistema de arquivos devfs(8) dentro de uma jail nao e      
     necessaria. Por outro lado, qualquer, ou quase qualquer aplicativo       
     requer acesso a pelo menos um dispositivo, dependendo da finalidade do   
     aplicativo fornecido. E muito importante controlar o acesso a            
     dispositivos de dentro de uma jail, pois configurac,oes inadequadas      
     podem permitir que um invasor fac,a coisas desagradaveis na jail. O      
     controle sobre devfs(8) e gerenciado por meio de conjuntos de regras que 
     sao descritos nas paginas de manual devfs(8) e devfs.conf(5).            

   Uma vez que a jail e instalada, ela pode ser iniciada usando o utilitario
   jail(8). O utilitario jail(8) possui quatro argumentos obrigatorios que
   sao descritos em Sec,ao 14.1, "Sinopse". Outros argumentos podem ser
   especificados tambem, por exemplo, para executar o processo em jail com as
   credenciais de um usuario especifico. O argumento de command depende do
   tipo de jail; para um sistema virtual, /etc/rc e uma boa escolha, ja que
   ele ira replicar a sequencia de inicializac,ao de um sistema real do
   FreeBSD. Para uma jail de servic,o, depende do servic,o ou aplicativo que
   sera executado dentro da jail.

   As jails geralmente sao iniciadas no boot e o mecanismo rc do FreeBSD
   fornece uma maneira facil de fazer isso.

     * Configure os parametros da jail no arquivo jail.conf:

 www {
     host.hostname = www.example.org;           # Hostname
     ip4.addr = 192.168.0.10;                   # IP address of the jail
     path ="/usr/jail/www";                     # Path to the jail
     devfs_ruleset = "www_ruleset";             # devfs ruleset
     mount.devfs;                               # Mount devfs inside the jail
     exec.start = "/bin/sh /etc/rc";            # Start command
     exec.stop = "/bin/sh /etc/rc.shutdown";    # Stop command
 }

       Configure as jails para iniciar no boot no arquivo rc.conf:

 jail_enable="YES"   # Set to NO to disable starting of any jails

       A inicializac,ao padrao das jails configuradas no arquivo
       jail.conf(5), executara o script /etc/rc da jail, que assume que a
       jail e um sistema virtual completo. Para jails de servic,o, o comando
       de inicializac,ao padrao da jail deve ser alterado, definindo a opc,ao
       exec.start apropriadamente.

  Nota:

       Para obter uma lista completa das opc,oes disponiveis, consulte a
       pagina de manual jail.conf(5).

   service(8) pode ser usado para iniciar ou parar uma jail manualmente, se
   uma entrada para ela existir no arquivo jail.conf:

 # service jail start www
 # service jail stop www

   As jails podem ser desligadas com o jexec(8). Use jls(8) para identificar
   o JID da jail e, em seguida, use jexec(8) para executar o script de
   desligamento nessa jail.

 # jls
    JID  IP Address      Hostname                      Path
      3  192.168.0.10    www                           /usr/jail/www
 # jexec 3 /etc/rc.shutdown

   Mais informac,oes sobre isso podem ser encontradas na pagina de manual
   jail(8).

14.4. Tuning e Administrac,ao

   Existem varias opc,oes que podem ser configuradas para qualquer jail, e
   varias maneiras de combinar um sistema host FreeBSD com jails, para
   produzir aplicac,oes de alto nivel. Esta sec,ao apresenta:

     * Algumas das opc,oes disponiveis para ajustar as restric,oes de
       comportamento e seguranc,a implementadas pela instalac,ao de uma jail.

     * Alguns das aplicac,oes de alto nivel para gerenciamento de jail, que
       estao disponiveis atraves da Colec,ao de Ports do FreeBSD, e que podem
       ser usados para implementar soluc,oes globais baseadas em jails.

  14.4.1. Ferramentas de Sistema para Tuning de Jail no FreeBSD

   O tuning da configurac,ao de uma jail e feito principalmente configurando
   variaveis sysctl(8). Uma sub-arvore especial do sysctl existe como base
   para organizar todas as opc,oes relevantes: a hierarquia security.jail.*
   das opc,oes do kernel do FreeBSD. Aqui esta uma lista dos principais
   sysctls relacionados `a jail, completas com seu valor padrao. Os nomes
   devem ser autoexplicativos, mas para obter mais informac,oes sobre eles,
   consulte as paginas de manual jail(8) e sysctl(8).

     * security.jail.set_hostname_allowed: 1

     * security.jail.socket_unixiproute_only: 1

     * security.jail.sysvipc_allowed: 0

     * security.jail.enforce_statfs: 2

     * security.jail.allow_raw_sockets: 0

     * security.jail.chflags_allowed: 0

     * security.jail.jailed: 0

   Estas variaveis podem ser usadas pelo administrador de sistemas do sistema
   host para adicionar ou remover algumas das limitac,oes impostas por padrao
   no usuario root. Note que existem algumas limitac,oes que nao podem ser
   removidas. O usuario root nao tem permissao para montar ou desmontar
   sistemas de arquivos de dentro de uma jail(8). O root dentro de uma jail
   nao pode carregar ou descarregar conjuntos de regras devfs(8), definir
   regras de firewall, ou fazer muitas outras tarefas administrativas que
   requerem modificac,oes de dados no kernel, como a configurac,ao do
   securelevel do kernel.

   O sistema base do FreeBSD contem um conjunto basico de ferramentas para
   visualizar informac,oes sobre as jails ativas e para se conectar a uma
   jail para executar comandos administrativos. Os comandos jls(8) e jexec(8)
   sao parte do sistema base do FreeBSD, e podem ser usados para realizar as
   seguintes tarefas simples:

     * Apresentar uma lista de jails ativas e seu identificador de jail
       correspondente (JID), enderec,o IP, hostname e path.

     * Se conectar a uma jail em execuc,ao, a partir de seu sistema host, e
       executar um comando dentro da jaijl ou executar tarefas
       administrativas dentro da propria jail. Isso e especialmente util
       quando o usuario root deseja desligar de maneira limpa uma jail. O
       utilitario jexec(8) tambem pode ser usado para iniciar um shell em uma
       jail para administrac,ao; por exemplo:

 # jexec 1 tcsh

  14.4.2. Ferramentas Administrativas de Alto Nivel na Colec,ao de Ports do
  FreeBSD

   Entre os muitos utilitarios de terceiros para administrac,ao de jail, um
   dos mais completos e uteis e o sysutils/ezjail. E um conjunto de scripts
   que contribuem para o gerenciamento de jail(8). Consulte a sec,ao ezjail
   do handbook para mais informac,oes.

  14.4.3. Mantendo as Jails com Alterac,oes e Atualizadas

   As jails devem ser atualizadas a partir do sistema operacional do host,
   pois a tentativa de aplicar patchs no userland de dentro da jail pode
   falhar, ja que o comportamento padrao no FreeBSD e nao permitir o uso de
   chflags(1) em uma jail, o que impede a substituic,ao de alguns arquivos. E
   possivel alterar esse comportamento, mas e recomendado usar o
   freebsd-update(8) para atualizar as jails. Use -b para especificar o
   caminho da jail a ser atualizada.

 # freebsd-update -b /here/is/the/jail fetch
 # freebsd-update -b /here/is/the/jail install

14.5. Atualizando Multiplas Jails

   Contribuido por Daniel Gerzo.
   Baseado em uma ideia apresentada por Simon L. B. Nielsen.
   E artigo escrito por Ken Tom.

   O gerenciamento de varias jails pode se tornar problematico porque toda
   jail tem que ser recompilada a partir do zero sempre que for atualizada.
   Isso pode ser demorado e entediante se muitas jails forem criadas e
   atualizadas manualmente.

   Esta sec,ao demonstra um metodo para resolver esse problema compartilhando
   com seguranc,a o maximo possivel entre jails usando montagens somente
   leitura mount_nullfs(8), para que a atualizac,ao seja mais simples. Isso
   torna mais atraente colocar servic,os unicos, como HTTP, DNS e SMTP, em
   jails individuais. Alem disso, fornece uma maneira simples de adicionar,
   remover e atualizar jails.

  Nota:

   Existem soluc,oes mais simples, como o ezjail, que fornece um metodo mais
   facil de administrar as jails do FreeBSD, mas e menos versatil que essa
   configurac,ao. O ezjail e coberto com mais detalhes em Sec,ao 14.6,
   "Gerenciando Jails com o ezjail".

   Os objetivos da configurac,ao descrita nesta sec,ao sao:

     * Criar uma estrutura de jail simples e facil de entender que nao exija
       a execuc,ao de um installworld completo em todas as jails.

     * Facilitar a adic,ao de novas jails ou remoc,ao das ja existentes.

     * Facilitar a atualizac,ao ou upgrade de jails existentes.

     * Tornar possivel a utilizac,ao de uma branch customizada do FreeBSD.

     * Seja paranoico com a seguranc,a, reduzindo ao maximo a possibilidade
       de comprometimento.

     * Economize espac,o e inodes, tanto quanto possivel.

   Esse design depende de um template master unico, read-only, que e montado
   em cada jail e em um dispositivo read-write por jail. Um dispositivo pode
   ser um disco fisico separado, uma partic,ao ou um dispositivo de memoria
   com suporte a vnode. Este exemplo usa montagens nullfs read-write.

   O layout do sistema de arquivos e o seguinte:

     * As jails sao hospedadas na partic,ao /home.

     * Cada jail sera montada no diretorio /home/j.

     * O template para cada jail e a partic,ao read-only para todos as jails
       e /home/j/mroot.

     * Um diretorio em branco sera criado para cada jail no diretorio
       /home/j.

     * Cada jail tera um diretorio /s que sera vinculado `a parte de
       read-write do sistema.

     * Cada jail tera seu proprio sistema de read-write baseado em
       /home/j/skel.

     * A parte de read-write de cada jail sera criada em /home/js.

  14.5.1. Criando o Template

   Esta sec,ao descreve as etapas necessarias para criar o template master.

   E recomendado primeiramente atualizar o sistema host FreeBSD para a branch
   -RELEASE mais recente usando as instruc,oes em Sec,ao 23.5, "Atualizando o
   FreeBSD a partir do codigo fonte". Adicionalmente, este template usa o
   pacote ou port sysutils/cpdup e o portsnap sera utilizado para baixar a
   Colec,ao de Ports do FreeBSD.

    1. Primeiro, crie uma estrutura de diretorio para o sistema de arquivo
       read-only que contera os binarios do FreeBSD para as jails. Em
       seguida, altere para o diretorio de codigo-fonte do FreeBSD e instale
       o sistema de arquivos read-only no template das jails:

 # mkdir /home/j /home/j/mroot
 # cd /usr/src
 # make installworld DESTDIR=/home/j/mroot

    2. Em seguida, prepare uma Colec,ao de Ports do FreeBSD para as jails,
       assim como uma arvore de codigo fonte do FreeBSD, que sao necessarios
       para o mergemaster:

 # cd /home/j/mroot
 # mkdir usr/ports
 # portsnap -p /home/j/mroot/usr/ports fetch extract
 # cpdup /usr/src /home/j/mroot/usr/src

    3. Crie um esqueleto para a parte de read-write do sistema:

 # mkdir /home/j/skel /home/j/skel/home /home/j/skel/usr-X11R6 /home/j/skel/distfiles
 # mv etc /home/j/skel
 # mv usr/local /home/j/skel/usr-local
 # mv tmp /home/j/skel
 # mv var /home/j/skel
 # mv root /home/j/skel

    4. Use o mergemaster para instalar os arquivos de configurac,ao ausentes.
       Em seguida, remova os diretorios extras criados pelo mergemaster:

 # mergemaster -t /home/j/skel/var/tmp/temproot -D /home/j/skel -i
 # cd /home/j/skel
 # rm -R bin boot lib libexec mnt proc rescue sbin sys usr dev

    5. Agora, fac,a os links dos sistema de arquivos read-write ao sistema de
       arquivos read-only. Certifique-se de que os links simbolicos sejam
       criados nos locais corretos de s/, pois a criac,ao de diretorios nos
       locais errados fara com que a instalac,ao falhe.

 # cd /home/j/mroot
 # mkdir s
 # ln -s s/etc etc
 # ln -s s/home home
 # ln -s s/root root
 # ln -s ../s/usr-local usr/local
 # ln -s ../s/usr-X11R6 usr/X11R6
 # ln -s ../../s/distfiles usr/ports/distfiles
 # ln -s s/tmp tmp
 # ln -s s/var var

    6. Como ultimo passo, crie um arquivo /home/j/skel/etc/make.conf generico
       contendo esta linha:

 WRKDIRPREFIX?=  /s/portbuild

       Isto torna possivel compilar ports do FreeBSD dentro de cada jail.
       Lembre-se de que o diretorio do ports faz parte do sistema somente
       leitura. O caminho customizado para o WRKDIRPREFIX permite que
       compilac,oes sejam feitas na parte read-write de cada jail.

  14.5.2. Criando Jails

   O template jail agora pode ser usado para preparar e configurar as jails
   no arquivo /etc/rc.conf. Este exemplo demonstra a criac,ao de 3 jails: NS,
   MAIL e WWW.

    1. Adicione as seguintes linhas ao arquivo /etc/fstab, para que o
       template read-only e o espac,o read-write das jails estejam disponivel
       nas respectivas jails:

 /home/j/mroot   /home/j/ns     nullfs  ro  0   0
 /home/j/mroot   /home/j/mail   nullfs  ro  0   0
 /home/j/mroot   /home/j/www    nullfs  ro  0   0
 /home/js/ns     /home/j/ns/s   nullfs  rw  0   0
 /home/js/mail   /home/j/mail/s nullfs  rw  0   0
 /home/js/www    /home/j/www/s  nullfs  rw  0   0

       Para evitar que o fsck verifique as montagens nullfs durante a
       inicializac,ao e o dump fac,a backup das montagens nullfs read-only
       das jails, as duas ultimas colunas sao ambos definidos para 0.

    2. Configure as jails no arquivo /etc/rc.conf:

 jail_enable="YES"
 jail_set_hostname_allow="NO"
 jail_list="ns mail www"
 jail_ns_hostname="ns.example.org"
 jail_ns_ip="192.168.3.17"
 jail_ns_rootdir="/usr/home/j/ns"
 jail_ns_devfs_enable="YES"
 jail_mail_hostname="mail.example.org"
 jail_mail_ip="192.168.3.18"
 jail_mail_rootdir="/usr/home/j/mail"
 jail_mail_devfs_enable="YES"
 jail_www_hostname="www.example.org"
 jail_www_ip="62.123.43.14"
 jail_www_rootdir="/usr/home/j/www"
 jail_www_devfs_enable="YES"

       A variavel jail_name_rootdir e configurada como /usr/home em vez de
       /home porque o caminho fisico de /home em uma instalac,ao padrao do
       FreeBSD e /usr/home. A variavel jail_name_rootdir nao deve ser
       configurada para um caminho que inclua um link simbolico, caso
       contrario as jails nao serao iniciadas.

    3. Crie os pontos de montagem necessarios para o sistema de arquivos
       read-only de cada jail:

 # mkdir /home/j/ns /home/j/mail /home/j/www

    4. Instale o template read-write em cada jail usando sysutils/cpdup:

 # mkdir /home/js
 # cpdup /home/j/skel /home/js/ns
 # cpdup /home/j/skel /home/js/mail
 # cpdup /home/j/skel /home/js/www

    5. Nesta fase, as jails estao compiladas e preparadas para execuc,ao.
       Primeiro, monte os sistemas de arquivos necessarios para cada jail e,
       em seguida, inicie-as:

 # mount -a
 # service jail start

   As jails devem estar funcionando agora. Para verificar se eles foram
   iniciadas corretamente, use jls. Sua saida deve ser semelhante ao
   seguinte:

 # jls
    JID  IP Address      Hostname                      Path
      3  192.168.3.17    ns.example.org                /home/j/ns
      2  192.168.3.18    mail.example.org              /home/j/mail
      1  62.123.43.14    www.example.org               /home/j/www

   Neste ponto, deve ser possivel entrar em cada jail, adicionar novos
   usuarios ou configurar daemons. A coluna JID indica o numero de
   identificac,ao da jail de cada jail em execuc,ao. Use o seguinte comando
   para executar tarefas administrativas na jail cujo JID e 3:

 # jexec 3 tcsh

  14.5.3. Fazendo Upgrade

   O design dessa configurac,ao fornece uma maneira facil de atualizar as
   jails existentes, minimizando o tempo de downtime. Alem disso, fornece uma
   maneira de reverter para a versao mais antiga, caso ocorra algum problema.

    1. O primeiro passo e atualizar o sistema host. Em seguida, crie um novo
       template temporario read-only em /home/j/mroot2.

 # mkdir /home/j/mroot2
 # cd /usr/src
 # make installworld DESTDIR=/home/j/mroot2
 # cd /home/j/mroot2
 # cpdup /usr/src usr/src
 # mkdir s

       O installworld cria alguns diretorios desnecessarios, que devem ser
       removidos:

 # chflags -R 0 var
 # rm -R etc var root usr/local tmp

    2. Recrie os links simbolicos read-write para o sistema de arquivos
       master:

 # ln -s s/etc etc
 # ln -s s/root root
 # ln -s s/home home
 # ln -s ../s/usr-local usr/local
 # ln -s ../s/usr-X11R6 usr/X11R6
 # ln -s s/tmp tmp
 # ln -s s/var var

    3. Em seguida, pare as jails:

 # service jail stop

    4. Desmonte os sistemas de arquivos originais, pois os sistemas
       read-write estao conectados ao sistema read-only (/s):

 # umount /home/j/ns/s
 # umount /home/j/ns
 # umount /home/j/mail/s
 # umount /home/j/mail
 # umount /home/j/www/s
 # umount /home/j/www

    5. Mova o antigo sistema de arquivos read-only e substitua-o pelo novo.
       Isso servira como backup e arquivamento do antigo sistema de arquivos
       read-only se algo der errado. A convenc,ao de nomenclatura usada aqui
       corresponde a quando um novo sistema de arquivos read-only foi criado.
       Mova a Colec,ao de Ports do FreeBSD original para o novo sistema de
       arquivos para economizar espac,o e inodes:

 # cd /home/j
 # mv mroot mroot.20060601
 # mv mroot2 mroot
 # mv mroot.20060601/usr/ports mroot/usr

    6. Neste ponto, o novo template read-only esta pronto, entao a unica
       tarefa restante e remontar os sistemas de arquivos e iniciar as jails:

 # mount -a
 # service jail start

   Use jls para verificar se as jails foram iniciadas corretamente. Execute
   mergemaster em cada jail para atualizar os arquivos de configurac,ao.

14.6. Gerenciando Jails com o ezjail

   Originalmente contribuido por Warren Block.

   Criar e gerenciar multiplas jails pode se tornar um trabalho tedioso e
   propenso a erros. O ezjail de Dirk Engling automatiza e simplifica muito
   as tarefas de jails. Uma basejail e criada como um template. Jails
   adicionais usam mount_nullfs(8) para compartilhar muitos dos diretorios da
   basejail sem usar espac,o em disco adicional. Cada jail adicional leva
   apenas alguns megabytes de espac,o em disco antes que os aplicativos sejam
   instalados. A atualizac,ao da copia do userland na basejail atualiza
   automaticamente todas as outras jails.

   Beneficios e recursos adicionais sao descritos em detalhes no site do
   ezjail, https://erdgeist.org/arts/software/ezjail/.

  14.6.1. Instalando o ezjail

   A instalac,ao do ezjail consiste na inclusao de uma interface de loopback
   para uso nas jails, instalac,ao do port ou pacote e ativac,ao do servic,o.

    1. Para manter o trafego de loopback da jail fora da interface de rede de
       loopback do host lo0, uma segunda interface de loopback e criada
       adicionando uma entrada no arquivo /etc/rc.conf:

 cloned_interfaces="lo1"

       A segunda interface de loopback lo1 sera criada quando o sistema for
       iniciado. Tambem pode ser criado manualmente sem reiniciar:

 # service netif cloneup
 Created clone interfaces: lo1.

       Jails podem ter permissao para usar aliases dessa interface de
       loopback secundaria sem interferir no host.

       Dentro de uma jail, o acesso ao enderec,o de loopback 127.0.0.1 e
       redirecionado para o primeiro enderec,o de IP atribuido `a jail. Para
       fazer com que o loopback da jail corresponda `a nova interface lo1,
       essa interface deve ser especificada primeiro na lista de interfaces e
       enderec,os IP fornecidos ao criar uma nova jail.

       De a cada jail um enderec,o de loopback exclusivo no bloco de rede
       127.0.0.0/8.

    2. Instale o sysutils/ezjail:

 # cd /usr/ports/sysutils/ezjail
 # make install clean

    3. Ative o ezjail adicionando esta linha ao arquivo /etc/rc.conf:

 ezjail_enable="YES"

    4. O servic,o sera iniciado automaticamente na inicializac,ao do sistema.
       Ele pode ser iniciado imediatamente na sessao atual:

 # service ezjail start

  14.6.2. Configurac,ao inicial

   Com o ezjail instalado, a estrutura do diretorio basejail pode ser criada
   e preenchida. Esta etapa e necessaria apenas uma vez no computador host da
   jail.

   Em ambos os exemplos, -p faz com que a arvore de ports seja baixada com o
   portsnap(8) para a basejail. Essa copia unica do diretorio de ports sera
   compartilhada por todas as jails. Usar uma copia separada do diretorio de
   ports para jails isola-os do host. O ezjail e explicado com mais detalhes
   no FAQ: http://erdgeist.org/arts/software/ezjail/#FAQ.

     *    * Preencher a Jail com o FreeBSD-RELEASE

            Para uma basejail baseada na mesma versao FreeBSD RELEASE do
            computador host, use o comando install. Por exemplo, em um
            computador host executando o FreeBSD 10-STABLE, a versao mais
            recente do FreeBSD -10 sera instalada na jail:

 # ezjail-admin install -p

          * Preencher a Jail com o comando installworld

            A basejail pode ser instalada a partir de binarios criados pelo
            buildworld no host com ezjail-admin update.

            Neste exemplo, o FreeBSD 10-STABLE foi compilado a partir do
            codigo fonte. Os diretorios da jail sao criados. E entao
            installworld e executado, instalando o /usr/obj do host na
            basejail.

 # ezjail-admin update -i -p

            O /usr/src do host e usado por padrao. Um diretorio de codigo
            fonte diferente no host pode ser especificado com -s e um caminho
            ou com ezjail_sourcetree em /usr/local/etc/ezjail.conf.

  Dica:

   A arvore de ports da basejail e compartilhada por outras jails. No
   entanto, os distfiles baixados sao armazenados na jail que os baixou. Por
   padrao, esses arquivos sao armazenados em /var/ports/distfiles dentro de
   cada jail. /var/ports dentro de cada jail tambem e usado como um diretorio
   de trabalho ao compilar ports.

  Dica:

   O protocolo FTP e usado por padrao para baixar pacotes para a instalac,ao
   da basejail. Configurac,oes de firewall ou proxy podem impedir ou
   interferir nas transferencias de FTP. O protocolo HTTP funciona de maneira
   diferente e evita esses problemas. Ele pode ser escolhido especificando
   uma URL completa para um espelho de download especifico no arquivo
   /usr/local/etc/ezjail.conf:

 ezjail_ftphost=http://ftp.FreeBSD.org

   Veja Sec,ao A.2, "Sites de FTP" para uma lista de sites.

  14.6.3. Criando e Iniciando uma Nova Jail

   Novas jails sao criadas com o comando ezjail-admin create. Nestes
   exemplos, a interface de loopback lo1 e usada conforme descrito acima.

   Procedimento 14.1. Crie e Inicie uma Nova Jail
    1. Crie a jail, especificando um nome e as interfaces de loopback e de
       rede a serem usadas, junto com seus enderec,os IP. Neste exemplo, a
       jail e denominada dnsjail.

 # ezjail-admin create dnsjail 'lo1|127.0.1.1,em0|192.168.1.50'

  Dica:

       A maioria dos servic,os de rede sao executados em jails sem problemas.
       Alguns servic,os de rede, como ping(8), usam raw network sockets. Nas
       jails, raw network sockets sao desativados por padrao para seguranc,a.
       Servic,os que exigem eles nao irao funcionar.

       Ocasionalmente, uma jail pode realmente precisar de raw sockets. Por
       exemplo, os aplicativos de monitoramento de rede geralmente usam
       ping(8) para verificar a disponibilidade de outros computadores.
       Quando raw network sockets sao realmente necessarios em uma jail, eles
       podem ser ativados editando o arquivo de configurac,ao do ezjail para
       uma jail individual, /usr/local/etc/ezjail/jailname. Modifique a
       entrada parameters:

 export jail_jailname_parameters="allow.raw_sockets=1"

       Nao habilite raw network sockets, a menos que os servic,os na jail
       realmente precisem deles.

    2. Inicie a jail:

 # ezjail-admin start dnsjail

    3. Use um console na jail:

 # ezjail-admin console dnsjail

   A jail esta funcionando e configurac,oes adicionais podem ser realizadas.
   Configurac,oes tipicas adicionadas neste momento incluem:

    1. Defina a Senha de root

       Conecte-se `a jail e configure a senha do usuario root:

 # ezjail-admin console dnsjail
 # passwd
 Changing local password for root
 New Password:
 Retype New Password:

    2. Configurac,ao de Fuso Horario

       O fuso horario da jail pode ser definido com tzsetup(8). Para evitar
       mensagens de erro espurias, a entrada adjkerntz(8) em /etc/crontab
       pode ser comentada ou removida. Este comando tenta atualizar o relogio
       de hardware do computador com alterac,oes de fuso horario, mas as
       jails nao tem permissao para acessar esse hardware.

    3. Servidores DNS

       Insira as linhas com o servidor de nomes de dominio no arquivo
       /etc/resolv.conf para que o DNS funcione na jail.

    4. Edite o arquivo /etc/hosts

       Altere o enderec,o e adicione o nome da jail para as entradas
       localhost no /etc/hosts.

    5. Configure o arquivo /etc/rc.conf

       Digite as definic,oes de configurac,ao no arquivo /etc/rc.conf. Isso e
       muito parecido com a configurac,ao de um computador completo. O nome
       do host e o enderec,o IP nao estao definidos aqui. Esses valores ja
       sao fornecidos pela configurac,ao da jail.

   Com a jail configurada, os aplicativos para os quais a jail foi criada
   podem ser instalados.

  Dica:

   Alguns ports devem ser compilados com opc,oes especiais para serem usados
   em uma jail. Por exemplo, os dois pacotes de plugin de monitoramento de
   rede net-mgmt/nagios-plugins e net-mgmt/monitoring-plugins possuem uma
   opc,ao JAIL que deve ser ativada para que funcionem corretamente dentro de
   uma jail.

  14.6.4. Atualizando as Jails

    14.6.4.1. Atualizando o Sistema Operacional

   Como a copia do userland da basejail e compartilhada pelas outras jails, a
   atualizac,ao da basejail atualiza automaticamente todas as outras jails.
   Atualizac,oes binarias ou por codigo fonte podem ser usadas.

   Para compilar o world a partir do codigo fonte no host, e depois
   instala-lo na basejail, use:

 # ezjail-admin update -b

   Se o world ja estiver sido compilado no host, instale-o no basejail com:

 # ezjail-admin update -i

   Atualizac,oes binarias usam o freebsd-update(8). Essas atualizac,oes tem
   as mesmas limitac,oes como se o freebsd-update(8) estivesse sendo
   executado diretamente. O mais importante e que apenas as versoes -RELEASE
   do FreeBSD estao disponiveis com este metodo.

   Atualize a basejail para a ultima versao de patchs da versao do FreeBSD no
   host. Por exemplo, atualizando de RELEASE-p1 para RELEASE-p2.

 # ezjail-admin update -u

   Para atualizar a basejail para uma nova versao, primeiro atualize o
   sistema host como descrito em Sec,ao 23.2.3, "Realizando Upgrades de
   Versao Principais e Menores". Depois que o host tiver sido atualizado e
   reinicializado, a basejail podera ser atualizada. O freebsd-update(8) nao
   tem como determinar qual versao esta atualmente instalada na basejail,
   entao a versao original deve ser especificada. Use o file(1) para
   determinar a versao original na basejail:

 # file /usr/jails/basejail/bin/sh
 /usr/jails/basejail/bin/sh: ELF 64-bit LSB executable, x86-64, version 1 (FreeBSD), dynamically linked (uses shared libs), for FreeBSD 9.3, stripped

   Agora use essas informac,oes para executar a atualizac,ao de 9.3-RELEASE
   para a versao atual do sistema host:

 # ezjail-admin update -U -s 9.3-RELEASE

   Depois de atualizar a basejail, o mergemaster(8) deve ser executado para
   atualizar os arquivos de configurac,ao de cada jail.

   Como usar o mergemaster(8) depende do proposito e da confiabilidade de uma
   jail. Se os servic,os ou usuarios de uma jail nao sao confiaveis, entao o
   mergemaster(8) deve ser executado somente dentro dessa jail:

   Exemplo 14.1. mergemaster(8) em Jail Nao Confiavel

   Exclua o link do /usr/src da jail para a basejail e crie um novo /usr/src
   na jail como um ponto de montagem. Monte o /usr/src do computador host
   como read-only no novo ponto de montagem /usr/src da jail:

 # rm /usr/jails/jailname/usr/src
 # mkdir /usr/jails/jailname/usr/src
 # mount -t nullfs -o ro /usr/src /usr/jails/jailname/usr/src

   Execute um console na jail:

 # ezjail-admin console jailname

   Dentro da jail, execute mergemaster. Em seguida, saia do console da jail:

 # cd /usr/src
 # mergemaster -U
 # exit

   Finalmente, desmonte o /usr/src da jail:

 # umount /usr/jails/jailname/usr/src

   Exemplo 14.2. mergemaster(8) em Jail Confiavel

   Se os usuarios e servic,os em uma jail forem confiaveis, o mergemaster(8)
   pode ser executado a partir do host:

 # mergemaster -U -D /usr/jails/jailname

  Dica:

   Apos uma atualizac,ao de versao principal, e recomendado pelo
   sysutils/ezjail garantir que o pkg seja da versao correta. Portanto,
   digite:

 # pkg-static upgrade -f pkg

   para atualizar ou fazer o downgrade para a versao apropriada.

    14.6.4.2. Atualizando o Ports

   A arvore de ports na basejail e compartilhada pelas outras jails. A
   atualizac,ao dessa copia da arvore de ports fornece `as outras jails a
   versao atualizada tambem.

   A arvore de ports da basejail e atualizada com o portsnap(8):

 # ezjail-admin update -P

  14.6.5. Controlando as Jails

    14.6.5.1. Parando e Iniciando Jails

   O ezjail inicia automaticamente as jails quando o computador e iniciado.
   As jails podem ser manualmente paradas e reiniciadas com stop e start:

 # ezjail-admin stop sambajail
 Stopping jails: sambajail.

   Por padrao, as jails sao iniciadas automaticamente quando o computador
   host e iniciado. A inicializac,ao automatica pode ser desativada com
   config:

 # ezjail-admin config -r norun seldomjail

   Isso entrara em vigor na proxima vez em que o computador host for
   iniciado. Uma jail que ja esta em execuc,ao nao sera interrompida.

   A ativac,ao do inicio automatico e muito semelhante:

 # ezjail-admin config -r run oftenjail

    14.6.5.2. Arquivando e Restaurando Jails

   Use archive para criar um arquivo .tar.gz de uma jail. O nome do arquivo e
   composto pelo nome da jail e pela data atual. Os archives sao gravados no
   diretorio de archive, /usr/jails/ezjail_archives. Um diretorio de archive
   diferente pode ser escolhido configurando ezjail_archivedir no arquivo de
   configurac,ao.

   O archive pode ser copiado em outro lugar como um backup, ou uma jail
   existente pode ser restaurada a partir dele com o restore. Uma nova jail
   pode ser criada a partir de um archive, fornecendo uma maneira conveniente
   de clonar as jails existentes.

   Pare e arquive uma jail chamada wwwserver:

 # ezjail-admin stop wwwserver
 Stopping jails: wwwserver.
 # ezjail-admin archive wwwserver
 # ls /usr/jails/ezjail-archives/
 wwwserver-201407271153.13.tar.gz

   Crie uma nova jail chamada wwwserver-clone do archive criado na etapa
   anterior. Use a interface em1 e atribua um novo enderec,o IP para evitar
   conflito com a original:

 # ezjail-admin create -a /usr/jails/ezjail_archives/wwwserver-201407271153.13.tar.gz wwwserver-clone 'lo1|127.0.3.1,em1|192.168.1.51'

  14.6.6. Exemplo Completo: BIND em uma Jail

   Colocar o servidor DNS BIND em uma jail melhora a seguranc,a ao isola-lo.
   Este exemplo cria um servidor de nomes de cache simples.

     * A jail sera chamada de dns1.

     * A jail usara o enderec,o IP 192.168.1.240 na interface re0 do host.

     * Os servidores DNS de upstream do ISP sao 10.0.0.62 e 10.0.0.61.

     * A basejail ja foi criada e uma arvore de ports instalada como mostrado
       em Sec,ao 14.6.2, "Configurac,ao inicial".

   Exemplo 14.3. Executando o BIND em uma Jail

   Crie uma interface de loopback clonada adicionando uma linha ao arquivo
   /etc/rc.conf:

 cloned_interfaces="lo1"

   Imediatamente crie a nova interface de loopback:

 # service netif cloneup
 Created clone interfaces: lo1.

   Crie a jail:

 # ezjail-admin create dns1 'lo1|127.0.2.1,re0|192.168.1.240'

   Inicie a jail, conecte-se a ao seu console e realize algumas
   configurac,oes basicas:

 # ezjail-admin start dns1
 # ezjail-admin console dns1
 # passwd
 Changing local password for root
 New Password:
 Retype New Password:
 # tzsetup
 # sed -i .bak -e '/adjkerntz/ s/^/#/' /etc/crontab
 # sed -i .bak -e 's/127.0.0.1/127.0.2.1/g; s/localhost.my.domain/dns1.my.domain dns1/' /etc/hosts

   Configure temporariamente os servidores upstream de DNS no arquivo
   /etc/resolv.conf para que os ports possam ser baixados:

 nameserver 10.0.0.62
 nameserver 10.0.0.61

   Ainda usando o console da jail, instale o dns/bind99.

 # make -C /usr/ports/dns/bind99 install clean

   Configure o servidor de nomes editando o arquivo
   /usr/local/etc/namedb/named.conf.

   Crie uma Access Control List (ACL) de enderec,os e redes que tem permissao
   para enviar consultas DNS para este servidor de nomes. Esta sec,ao e
   adicionada logo antes da sec,ao options no arquivo:

 ...
 // or cause huge amounts of useless Internet traffic.

 acl "trusted" {
         192.168.1.0/24;
         localhost;
         localnets;
 };

 options {
 ...

   Use o enderec,o IP da jail na configurac,ao listen-on para aceitar
   consultas DNS de outros computadores na rede:

         listen-on       { 192.168.1.240; };

   Um servidor DNS de nomes para cache simples e criado alterando a sec,ao
   forwarders. O arquivo original contem:

 /*
         forwarders {
                 127.0.0.1;
         };
 */

   Descomente a sec,ao removendo as linhas /* e */. Digite os enderec,os IP
   dos servidores DNS upstream. Logo apos a sec,ao forwarders, adicione
   referencias `a trusted ACL definida anteriormente:

         forwarders {
                 10.0.0.62;
                 10.0.0.61;
         };

         allow-query       { any; };
         allow-recursion   { trusted; };
         allow-query-cache { trusted; };

   Ative o servic,o no arquivo /etc/rc.conf:

 named_enable="YES"

   Inicie e teste o servidor de nomes:

 # service named start
 wrote key file "/usr/local/etc/namedb/rndc.key"
 Starting named.
 # /usr/local/bin/dig @192.168.1.240 freebsd.org

   Uma resposta que inclui

 ;; Got answer;

   mostra que o novo servidor DNS esta funcionando. Um longo delay seguido
   por uma resposta incluindo

 ;; connection timed out; no servers could be reached

   mostra um problema. Verifique as definic,oes de configurac,ao e
   certifique-se de que quaisquer firewalls locais permitam que o novo DNS
   acesse os servidores upstream de DNS.

   O novo servidor DNS pode usar pra resoluc,ao de nomes seu proprio
   servic,o, assim como outros computadores locais. Defina o enderec,o do
   servidor DNS no arquivo /etc/resolv.conf do computador-cliente:

 nameserver 192.168.1.240

   Um servidor DHCP local pode ser configurado para fornecer este enderec,o
   como servidor de DNS local, fornecendo configurac,ao automatica em
   clientes DHCP.

Capitulo 15. Controle de acesso obrigatorio

   Escrito por Tom Rhodes.
   Indice

   15.1. Sinopse

   15.2. Termos chave

   15.3. Entendendo os rotulos MAC

   15.4. Planejando a configurac,ao de seguranc,a

   15.5. Politicas MAC Disponiveis

   15.6. Bloqueio do Usuario

   15.7. Nagios em Jail MAC

   15.8. Soluc,ao de problemas do framework MAC

15.1. Sinopse

   O FreeBSD suporta extensoes de seguranc,a baseadas no projeto POSIX(R).1e.
   Esses mecanismos de seguranc,a incluem as Listas de Controle de Acesso do
   sistema de arquivos (Sec,ao 13.9, "Listas de Controle de Acesso") e o
   Controle de Acesso Obrigatorio, (Mandatory Access Control - MAC). O MAC
   permite que os modulos de controle de acesso sejam carregados para
   implementar politicas de seguranc,a. Alguns modulos fornecem protec,oes
   para um subconjunto restrito do sistema, fortalecendo um servic,o
   especifico. Outros fornecem seguranc,a rotulada abrangente em todos os
   assuntos e objetos. A parte obrigatoria da definic,ao indica que a
   imposic,ao de controles e executada pelos administradores e pelo sistema
   operacional. Isso esta em contraste com o mecanismo de seguranc,a padrao
   do Controle de Acesso Discricionario (Discretionary Access Control - DAC),
   onde a imposic,ao e deixada a criterio dos usuarios.

   Este capitulo enfoca o framework MAC e o conjunto de modulos de politica
   de seguranc,a plugaveis que o FreeBSD fornece para habilitar varios
   mecanismos de seguranc,a.

   Depois de ler este capitulo, voce sabera:

     * A terminologia associada ao framework MAC.

     * Os recursos dos modulos de politica de seguranc,a MAC, bem como a
       diferenc,a entre uma politica rotulada e nao rotulada.

     * As considerac,oes a se levar em conta antes de configurar um sistema
       para usar o framework MAC.

     * Quais modulos de politica de seguranc,a MAC estao incluidos no FreeBSD
       e como configura-los.

     * Como implementar um ambiente mais seguro usando o framework MAC.

     * Como testar a configurac,ao para garantir que o framework MAC foi
       implementado corretamente.

   Antes de ler este capitulo, voce deve:

     * Entender os fundamentos do UNIX(R) e do FreeBSD (Capitulo 3,
       Fundamentos do FreeBSD).

     * Ter alguma familiaridade com seguranc,a e como ela esta presente no
       FreeBSD (Capitulo 13, Seguranc,a).

  Atenc,ao:

   A configurac,ao incorreta do MAC pode causar perda de acesso ao sistema,
   agravamento de usuarios, ou incapacidade de acessar os recursos fornecidos
   pelo Xorg. Mais importante, o MAC nao deve ser usado para proteger
   completamente um sistema. O framework MAC apenas aumenta uma politica de
   seguranc,a existente. Sem praticas de seguranc,a solidas e verificac,oes
   regulares de seguranc,a, o sistema nunca estara completamente seguro.

   Os exemplos contidos neste capitulo sao para fins de demonstrac,ao e os
   exemplos de configurac,oes nao devem ser implementadas em um sistema de
   produc,ao. A implementac,ao de qualquer politica de seguranc,a requer um
   bom entendimento, design adequado e testes completos.

   Embora este capitulo abranja uma ampla gama de questoes de seguranc,a
   relacionadas `a estrututa MAC, o desenvolvimento de novos modulos de
   politicas de seguranc,a MAC nao serao abrangidos. Varios modulos de
   politica de seguranc,a incluidos com o framework MAC possuem
   caracteristicas especificas que sao fornecidas tanto para o teste quanto
   para o desenvolvimento de novos modulos. Consulte mac_test(4), mac_stub(4)
   e mac_none(4) para obter mais informac,oes sobre esses modulos de politica
   de seguranc,a e os diversos mecanismos que eles fornecem.

15.2. Termos chave

   Os seguintes termos chave sao usados ao se referir ao framework MAC:

     * compartment: um conjunto de programas e dados a serem particionados ou
       separados, onde os usuarios recebem acesso explicito ao componente
       especifico de um sistema. Um compartimento (compartment) representa um
       agrupamento, como um grupo de trabalho, departamento, projeto ou
       topico. Os compartimentos possibilitam a implementac,ao de uma
       politica de seguranc,a baseada na necessidade de conhecimento.

     * integrity: o nivel de confianc,a que pode ser colocado nos dados. Como
       a integridade (integrity) dos dados e elevada, tambem aumenta a
       capacidade de confiar nesses dados.

     * level: a configurac,ao aumentada ou diminuida de um atributo de
       seguranc,a. A medida que o nivel (level) aumenta, sua seguranc,a
       tambem e considerada alta.

     * label: um atributo de seguranc,a que pode ser aplicado a arquivos,
       diretorios ou outros itens no sistema. Pode ser considerado um selo de
       confidencialidade. Quando um rotulo (label) e colocado em um arquivo,
       ele descreve as propriedades de seguranc,a desse arquivo e so
       permitira acesso por arquivos, usuarios e recursos com uma
       configurac,ao de seguranc,a semelhante. O significado e a
       interpretac,ao dos valores do rotulo dependem da configurac,ao da
       politica. Algumas politicas tratam um rotulo como representando a
       integridade ou o sigilo de um objeto, enquanto outras politicas podem
       usar rotulos para manter regras de acesso.

     * multilabel: esta propriedade e uma opc,ao de sistema de arquivos que
       pode ser configurada no modo usuario unico (single-user) usando o
       tunefs(8), durante a inicializac,ao usando o fstab(5), ou durante a
       criac,ao de um novo sistema de arquivos. Essa opc,ao permite que um
       administrador aplique rotulos MAC diferentes em objetos diferentes.
       Essa opc,ao aplica-se somente aos modulos de politica de seguranc,a
       que suportam rotulagem.

     * single label: uma politica em que o sistema de arquivos inteiro usa um
       rotulo para impor o controle de acesso sobre o fluxo de dados. Sempre
       que multilabel nao estiver definido, todos os arquivos estarao em
       conformidade com a mesma configurac,ao de rotulo.

     * object: uma entidade atraves da qual a informac,ao flui sob a direc,ao
       de um sujeito. Isso inclui diretorios, arquivos, campos, telas,
       teclados, memoria, armazenamento magnetico, impressoras ou qualquer
       outro dispositivo de armazenamento ou movimentac,ao de dados. Um
       objeto (object) e um conteiner de dados ou um recurso do sistema. O
       acesso a um objeto significa efetivamente acesso aos seus dados.

     * subject: qualquer entidade ativa que faz com que as informac,oes fluam
       entre objetos, como um usuario, processo do usuario ou processo do
       sistema. No FreeBSD, isso e quase sempre um segmento agindo em um
       processo em nome de um usuario.

     * policy: uma colec,ao de regras que define como os objetivos devem ser
       alcanc,ados. Uma politica (policy) geralmente documenta como
       determinados itens devem ser manipulados. Este capitulo considera uma
       politica como uma colec,ao de regras que controla o fluxo de dados e
       informac,oes e define quem tem acesso a esses dados e informac,oes.

     * high-watermark: esse tipo de politica permite o aumento dos niveis de
       seguranc,a com o objetivo de acessar informac,oes de nivel superior.
       Na maioria dos casos, o nivel original e restaurado depois que o
       processo e concluido. Atualmente, o framework MAC do FreeBSD nao
       inclui este tipo de politica.

     * low-watermark: esse tipo de politica permite reduzir os niveis de
       seguranc,a com o objetivo de acessar informac,oes menos seguras. Na
       maioria dos casos, o nivel de seguranc,a original do usuario e
       restaurado apos a conclusao do processo. O unico modulo de politica de
       seguranc,a no FreeBSD para usar isto e o mac_lomac(4).

     * sensitivity: normalmente usado quando se discute Seguranc,a Multinivel
       (Multilevel Security - MLS). Um nivel de sensibilidade (sensitivity)
       descreve o quao importante ou secreto os dados devem ser. A medida que
       o nivel de sensibilidade aumenta, tambem aumenta a importancia do
       sigilo ou confidencialidade dos dados.

15.3. Entendendo os rotulos MAC

   Um rotulo MAC e um atributo de seguranc,a que pode ser aplicado a sujeitos
   e objetos em todo o sistema. Ao definir um rotulo, o administrador deve
   entender suas implicac,oes para evitar o comportamento inesperado ou
   indesejado do sistema. Os atributos disponiveis em um objeto dependem do
   modulo de politica carregado, pois os modulos de politica interpretam seus
   atributos de maneiras diferentes.

   O rotulo de seguranc,a em um objeto e usado como parte de uma decisao de
   controle de acesso de seguranc,a por uma politica. Com algumas politicas,
   o rotulo contem todas as informac,oes necessarias para tomar uma decisao.
   Em outras politicas, os rotulos podem ser processados como parte de um
   conjunto de regras maior.

   Existem dois tipos de politicas de rotulos: rotulo unico e rotulo
   multiplo. Por padrao, o sistema usara rotulo unico. O administrador deve
   estar ciente dos pros e contras de cada um para implementar politicas que
   atendam aos requisitos do modelo de seguranc,a do sistema.

   Uma diretiva de seguranc,a de rotulo unico permite que apenas um rotulo
   seja usado para cada sujeito ou objeto. Como uma politica de rotulo unico
   impoe um conjunto de permissoes de acesso em todo o sistema, ela fornece
   menor sobrecarga de administrac,ao, mas diminui a flexibilidade das
   politicas que suportam rotulagem. No entanto, em muitos ambientes, uma
   unica diretiva de rotulo pode ser tudo o que e necessario.

   Uma diretiva de seguranc,a de rotulo unico e um pouco semelhante ao DAC
   pois o root configura as politicas para que os usuarios sejam colocados
   nas categorias e niveis de acesso apropriados. Uma diferenc,a notavel e
   que muitos modulos de politica tambem podem restringir o root. O controle
   basico sobre os objetos sera entao liberado para o grupo, mas o root
   podera revogar ou modificar as configurac,oes a qualquer momento.

   Quando apropriado, uma politica de rotulos multiplos pode ser configurada
   em um sistema de arquivos UFS passando multilabel para o tunefs(8). Uma
   politica de rotulos multiplos permite que cada sujeito ou objeto tenha seu
   proprio rotulo MAC independente. A decisao de usar uma politica de rotulos
   multiplos ou rotulo unico e necessaria apenas para politicas que
   implementam o recurso de rotulagem, como biba, lomac e mls. Algumas
   politicas, como seeotheruids, portacl e partition, nao usam rotulos.

   Usar uma politica de rotulos multiplos em uma partic,ao e estabelecer um
   modelo de seguranc,a de rotulos multiplos pode aumentar a sobrecarga
   administrativa, ja que tudo nesse sistema de arquivos tem um rotulo. Isso
   inclui diretorios, arquivos e ate mesmo nos de dispositivos.

   O comando a seguir definira a flag multilabel no sistema de arquivos UFS
   especificado . Isso so pode ser feito no modo de usuario unico e nao e um
   requisito para o sistema de arquivos de swap:

 # tunefs -l enable /

  Nota:

   Alguns usuarios tiveram problemas com a configurac,ao de flag multilabel
   na partic,ao raiz. Se este for o caso, por favor consulte Sec,ao 15.8,
   "Soluc,ao de problemas do framework MAC".

   Como a politica de rotulos multiplos e definida por sistema de arquivos,
   ela pode nao ser necessaria se o layout do sistema de arquivos for bem
   projetado. Considere um exemplo de modelo de seguranc,a MAC para um
   servidor Web do FreeBSD. Esta maquina usa o rotulo unico, biba/high, para
   tudo nos sistemas de arquivos padrao. Se o servidor Web precisar ser
   executado em biba/low para evitar recursos de gravac,ao, ele podera ser
   instalado em um sistema de arquivos UFS separado, /usr/local, definido com
   biba/low.

  15.3.1. Configurac,ao de rotulo

   Praticamente todos os aspectos da configurac,ao do modulo de politica de
   rotulo serao executados usando os utilitarios do sistema base. Esses
   comandos fornecem uma interface simples para a configurac,ao de objeto ou
   sujeito ou a manipulac,ao e verificac,ao da configurac,ao.

   Toda a configurac,ao pode ser feita usando setfmac, que e usado para
   definir rotulos MAC em objetos do sistema, e setpmac, que e usado para
   definir os rotulos em sujeitos do sistema. Por exemplo, para definir o
   rotulo MAC biba como high em test:

 # setfmac biba/high test

   Se a configurac,ao for bem sucedida, o prompt sera retornado sem erro. Um
   erro comum e Permission denied, que geralmente ocorre quando o rotulo esta
   sendo definido ou modificado em um objeto restrito. Outras condic,oes
   podem produzir falhas diferentes. Por exemplo, o arquivo pode nao ser de
   propriedade do usuario que esta tentando re-rotular o objeto, o objeto
   pode nao existir ou o objeto pode ser somente de leitura. Uma politica
   obrigatoria nao permitira que o processo renomeie o arquivo, talvez devido
   a uma propriedade do arquivo, uma propriedade do processo ou uma
   propriedade do novo valor de rotulo proposto. Por exemplo, se um usuario
   que estiver executando com baixa integridade tentar alterar o rotulo de um
   arquivo de alta integridade, ou um usuario executando com baixa
   integridade tentar alterar o rotulo de um arquivo de baixa integridade
   para um rotulo de alta integridade, essas operac,oes falharao.

   O administrador do sistema pode usar setpmac para substituir as
   configurac,oes do modulo de politica, atribuindo um rotulo diferente a
   chamada do processo:

 # setfmac biba/high test
 Permission denied
 # setpmac biba/low setfmac biba/high test
 # getfmac test
 test: biba/high

   Para processos atualmente em execuc,ao, como o sendmail, o getpmac e
   normalmente usado. Esse comando usa uma ID de processo (PID) no lugar de
   um nome de comando. Se os usuarios tentarem manipular um arquivo que nao
   esteja em seu acesso, sujeito `as regras dos modulos de politica
   carregados, o erro Operation not permitted sera exibido.

  15.3.2. Rotulos pre-definidos

   Alguns modulos de politica do FreeBSD que suportam o recurso de rotulagem
   oferecem tres rotulos predefinidos: low, equal e high, onde:

     * low e considerada a configurac,ao de rotulo mais baixa que um objeto
       ou assunto pode ter. Definir isso em sujeitos ou objetos bloqueia o
       acesso a objetos ou sujeitos marcados como alto (high).

     * equal define o sujeito ou objeto a ser desabilitado ou nao afetado e
       deve ser colocado apenas em objetos considerados como isentos da
       politica.

     * high concede a um objeto ou sujeito a configurac,ao mais alta
       disponivel nos modulos de politica Biba e MLS.

   Esses modulos de politica incluem mac_biba(4), mac_mls(4) e mac_lomac(4).
   Cada um dos rotulos predefinidos estabelece uma diretiva de fluxo de
   informac,oes diferentes. Consulte a pagina de manual do modulo para
   determinar as caracteristicas das configurac,oes genericas de rotulos.

  15.3.3. Rotulos numericos

   Os modulos de politicas Biba e MLS suportam um rotulo numerico que pode
   ser configurado para indicar o nivel exato de controle hierarquico. Esse
   nivel numerico e usado para particionar ou classificar informac,oes em
   diferentes grupos de classificac,ao, permitindo apenas o acesso a esse
   grupo ou a um nivel de grupo mais alto. Por exemplo:

 biba/10:2+3+6(5:2+3-20:2+3+4+5+6)

   pode ser interpretado como "Rotulo de Politica Biba/Grau 10:Compartimentos
   2, 3 e 6: (grau 5 ...")

   Neste exemplo, o primeiro grau seria considerado o grau efetivo com
   compartimentos efetivos, o segundo grau e o grau baixo e o ultimo e o grau
   alto. Na maioria das configurac,oes, essas definic,oes refinadas nao sao
   necessarias, pois sao consideradas configurac,oes avanc,adas.

   Objetos do sistema possuem apenas um grau e compartimento atuais. Os
   sujeitos do sistema refletem o intervalo de direitos disponiveis no
   sistema e as interfaces de rede, onde sao usados para controle de acesso.

   O grau e os compartimentos em um par de sujeito e objeto sao usados para
   construir um relacionamento conhecido como dominance, em que um sujeito
   domina um objeto, o objeto domina o sujeito, nenhum domina o outro, ou
   ambos dominam cada um. O caso em que "ambos dominam" ocorre quando dois
   rotulos sao iguais. Devido `a natureza do fluxo de informac,oes do Biba,
   um usuario tem direitos sobre um conjunto de compartimentos que podem
   corresponder aos projetos, mas os objetos tambem tem um conjunto de
   compartimentos. Os usuarios podem ter que subconjuntar seus direitos
   usando su ou setpmac para acessar objetos em um compartimento a partir do
   qual eles nao estao restritos.

  15.3.4. Rotulos de usuarios

   Os usuarios precisam ter rotulos para que seus arquivos e processos
   interajam adequadamente com a politica de seguranc,a definida no sistema.
   Isso e configurado no /etc/login.conf usando classes de login. Todo modulo
   de politica que usa rotulos implementara a configurac,ao da classe de
   usuario.

   Para definir o rotulo padrao da classe de usuario que sera imposto pelo
   MAC, adicione uma entrada label. Um exemplo de entrada label contendo
   todos os modulos de politica e exibida abaixo. Observe que, em uma
   configurac,ao real, o administrador nunca habilitaria todos os modulos de
   politica. Recomenda-se que o restante deste capitulo seja revisado antes
   que qualquer configurac,ao seja implementada.

 default:\
         :copyright=/etc/COPYRIGHT:\
         :welcome=/etc/motd:\
         :setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
         :path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:\
         :manpath=/usr/share/man /usr/local/man:\
         :nologin=/usr/sbin/nologin:\
         :cputime=1h30m:\
         :datasize=8M:\
         :vmemoryuse=100M:\
         :stacksize=2M:\
         :memorylocked=4M:\
         :memoryuse=8M:\
         :filesize=8M:\
         :coredumpsize=8M:\
         :openfiles=24:\
         :maxproc=32:\
         :priority=0:\
         :requirehome:\
         :passwordtime=91d:\
         :umask=022:\
         :ignoretime@:\
         :label=partition/13,mls/5,biba/10(5-15),lomac/10[2]:

   Embora os usuarios nao possam modificar o valor padrao, eles podem alterar
   seu rotulo apos o login, sujeito `as restric,oes da politica. O exemplo
   acima diz `a politica do Biba que a integridade minima de um processo e 5,
   seu maximo e 15 e o rotulo efetivo padrao e 10. O processo sera executado
   em 10 ate que ele escolha alterar o rotulo, talvez devido ao usuario usar
   setpmac, que sera restringido pelo Biba ao intervalo configurado.

   Apos qualquer alterac,ao no login.conf, o banco de dados de recursos da
   classe de login deve ser reconstruido usando o cap_mkdb.

   Muitos sites tem um grande numero de usuarios que exigem varias classes de
   usuario diferentes. Um planejamento detalhado e necessario, pois isso pode
   dificultar o gerenciamento.

  15.3.5. Rotulos de interface de rede

   Os rotulos podem ser definidos em interfaces de rede para ajudar a
   controlar o fluxo de dados atraves da rede. Politicas que usam rotulos de
   interface de rede funcionam da mesma maneira que as politicas funcionam em
   relac,ao aos objetos. Usuarios com configurac,oes altas no Biba, por
   exemplo, nao terao permissao para acessar interfaces de rede com um rotulo
   low.

   Ao definir o rotulo MAC em interfaces de rede, maclabel pode ser passado
   para o ifconfig:

 # ifconfig bge0 maclabel biba/equal

   Este exemplo ira definir o rotulo MAC de biba/equal na interface bge0. Ao
   usar uma configurac,ao semelhante a biba/high(low-high), o rotulo inteiro
   deve ser citado para evitar que um erro seja retornado.

   Cada modulo de politica que suporta rotulagem tem um ajuste que pode ser
   usado para desativar o rotulo MAC em interfaces de rede. Configurar o
   rotulo para equal tera um efeito semelhante. Reveja a saida do sysctl, as
   paginas do manual de politicas e as informac,oes no restante deste
   capitulo para obter mais informac,oes sobre esses ajustes.

15.4. Planejando a configurac,ao de seguranc,a

   Antes de implementar qualquer politica de MAC, recomenda-se uma fase de
   planejamento. Durante as etapas de planejamento, um administrador deve
   considerar os requisitos e metas de implementac,ao, como:

     * Como classificar informac,oes e recursos disponiveis nos sistemas de
       destino.

     * Quais informac,oes ou recursos para restringir o acesso, juntamente
       com o tipo de restric,oes que devem ser aplicadas.

     * Quais modulos MAC serao necessarios para atingir esse objetivo.

   Um teste de sistema confiavel e sua configurac,ao deve ocorrer antes de
   uma implementac,ao MAC ser usada em sistemas de produc,ao. Como diferentes
   ambientes tem diferentes necessidades e requisitos, estabelecer um perfil
   de seguranc,a completo diminuira a necessidade de alterac,oes quando o
   sistema entrar em operac,ao.

   Considere como o framework MAC aumenta a seguranc,a do sistema como um
   todo. Os varios modulos de politica de seguranc,a fornecidos pelo
   framework MAC podem ser usados para proteger a rede e os sistemas de
   arquivos ou para impedir que usuarios acessem determinadas portas e
   soquetes. Talvez o melhor uso dos modulos de politica seja carregar varios
   modulos de politica de seguranc,a por vez para fornecer um ambiente MLS.
   Essa abordagem difere de uma politica rigida, que tipicamente endurece
   elementos de um sistema que sao usados apenas para propositos especificos.
   A desvantagem de MLS e o aumento da sobrecarga administrativa.

   A sobrecarga e minima quando comparada ao efeito duradouro de uma
   estrutura que fornece a capacidade de escolher quais politicas sao
   necessarias para uma configurac,ao especifica e que reduzem a sobrecarga
   de desempenho. A reduc,ao do suporte a politicas desnecessarias pode
   aumentar o desempenho geral do sistema, alem de oferecer flexibilidade de
   escolha. Uma boa implementac,ao consideraria os requisitos gerais de
   seguranc,a e implementaria efetivamente os varios modulos de politica de
   seguranc,a oferecidos pelo framework.

   Um sistema que utiliza MAC garante que um usuario nao tera permissao para
   alterar atributos de seguranc,a `a vontade. Todos os utilitarios,
   programas e scripts de usuario devem funcionar dentro das restric,oes das
   regras de acesso fornecidas pelos modulos de politica de seguranc,a
   selecionados e o controle das regras de acesso do MAC esta nas maos do
   administrador do sistema.

   E dever do administrador do sistema selecionar cuidadosamente os modulos
   de politica de seguranc,a corretos. Para um ambiente que precisa limitar o
   controle de acesso na rede, o mac_portacl(4), mac_ifoff(4), e os modulos
   de politicas mac_biba(4) sao bons pontos de partida. Para um ambiente em
   que a confidencialidade rigorosa dos objetos do sistema de arquivos e
   necessaria, considere mac_bsdextended(4) e os modulos de politica
   mac_mls(4).

   Decisoes de politicas podem ser tomadas com base na configurac,ao da rede.
   Se apenas determinados usuarios tiverem permissao para acessar o ssh(1), o
   modulo de politica mac_portacl(4) e uma boa escolha. No caso de sistemas
   de arquivos, o acesso a objetos pode ser considerado confidencial para
   alguns usuarios, mas nao para outros. Como um exemplo, uma grande equipe
   de desenvolvimento pode ser dividida em projetos menores, onde os
   desenvolvedores do projeto A podem nao ter permissao para acessar objetos
   escritos por desenvolvedores do projeto B. No entanto, ambos os projetos
   podem precisar acessar objetos criados por desenvolvedores do projeto C.
   Usando os diferentes modulos de politica de seguranc,a fornecidos pelo
   framework MAC, os usuarios poderiam ser divididos nesses grupos e entao
   receber acesso aos objetos apropriados.

   Cada modulo de politica de seguranc,a tem uma maneira exclusiva de lidar
   com a seguranc,a geral de um sistema. A selec,ao de modulos deve se basear
   em uma politica de seguranc,a bem pensada, que pode exigir revisao e
   reimplementac,ao. Entender os diferentes modulos da politica de seguranc,a
   oferecidos pelo framework MAC ajudara os administradores a escolher as
   melhores politicas para suas situac,oes.

   O restante deste capitulo aborda os modulos disponiveis, descreve seu uso
   e configurac,ao e, em alguns casos, fornece informac,oes sobre as
   situac,oes aplicaveis.

  Cuidado:

   A implementac,ao do MAC e muito parecida com a implementac,ao de um
   firewall, ja que e preciso tomar cuidado para evitar que o sistema seja
   completamente bloqueado. A capacidade de reverter para uma configurac,ao
   anterior deve ser considerada e a implementac,ao do MAC em uma conexao
   remota deve ser feita com extrema cautela.

15.5. Politicas MAC Disponiveis

   O kernel padrao do FreeBSD inclui a diretiva options MAC. Isso significa
   que todos os modulos incluidos no framework MAC podem ser carregados com o
   comando kldload como um modulo do kernel em tempo de execuc,ao. Depois de
   testar o modulo, adicione o nome do modulo ao arquivo /boot/loader.conf
   para que ele seja carregado durante a inicializac,ao. Cada modulo tambem
   fornece uma opc,ao de kernel para os administradores que escolhem compilar
   seu proprio kernel personalizado.

   O FreeBSD inclui um grupo de politicas que cobrira a maioria dos
   requisitos de seguranc,a. Cada politica e resumida abaixo. As tres ultimas
   politicas suportam configurac,oes inteiras no lugar dos tres rotulos
   padrao.

  15.5.1. O MAC ve a Politica de Outros UIDs

   Nome do modulo: mac_seeotheruids.ko

   Linha de configurac,ao do kernel: options MAC_SEEOTHERUIDS

   Opc,ao de inicializac,ao: mac_seeotheruids_load="YES"

   O modulo mac_seeotheruids(4) amplia os ajustes security.bsd.see_other_uids
   e security.bsd.see_other_gids do sysctl. Esta opc,ao nao requer que nenhum
   rotulo seja definido antes da configurac,ao e pode operar de forma
   transparente com outros modulos.

   Depois de carregar o modulo, os seguintes ajustes sysctl podem ser usados
   para controlar seus recursos:

     * O security.mac.seeotheruids.enabled ativa o modulo e implementa as
       configurac,oes padroes que impedem que os usuarios visualizem
       processos e soquetes pertencentes a outros usuarios.

     * security.mac.seeotheruids.specificgid_enabled permite que grupos
       especificados sejam isentos desta politica. Para isentar grupos
       especificos, use a variavel security.mac.seeotheruids.specificgid=XXX
       do sysctl, substituindo XXX pelo ID numerico do grupo a ser isento.

     * security.mac.seeotheruids.primarygroup_enabled e usado para isentar
       grupos primarios especificos desta politica. Ao usar este ajuste, o
       security.mac.seeotheruids.specificgid_enabled nao pode estar definido.

  15.5.2. A Politica Estendida do BSD MAC

   Nome do modulo: mac_bsdextended.ko

   Linha de configurac,ao do kernel: options MAC_BSDEXTENDED

   Opc,ao de inicializac,ao: mac_bsdextended_load="YES"

   O modulo mac_bsdextended(4) aplica um firewall no sistema de arquivos. Ele
   fornece uma extensao para o modelo de permissoes do sistema de arquivos
   padrao, permitindo que um administrador crie um conjunto de regras
   semelhante a um firewall para proteger arquivos, utilitarios e diretorios
   na hierarquia do sistema de arquivos. Quando se tenta acessar um objeto do
   sistema de arquivos, a lista de regras e iterada ate que uma regra
   correspondente seja localizada ou o final seja atingido. Esse
   comportamento pode ser alterado usando
   security.mac.bsdextended.firstmatch_enabled. Semelhante a outros modulos
   de firewall no FreeBSD, um arquivo contendo as regras de controle de
   acesso pode ser criado e lido pelo sistema no momento da inicializac,ao
   usando uma variavel do rc.conf(5).

   A lista de regras pode ser inserida usando o ugidfw(8) que possui uma
   sintaxe similar ao ipfw(8). Mais ferramentas podem ser escritas usando as
   func,oes da biblioteca libugidfw(3).

   Depois que o modulo mac_bsdextended(4) tiver sido carregado, o seguinte
   comando podera ser usado para listar a configurac,ao atual da regra:

 # ugidfw list
 0 slots, 0 rules

   Por padrao, nenhuma regra e definida e tudo esta completamente acessivel.
   Para criar uma regra que bloqueia todo o acesso dos usuarios, mas que nao
   afeta o root :

 # ugidfw add subject not uid root new object not uid root mode n

   Embora essa regra seja simples de implementar, e uma ideia muito ruim,
   pois impede que todos os usuarios emitam comandos. Um exemplo mais
   realista bloqueia todo o acesso do user1, incluindo listagens de
   diretorios, ao diretorio inicial do usuario user2 :

 # ugidfw set 2 subject uid user1 object uid user2 mode n
 # ugidfw set 3 subject uid user1 object gid user2 mode n

   Em vez de user1, not uiduser2 poderia ser usado para impor as mesmas
   restric,oes de acesso para todos os usuarios. No entanto, o usuario root
   nao e afetado por essas regras.

  Nota:

   Deve-se ter extremo cuidado ao trabalhar com este modulo, pois o uso
   incorreto pode bloquear o acesso a certas partes do sistema de arquivos.

  15.5.3. A politica de silenciamento da interface MAC

   Nome do modulo: mac_ifoff.ko

   Linha de configurac,ao do kernel: options MAC_IFOFF

   Opc,ao de inicializac,ao: mac_ifoff_load="YES"

   O modulo mac_ifoff(4) e usado para desabilitar as interfaces de rede e
   evitar que as interfaces de rede sejam ativadas durante a inicializac,ao
   do sistema. Ele nao usa rotulos e nao depende de nenhum outro modulo MAC.

   A maior parte do controle deste modulo e realizada atraves destes ajustes
   sysctl:

     * security.mac.ifoff.lo_enabled ativa ou desativa todo o trafego na
       interface de loopback, lo(4).

     * security.mac.ifoff.bpfrecv_enabled ativa ou desativa todo o trafego na
       interface do Filtro de Pacotes Berkeley, bpf(4).

     * security.mac.ifoff.other_enabled ativa ou desativa o trafego em todas
       as outras interfaces.

   Um dos usos mais comuns do mac_ifoff(4) e o monitoramento de rede em um
   ambiente onde o trafego de rede nao deve ser permitido durante a sequencia
   de inicializac,ao. Outro uso seria escrever um script que usa um
   aplicativo como o security/aide para bloquear automaticamente o trafego da
   rede se encontrar arquivos novos ou alterados em diretorios protegidos.

  15.5.4. A politica de lista de controle de acesso da porta MAC

   Nome do modulo: mac_portacl.ko

   Linha de configurac,ao do kernel: MAC_PORTACL

   Opc,ao de inicializac,ao: mac_portacl_load="YES"

   O modulo mac_portacl (4) e usado para limitar a ligac,ao a portas TCP e
   UDP locais , tornando possivel permitir que usuarios non-root sejam
   vinculados a portas privilegiadas especificadas abaixo de 1024.

   Uma vez carregado, este modulo habilita a politica MAC em todos os
   sockets. Os seguintes ajustes estao disponiveis:

     * security.mac.portacl.enabled ativa ou desativa a politica
       completamente.

     * A security.mac.portacl.port_high configura o numero de porta mais alto
       que o mac_portacl(4) protege.

     * A security.mac.portacl.suser_exempt, quando configurada para um valor
       diferente de zero, isenta o usuario root desta politica.

     * A security.mac.portacl.rules especifica a politica como uma cadeia de
       texto no formato rule [, rule, ...], com tantas regras quantas forem
       necessarias, e onde cada regra esta na forma idtype:id:protocol:port.
       O idtype e uid ou gid. O parametro protocol pode ser tcp ou udp. O
       parametro port e o numero da porta para permitir que o usuario ou
       grupo especificado se vincule. Somente valores numericos podem ser
       usados para os parametros ID do usuario, ID do grupo e porta.

   Por padrao, as portas abaixo de 1024 so podem ser usadas por processos
   privilegiados que sao executados como root. Para que o mac_portacl(4)
   permita que processos nao privilegiados se vinculem a portas abaixo de
   1024, defina os seguintes ajustes da seguinte forma:

 # sysctl security.mac.portacl.port_high=1023
 # sysctl net.inet.ip.portrange.reservedlow=0
 # sysctl net.inet.ip.portrange.reservedhigh=0

   Para evitar que o usuario root seja afetado por esta politica, configure
   security.mac.portacl.suser_exempt para um valor diferente de zero.

 # sysctl security.mac.portacl.suser_exempt=1

   Para permitir que o usuario www com UID 80 seja vinculado `a porta 80 sem
   precisar do privilegio root:

 # sysctl security.mac.portacl.rules=uid:80:tcp:80

   Este proximo exemplo permite que o usuario com o UID de 1001 se vincule
   `as portas TCP 110 (POP3) e 995 (POP3):

 # sysctl security.mac.portacl.rules=uid:1001:tcp:110,uid:1001:tcp:995

  15.5.5. A Politica de Partic,ao MAC

   Nome do modulo: mac_partition.ko

   Linha de configurac,ao do kernel: options MAC_PARTITION

   Opc,ao de inicializac,ao: mac_partition_load="YES"

   A politica mac_partition(4) coloca os processos em "partic,oes"
   especificas com base no rotulo MAC. A maioria das configurac,oes para esta
   politica e feita usando setpmac(8). Uma vari[avek sysctl esta disponivel
   para esta politica:

     * A security.mac.partition.enabled permite a aplicac,ao de partic,oes de
       processo MAC.

   Quando essa politica esta ativada, os usuarios so poderao ver seus
   processos e quaisquer outros em sua partic,ao, mas nao terao permissao
   para trabalhar com utilitarios fora do escopo dessa partic,ao. Por
   exemplo, um usuario na classe insecure nao tera permissao para acessar
   top, bem como muitos outros comandos que devem fazer spawn de um processo.

   Este exemplo adiciona o top ao conjunto de rotulos dos usuarios na classe
   insecure. Todos os processos gerados por usuarios na classe insecure
   permanecerao no rotulo partition/13.

 # setpmac partition/13 top

   Este comando exibe o rotulo da partic,ao e a lista de processos:

 # ps Zax

   Esse comando exibe o rotulo da partic,ao de processo de outro usuario e os
   processos atualmente em execuc,ao desse usuario:

 # ps -ZU trhodes

  Nota:

   Os usuarios podem ver processos no rotulo root, a menos que a politica
   mac_seeotheruids(4) esteja carregada.

  15.5.6. O modulo de seguranc,a multinivel MAC

   Nome do modulo: mac_mls.ko

   Linha de configurac,ao do kernel: options MAC_MLS

   Opc,ao de inicializac,ao: mac_mls_load="YES"

   A politica mac_mls(4) controla o acesso entre sujeitos e objetos no
   sistema, aplicando uma diretiva de fluxo de informac,oes restrita.

   Em ambientes MLS, um nivel de "clearance" e definido no rotulo de cada
   sujeito ou objeto, juntamente com os compartimentos. Como esses niveis de
   liberac,ao podem atingir numeros maiores que varios milhares, seria uma
   tarefa dificil configurar completamente cada sujeito ou objeto. Para
   facilitar essa sobrecarga administrativa, tres rotulos sao incluidos nesta
   politica: mls/low, mls/equal e mls/high, onde:

     * Qualquer coisa rotulada com mls/low tera um nivel de folga baixo e nao
       sera permitido acessar informac,oes de um nivel superior. Esse rotulo
       tambem evita que objetos de nivel de liberac,ao mais alto gravem ou
       transmitam informac,oes para um nivel inferior.

     * mls/equal deve ser colocado em objetos que devem ser isentos da
       politica.

     * mls/high e o nivel mais alto de permissao possivel. Objetos atribuidos
       a esse rotulo terao dominio sobre todos os outros objetos no sistema;
       no entanto, eles nao permitirao o vazamento de informac,oes para
       objetos de classe baixa.

   O MLS fornece:

     * Um nivel de seguranc,a hierarquico com um conjunto de categorias nao
       hierarquicas.

     * Regras fixas de no read up, no write down. Isso significa que um
       sujeito pode ter acesso de leitura a objetos em seu proprio nivel ou
       abaixo, mas nao acima. Da mesma forma, um sujeito pode ter acesso de
       gravac,ao a objetos em seu proprio nivel ou acima, mas nao abaixo
       dele.

     * Sigilo, ou a prevenc,ao de divulgac,ao inadequada de dados.

     * Uma base para o projeto de sistemas que lidam simultaneamente com
       dados em multiplos niveis de sensibilidade sem vazar informac,oes
       entre secretas e confidenciais.

   Os seguintes ajustes sysctl estao disponiveis:

     * security.mac.mls.enabled e usado para habilitar ou desabilitar a
       politica MLS.

     * security.mac.mls.ptys_equal todos os dispositivos pty(4) como
       mls/equal durante a criac,ao.

     * security.mac.mls.revocation_enabled revoga o acesso a objetos depois
       que seu rotulo e alterado para um rotulo de nivel inferior.

     * security.mac.mls.max_compartments define o numero maximo de niveis de
       compartimentos permitidos em um sistema.

   Para manipular os rotulos MLS, use setfmac(8). Para atribuir um rotulo a
   um objeto:

 # setfmac mls/5 test

   Para obter o rotulo MLS para o arquivo test:

 # getfmac test

   Outra abordagem e criar um arquivo de politica mestre em /etc/, que
   especifica as informac,oes de politica de MLS e alimentar o setfmac com
   esse arquivo.

   Ao usar o modulo de politica do MLS, um administrador planeja controlar o
   fluxo de informac,oes confidenciais. O padrao block read up block write
   down define tudo para um estado baixo. Tudo e acessivel e um administrador
   aumenta lentamente a confidencialidade das informac,oes.

   Alem das tres opc,oes basicas de rotulo, um administrador pode agrupar
   usuarios e grupos conforme necessario para bloquear o fluxo de
   informac,oes entre eles. Pode ser mais facil olhar as informac,oes em
   niveis de clearance usando palavras descritivas, como classificac,oes de
   Confidential, Secret e Top Secret. Alguns administradores criam grupos
   diferentes com base nos niveis do projeto. Independentemente do metodo de
   classificac,ao, um plano bem pensado deve existir antes de implementar uma
   politica restritiva.

   Alguns exemplos de situac,oes para o modulo de politica MLS incluem um
   servidor Web de e-commerce, um servidor de arquivos com informac,oes
   criticas sobre a empresa e ambientes de instituic,oes financeiras.

  15.5.7. O Modulo MAC Biba

   Nome do modulo: mac_biba.ko

   Linha de configurac,ao do kernel: options MAC_BIBA

   Opc,ao de inicializac,ao: mac_biba_load="YES"

   O modulo mac_biba(4) carrega a politica MAC Biba. Essa politica e
   semelhante `a politica MLS, com a excec,ao de que as regras para o fluxo
   de informac,oes sao levemente revertidas. Isso evita o fluxo descendente
   de informac,oes confidenciais, enquanto a politica MLS impede o fluxo
   ascendente de informac,oes confidenciais.

   Nos ambientes do Biba, um rotulo "integrity" e definido em cada sujeito ou
   objeto. Esses rotulos sao compostos de classes hierarquicas e componentes
   nao hierarquicos. Como um grau ascende, o mesmo acontece com a sua
   integridade.

   Rotulos suportados sao biba/low, biba/equal e biba/high, onde:

     * biba/low e considerado a integridade mais baixa que um sujeito ou
       objeto pode ter. Definir isso em sujeitos ou objetos bloqueia o acesso
       de gravac,ao a objetos ou sujeitos marcados como biba/high, mas nao
       impede o acesso de leitura.

     * biba/equal so deve ser colocado em objetos considerados como isentos
       da politica.

     * biba/high permite gravar objetos em um rotulo inferior, mas nao
       permite a leitura desse objeto. Recomenda-se que esse rotulo seja
       colocado em objetos que afetam a integridade de todo o sistema.

   O Biba fornece:

     * Niveis de integridade hierarquica com um conjunto de categorias de
       integridade nao hierarquicas.

     * As regras fixas sao no write up, no read down, o oposto do MLS. Um
       sujeito pode ter acesso de gravac,ao a objetos em seu proprio nivel ou
       abaixo, mas nao acima. Da mesma forma, um sujeito pode ter acesso de
       leitura a objetos em seu proprio nivel ou acima, mas nao abaixo.

     * Integridade, impedindo a modificac,ao inadequada de dados.

     * Niveis de integridade em vez dos niveis de sensibilidade do MLS.

   Os seguintes ajustes podem ser usados para manipular a politica Biba:

     * security.mac.biba.enabled e usado para ativar ou desativar a
       imposic,ao da politica Biba na maquina de destino.

     * O security.mac.biba.ptys_equal e usado para desabilitar a politica
       Biba em dispositivos pty(4).

     * security.mac.biba.revocation_enabled forc,a a revogac,ao do acesso a
       objetos se o rotulo for alterado para dominar o sujeito.

   Para acessar a configurac,ao de politica Biba em objetos do sistema, use
   setfmac e getfmac:

 # setfmac biba/low test
 # getfmac test
 test: biba/low

   Integridade, que e diferente de sensibilidade, e usada para garantir que a
   informac,ao nao seja manipulada por partes nao confiaveis. Isso inclui
   informac,oes passadas entre sujeitos e objetos. Ele garante que os
   usuarios so poderao modificar ou acessar as informac,oes para as quais
   receberam acesso explicito. O modulo de politica de seguranc,a mac_biba(4)
   permite que um administrador configure quais arquivos e programas um
   usuario pode ver e invocar enquanto assegura que os programas e arquivos
   sejam confiaveis pelo sistema para esse usuario.

   Durante a fase de planejamento inicial, um administrador deve estar
   preparado para particionar os usuarios em graus, niveis e areas. O sistema
   tera como padrao um rotulo alto assim que esse modulo de politica for
   ativado e cabe ao administrador configurar as diferentes classificac,oes e
   niveis para os usuarios. Em vez de usar niveis de liberac,ao, um bom
   metodo de planejamento pode incluir topicos. Por exemplo, permita apenas
   que os desenvolvedores modifiquem o acesso ao repositorio do codigo-fonte,
   ao compilador do codigo-fonte e a outros utilitarios de desenvolvimento.
   Outros usuarios seriam agrupados em outras categorias, como testadores,
   designers ou usuarios finais, e somente o acesso de leitura seria
   permitido.

   Um sujeito de integridade inferior e incapaz de escrever para um sujeito
   de integridade superior e um sujeito de integridade superior nao pode
   listar ou ler um objeto de integridade inferior. Definir um rotulo com o
   grau mais baixo possivel pode torna-lo inacessivel aos sujeitos. Alguns
   ambientes em potencial para esse modulo de politica de seguranc,a
   incluiriam um servidor Web restrito, uma maquina de desenvolvimento e
   teste e um repositorio de codigo-fonte. Uma implementac,ao menos util
   seria uma estac,ao de trabalho pessoal, uma maquina usada como roteador ou
   um firewall de rede.

  15.5.8. O modulo MAC de marca d'agua baixa

   Nome do modulo: mac_lomac.ko

   Linha de configurac,ao do kernel: options MAC_LOMAC

   Opc,ao de inicializac,ao: mac_lomac_load="YES"

   Diferentemente da politica do MAC Biba, a politica mac_lomac(4) permite
   acesso a objetos de baixa integridade somente apos diminuir o nivel de
   integridade para nao interromper nenhuma regra de integridade.

   A politica de integridade de marca d'agua baixa funciona de forma quase
   identica ao Biba, com a excec,ao do uso de rotulos flutuantes para
   suportar o rebaixamento do sujeito por meio de um compartimento auxiliar
   de classificac,ao. Este compartimento secundario assume o formato
   [auxgrade]. Ao atribuir uma politica com um grau auxiliar, use a sintaxe
   lomac/10[2], onde 2 e o grau auxiliar.

   Essa politica se baseia na rotulagem onipresente de todos os objetos do
   sistema com rotulos de integridade, permitindo que os sujeitos leiam
   objetos de baixa integridade e fazendo o downgrade do rotulo no sujeito
   para evitar gravac,oes futuras em objetos de alta integridade usando
   [auxgrade] . A politica pode fornecer maior compatibilidade e exigir menos
   configurac,ao inicial do que o Biba.

   Como as politicas Biba e MLS, setfmac e setpmac sao usadas para colocar
   rotulos nos objetos do sistema:

 # setfmac /usr/home/trhodes lomac/high[low]
 # getfmac /usr/home/trhodes lomac/high[low]

   Um grau auxiliar low e uma funcionalidade fornecida apenas pela politica
   MAC LOMAC.

15.6. Bloqueio do Usuario

   Este exemplo considera um sistema de armazenamento relativamente pequeno
   com menos de cinquenta usuarios. Os usuarios terao recursos de login e
   terao permissao para armazenar dados e acessar recursos.

   Para este cenario, os modulos de politica mac_bsdextended(4) e
   mac_seeotheruids(4) podem coexistir e bloquear o acesso a objetos do
   sistema enquanto ocultam processos do usuario.

   Comece adicionando a seguinte linha ao /boot/loader.conf:

 mac_seeotheruids_load="YES"

   O modulo de politica de seguranc,a mac_bsdextended(4) pode ser ativado
   adicionando esta linha ao arquivo /etc/rc.conf:

 ugidfw_enable="YES"

   As regras padroes armazenadas em /etc/rc.bsdextended serao carregadas na
   inicializac,ao do sistema. No entanto, as entradas padroes podem precisar
   de modificac,ao. Como esta maquina e destinada apenas para servir os
   usuarios, tudo pode ser deixado comentado, exceto as duas ultimas linhas,
   a fim de forc,ar o carregamento de objetos do sistema de propriedade do
   usuario por padrao.

   Adicione os usuarios necessarios a esta maquina e reinicie. Para fins de
   teste, tente efetuar login como um usuario diferente em dois consoles.
   Execute ps aux para ver se os processos de outros usuarios estao visiveis.
   Verifique se a execuc,ao do ls(1) no diretorio inicial de outro usuario
   falha.

   Nao tente testar com o usuario root, a menos que o sysctl especifico tenha
   sido modificado para bloquear o acesso do superusuario.

  Nota:

   Quando um novo usuario e adicionado, sua regra mac_bsdextended(4) nao
   estara na lista de conjuntos de regras. Para atualizar o conjunto de
   regras rapidamente, descarregue o modulo de politica de seguranc,a e
   recarregue-o novamente usando kldunload(8) e kldload(8).

15.7. Nagios em Jail MAC

   Esta sec,ao demonstra as etapas necessarias para implementar o sistema de
   monitoramento de rede Nagios em um ambiente MAC. Isso e um exemplo que
   ainda exige que o administrador teste se a politica implementada atende
   aos requisitos de seguranc,a da rede antes de usar em um ambiente de
   produc,ao.

   Este exemplo requer que o multilabel seja definido em cada sistema de
   arquivos. Ele tambem assume que o net-mgmt/nagios-plugins, net-mgmt/nagios
   e www/apache22 estao todos instalados, configurados e funcionando
   corretamente antes de tentar a integrac,ao na estrutura MAC.

  15.7.1. Criar uma Classe de Usuario Insegura

   Comece o procedimento adicionando a seguinte classe de usuario ao
   /etc/login.conf:

 insecure:\
 :copyright=/etc/COPYRIGHT:\
 :welcome=/etc/motd:\
 :setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
 :path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin
 :manpath=/usr/share/man /usr/local/man:\
 :nologin=/usr/sbin/nologin:\
 :cputime=1h30m:\
 :datasize=8M:\
 :vmemoryuse=100M:\
 :stacksize=2M:\
 :memorylocked=4M:\
 :memoryuse=8M:\
 :filesize=8M:\
 :coredumpsize=8M:\
 :openfiles=24:\
 :maxproc=32:\
 :priority=0:\
 :requirehome:\
 :passwordtime=91d:\
 :umask=022:\
 :ignoretime@:\
 :label=biba/10(10-10):

   Em seguida, adicione a seguinte linha a sec,ao de classe de usuario
   padrao:

 :label=biba/high:

   Salve as edic,oes e rode o seguinte comando para reconstruir o banco de
   dados:

 # cap_mkdb /etc/login.conf

  15.7.2. Configurar usuarios

   Configure o usuario root para a classe padrao usando:

 # pw usermod root -L default

   Todas as contas de usuario que nao sao root agora exigirao uma classe de
   login. A classe de login e necessaria, caso contrario, os usuarios terao
   acesso recusado aos comandos comuns. O seguinte script sh deve resolver:

 # for x in `awk -F: '($3 >= 1001) && ($3 != 65534) { print $1 }' \
         /etc/passwd`; do pw usermod $x -L default; done;

   Em seguida, altere as contas nagios e www para a classe insegura:

 # pw usermod nagios -L insecure
 # pw usermod www -L insecure

  15.7.3. Crie o arquivo de contextos

   Um arquivo de contexto deve agora ser criado como /etc/policy.contexts:

 # This is the default BIBA policy for this system.

 # System:
 /var/run(/.*)?                  biba/equal

 /dev/(/.*)?                     biba/equal

 /var                            biba/equal
 /var/spool(/.*)?                biba/equal

 /var/log(/.*)?                  biba/equal

 /tmp(/.*)?                      biba/equal
 /var/tmp(/.*)?                  biba/equal

 /var/spool/mqueue               biba/equal
 /var/spool/clientmqueue         biba/equal

 # For Nagios:
 /usr/local/etc/nagios(/.*)?     biba/10

 /var/spool/nagios(/.*)?         biba/10

 # For apache
 /usr/local/etc/apache(/.*)?     biba/10

   Essa politica impoe seguranc,a ao definir restric,oes no fluxo de
   informac,oes. Nesta configurac,ao especifica, os usuarios, incluindo O
   root, nunca devem ter permissao para acessar o Nagios. Arquivos de
   configurac,ao e processos que fazem parte do Nagios serao completamente
   auto-contidos ou presos.

   Este arquivo sera lido depois da execuc,ao do setfsmac em cada sistema de
   arquivos. Este exemplo define a politica no sistema de arquivos raiz:

 # setfsmac -ef /etc/policy.contexts /

   Em seguida, adicione estas edic,oes a sec,ao principal do /etc/mac.conf:

 default_labels file ?biba
 default_labels ifnet ?biba
 default_labels process ?biba
 default_labels socket ?biba

  15.7.4. Configurac,ao do Inicializador

   Para finalizar a configurac,ao, adicione as seguintes linhas ao
   /boot/loader.conf:

 mac_biba_load="YES"
 mac_seeotheruids_load="YES"
 security.mac.biba.trust_all_interfaces=1

   E a seguinte linha para a configurac,ao da placa de rede armazenada em
   /etc/rc.conf. Se a configurac,ao de rede principal for feita via DHCP,
   talvez seja necessario configura-la manualmente apos cada inicializac,ao
   do sistema:

 maclabel biba/equal

  15.7.5. Testando a Configurac,ao

   Primeiro, certifique-se de que o servidor Web e o Nagios nao iniciarao na
   inicializac,ao e reinicializac,ao do sistema. Assegure-se de que o root
   nao possa acessar nenhum dos arquivos no diretorio de configurac,ao do
   Nagios. Se o root puder listar o conteudo de /var/spool/nagios, algo esta
   errado. Em vez disso, um erro "permission denied" deve ser retornado.

   Se tudo parecer bem, o Nagios, o Apache e o Sendmail agora poderao ser
   iniciados:

 # cd /etc/mail && make stop && \
 setpmac biba/equal make start && setpmac biba/10\(10-10\) apachectl start && \
 setpmac biba/10\(10-10\) /usr/local/etc/rc.d/nagios.sh forcestart

   Verifique novamente para garantir que tudo esteja funcionando
   corretamente. Caso contrario, verifique os arquivos de log em busca de
   mensagens de erro. Se necessario, use o sysctl(8) para desativar o modulo
   de politica de seguranc,a mac_biba(4) e tente iniciar tudo novamente.

  Nota:

   O usuario root ainda pode alterar a aplicac,ao de seguranc,a e editar seus
   arquivos de configurac,ao. O comando a seguir permitira a degradac,ao da
   politica de seguranc,a para um nivel inferior para um shell recem
   executado:

 # setpmac biba/10 csh

   Para impedir que isso acontec,a, force o usuario a um intervalo usando
   login.conf(5). Se o setpmac(8) tentar executar um comando fora do
   intervalo do compartimento, um erro sera retornado e o comando nao sera
   executado. Nesse caso, defina root como biba/high(high-high).

15.8. Soluc,ao de problemas do framework MAC

   Esta sec,ao discute erros de configurac,ao comuns e como resolve-los.

   O sinalizador multilabel nao fica habilitado na partic,ao raiz (/):

           As etapas a seguir podem resolver este erro transitorio:

             1. Edite /etc/fstab e defina a partic,ao raiz como somente
                leitura ro.

             2. Reinicie no modo single user.

             3. Execute tunefs -l enable no /.

             4. Reinicie o sistema.

             5. Execute mount -urw / e mude a opc,ao ro de volta para rw no
                /etc/fstab e reinicie o sistema novamente.

             6. Verifique novamente a saida do mount para garantir que o
                multilabel tenha sido configurado corretamente no sistema de
                arquivos raiz.

   Depois de estabelecer um ambiente seguro com o MAC, o Xorg nao inicia
   mais:

           Isso pode ser causado pela politica MAC partition ou por uma
           rotulagem incorreta em uma das politicas de rotulagem do MAC. Para
           depurar, tente o seguinte:

             1. Verifique a mensagem de erro. Se o usuario estiver na classe
                insecure, a politica partition pode ser a culpada. Tente
                definir a classe do usuario de volta para a classe default e
                reconstrua o banco de dados com o cap_mkdb. Se isso nao
                mitigar o problema, va para a etapa dois.

             2. Verifique duas vezes se as politicas de rotulo estao
                definidas corretamente para o usuario, para o Xorg e para as
                entradas no /dev.

             3. Se nenhum destes resolver o problema, envie a mensagem de
                erro e uma descric,ao do ambiente para a lista de discussao
                de perguntas gerais sobre o FreeBSD.

   O erro _secure_path: unable to stat .login_conf aparece:

           Esse erro pode aparecer quando um usuario tenta alternar do
           usuario root para outro usuario no sistema. Essa mensagem
           geralmente ocorre quando o usuario possui uma qualificac,ao mais
           alta do que a do usuario que ele esta tentando se tornar. Por
           exemplo, se joe tiver uma classificac,ao padrao de biba/low e o
           root tiver uma classificac,ao de biba/high, o root nao podera
           visualizar o diretorio inicial de joe. Isso acontecera
           independente se o root usou ou nao o su para se tornar o joe, pois
           o modelo de integridade do Biba nao permitira que o root exiba
           objetos definidos em um nivel de integridade mais baixo.

   O sistema nao reconhece mais o root:

           Quando isso ocorre, o whoami retorna 0 e su retorna who are you?.

           Isso pode acontecer se uma politica de rotulagem foi desativada
           por sysctl(8) ou o modulo de politica foi descarregado. Se a
           politica estiver desativada, o banco de dados de recursos de login
           precisara ser reconfigurado. Verifique duas vezes o
           /etc/login.conf para garantir que todas as opc,oes de label tenham
           sido removidas e reconstrua o banco de dados com cap_mkdb.

           Isso tambem pode acontecer se uma politica restringir o acesso ao
           master.passwd. Isso geralmente e causado por um administrador que
           altera o arquivo sob um rotulo que entra em conflito com a
           politica geral que esta sendo usada pelo sistema. Nesses casos, as
           informac,oes do usuario seriam lidas pelo sistema e o acesso seria
           bloqueado, pois o arquivo herdaria o novo rotulo. Desative a
           politica usando o sysctl(8) e tudo deve retornar ao normal.

Capitulo 16. Auditoria de Evento de Seguranc,a

   Escrito porTom Rhodes e Robert Watson.
   Indice

   16.1. Sinopse

   16.2. Termos chave

   16.3. Configurac,ao de Auditoria

   16.4. Trabalhando com Trilhas de Auditoria

16.1. Sinopse

   O sistema operacional FreeBSD inclui suporte para auditoria de eventos de
   seguranc,a. A auditoria de eventos oferece suporte a registros confiaveis,
   detalhados e configuraveis de diversos eventos do sistema relevantes para
   a seguranc,a, incluindo logins, alterac,oes de configurac,ao e acesso a
   arquivos e rede. Esses registros de log podem ser inestimaveis para
   monitoramento de sistema em tempo real, detecc,ao de intrusao e analise
   "post mortem". O FreeBSD implementa a Application Programming Interface
   (API) Basic Security Module (BSM) publicada pela Sun(TM) e o formato de
   arquivo, e e interoperavel com as implementac,oes de auditoria do
   Solaris(TM) e do Mac OS(R) X.

   Este capitulo se concentra na instalac,ao e configurac,ao da auditoria de
   eventos. Ele explica as politicas de auditoria e fornece um exemplo de
   configurac,ao de auditoria.

   Depois de ler este capitulo, voce sabera:

     * O que e auditoria de eventos e como funciona.

     * Como configurar a auditoria de eventos no FreeBSD para usuarios e
       processos.

     * Como revisar o caminho da auditoria usando as ferramentas de auditoria
       para reduc,ao e revisao.

   Antes de ler este capitulo, voce deve:

     * Entender os fundamentos do UNIX(R) e do FreeBSD (Capitulo 3,
       Fundamentos do FreeBSD).

     * Familiarize-se com os conceitos basicos de configurac,ao/compilac,ao
       do kernel (Capitulo 8, Configurando o kernel do FreeBSD).

     * Ter alguma familiaridade com seguranc,a e como ela esta presente no
       FreeBSD (Capitulo 13, Seguranc,a).

  Atenc,ao:

   O recurso de auditoria possui algumas limitac,oes conhecidas. Nem todos os
   eventos do sistema que sao relevantes para a seguranc,a sao auditaveis, e
   tambem alguns mecanismos de login, como gerenciadores de exibic,ao
   baseados em Xorg e daemons de terceiros, nao configuram adequadamente a
   auditoria para sessoes de login do usuario.

   O recurso de auditoria de eventos de seguranc,a e capaz de gerar logs
   muito detalhados da atividade do sistema. Em um sistema muito utilizado,
   os dados do arquivo de rastreamento podem ser muito grandes quando
   configurados para grandes detalhes, excedendo gigabytes por semana em
   algumas configurac,oes. Os administradores devem levar em considerac,ao os
   requisitos de espac,o em disco associados a configurac,oes de auditoria de
   alto volume. Por exemplo, pode ser desejavel dedicar um sistema de
   arquivos ao /var/audit para que outros sistemas de arquivos nao sejam
   afetados se o sistema de arquivos de auditoria ficar cheio.

16.2. Termos chave

   Os termos a seguir estao relacionados a auditoria de eventos de
   seguranc,a:

     * event: um evento auditavel e qualquer evento que pode ser registrado
       usando o subsistema de auditoria. Exemplos de eventos relevantes para
       a seguranc,a incluem a criac,ao de um arquivo, a construc,ao de uma
       conexao de rede ou o logon de um usuario. Os eventos sao
       "atribuiveis", o que significa que podem ser rastreados para um
       usuario autenticado, ou "nao atribuivel". Exemplos de eventos nao
       atribuiveis sao eventos que ocorrem antes da autenticac,ao no processo
       de login, como tentativas de senha incorreta.

     * class: um conjunto nomeado de eventos relacionados que sao usados em
       expressoes de selec,ao. As classes de eventos comumente usadas incluem
       "file creation" (fc), "exec" (ex), e "login_logout" (lo).

     * record: uma entrada de log de auditoria que descreve um evento de
       seguranc,a. Os registros contem um tipo de evento de registro,
       informac,oes sobre o assunto (usuario) executando a ac,ao,
       informac,oes de data e hora, informac,oes sobre quaisquer objetos ou
       argumentos e uma condic,ao de sucesso ou falha.

     * trail: um arquivo de log que consiste em uma serie de registros de
       auditoria que descrevem eventos de seguranc,a. As trilhas estao em
       ordem cronologica aproximada com relac,ao aos eventos concluidos.
       Apenas processos autorizados podem enviar registros para a trilha de
       auditoria.

     * selection expression: uma string contendo uma lista de prefixos e
       nomes de classes de eventos de auditoria usados para combinar eventos.

     * preselection: o processo pelo qual o sistema identifica quais eventos
       sao de interesse do administrador. A configurac,ao de pre-selec,ao usa
       uma serie de expressoes de selec,ao para identificar quais classes de
       eventos auditar quais usuarios, bem como configurac,oes globais que se
       aplicam a processos autenticados e nao autenticados.

     * reduction: o processo pelo qual os registros das trilhas de auditoria
       existentes sao selecionados para preservac,ao, impressao ou analise.
       Da mesma forma, o processo pelo qual os registros de auditoria
       indesejados sao removidos da trilha de auditoria. Usando a reduc,ao,
       os administradores podem implementar politicas para a preservac,ao de
       dados de auditoria. Por exemplo, trilhas de auditoria detalhadas podem
       ser mantidas por um mes, mas depois disso, as trilhas podem ser
       reduzidas para preservar apenas as informac,oes de login para fins de
       arquivamento.

16.3. Configurac,ao de Auditoria

   O suporte para auditoria de eventos no espac,o do usuario e instalado como
   parte do sistema operacional basico do FreeBSD. O suporte a kernel esta
   disponivel no kernel GENERIC por padrao, e auditd(8) pode ser ativado
   adicionando a seguinte linha no /etc/rc.conf:

 auditd_enable="YES"

   Em seguida, inicie o daemon de auditoria:

 # service auditd start

   Usuarios que preferem compilar um kernel personalizado devem incluir a
   seguinte linha em seu arquivo de configurac,ao de kernel personalizado:

 options AUDIT

  16.3.1. Expressoes de Selec,ao de Eventos

   Expressoes de selec,ao sao usadas em varios lugares na configurac,ao de
   auditoria para determinar quais eventos devem ser auditados. Expressoes
   contem uma lista de classes de eventos para correspondencia. As expressoes
   de selec,ao sao avaliadas da esquerda para a direita e duas expressoes sao
   combinadas, acrescentando uma `a outra.

   Tabela 16.1, "Classes de Eventos de Auditoria Padrao" resume as classes de
   eventos de auditoria padrao:

   Tabela 16.1. Classes de Eventos de Auditoria Padrao

   Nome da      Descric,ao                          Ac,ao                     
   classe  
   all     all                   Corresponde todas as classes de eventos.     
   aa      autenticac,ao e                                                    
           autorizac,ao          
   ad      administrativo        Ac,oes administrativas executadas no sistema 
                                 como um todo.                                
   ap      aplicac,ao            Ac,ao definida pela aplicac,ao.              
   cl      file close            Auditar chamadas para a chamada de sistema   
                                 close.                                       
                                 Execuc,ao do programa de auditoria.          
                                 Auditoria de argumentos de linha de comando  
   ex      exec                  e variaveis de ambiente sao controladas via  
                                 audit_control(5) usando os parametros argv e 
                                 envv para a configurac,ao da politica.       
   fa      acesso ao atributo de Audite o acesso de atributos de objetos como 
           arquivo               stat(1) e pathconf(2).                       
   fc      file create           Eventos de auditoria em que um arquivo e     
                                 criado.                                      
   fd      file delete           Eventos de auditoria onde ocorre a exclusao  
                                 de arquivos.                                 
                                 Eventos de auditoria onde ocorre a           
   fm      file attribute modify modificac,ao do atributo do arquivo, como    
                                 chown(8), chflags(1), e flock(2).            
   fr      file read             Eventos de auditoria nos quais dados sao     
                                 lidos ou arquivos sao abertos para leitura.  
                                 Eventos de auditoria nos quais os dados sao  
   fw      file write            gravados ou os arquivos sao gravados ou      
                                 modificados.                                 
   io      ioctl                 Auditar o uso da chamada de sistema ioctl.   
                                 Auditar varias formas de comunicac,ao entre  
   ip      ipc                   processos, incluindo pipes POSIX e           
                                 operac,oes IPC do System V.                  
   lo      login_logout          Audite os eventos login(1) e logout(1).      
   na      nao atribuivel        Auditar eventos nao atribuiveis.             
   no      classe invalida       Nao coincidir com eventos de auditoria.      
   nt      rede (network)        Eventos de auditoria relacionados a ac,oes   
                                 de rede, como connect(2) e accept(2).        
   ot      outros                Auditoria de eventos diversos.               
   pc      processo              Auditar operac,oes de processos, como        
                                 exec(3) e exit(3).                           

   Essas classes de eventos de auditoria podem ser personalizadas modificando
   os arquivos de configurac,ao audit_class e audit_event.

   Cada classe de eventos de auditoria pode ser combinada com um prefixo
   indicando se as operac,oes com exito/falha sao correspondidas e se a
   entrada esta adicionando ou removendo a correspondencia para a classe e o
   tipo. Tabela 16.2, "Prefixos para Classes de Eventos de Auditoria" resume
   os prefixos disponiveis:

   Tabela 16.2. Prefixos para Classes de Eventos de Auditoria

   Prefixo                               Ac,ao                                
   +       Auditoria de eventos bem sucedidos nesta classe.                   
   -       Auditoria de eventos com falha nesta classe.                       
   ^       Auditoria de eventos nem com sucesso e nem com falha nesta classe. 
   ^+      Nao fac,a auditoria de eventos bem-sucedidos nesta classe.         
   ^-      Nao audite eventos com falha nesta classe.                         

   Se nenhum prefixo estiver presente, as instancias com exito e com falha do
   evento serao auditadas.

   O seguinte exemplo de sequencia de selec,ao seleciona eventos de
   login/logout bem-sucedidos e com falha, mas apenas eventos de execuc,ao
   bem-sucedidos:

 lo,+ex

  16.3.2. Arquivos de Configurac,ao

   Os seguintes arquivos de configurac,ao para auditoria de eventos de
   seguranc,a sao encontrados em /etc/security:

     * audit_class: contem as definic,oes das classes de auditoria.

     * audit_control: controla os aspectos do subsistema de auditoria, como
       as classes de auditoria padrao, o espac,o em disco minimo a ser
       deixado no volume do log de auditoria e o tamanho maximo da trilha de
       auditoria.

     * audit_event: nomes e descric,oes textuais de eventos de auditoria do
       sistema e uma lista de quais classes cada evento esta.

     * audit_user: requisitos de auditoria especificos do usuario a serem
       combinados com os padroes globais no login.

     * audit_warn: um script de shell personalizavel usado pelo auditd(8)
       para gerar mensagens de aviso em situac,oes excepcionais, como quando
       o espac,o para registros de auditoria esta baixo ou quando o arquivo
       de trilha de auditoria foi rotacionado.

  Atenc,ao:

   Os arquivos de configurac,ao de auditoria devem ser editados e mantidos
   com cuidado, pois erros na configurac,ao podem resultar no registro
   inadequado de eventos.

   Na maioria dos casos, os administradores precisarao modificar apenas
   audit_control e audit_user. O primeiro arquivo controla as politicas e as
   propriedades de auditoria de todo o sistema, e o segundo arquivo pode ser
   usado para ajustar a auditoria pelo usuario.

    16.3.2.1. O arquivo audit_control

   Varios padroes para o subsistema de auditoria sao especificados em
   audit_control:

 dir:/var/audit
 dist:off
 flags:lo,aa
 minfree:5
 naflags:lo,aa
 policy:cnt,argv
 filesz:2M
 expire-after:10M

   A entrada dir e usada para definir um ou mais diretorios onde os logs de
   auditoria serao armazenados. Se mais de uma entrada de diretorio aparecer,
   elas serao usadas em ordem `a medida que forem preenchidas. E comum
   configurar a auditoria para que os logs de auditoria sejam armazenados em
   um sistema de arquivos dedicado, para evitar a interferencia entre o
   subsistema de auditoria e outros subsistemas, se o sistema de arquivos
   encher.

   Se o campo dist estiver definido como on ou yes, os links fisicos serao
   criados para todos os arquivos de rastreio em /var/audit/dist.

   O campo flags define a mascara de pre-selec,ao padrao para todo o sistema
   para eventos atribuiveis. No exemplo acima, eventos de login/logout
   bem-sucedidos e com falha, bem como autenticac,ao e autorizac,ao, sao
   auditados para todos os usuarios.

   A entrada minfree define a porcentagem minima de espac,o livre para o
   sistema de arquivos no qual a trilha de auditoria esta armazenada.

   A entrada naflags especifica as classes de auditoria a serem auditadas
   para eventos nao atribuidos, como o processo de login/logout e
   autenticac,ao e autorizac,ao.

   A entrada policy especifica uma lista separada por virgula de
   sinalizadores de politica que controla varios aspectos do comportamento de
   auditoria. O cnt indica que o sistema deve continuar em execuc,ao apesar
   de uma falha de auditoria (este sinalizador e altamente recomendado). O
   outro sinalizador, argv, faz com que os argumentos da linha de comando
   para a chamada de sistema execve(2) sejam auditados como parte de
   execuc,ao de comando.

   A entrada filesz especifica o tamanho maximo para uma trilha de auditoria
   antes de finalizar e rotacionar automaticamente o arquivo de trilha. Um
   valor de 0 desabilita a rotac,ao automatica de log. Se o tamanho do
   arquivo solicitado estiver abaixo do minimo de 512k, ele sera ignorado e
   uma mensagem de log sera gerada.

   O campo expire-after especifica quando os arquivos de log de auditoria
   expirarao e serao removidos.

    16.3.2.2. O Arquivo audit_user

   O administrador pode especificar requisitos adicionais de auditoria para
   usuarios especificos em audit_user. Cada linha configura a auditoria para
   um usuario atraves de dois campos: o campo alwaysaudit especifica um
   conjunto de eventos que devem sempre ser auditados para o usuario, e o
   campo neveraudit especifica um conjunto de eventos que nunca devem ser
   auditados para o usuario.

   As entradas de exemplo a seguir auditam os eventos de login/logout e a
   execuc,ao bem-sucedida do comando para root e criac,ao de arquivos e
   execuc,ao de comando bem-sucedida para www. Se usado com o audit_control,
   a entrada lo para root e redundante, e os eventos login/logout tambem
   serao auditados para www.

 root:lo,+ex:no
 www:fc,+ex:no

16.4. Trabalhando com Trilhas de Auditoria

   Como as trilhas de auditoria sao armazenadas no formato binario BSM,
   varias ferramentas internas estao disponiveis para modificar ou converter
   essas trilhas em texto. Para converter arquivos de trilha em um formato de
   texto simples, use o praudit. Para reduzir o arquivo de trilha de
   auditoria para fins de analise, arquivamento ou impressao, use o
   auditreduce. Esse utilitario suporta varios parametros de selec,ao,
   incluindo tipo de evento, classe de evento, usuario, data ou hora do
   evento e o caminho ou objeto do arquivo em questao.

   Por exemplo, para baixar todo o conteudo de um log de auditoria
   especificado em texto simples:

 # praudit /var/audit/AUDITFILE

   Onde AUDITFILE e o log de auditoria a ser descarregado.

   As trilhas de auditoria consistem em uma serie de registros de auditoria
   compostos por tokens, em que o praudit imprime sequencialmente, um por
   linha. Cada token e de um tipo especifico, como header (um cabec,alho de
   registro de auditoria) ou path (um caminho de arquivo de uma pesquisa de
   nome). O seguinte e um exemplo de um evento execve:

 header,133,10,execve(2),0,Mon Sep 25 15:58:03 2006, + 384 msec
 exec arg,finger,doug
 path,/usr/bin/finger
 attribute,555,root,wheel,90,24918,104944
 subject,robert,root,wheel,root,wheel,38439,38032,42086,128.232.9.100
 return,success,0
 trailer,133

   Esta auditoria representa uma chamada execve bem-sucedida, na qual o
   comando finger doug foi executado. O token exec arg contem a linha de
   comando processada apresentada pelo shell ao kernel. O token path contem o
   caminho para o executavel conforme procurado pelo kernel. O token
   attribute descreve o binario e inclui o modo de arquivo. O token subject
   armazena o ID do usuario de auditoria, ID do usuario e ID do grupo, ID do
   usuario real e ID do grupo, ID do processo, ID da sessao, ID da porta e
   enderec,o de login. Observe que o ID do usuario de auditoria e o ID do
   usuario real sao diferentes quando o usuario robert mudou para a conta
   root antes de executar este comando, mas e auditado usando o usuario
   original autenticado. O token return indica a execuc,ao bem-sucedida e o
   trailer conclui o registro.

   O formato de saida XML tambem e suportado e pode ser selecionado incluindo
   -x.

   Como os logs de auditoria podem ser muito grandes, um subconjunto de
   registros pode ser selecionado usando auditreduce. Este exemplo seleciona
   todos os registros de auditoria produzidos para o usuario trhodes
   armazenados em AUDITFILE:

 # auditreduce -u trhodes /var/audit/AUDITFILE | praudit

   Os membros do grupo audit tem permissao para ler trilhas de auditoria em
   /var/audit. Por padrao, esse grupo esta vazio, portanto, apenas o usuario
   root pode ler trilhas de auditoria. Os usuarios podem ser adicionados ao
   grupo auditoria para delegar direitos de revisao de auditoria. Como a
   capacidade de rastrear o conteudo do log de auditoria fornece informac,oes
   significativas sobre o comportamento dos usuarios e processos,
   recomenda-se que a delegac,ao dos direitos de revisao de auditoria seja
   executada com cautela.

  16.4.1. Monitoramento em Tempo Real Usando Pipes de Auditoria

   Pipes de auditoria sao pseudo-dispositivos clones que permitem que os
   aplicativos acessem o fluxo de registro de auditoria em tempo real. Isto e
   principalmente de interesse para os autores de aplicac,oes de detecc,ao de
   intrusao e monitoramento de sistemas. No entanto, o dispositivo de canal
   de auditoria e uma maneira conveniente para o administrador permitir o
   monitoramento ao vivo sem incorrer em problemas com a propriedade do
   arquivo de trilha de auditoria ou a rotac,ao de log interrompendo o fluxo
   de eventos. Para acompanhar o fluxo de eventos de auditoria em tempo real:

 # praudit /dev/auditpipe

   Por padrao, os nos de dispositivo dos pipes de auditoria sao acessiveis
   apenas para o usuario root. Para torna-los acessiveis aos membros do grupo
   audit, adicione uma regra devfs para /etc/devfs.rules:

 add path 'auditpipe*' mode 0440 group audit

   Veja devfs.rules(5) para mais informac,oes sobre como configurar o sistema
   de arquivos devfs.

  Atenc,ao:

   E facil produzir ciclos de feedback de evento de auditoria, nos quais a
   visualizac,ao de cada evento de auditoria resulta na gerac,ao de mais
   eventos de auditoria. Por exemplo, se toda a rede I/O for auditada e
   praudit for executada a partir de uma sessao SSH, um fluxo continuo de
   eventos de auditoria sera gerada em uma taxa alta, pois cada evento sendo
   impresso gerara outro evento. Por esse motivo, e aconselhavel executar
   praudit em um dispositivo de pipe de auditoria a partir de sessoes sem
   auditoria de I/O de baixa granularidade.

  16.4.2. Rotac,ao e Compactac,ao de Arquivos de Trilha de Auditoria

   As trilhas de auditoria sao gravadas pelo kernel e gerenciadas pelo daemon
   de auditoria, auditd(8). Os administradores nao devem tentar usar o
   newsyslog.conf(5) ou outras ferramentas para rotacionar diretamente os
   logs de auditoria. Em vez disso, o audit deve ser usado para encerrar a
   auditoria, reconfigurar o sistema de auditoria e executar a rotac,ao de
   log. O comando a seguir faz com que o daemon de auditoria crie um novo log
   de auditoria e sinalize ao kernel para alternar para o novo log. O log
   antigo sera finalizado e renomeado, podendo entao ser manipulado pelo
   administrador:

 # audit -n

   Se auditd(8) nao estiver em execuc,ao no momento, este comando falhara e
   uma mensagem de erro sera apresentada.

   Adicionar a seguinte linha ao /etc/crontab agendara essa rotac,ao a cada
   doze horas:

 0     */12       *       *       *       root    /usr/sbin/audit -n

   A alterac,ao tera efeito quando o /etc/crontab for salvo.

   A rotac,ao automatica do arquivo de trilha de auditoria com base no
   tamanho do arquivo e possivel usando filesz em audit_control, conforme
   descrito em Sec,ao 16.3.2.1, "O arquivo audit_control".

   Como os arquivos de trilha de auditoria podem se tornar muito grandes,
   geralmente e desejavel compactar ou arquivar rastros depois que eles forem
   fechados pelo daemon de auditoria. O script audit_warn pode ser usado para
   executar operac,oes personalizadas para uma variedade de eventos
   relacionados `a auditoria, incluindo a terminac,ao limpa de trilhas de
   auditoria quando elas sao rotacionadas. Por exemplo, o seguinte pode ser
   adicionado ao /etc/security/audit_warn para compactar as trilhas de
   auditoria ao serem fechados:

 #
 # Compress audit trail files on close.
 #
 if [ "$1" = closefile ]; then
         gzip -9 $2
 fi

   Outras atividades de arquivamento podem incluir a copia de arquivos de
   trilha para um servidor centralizado, a exclusao de arquivos de trilha
   antigos ou a reduc,ao da trilha de auditoria para remover registros
   desnecessarios. Este script sera executado somente quando os arquivos da
   trilha de auditoria forem finalizados de forma limpa, portanto, nao serao
   executados em trilhas deixadas sem serem eliminadas apos um desligamento
   incorreto.

Capitulo 17. Armazenamento

   Indice

   17.1. Sinopse

   17.2. Adicionando Discos

   17.3. Redimensionando e Ampliando Discos

   17.4. Dispositivos de Armazenamento USB

   17.5. Criando e Usando Midia em CD

   17.6. Criando e Usando Midia de DVD

   17.7. Criando e Usando Disquetes

   17.8. Noc,oes Basicas de Backup

   17.9. Discos de Memoria

   17.10. Snapshots de Sistemas de Arquivos

   17.11. Cotas de Disco

   17.12. Criptografando Partic,oes de Disco

   17.13. Criptografando Swap

   17.14. Alta Disponibilidade de Armazenamento (HAST)

17.1. Sinopse

   Este capitulo aborda o uso de discos e midia de armazenamento no FreeBSD.
   Isso inclui discos SCSI e IDE, midias de CD e DVD, discos com suporte de
   memoria e dispositivos de armazenamento USB.

   Depois de ler este capitulo, voce sabera:

     * Como adicionar discos rigidos adicionais a um sistema FreeBSD.

     * Como aumentar o tamanho da partic,ao de um disco no FreeBSD.

     * Como configurar o FreeBSD para usar dispositivos de armazenamento USB.

     * Como usar midias de CD e DVD em um sistema FreeBSD.

     * Como usar os programas de backup disponiveis no FreeBSD.

     * Como configurar discos de memoria.

     * O que sao snapshots de sistema de arquivos e como usa-los com
       eficiencia.

     * Como usar cotas para limitar o uso de espac,o em disco.

     * Como criptografar discos e swap para protege-los contra invasores.

     * Como configurar uma rede de armazenamento altamente disponivel.

   Antes de ler este capitulo, voce deve:

     * Saiba como configurar e instalar um novo kernel do FreeBSD.

17.2. Adicionando Discos

   Originalmente contribuido por David O'Brien.

   Esta sec,ao descreve como adicionar um novo disco SATA a uma maquina que
   atualmente possui apenas uma unica unidade. Primeiro, desligue o
   computador e instale a unidade no computador seguindo as instruc,oes do
   fabricante do computador, controladora e unidade. Reinicialize o sistema e
   torne-se root.

   Inspecione o arquivo /var/run/dmesg.boot para garantir que o novo disco
   foi encontrado. Neste exemplo, a unidade SATA recem-adicionada aparecera
   como ada1.

   Para este exemplo, uma unica partic,ao grande sera criada no novo disco. O
   esquema de particionamento GPT sera usado ao inves do esquema MBR, mais
   antigo e menos versatil.

  Nota:

   Se o disco a ser adicionado nao estiver em branco, as informac,oes antigas
   da partic,ao podem ser removidas com gpart delete. Veja gpart(8) para
   detalhes.

   O esquema de partic,ao e criado e, em seguida, uma unica partic,ao e
   adicionada. Para melhorar o desempenho em discos mais recentes com
   tamanhos maiores de blocos de hardware, a partic,ao esta alinhada a
   divisoes de um megabyte:

 # gpart create -s GPT ada1
 # gpart add -t freebsd-ufs -a 1M ada1

   Dependendo do uso, varias partic,oes menores podem ser desejadas. Veja
   gpart(8) para opc,oes para criar partic,oes menores que um disco inteiro.

   As informac,oes da partic,ao de disco podem ser visualizadas com gpart
   show:

 % gpart show ada1
 =>        34  1465146988  ada1  GPT  (699G)
           34        2014        - free -  (1.0M)
         2048  1465143296     1  freebsd-ufs  (699G)
   1465145344        1678        - free -  (839K)

   Um sistema de arquivos e criado em uma nova partic,ao no novo disco:

 # newfs -U /dev/ada1p1

   Um diretorio vazio e criado como um ponto de montagem, um local para
   montar o novo disco no sistema de arquivos do disco original:

 # mkdir /newdisk

   Finalmente, uma entrada e adicionada ao arquivo /etc/fstab para que o novo
   disco seja montado automaticamente na inicializac,ao:

 /dev/ada1p1     /newdisk        ufs     rw      2       2

   O novo disco pode ser montado manualmente, sem reiniciar o sistema:

 # mount /newdisk

17.3. Redimensionando e Ampliando Discos

   Originalmente contribuido por Allan Jude.

   A capacidade de um disco pode aumentar sem alterac,oes nos dados ja
   presentes. Isso acontece normalmente com maquinas virtuais, quando o disco
   virtual torna-se muito pequeno e e ampliado. As vezes, uma imagem de disco
   e gravada em um cartao de memoria USB, mas nao usa toda a capacidade. Aqui
   nos descrevemos como redimensionar ou ampliar o conteudo do disco para
   aproveitar a capacidade aumentada.

   Determine o nome do dispositivo do disco a ser redimensionado
   inspecionando o arquivo /var/run/dmesg.boot. Neste exemplo, ha apenas um
   disco SATA no sistema, portanto a unidade aparecera como ada0.

   Liste as partic,oes no disco para ver a configurac,ao atual:

 # gpart show ada0
 =>      34  83886013  ada0  GPT  (48G) [CORRUPT]
         34       128     1  freebsd-boot  (64k)
        162  79691648     2  freebsd-ufs  (38G)
   79691810   4194236     3  freebsd-swap  (2G)
   83886046         1        - free -  (512B)

  Nota:

   Se o disco foi formatado com o esquema de particionamento GPT, ele pode
   ser exibido como "corrompido" porque a tabela de partic,oes de backup GPT
   nao esta mais no final da unidade. Corrija a tabela de partic,oes de
   backup com o gpart:

 # gpart recover ada0
 ada0 recovered

   Agora, o espac,o adicional no disco esta disponivel para uso por uma nova
   partic,ao ou uma partic,ao existente pode ser expandida:

 # gpart show ada0
 =>       34  102399933  ada0  GPT  (48G)
          34        128     1  freebsd-boot  (64k)
         162   79691648     2  freebsd-ufs  (38G)
    79691810    4194236     3  freebsd-swap  (2G)
    83886046   18513921        - free -  (8.8G)

   As partic,oes so podem ser redimensionadas para um espac,o livre contiguo.
   Aqui, a ultima partic,ao no disco e a partic,ao swap, mas a segunda
   partic,ao e aquela que precisa ser redimensionada. As partic,oes de Swap
   contem apenas dados temporarios, portanto, podem ser desmontadas,
   excluidas e, em seguida, recriadas a terceira partic,ao apos redimensionar
   a segunda partic,ao.

   Desative a partic,ao de swap:

 # swapoff /dev/ada0p3

   Exclua a terceira partic,ao, especificada pela flag -i, do disco ada0.

 # gpart delete -i 3 ada0
 ada0p3 deleted
 # gpart show ada0
 =>       34  102399933  ada0  GPT  (48G)
          34        128     1  freebsd-boot  (64k)
         162   79691648     2  freebsd-ufs  (38G)
    79691810   22708157        - free -  (10G)

  Atenc,ao:

   Existe o risco de perda de dados ao modificar a tabela de partic,oes de um
   sistema de arquivos montado. E melhor executar as etapas a seguir em um
   sistema de arquivos desmontado durante a execuc,ao de um dispositivo
   CD-ROM ou USB live. No entanto, se for absolutamente necessario, um
   sistema de arquivos montado pode ser redimensionado depois de desativar os
   recursos de seguranc,a do GEOM:

 # sysctl kern.geom.debugflags=16

   Redimensione a partic,ao, deixando espac,o para recriar uma partic,ao swap
   do tamanho desejado. A partic,ao a ser redimensionada e especificada com
   -i e o novo tamanho desejado com -s. Opcionalmente, o alinhamento da
   partic,ao e controlado com -a. Isso so modifica o tamanho da partic,ao. O
   sistema de arquivos na partic,ao sera expandido em uma etapa separada.

 # gpart resize -i 2 -s 47G -a 4k ada0
 ada0p2 resized
 # gpart show ada0
 =>       34  102399933  ada0  GPT  (48G)
          34        128     1  freebsd-boot  (64k)
         162   98566144     2  freebsd-ufs  (47G)
    98566306    3833661        - free -  (1.8G)

   Recrie a partic,ao swap e ative-a. Se nenhum tamanho for especificado com
   -s, todo o espac,o restante sera usado:

 # gpart add -t freebsd-swap -a 4k ada0
 ada0p3 added
 # gpart show ada0
 =>       34  102399933  ada0  GPT  (48G)
          34        128     1  freebsd-boot  (64k)
         162   98566144     2  freebsd-ufs  (47G)
    98566306    3833661     3  freebsd-swap  (1.8G)
 # swapon /dev/ada0p3

   Aumente o sistema de arquivos UFS para usar a nova capacidade da partic,ao
   redimensionada:

 # growfs /dev/ada0p2
 Device is mounted read-write; resizing will result in temporary write suspension for /.
 It's strongly recommended to make a backup before growing the file system.
 OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/No] Yes
 super-block backups (for fsck -b #) at:
  80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,
  89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432

   Se o sistema de arquivos for ZFS, o redimensionamento sera acionado pela
   execuc,ao do subcomando online com -e:

 # zpool online -e zroot /dev/ada0p2

   Tanto a partic,ao quanto o sistema de arquivos foram redimensionados para
   usar o espac,o em disco recem-disponivel.

17.4. Dispositivos de Armazenamento USB

   Contribuido por Marc Fonvieille.

   Muitas soluc,oes de armazenamento externo, como discos rigidos,
   thumbdrives USB e gravadores de CD e DVD, usam o Universal Serial Bus (
   USB ). O FreeBSD fornece suporte para dispositivos USB 1.x, 2.0 e 3.0.

  Nota:

   O suporte a USB 3.0 nao e compativel com alguns hardwares, incluindo os
   chipsets Haswell (Lynx Point). Se o FreeBSD inicializar com uma mensagem
   falhou com erro 19, desative xHCI/USB3 na BIOS.

   O suporte para dispositivos de armazenamento USB e embutido no kernel
   GENERIC. Para um kernel personalizado, certifique-se de que as seguintes
   linhas estejam presentes no arquivo de configurac,ao do kernel:

 device scbus    # SCSI bus (required for ATA/SCSI)
 device da       # Direct Access (disks)
 device pass     # Passthrough device (direct ATA/SCSI access)
 device uhci     # provides USB 1.x support
 device ohci     # provides USB 1.x support
 device ehci     # provides USB 2.0 support
 device xhci     # provides USB 3.0 support
 device usb      # USB Bus (required)
 device umass    # Disks/Mass storage - Requires scbus and da
 device cd       # needed for CD and DVD burners

   O FreeBSD usa o driver umass(4) que usa o subsistema SCSI para acessar o
   armazenamento de dispositivos USB. Como qualquer dispositivo USB sera
   visto como um dispositivo SCSI pelo sistema, se o dispositivo USB for um
   gravador de CD ou DVD, nao inclua device atapicam em um arquivo de
   configurac,ao do kernel personalizado.

   O restante desta sec,ao demonstra como verificar se um dispositivo de
   armazenamento USB e reconhecido pelo FreeBSD e como configurar o
   dispositivo para que ele possa ser usado.

  17.4.1. Configurac,ao de Dispositivo

   Para testar a configurac,ao USB, conecte o dispositivo USB. Use dmesg para
   confirmar que a unidade aparece no buffer de mensagens do sistema. Deve
   parecer algo como isto:

 umass0: <STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3> on usbus0
 umass0:  SCSI over Bulk-Only; quirks = 0x0100
 umass0:4:0:-1: Attached to scbus4
 da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
 da0: <STECH Simple Drive 1.04> Fixed Direct Access SCSI-4 device
 da0: Serial Number WD-WXE508CAN263
 da0: 40.000MB/s transfers
 da0: 152627MB (312581808 512 byte sectors: 255H 63S/T 19457C)
 da0: quirks=0x2<NO_6_BYTE>

   A marca, o no de dispositivo (da0), a velocidade e o tamanho serao
   diferentes de acordo com o dispositivo.

   Como o dispositivo USB e visto como um SCSI, o camcontrol pode ser usado
   para listar os dispositivos de armazenamento USB conectados ao sistema:

 # camcontrol devlist
 <STECH Simple Drive 1.04>          at scbus4 target 0 lun 0 (pass3,da0)

   Alternativamente, o usbconfig pode ser usado para listar o dispositivo.
   Consulte o usbconfig(8) para obter mais informac,oes sobre este comando.

 # usbconfig
 ugen0.3: <Simple Drive STECH> at usbus0, cfg=0 md=HOST spd=HIGH (480Mbps) pwr=ON (2mA)

   Se o dispositivo nao tiver sido formatado, consulte Sec,ao 17.2,
   "Adicionando Discos" para obter instruc,oes sobre como formatar e criar
   partic,oes na unidade USB. Se a unidade vier com um sistema de arquivos,
   ela pode ser montada pelo root usando as instruc,oes em Sec,ao 3.7,
   "Montando e Desmontando Sistemas de Arquivos".

  Atenc,ao:

   Permitir que usuarios nao confiaveis montem midia arbitraria, ativando
   vfs.usermount como descrito abaixo, nao deve ser considerado seguro do
   ponto de vista da seguranc,a. A maioria dos sistemas de arquivos nao foi
   criada para proteger contra dispositivos maliciosos.

   Para tornar o dispositivo montavel como um usuario normal, uma soluc,ao e
   tornar todos os usuarios do dispositivo membros do grupo operator usando
   pw(8). Em seguida, certifique-se de que operator possa ler e gravar o
   dispositivo adicionando estas linhas ao /etc/devfs.rules:

 [localrules=5]
 add path 'da*' mode 0660 group operator

  Nota:

   Se discos internos SCSI tambem estiverem instalados no sistema, altere a
   segunda linha da seguinte maneira:

 add path 'da[3-9]*' mode 0660 group operator

   Isso excluira os tres primeiros discos SCSI (da0 para da2) pertencentes ao
   grupo operator. Substitua 3 pelo numero de discos SCSI internos. Consulte
   devfs.rules(5) para obter mais informac,oes sobre esse arquivo.

   Em seguida, ative o conjunto de regras no arquivo /etc/rc.conf:

 devfs_system_ruleset="localrules"

   Em seguida, instrua o sistema para permitir que usuarios comuns montem
   sistemas de arquivos incluindo a seguinte linha no arquivo
   /etc/sysctl.conf:

 vfs.usermount=1

   Como isso so entra em vigor apos a proxima reinicializac,ao, use sysctl
   para definir essa variavel agora:

 # sysctl vfs.usermount=1
 vfs.usermount: 0 -> 1

   A etapa final e criar um diretorio no qual o sistema de arquivos deve ser
   montado. Esse diretorio precisa pertencer ao usuario que deve montar o
   sistema de arquivos. Uma maneira de fazer isso e para o root criar um
   subdiretorio de propriedade daquele usuario como /mnt/username. No exemplo
   a seguir, substitua username pelo nome de login do usuario e usergroup
   pelo grupo principal do usuario:

 # mkdir /mnt/username
 # chown username:usergroup /mnt/username

   Suponha que um thumbdrive USB esteja conectado e um dispositivo /dev/da0s1
   aparec,a. Se o dispositivo estiver formatado com um sistema de arquivos
   FAT, o usuario podera monta-lo usando:

 % mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/username

   Antes que o dispositivo possa ser desconectado, ele deve ser desmontado
   primeiro:

 % umount /mnt/username

   Apos a remoc,ao do dispositivo, o buffer de mensagens do sistema mostrara
   mensagens semelhantes `as seguintes:

 umass0: at uhub3, port 2, addr 3 (disconnected)
 da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
 da0: <STECH Simple Drive 1.04> s/n WD-WXE508CAN263          detached
 (da0:umass-sim0:0:0:0): Periph destroyed

  17.4.2. Montando Automaticamente Uma Midia Removivel

   Dispositivos USB podem ser montados automaticamente removendo o comentario
   desta linha no arquivo /etc/auto_master:

 /media          -media          -nosuid

   Entao adicione estas linhas ao arquivo /etc/devd.conf:

 notify 100 {
         match "system" "GEOM";
         match "subsystem" "DEV";
         action "/usr/sbin/automount -c";
 };

   Recarregue a configurac,ao se autofs(5) e devd(8) ja estiverem em
   execuc,ao:

 # service automount restart
 # service devd restart

   autofs(5) pode ser configurado para iniciar no boot, adicionando esta
   linha ao arquivo /etc/rc.conf:

 autofs_enable="YES"

   autofs(5) requer que o devd(8) esteja ativado, como e por padrao.

   Inicie os servic,os imediatamente com:

 # service automount start
 # service automountd start
 # service autounmountd start
 # service devd start

   Cada sistema de arquivos que pode ser montado automaticamente aparece como
   um diretorio em /media/. O diretorio e nomeado apos o rotulo do sistema de
   arquivos. Se o rotulo estiver ausente, o diretorio sera nomeado apos o no
   do dispositivo.

   O sistema de arquivos e montado de forma transparente no primeiro acesso e
   desmontado apos um periodo de inatividade. Unidades montadas
   automaticamente tambem podem ser desmontadas manualmente:

 # automount -fu

   Este mecanismo e normalmente usado para cartoes de memoria e cartoes de
   memoria USB. Pode ser usado com qualquer dispositivo de bloco, incluindo
   unidades opticas ou iSCSI LUNs.

17.5. Criando e Usando Midia em CD

   Contribuido por Mike Meyer.

   A midia em disco compacto (CD) fornece varios recursos que os diferenciam
   dos discos convencionais. Eles sao projetados para que possam ser lidos
   continuamente sem atrasos para mover a cabec,a entre as trilhas. Embora a
   midia CD tenha faixas, elas se referem a uma sec,ao de dados a ser lida
   continuamente e nao a uma propriedade fisica do disco. O sistema de
   arquivos ISO 9660 foi projetado para lidar com essas diferenc,as.

   A Colec,ao de Ports do FreeBSD fornece varios utilitarios para gravar e
   duplicar audio e dados de CDs. Este capitulo demonstra o uso de varios
   utilitarios de linha de comando. Para o software de gravac,ao de CD com um
   utilitario grafico, considere instalar os pacotes ou ports
   sysutils/xcdroast ou sysutils/k3b.

  17.5.1. Dispositivos Suportados

   Contribuido por Marc Fonvieille.

   O kernel GENERIC fornece suporte para SCSI, USB, e leitores e gravadores
   de CD ATAPI. Se um kernel personalizado for usado, as opc,oes que precisam
   estar presentes no arquivo de configurac,ao do kernel variam de acordo com
   o tipo de dispositivo.

   Para um gravador SCSI, verifique se essas opc,oes estao presentes:

 device scbus    # SCSI bus (required for ATA/SCSI)
 device da       # Direct Access (disks)
 device pass     # Passthrough device (direct ATA/SCSI access)
 device cd       # needed for CD and DVD burners

   Para um gravador de USB, verifique se essas opc,oes estao presentes:

 device scbus    # SCSI bus (required for ATA/SCSI)
 device da       # Direct Access (disks)
 device pass     # Passthrough device (direct ATA/SCSI access)
 device cd       # needed for CD and DVD burners
 device uhci     # provides USB 1.x support
 device ohci     # provides USB 1.x support
 device ehci     # provides USB 2.0 support
 device xhci     # provides USB 3.0 support
 device usb      # USB Bus (required)
 device umass    # Disks/Mass storage - Requires scbus and da

   Para um gravador ATAPI, verifique se essas opc,oes estao presentes:

 device ata      # Legacy ATA/SATA controllers
 device scbus    # SCSI bus (required for ATA/SCSI)
 device pass     # Passthrough device (direct ATA/SCSI access)
 device cd       # needed for CD and DVD burners

  Nota:

   Nas versoes do FreeBSD anteriores a 10.x, esta linha tambem e necessaria
   no arquivo de configurac,ao do kernel se o gravador for um dispositivo
   ATAPI:

 device atapicam

   Como alternativa, esse driver pode ser carregado no momento da
   inicializac,ao adicionando a seguinte linha ao arquivo /boot/loader.conf:

 atapicam_load="YES"

   Isso exigira uma reinicializac,ao do sistema, pois esse driver so pode ser
   carregado no momento da inicializac,ao.

   Para verificar se o FreeBSD reconhece o dispositivo, execute o dmesg e
   procure por uma entrada para o dispositivo. Nos sistemas anteriores a
   10.x, o nome do dispositivo na primeira linha da saida sera acd0 em vez de
   cd0.

 % dmesg | grep cd
 cd0 at ahcich1 bus 0 scbus1 target 0 lun 0
 cd0: <HL-DT-ST DVDRAM GU70N LT20> Removable CD-ROM SCSI-0 device
 cd0: Serial Number M3OD3S34152
 cd0: 150.000MB/s transfers (SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes)
 cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed

  17.5.2. Gravando um CD

   No FreeBSD, cdrecord pode ser usado para gravar CDs. Este comando e
   instalado com o pacote ou port sysutils/cdrtools.

   Enquanto o cdrecord tem muitas opc,oes, o uso basico e simples.
   Especifique o nome do arquivo ISO para gravar e, se o sistema tiver varios
   dispositivos de gravac,ao, especifique o nome do dispositivo a ser usado:

 # cdrecord dev=device imagefile.iso

   Para determinar o nome do dispositivo do gravador, use -scanbus, que pode
   produzir resultados como este:

 # cdrecord -scanbus
 ProDVD-ProBD-Clone 3.00 (amd64-unknown-freebsd10.0) Copyright (C) 1995-2010 Jo:rg Schilling
 Using libscg version 'schily-0.9'
 scsibus0:
         0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
         0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
         0,2,0     2) *
         0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
         0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
         0,5,0     5) *
         0,6,0     6) *
         0,7,0     7) *
 scsibus1:
         1,0,0   100) *
         1,1,0   101) *
         1,2,0   102) *
         1,3,0   103) *
         1,4,0   104) *
         1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
         1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
         1,7,0   107) *

   Localize a entrada para o gravador de CD e use os tres numeros separados
   por virgulas como o valor para dev. Nesse caso, o dispositivo gravador
   Yamaha e 1,5,0, portanto, a entrada apropriada para especificar esse
   dispositivo e dev=1,5,0. Consulte a pagina de manual do cdrecord para
   outras formas de especificar este valor e informac,oes sobre como gravar
   faixas de audio e controlar a velocidade de gravac,ao.

   Como alternativa, execute o seguinte comando para obter o enderec,o do
   dispositivo do gravador:

 # camcontrol devlist
 <MATSHITA CDRW/DVD UJDA740 1.00>   at scbus1 target 0 lun 0 (cd0,pass0)

   Use os valores numericos para scbus, target e lun. Para este exemplo,
   1,0,0 e o nome do dispositivo a ser usado.

  17.5.3. Escrevendo Dados em um Sistema de Arquivos ISO

   Para produzir um CD de dados, os arquivos de dados que compoem as faixas
   no CD devem ser preparados antes que possam ser gravados no CD. No
   FreeBSD, sysutils/cdrtools instala o mkisofs, que pode ser usado para
   produzir um sistema de arquivos ISO 9660 que e uma imagem de uma arvore de
   diretorios dentro um sistema de arquivos UNIX(R). O uso mais simples e
   especificar o nome do arquivo ISO para criar e o caminho para os arquivos
   a serem colocados no sistema de arquivos ISO 9660:

 # mkisofs -o imagefile.iso /path/to/tree

   Este comando mapeia os nomes dos arquivos no caminho especificado para os
   nomes que se ajustam `as limitac,oes do sistema de arquivos padrao ISO
   9660 e excluira arquivos que nao atendem ao padrao para o sistemas de
   arquivos ISO.

   Varias opc,oes estao disponiveis para superar as restric,oes impostas pelo
   padrao. Em particular, -R permite que as extensoes Rock Ridge comuns aos
   sistemas UNIX(R) e -J ativem as extensoes Joliet usadas por sistemas
   Microsoft(R).

   Para CDs que serao usados apenas em sistemas FreeBSD, -U pode ser usado
   para desabilitar todas as restric,oes de nome de arquivo. Quando usado com
   -R, ele produz uma imagem do sistema de arquivos que e identica `a arvore
   FreeBSD especificada, mesmo se violar o padrao ISO 9660.

   A ultima opc,ao de uso geral e -b. Isso e usado para especificar a
   localizac,ao de uma imagem de inicializac,ao para uso na produc,ao de um
   CD inicializavel "El Torito". Essa opc,ao usa um argumento que e o caminho
   para uma imagem de inicializac,ao a partir do topo da arvore que esta
   sendo gravada no CD. Por padrao, o mkisofs cria uma imagem ISO no modo de
   "emulac,ao de disquete" e, portanto, espera que a imagem de inicializac,ao
   tenha exatamente 1200, 1440 ou 2880 KB de tamanho. Alguns gerenciadores de
   inicializac,ao, como o usado pela midia de distribuic,ao do FreeBSD, nao
   utilizam o modo de emulac,ao. Nesse caso, -no-emul-boot deve ser usado.
   Entao, se /tmp/myboot possuir um sistema FreeBSD inicializavel com a
   imagem de inicializac,ao em /tmp/myboot/boot/cdboot, este comando
   produziria /tmp/bootable.iso:

 # mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot

   A imagem ISO resultante pode ser montada como um disco de memoria com:

 # mdconfig -a -t vnode -f /tmp/bootable.iso -u 0
 # mount -t cd9660 /dev/md0 /mnt

   Pode-se entao verificar se /mnt e /tmp/myboot sao identicos.

   Existem muitas outras opc,oes disponiveis para mkisofs para ajustar seu
   comportamento. Consulte mkisofs(8) para obter detalhes.

  Nota:

   E possivel copiar um CD de dados para um arquivo de imagem que seja
   funcionalmente equivalente ao arquivo de imagem criado com mkisofs. Para
   fazer isso, use dd com o nome do dispositivo como o arquivo de entrada e o
   nome do ISO para criar como o arquivo de saida:

 # dd if=/dev/cd0 of=file.iso bs=2048

   O arquivo de imagem resultante pode ser gravado em CD, conforme descrito
   em Sec,ao 17.5.2, "Gravando um CD".

  17.5.4. Usando CDs de Dados

   Uma vez que uma ISO tenha sido gravada em um CD, ela pode ser montada
   especificando o tipo de sistema de arquivos, o nome do dispositivo que
   contem o CD e um ponto de montagem existente:

 # mount -t cd9660 /dev/cd0 /mnt

   Como mount assume que um sistema de arquivos e do tipo ufs, um erro
   Incorrect super block ocorrera se -t cd9660 nao esta incluido ao montar um
   arquivo de dados CD.

   Embora qualquer CD de dados possa ser montado dessa forma, discos com
   determinadas extensoes ISO 9660 podem se comportar de maneira estranha.
   Por exemplo, os discos Joliet armazenam todos os nomes de arquivos em
   caracteres Unicode de dois bytes. Se alguns caracteres nao ingleses
   aparecerem como pontos de interrogac,ao, especifique o conjunto de
   caracteres local com -C. Para mais informac,oes, consulte mount_cd9660(8).

  Nota:

   Para fazer esta conversao de caracteres com a ajuda de -C, o kernel requer
   que o modulo cd9660_iconv.ko seja carregado. Isto pode ser feito
   adicionando esta linha ao arquivo loader.conf:

 cd9660_iconv_load="YES"

   e reinicializando a maquina, ou carregando diretamente o modulo com
   kldload .

   Ocasionalmente, Device not configured sera exibido ao tentar montar um CD
   de dados. Isso geralmente significa que a unidade de CD nao detectou um
   disco na bandeja ou que a unidade nao esta visivel no barramento. Pode
   levar alguns segundos para que uma unidade de CD detecte a midia, por
   isso, seja paciente.

   As vezes, uma unidade de CD SCSI pode ser perdida porque nao teve tempo
   suficiente para responder `a reinicializac,ao do barramento. Para resolver
   isso, um kernel personalizado pode ser criado, o que aumenta o delay SCSI
   padrao. Adicione a seguinte opc,ao ao arquivo de configurac,ao do kernel
   personalizado e reconstrua o kernel usando as instruc,oes em Sec,ao 8.5,
   "Criando e Instalando um Kernel Customizado":

 options SCSI_DELAY=15000

   Isso faz com que o barramento SCSI fac,a uma pausa de 15 segundos durante
   a inicializac,ao, para dar `a unidade de CD todas as chances possiveis de
   responder `a reinicializac,ao do barramento.

  Nota:

   E possivel gravar um arquivo diretamente no CD, sem criar um sistema de
   arquivos ISO 9660. Isso e conhecido como gravac,ao de dados brutos em CD e
   algumas pessoas fazem isso para fins de backup.

   Este tipo de disco nao pode ser montado como um CD de dados normal. Para
   recuperar os dados gravados em um CD, os dados devem ser lidos no no do
   dispositivo bruto. Por exemplo, este comando ira extrair um arquivo tar
   compactado localizado no segundo dispositivo de CD para o diretorio de
   trabalho atual:

 # tar xzvf /dev/cd1

   Para montar um CD de dados, os dados devem ser escritos usando mkisofs.

  17.5.5. Duplicando CDs de Audio

   Para duplicar um CD de audio, extraia os dados de audio do CD para uma
   serie de arquivos e, em seguida, grave esses arquivos em um CD em branco.

   Procedimento 17.1, "Duplicando um CD de Audio" descreve como duplicar e
   gravar um CD de audio. Se a versao do FreeBSD for menor que 10.0 e o
   dispositivo for ATAPI, o modulo atapicam deve ser carregado primeiro
   usando as instruc,oes em Sec,ao 17.5.1, "Dispositivos Suportados".

   Procedimento 17.1. Duplicando um CD de Audio
    1. O pacote ou port sysutils/cdrtools instala o cdda2wav. Este comando
       pode ser usado para extrair todas as faixas de audio, com cada faixa
       gravada em um arquivo WAV separado no diretorio de trabalho atual:

 % cdda2wav -vall -B -Owav

       Um nome de dispositivo nao precisa ser especificado se houver apenas
       um dispositivo de CD no sistema. Consulte a pagina de manual cdda2wav
       para obter instruc,oes sobre como especificar um dispositivo e
       aprender mais sobre as outras opc,oes disponiveis para este comando.

    2. Use o cdrecord para escrever os arquivos .wav:

 % cdrecord -v dev=2,0 -dao -useinfo  *.wav

       Certifique-se de que 2,0 esteja configurado adequadamente, conforme
       descrito em Sec,ao 17.5.2, "Gravando um CD".

17.6. Criando e Usando Midia de DVD

   Contribuido por Marc Fonvieille.
   Com entradas de Andy Polyakov.

   Comparado ao CD, o DVD e a proxima gerac,ao de tecnologia de armazenamento
   de midia otica. O DVD pode conter mais dados do que qualquer CD e e o
   padrao para publicac,ao de videos.

   Cinco formatos gravaveis fisicos podem ser definidos para um DVD gravavel:

     * DVD-R: Este foi o primeiro formato gravavel disponivel em DVD. O
       padrao DVD-R e definido pelo DVD Forum. Este formato e escrito uma
       vez.

     * DVD-RW: Esta e a versao regravavel do padrao DVD-R. Um DVD-RW pode ser
       reescrito cerca de 1000 vezes.

     * DVD-RAM: Este e um formato regravavel que pode ser visto como um disco
       rigido removivel. No entanto, esta midia nao e compativel com a
       maioria das unidades e reprodutores de DVD-Video DVD-ROM, pois apenas
       alguns gravadores de DVD suportam o formato DVD-RAM. Consulte
       Sec,ao 17.6.8, "Usando um DVD-RAM" para mais informac,oes sobre o uso
       de DVD-RAM.

     * DVD+RW: Este e um formato regravavel definido pelo DVD+RW Alliance. Um
       DVD+RW pode ser reescrito cerca de 1000 vezes.

     * DVD+R: Este formato e a variac,ao de gravac,ao do formato DVD+RW.

   Um DVD gravavel de camada unica pode armazenar ate 4.700.000.000 bytes, o
   que e, na verdade, 4,38 GB ou 4485 MB, pois 1 kilobyte e 1024 bytes.

  Nota:

   Uma distinc,ao deve ser feita entre a midia fisica e a aplicac,ao. Por
   exemplo, um DVD-Video e um layout de arquivo especifico que pode ser
   gravado em qualquer midia fisica DVD gravavel, como DVD-R, DVD+R ou
   DVD-RW. Antes de escolher o tipo de midia, verifique se o gravador e o
   reprodutor de DVD-Video sao compativeis com a midia em questao.

  17.6.1. Configurac,ao

   Para executar a gravac,ao de um DVD, use growisofs(1). Este comando e
   parte dos utilitarios sysutils/dvd+rw-tools que suportam todos os tipos de
   midia DVD.

   Estas ferramentas usam o subsistema SCSI para acessar os dispositivos,
   portanto suporte a ATAPI/CAM deve ser carregado ou estaticamente compilado
   no kernel. Este suporte nao e necessario se o gravador usar a interface
   USB. Consulte Sec,ao 17.4, "Dispositivos de Armazenamento USB" para mais
   detalhes sobre a configurac,ao do dispositivo USB.

   O acesso DMA tambem deve estar ativado para dispositivos ATAPI,
   adicionando a seguinte linha ao arquivo /boot/loader.conf:

 hw.ata.atapi_dma="1"

   Antes de tentar usar dvd+rw-tools, consulte o Notas de compatibilidade de
   hardware.

  Nota:

   Para uma interface grafica de usuario, considere o uso de sysutils/k3b que
   fornece uma interface amigavel para growisofs(1) e muitas outras
   ferramentas de gravac,ao.

  17.6.2. Gravando DVDs de Dados

   Ja que growisofs(1) e um front-end para mkisofs, ele invocara mkisofs(8)
   para criar o layout do sistema de arquivos e executar a gravac,ao no DVD .
   Isso significa que uma imagem dos dados nao precisa ser criada antes do
   processo de gravac,ao.

   Para gravar em um DVD+R ou DVD-R os dados em /path/to/data, use o seguinte
   comando:

 # growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data

   Neste exemplo, -J -R e passado para mkisofs(8) para criar um sistemas de
   arquivos ISO 9660 com extensoes Joliet e Rock Ridge. Consulte o mkisofs(8)
   para obter mais detalhes.

   Para a gravac,ao inicial da sessao, -Z e usado para sessoes unicas e
   multiplas. Substitua /dev/cd0, com o nome do dispositivo de DVD. O uso de
   -dvd-compat indica que o disco sera fechado e que a gravac,ao sera
   inaplicavel. Isso tambem deve fornecer melhor compatibilidade de midia com
   unidades DVD-ROM.

   Para gravar uma imagem pre-masterizada, como imagefile.iso, use:

 # growisofs -dvd-compat -Z /dev/cd0=imagefile.iso

   A velocidade de gravac,ao deve ser detectada e configurada automaticamente
   de acordo com a midia e a unidade que esta sendo usada. Para forc,ar a
   velocidade de gravac,ao, use -speed=. Consulte o growisofs(1) para
   exemplos de uso.

  Nota:

   Para suportar arquivos de trabalho maiores que 4.38GB, um sistema de
   arquivos hibrido UDF/ISO-9660 deve ser criado passando -udf -iso-level 3
   para mkisofs(8) e todos os programas relacionados, como growisofs(1). Isso
   e necessario apenas ao criar um arquivo de imagem ISO ou ao gravar
   arquivos diretamente em um disco. Como um disco criado dessa maneira deve
   ser montado como um sistema de arquivos UDF com mount_udf(8), ele sera
   utilizavel apenas em um sistema operacional com suporte a UDF. Caso
   contrario, parecera que contem arquivos corrompidos.

   Para criar este tipo de arquivo ISO:

 % mkisofs -R -J -udf -iso-level 3 -o imagefile.iso /path/to/data

   Para gravar arquivos diretamente em um disco:

 # growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data

   Quando uma imagem ISO ja contem arquivos grandes, nenhuma opc,ao adicional
   e necessaria para o growisofs(1) gravar a imagem em um disco.

   Certifique-se de usar uma versao atualizada do port sysutils/cdrtools, que
   contenha o mkisofs(8), como uma versao mais antiga pode nao conter suporte
   a arquivos grandes. Se a versao mais recente nao funcionar, instale o
   sysutils/cdrtools-devel e leia o mkisofs(8).

  17.6.3. Gravando um DVD -Video

   Um DVD-Video e um layout de arquivo especifico baseado nas especificac,oes
   ISO 9660 e micro-UDF (M-UDF). Como o DVD-Video apresenta uma hierarquia de
   estrutura de dados especifica, um programa especifico como
   multimedia/dvdauthor e necessario para criar o DVD.

   Se uma imagem do sistema de arquivos DVD-Video ja existir, ela podera ser
   gravada da mesma maneira que qualquer outra imagem. Se o dvdauthor foi
   usado para criar o DVD e o resultado esta em /path/to/video, o seguinte
   comando deve ser usado para gravar o DVD-Video:

 # growisofs -Z /dev/cd0 -dvd-video /path/to/video

   -dvd-video e passado para o mkisofs(8) para instrui-lo a criar um sistemas
   de arquivos com layout DVD-Video. Esta opc,ao implica na opc,ao
   -dvd-compat do growisofs(1).

  17.6.4. Usando um DVD+RW

   Ao contrario do CD-RW, um DVD+RW virgem precisa ser formatado antes do
   primeiro uso. E recomendado para permitir que growisofs(1) cuide disso
   automaticamente sempre que apropriado. No entanto, e possivel usar
   dvd+rw-format para formatar o DVD+RW:

 # dvd+rw-format /dev/cd0

   Somente execute esta operac,ao uma vez e tenha em mente que apenas midias
   DVD+RW virgens precisam ser formatadas. Uma vez formatado, o DVD+RW pode
   ser gravado como de costume.

   Para gravar um sistema de arquivos totalmente novo e nao apenas
   acrescentar alguns dados em um DVD+RW, a midia nao precisa ser apagada
   primeiro. Em vez disso, escreva sobre a gravac,ao anterior assim:

 # growisofs -Z /dev/cd0 -J -R /path/to/newdata

   O formato DVD+RW suporta anexar dados a uma gravac,ao anterior. Essa
   operac,ao consiste em mesclar uma nova sessao `a existente, pois ela nao e
   considerada como gravac,ao de varias sessoes. growisofs(1) vai ampliar o
   sistema de arquivos ISO 9660 presente na midia.

   Por exemplo, para anexar dados a um DVD+RW, use o seguinte:

 # growisofs -M /dev/cd0 -J -R /path/to/nextdata

   As mesmas opc,oes do mkisofs(8) usadas para gravar a sessao inicial devem
   ser usadas durante as proximas gravac,oes.

  Nota:

   Use -dvd-compat para melhor compatibilidade de midia com as unidades de
   DVD-ROM. Ao usar DVD+RW, essa opc,ao nao impedira a adic,ao de dados.

   Para apagar a midia, use:

 # growisofs -Z /dev/cd0=/dev/zero

  17.6.5. Usando um DVD-RW

   Um DVD-RW aceita dois formatos de disco: sequencial incremental e
   substituic,ao restrita. Por padrao, os discos DVD-RW estao em formato
   sequencial.

   Um DVD-RW virgem pode ser escrito diretamente sem ser formatado. No
   entanto, um DVD-RW nao-virgem em formato sequencial precisa ser apagado
   antes de escrever uma nova sessao inicial.

   Para apagar um DVD-RW em modo sequencial:

 # dvd+rw-format -blank=full /dev/cd0

  Nota:

   Um preenchimento completo usando -blank=full levara cerca de uma hora em
   uma midia 1x. Um limpeza rapida pode ser executada usando -blank, se o
   DVD-RW for gravado no modo Disk-At-Once (DAO). Para gravar o DVD-RW no
   modo DAO, use o comando:

 # growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso

   Como o growisofs(1) tenta automaticamente detectar a midia rapidamente em
   branco e ativar a gravac,ao do DAO, -use-the-force -luke=dao nao deve ser
   requerido.

   Em vez disso, deve-se usar o modo de sobrescrita restrita com qualquer
   DVD-RW, pois esse formato e mais flexivel do que o padrao de sequencial
   incremental.

   Para escrever dados em um DVD-RW sequ:encial, use as mesmas instruc,oes
   que para os outros formatos de DVD:

 # growisofs -Z /dev/cd0 -J -R /path/to/data

   Para acrescentar alguns dados a uma gravac,ao anterior, use -M com o
   growisofs(1). No entanto, se os dados forem anexados em um DVD-RW no modo
   sequencial incremental, uma nova sessao sera criada no disco e o resultado
   sera um disco multi-sessao.

   Um DVD-RW no formato de sobrescrita restrita nao precisa ser em apagado
   antes de uma nova sessao inicial. Em vez disso, sobrescreva o disco com
   -Z. Tambem e possivel aumentar um sistema de arquivos ISO 9660 existente
   escrito no disco com -M. O resultado sera um DVD de uma sessao.

   Para colocar um DVD-RW no formato de sobrescrita restrita, o seguinte
   comando deve ser usado:

 # dvd+rw-format /dev/cd0

   Para voltar ao formato sequencial, use:

 # dvd+rw-format -blank=full /dev/cd0

  17.6.6. Multi-Sessao

   Poucas unidades de DVD-ROM suportam DVDs multi-sessao e na maioria das
   vezes apenas leem a primeira sessao. DVD+R, DVD-R e DVD-RW em formato
   sequencial podem aceitar varias sessoes. A noc,ao de varias sessoes nao
   existe para os formatos de sobrescrita restrita DVD+RW e DVD-RW.

   Usando o seguinte comando apos uma sessao inicial nao fechada em um DVD+R,
   DVD-R ou DVD-RW em formato sequencial, sera adicionada uma nova sessao ao
   disco:

 # growisofs -M /dev/cd0 -J -R /path/to/nextdata

   Usando este comando com um DVD+RW ou um DVD-RW no modo de sobrescrita
   restrita adicionara dados ao mesclar a nova sessao `a existente. O
   resultado sera um disco de sessao unica. Use este metodo para adicionar
   dados apos uma gravac,ao inicial nesses tipos de midia.

  Nota:

   Como algum espac,o na midia e usado entre cada sessao para marcar o final
   e o inicio das sessoes, deve-se adicionar sessoes com uma grande
   quantidade de dados para otimizar o espac,o da midia. O numero de sessoes
   e limitado a 154 para um DVD+R, cerca de 2000 para um DVD-R e 127 para um
   DVD+R Double Layer.

  17.6.7. Para Maiores Informac,oes

   Para obter mais informac,oes sobre um DVD, use o dvd+rw-mediainfo /dev/cd0
   enquanto o disco estiver na unidade especificada.

   Mais informac,oes sobre dvd+rw-tools podem ser encontradas em
   growisofs(1), no site de dvd+rw-tools, e nos arquivos do cdwrite mailing
   list.

  Nota:

   Ao criar um relatorio de problemas relacionado ao uso de dvd+rw-tools,
   inclua sempre a saida de dvd+rw-mediainfo.

  17.6.8. Usando um DVD-RAM

   Os gravadores de DVD-RAM podem usar uma interface SCSI ou ATAPI. Para
   dispositivos ATAPI, o acesso DMA deve ser ativado adicionando a seguinte
   linha ao arquivo /boot/loader.conf:

 hw.ata.atapi_dma="1"

   Um DVD-RAM pode ser visto como um disco rigido removivel. Como qualquer
   outro disco rigido, o DVD-RAM deve ser formatado antes de poder ser usado.
   Neste exemplo, todo o espac,o em disco sera formatado com um sistema de
   arquivos UFS2 padrao:

 # dd if=/dev/zero of=/dev/acd0 bs=2k count=1
 # bsdlabel -Bw acd0
 # newfs /dev/acd0

   O dispositivo DVD, acd0, deve ser alterado de acordo com a configurac,ao.

   Uma vez que o DVD-RAM tenha sido formatado, ele pode ser montado como um
   disco rigido normal:

 # mount /dev/acd0 /mnt

   Uma vez montado, o DVD-RAM sera legivel e gravavel.

17.7. Criando e Usando Disquetes

   Esta sec,ao explica como formatar um disquete de 3.5 polegadas no FreeBSD.

   Procedimento 17.2. Etapas para Formatar um Disquete

   Um disquete precisa ser formatado em baixo nivel antes de poder ser usado.
   Isso geralmente e feito pelo fornecedor, mas a formatac,ao e uma boa
   maneira de verificar a integridade da midia. Para o formato de baixo nivel
   do disquete no FreeBSD, use fdformat(1). Ao usar esse utilitario, anote
   todas as mensagens de erro, pois elas podem ajudar a determinar se o disco
   esta bom ou ruim.

    1. Para formatar o disquete, insira um novo disquete de 3.5 polegadas na
       primeira unidade de disquete e digite:

 # /usr/sbin/fdformat -f 1440 /dev/fd0

    2. Apos a formatac,ao de baixo nivel do disco, crie um rotulo de disco
       conforme requerido pelo sistema para determinar o tamanho do disco e
       sua geometria. Os valores de geometria suportados estao listados no
       arquivo /etc/disktab.

       Para escrever o rotulo do disco, use bsdlabel(8):

 # /sbin/bsdlabel -B -w /dev/fd0 fd1440

    3. O disquete agora esta pronto para ser formatado em alto nivel com um
       sistema de arquivos. O sistema de arquivos do disquete pode ser UFS ou
       FAT, onde o FAT geralmente e uma opc,ao melhor para disquetes.

       Para formatar o disquete com o FAT, digite:

 # /sbin/newfs_msdos /dev/fd0

   O disco esta agora pronto para uso. Para usar o disquete, monte-o com
   mount_msdosfs(8). Tambem e possivel instalar e usar emulators/mtools da
   colec,ao de ports.

17.8. Noc,oes Basicas de Backup

   A implementac,ao de um plano de backup e essencial para que seja possivel
   recuperar de uma falha de disco, exclusao acidental de arquivos,
   corrupc,ao aleatoria de arquivos ou destruic,ao completa da maquina,
   incluindo a destruic,ao de backups no local.

   O tipo e a programac,ao do backup variam, dependendo da importancia dos
   dados, da granularidade necessaria para as restaurac,oes de arquivos e da
   quantidade de tempo de inatividade aceitavel. Algumas tecnicas de backup
   possiveis incluem:

     * Arquivos de todo o sistema, protegidos por meio de backups em midias
       permanentes, armazenados off-site. Isso fornece protec,ao contra todos
       os problemas listados acima, mas e lento e inconveniente para
       restaurar, especialmente para usuarios sem privilegios.

     * Snapshots do sistema de arquivos, que sao uteis para restaurar
       arquivos excluidos ou versoes anteriores de arquivos.

     * Copias de sistemas de arquivos inteiros ou discos que sao
       sincronizados com outro sistema na rede usando um net/rsync agendado.

     * RAID por hardware ou software, que minimiza ou evita paralisac,oes
       quando um disco falha.

   Normalmente, uma mistura de tecnicas de backup e usada. Por exemplo,
   pode-se criar um agendamento semanal para automatizar um backup completo
   do sistema e armazena-lo off-site e para suplementa-lo, snapshots do ZFS
   tirados a cada hora. Alem disso, e possivel fazer um backup manual de
   diretorios ou arquivos individuais antes de fazer edic,oes ou exclusoes de
   arquivos.

   Esta sec,ao descreve alguns dos utilitarios que podem ser usados para
   criar e gerenciar backups em um sistema FreeBSD.

  17.8.1. Backups do Sistema de Arquivos

   Os programas tradicionais UNIX(R) para fazer backup de um sistema de
   arquivos sao dump(8), que cria o backup, e restore(8), que restaura o
   backup. Esses utilitarios funcionam no nivel do bloco do disco, abaixo das
   abstrac,oes dos arquivos, links e diretorios criados pelos sistemas de
   arquivos. Ao contrario de outros softwares de backup, dump faz backup de
   todo um sistema de arquivos e nao e capaz de fazer backup de apenas parte
   de um sistema de arquivos ou de uma arvore de diretorios que abrange
   varios sistemas de arquivos. Em vez de gravar arquivos e diretorios, dump
   grava os blocos de dados brutos que compreendem arquivos e diretorios.

  Nota:

   Se o dump for usado no diretorio raiz, ele nao fara o backup de /home,
   /usr ou de muitos outros diretorios, pois eles sao tipicamente pontos de
   montagem para outros sistemas de arquivos ou links simbolicos nesses
   sistemas de arquivos.

   Quando usado para restaurar dados, restore armazena arquivos temporarios
   em /tmp/ por padrao. Ao usar um disco de recuperac,ao com um pequeno /tmp,
   configure TMPDIR para um diretorio com mais espac,o livre para que a
   restaurac,ao seja bem-sucedida.

   Ao usar dump, esteja ciente de que algumas peculiaridades permanecem desde
   seus primeiros dias na versao 6 do AT&T UNIX(R), por volta de 1975. Os
   parametros padrao assumem um backup para uma fita de 9 faixas, em vez de
   para outro tipo de midia ou para as fitas de alta densidade disponiveis
   atualmente. Esses padroes devem ser substituidos na linha de comando.

   E possivel fazer backup de um sistema de arquivos pela rede para outro
   sistema ou para uma unidade de fita conectada a outro computador. Enquanto
   os utilitarios rdump(8) e rrestore(8) possam ser usado para este
   proposito, eles nao sao considerados seguros.

   Em vez disso, pode-se usar dump e restore de uma maneira mais segura em
   uma conexao SSH. Este exemplo cria um backup completo e compactado de /usr
   e envia o arquivo de backup para o host especificado em uma conexao SSH.

   Exemplo 17.1. Usando dump sobre ssh

 # /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
           targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz

   Este exemplo configura RSH para gravar o backup em uma unidade de fita em
   um sistema remoto atraves de uma conexao SSH:

   Exemplo 17.2. Usando o dump sobre ssh com o RSH configurado

 # env RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr

  17.8.2. Backups de Diretorio

   Varios utilitarios integrados estao disponiveis para backup e restaurac,ao
   de arquivos e diretorios especificados, conforme necessario.

   Uma boa alternativa para fazer backup de todos os arquivos em um diretorio
   e o tar(1). Este utilitario remonta `a versao 6 do AT&T UNIX(R) e, por
   padrao, assume um backup recursivo para um dispositivo de fita local.
   Redirecionadores podem ser utilizados para especificar o nome de um
   arquivo de backup.

   Este exemplo cria um backup compactado do diretorio atual e o salva no
   arquivo /tmp/mybackup.tgz. Ao criar um arquivo de backup, verifique se o
   backup nao esta salvo no mesmo diretorio em que esta sendo feito backup.

   Exemplo 17.3. Fazendo Backup do Diretorio Atual com o tar

 # tar czvf /tmp/mybackup.tgz .

   Para restaurar o backup inteiro, cd no diretorio para restaurar e
   especificar o nome do backup. Observe que isso sobrescrevera qualquer
   versao mais nova de arquivos no diretorio de restaurac,ao. Em caso de
   duvida, restaure para um diretorio temporario ou especifique o nome do
   arquivo dentro do backup a ser restaurado.

   Exemplo 17.4. Restaurando o Diretorio Atual com o tar

 # tar xzvf /tmp/mybackup.tgz

   Existem dezenas de opc,oes disponiveis, descritas em tar(1). Esse
   utilitario tambem suporta o uso de padroes de exclusao para especificar
   quais arquivos nao devem ser incluidos ao fazer backup do diretorio
   especificado ou restaurar arquivos de um backup.

   Para criar um backup usando uma lista especificada de arquivos e
   diretorios, cpio(1) e uma boa escolha. Ao contrario do tar, o cpio nao
   sabe como percorrer a arvore de diretorios e deve fornecer a lista de
   arquivos para backup.

   Por exemplo, uma lista de arquivos pode ser criada usando ls ou find. Este
   exemplo cria uma listagem recursiva do diretorio atual que e entao
   canalizado para o cpio para criar um arquivo de backup de saida chamado
   /tmp/mybackup.cpio.

   Exemplo 17.5. Usando ls e cpio para Criar um Backup Recursivo do Diretorio
   Atual

 # ls -R | cpio -ovF /tmp/mybackup.cpio

   Um utilitario de backup que tenta conectar os recursos fornecidos pelo tar
   e cpio e pax(1). Ao longo dos anos, as varias versoes do tar e do cpio
   tornaram-se ligeiramente incompativeis. POSIX(R) criou pax que tenta ler e
   escrever muitos dos varios formatos cpio e tar, alem de novos formatos
   proprios.

   O pax equivalente aos exemplos anteriores seria:

   Exemplo 17.6. Fazendo Backup do Diretorio Atual com pax

 # pax -wf /tmp/mybackup.pax .

  17.8.3. Usando Fitas de Dados para Backups

   Embora a tecnologia de fitas tenha continuado a evoluir, os sistemas de
   backup modernos tendem a combinar backups externos com midias removiveis
   locais. O FreeBSD suporta qualquer unidade de fita que use SCSI, como LTO
   ou DAT. Ha suporte limitado para as unidades de fita SATA e USB.

   Para dispositivos de fita SCSI, o FreeBSD usa o driver sa(4) e os
   dispositivos /dev/sa0, /dev/nsa0 e /dev/esa0. O nome do dispositivo fisico
   e /dev/sa0. Quando /dev/nsa0 e usado, o aplicativo de backup nao rebobina
   a fita depois de gravar um arquivo, o que permite gravar mais de um
   arquivo em uma fita. O uso de /dev/esa0 ejeta a fita apos o dispositivo
   ser fechado.

   No FreeBSD, o mt e usado para controlar as operac,oes da unidade de fita,
   como procurar arquivos em uma fita ou gravar marcas de controle na fita.
   Por exemplo, os tres primeiros arquivos em uma fita podem ser preservados,
   ignorando-os antes de gravar um novo arquivo:

 # mt -f /dev/nsa0 fsf 3

   Este utilitario suporta muitas operac,oes. Consulte mt(1) para detalhes.

   Para gravar um unico arquivo em fita usando tar, especifique o nome do
   dispositivo de fita e o arquivo para backup:

 # tar cvf /dev/sa0 file

   Para recuperar arquivos de um arquivo tar em fita no diretorio atual:

 # tar xvf /dev/sa0

   Para fazer backup de um sistema de arquivos UFS, use dump. Este exemplo
   faz o backup de /usr sem rebobinar a fita quando terminar:

 # dump -0aL -b64 -f /dev/nsa0 /usr

   Para restaurar arquivos interativamente de um arquivo dump em fita no
   diretorio atual:

 # restore -i -f /dev/nsa0

  17.8.4. Utilitarios de Backup de Terceiros

   A Colec,ao de Ports do FreeBSD fornece muitos utilitarios de terceiros que
   podem ser usados para agendar a criac,ao de backups, simplificar o backup
   em fita e tornar os backups mais faceis e convenientes. Muitos desses
   aplicativos sao baseados em cliente/servidor e podem ser usados para
   automatizar os backups de um unico sistema ou de todos os computadores em
   uma rede.

   Os utilitarios populares incluem Amanda, Bacula, rsync e duplicity.

  17.8.5. Recuperac,ao de Emergencia

   Alem dos backups regulares, e recomendavel executar as etapas a seguir
   como parte de um plano de preparac,ao para emergencias.

   Crie uma copia impressa da saida dos seguintes comandos:

     * gpart show

     * more /etc/fstab

     * dmesg

   Armazene esta saida e uma copia da midia de instalac,ao em um local
   seguro. Se uma restaurac,ao de emergencia for necessaria, inicialize na
   midia de instalac,ao e selecione Live CD para acessar um shell de
   recuperac,ao. Esse modo de recuperac,ao pode ser usado para exibir o
   estado atual do sistema e, se necessario, reformatar discos e restaurar
   dados de backups.

  Nota:

   A midia de instalac,ao do FreeBSD/i386 11.2-RELEASE nao inclui um shell de
   recuperac,ao. Para esta versao, baixe e grave uma imagem do Livefs CD de
   ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/11.2/FreeBSD-11.2-RELEASE-i386-livefs.iso.

   Em seguida, teste o shell de recuperac,ao e os backups. Fac,a anotac,oes
   do procedimento. Armazene estas notas com a midia, as impressoes e os
   backups. Estas notas podem impedir a destruic,ao inadvertida dos backups,
   enquanto sob o estresse de realizar uma recuperac,ao de emergencia.

   Para uma medida adicional de seguranc,a, armazene o backup mais recente em
   um local remoto, fisicamente separado dos computadores e das unidades de
   disco por uma distancia significativa.

17.9. Discos de Memoria

   Reorganizado e aprimorado por Marc Fonvieille.

   Alem de discos fisicos, o FreeBSD tambem suporta a criac,ao e uso de
   discos de memoria. Um uso possivel para um disco de memoria e acessar o
   conteudo de um sistema de arquivos ISO sem a sobrecarga de primeiro
   grava-lo em um CD ou DVD e, em seguida, montar a midia CD/DVD .

   No FreeBSD, o driver md(4) e usado para fornecer suporte para discos de
   memoria. O kernel GENERIC inclui este driver. Ao usar um arquivo de
   configurac,ao de kernel personalizado, certifique-se de incluir esta
   linha:

 device md

  17.9.1. Anexando e Desanexando Imagens Existentes

   Para montar uma imagem do sistema de arquivos existente, use o mdconfig
   para especificar o nome do arquivo ISO e um numero de unidade livre. Em
   seguida, consulte esse numero de unidade para monta-lo em um ponto de
   montagem existente. Uma vez montado, os arquivos na imagem ISO aparecerao
   no ponto de montagem. Este exemplo anexa o arquivo diskimage.iso ao
   dispositivo de memoria /dev/md0 e monta o dispositivo de memoria em /mnt:

 # mdconfig -f diskimage.iso -u 0
 # mount -t cd9660 /dev/md0 /mnt

   Note que -t cd9660 foi usado para montar uma imagem ISO. Se um numero de
   unidade nao for especificado com -u, o mdconfig alocara automaticamente um
   dispositivo de memoria nao utilizado e exibira o nome da unidade alocada,
   como md4. Consulte mdconfig(8) para mais detalhes sobre este comando e
   suas opc,oes.

   Quando um disco de memoria nao esta mais em uso, seus recursos devem ser
   liberados de volta ao sistema. Primeiro, desmonte o sistema de arquivos e
   use o mdconfig para desanexar o disco do sistema e liberar seus recursos.
   Para continuar este exemplo:

 # umount /mnt
 # mdconfig -d -u 0

   Para determinar se algum disco de memoria ainda esta conectado ao sistema,
   digite mdconfig -l.

  17.9.2. Criando um Disco Virtual Baseado em Arquivo ou Memoria

   O FreeBSD tambem suporta discos virtuais onde o armazenamento a ser
   utilizado e alocado a partir de um disco rigido ou de uma area de memoria.
   O primeiro metodo e comumente referido como um disco virtual baseado em
   arquivo e o segundo como um disco virtual baseado em memoria. Ambos os
   tipos podem ser criados usando o mdconfig.

   Para criar um novo disco virtual baseado em memoria, especifique um tipo
   de swap e o tamanho do disco de memoria a ser criado. Em seguida, formate
   o disco de memoria com um sistema de arquivos e monte como de costume.
   Este exemplo cria um disco de memoria de 5M na unidade 1. Esse disco de
   memoria e formatado com o sistema de arquivos UFS antes de ser montado:

 # mdconfig -a -t swap -s 5m -u 1
 # newfs -U md1
 /dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
         using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.
         with soft updates
 super-block backups (for fsck -b #) at:
  160, 2752, 5344, 7936
 # mount /dev/md1 /mnt
 # df /mnt
 Filesystem 1K-blocks Used Avail Capacity  Mounted on
 /dev/md1        4718    4  4338     0%    /mnt

   Para criar um novo disco virtual baseado em arquivo, primeiro aloque a
   area que sera usada para o disco. Esse exemplo cria um arquivo vazio de
   5MB chamado newimage:

 # dd if=/dev/zero of=newimage bs=1k count=5k
 5120+0 records in
 5120+0 records out

   Em seguida, anexe esse arquivo a um disco de memoria, rotule o disco de
   memoria e formate-o com o sistema de arquivos UFS, monte o disco de
   memoria e verifique o tamanho do disco com backup de arquivo:

 # mdconfig -f newimage -u 0
 # bsdlabel -w md0 auto
 # newfs -U md0a
 /dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048
         using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.
 super-block backups (for fsck -b #) at:
  160, 2720, 5280, 7840
 # mount /dev/md0a /mnt
 # df /mnt
 Filesystem 1K-blocks Used Avail Capacity  Mounted on
 /dev/md0a       4710    4  4330     0%    /mnt

   Sao necessarios varios comandos para criar um disco virtual baseado em
   arquivo ou memoria usando mdconfig. O FreeBSD tambem vem com o mdmfs que
   configura automaticamente um disco de memoria, formata-o com o sistema de
   arquivos UFS e o monta. Por exemplo, depois de criar newimage com dd, esse
   comando e equivalente a executar os comandos bsdlabel, newfs e mount
   mostrados acima:

 # mdmfs -F newimage -s 5m md0 /mnt

   Para criar um novo disco virtual baseado em memoria com o mdmfs, use este
   comando:

 # mdmfs -s 5m md1 /mnt

   Se o numero da unidade nao for especificado, o mdmfs selecionara
   automaticamente um dispositivo de memoria nao utilizado. Para mais
   detalhes sobre mdmfs, consulte mdmfs(8).

17.10. Snapshots de Sistemas de Arquivos

   Contribuido por Tom Rhodes.

   O FreeBSD oferece um recurso em conjunto com Atualizac,oes Soft: snapshots
   do sistema de arquivos.

   Os Snapshots de UFS permitem que um usuario crie imagens de sistemas de
   arquivos especificados e as trate como um arquivo. Os arquivos de snapshot
   devem ser criados no sistema de arquivos no qual a ac,ao e executada e um
   usuario pode criar no maximo 20 snapshots por sistema de arquivos. Os
   snapshots ativos sao registradas no superbloco, de modo que sao
   persistentes nas operac,oes de desmontagem e remontagem, juntamente com
   reinicializac,oes do sistema. Quando um snapshot nao e mais necessario,
   ele pode ser removido usando rm( 1). Embora os snapshots possam ser
   removidos em qualquer ordem, todo o espac,o usado pode nao ser adquirido
   porque outro snapshot possivelmente reivindicara alguns dos blocos
   liberados.

   A flag de arquivo snapshot nao alteravel e definida por mksnap_ffs(8) apos
   a criac,ao inicial de um arquivo de snapshot. O unlink(1) cria uma
   excec,ao para arquivos de snapshots, pois permite que sejam removidos.

   Os snapshots sao criados usando mount(8). Para colocar um snapshot de /var
   no arquivo /var/snapshot/snap, use o seguinte comando:

 # mount -u -o snapshot /var/snapshot/snap /var

   Como alternativa, use mksnap_ffs(8) para criar o snapshot:

 # mksnap_ffs /var /var/snapshot/snap

   E possivel encontrar arquivos de snapshots em um sistema de arquivos, como
   /var, usando find(1):

 # find /var -flags snapshot

   Depois que um snapshot foi criado, ele tem varios usos:

     * Alguns administradores usarao um arquivo de snapshot para fins de
       backup, porque o snapshot pode ser transferido para um CDs ou fita.

     * O verificador de integridade do sistema de arquivos, fsck(8), pode ser
       executado em um snapshot. Supondo que o sistema de arquivos estava
       limpo quando foi montado, isso deve sempre fornecer um resultado limpo
       e imutavel.

     * Executando dump(8) em um snapshot produzira um arquivo de dump que
       seja consistente com o sistema de arquivos e o registro de data e hora
       do snapshot. dump(8) tambem pode criar um snapshot, criar uma imagem
       de dump e remover o snapshot em um comando usando -L.

     * O snapshot pode ser montado como uma imagem congelada do sistema de
       arquivos. Para montar o snapshot use mount(8) passando o nome do
       snapshot /var/snapshot/snap:

 # mdconfig -a -t vnode -o readonly -f /var/snapshot/snap -u 4
 # mount -r /dev/md4 /mnt

   O /var congelado agora esta disponivel atraves de /mnt. Tudo estara
   inicialmente no mesmo estado que estava quando o snapshot foi criado. A
   unica excec,ao e que os snapshots anteriores aparecerao como arquivos com
   comprimento zero. Para desmontar o snapshot, use:

 # umount /mnt
 # mdconfig -d -u 4

   Para obter mais informac,oes sobre softupdates e snapshots do sistema de
   arquivos, incluindo documentos tecnicos, visite o site do Marshall Kirk
   McKusick em http://www.mckusick.com/.

17.11. Cotas de Disco

   As cotas de disco podem ser usadas para limitar a quantidade de espac,o em
   disco ou o numero de arquivos que um usuario ou membros de um grupo podem
   alocar em uma base por sistema de arquivos. Isso impede que um usuario ou
   grupo de usuarios consuma todo o espac,o em disco disponivel.

   Esta sec,ao descreve como configurar cotas de disco para o sistema de
   arquivos UFS. Para configurar cotas no sistema de arquivos ZFS, consulte
   Sec,ao 19.4.8, "Cotas para Datasets, Usuarios e Grupos"

  17.11.1. Habilitando Cotas de Disco

   Para determinar se o kernel do FreeBSD fornece suporte para cotas de
   disco:

 % sysctl kern.features.ufs_quota
 kern.features.ufs_quota: 1

   Neste exemplo, o 1 indica suporte `a cota. Se o valor for 0, adicione a
   seguinte linha a um arquivo de configurac,ao de kernel personalizado e
   reconstrua o kernel usando as instruc,oes em Capitulo 8, Configurando o
   kernel do FreeBSD:

 options QUOTA

   Em seguida, habilite as cotas de disco no arquivo /etc/rc.conf:

 quota_enable="YES"

   Normalmente, na inicializac,ao, a integridade da cota de cada sistema de
   arquivos e verificada por quotacheck(8). Esse programa garante que os
   dados no banco de dados de cotas reflitam adequadamente os dados no
   sistema de arquivos. Este e um processo demorado que afetara
   significativamente o tempo que o sistema leva para inicializar. Para pular
   este passo, adicione esta variavel ao arquivo /etc/rc.conf:

 check_quotas="NO"

   Por fim, edite o arquivo /etc/fstab para habilitar as cotas de disco por
   sistema de arquivos. Para habilitar cotas por usuario em um sistema de
   arquivos, adicione userquota ao campo de opc,oes na entrada /etc/fstab
   para o sistema de arquivos ativar as cotas. Por exemplo:

 /dev/da1s2g   /home    ufs rw,userquota 1 2

   Para ativar cotas de grupo, use groupquota. Para ativar cotas de usuarios
   e grupos, separe as opc,oes com uma virgula:

 /dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2

   Por padrao, os arquivos de cota sao armazenados no diretorio raiz do
   sistema de arquivos como quota.user e quota.group. Consulte fstab(5) para
   obter mais informac,oes. Especificar um local alternativo para os arquivos
   de cotas nao e recomendado.

   Quando a configurac,ao estiver concluida, reinicialize o sistema e o
   /etc/rc executara automaticamente os comandos apropriados para criar os
   arquivos de cotas iniciais para todas as cotas ativadas em /etc/fstab.

   No curso normal das operac,oes, nao deve haver necessidade de executar
   manualmente o quotacheck(8), quotaon(8), ou quotaoff(8). No entanto,
   deve-se ler estas paginas de manual para se familiarizar com sua
   operac,ao.

  17.11.2. Definindo Limites de Cota

   Para verificar se as cotas estao ativadas, execute:

 # quota -v

   Deve haver um resumo de uma linha sobre o uso de disco e limites de cota
   atuais para cada sistema de arquivos em que as cotas estao ativadas.

   O sistema agora esta pronto para receber limites de cota com edquota.

   Varias opc,oes estao disponiveis para impor limites `a quantidade de
   espac,o em disco que um usuario ou grupo pode alocar e quantos arquivos
   eles podem criar. As alocac,oes podem ser limitadas com base no espac,o em
   disco (cotas de bloco), no numero de arquivos (cotas de inode) ou em uma
   combinac,ao de ambos. Cada limite e subdividido em duas categorias:
   limites rigidos e flexiveis.

   Um limite rigido nao pode ser excedido. Quando um usuario atinge um limite
   rigido, nenhuma outra alocac,ao pode ser feita nesse sistema de arquivos
   por esse usuario. Por exemplo, se o usuario tiver um limite rigido de 500
   kbytes em um sistema de arquivos e estiver usando atualmente 490 kbytes, o
   usuario podera alocar apenas 10 kbytes adicionais. A tentativa de alocar
   11 kbytes adicionais falhara.

   Os limites flexiveis podem ser excedidos por um periodo de tempo limitado,
   conhecido como periodo de tolerancia, que e uma semana por padrao. Se um
   usuario permanecer acima do limite por mais tempo do que o periodo de
   carencia, o limite flexivel se tornara um limite rigido e nenhuma outra
   alocac,ao sera permitida. Quando o usuario cai abaixo do limite flexivel,
   o periodo de carencia e zerado.

   No exemplo a seguir, a cota da conta test esta sendo editada. Quando
   edquota e invocado, o editor especificado por EDITOR e aberto para editar
   os limites de cota. O editor padrao e configurado para vi.

 # edquota -u test
 Quotas for user test:
 /usr: kbytes in use: 65, limits (soft = 50, hard = 75)
         inodes in use: 7, limits (soft = 50, hard = 60)
 /usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
         inodes in use: 0, limits (soft = 50, hard = 60)

   Normalmente, ha duas linhas para cada sistema de arquivos com cotas
   ativadas. Uma linha representa os limites do bloco e a outra representa os
   limites do inode. Altere o valor para modificar o limite de cota. Por
   exemplo, para aumentar o limite de blocos em /usr para um limite flexivel
   de 500 e um limite rigido de 600, altere os valores nesse campo. linha da
   seguinte forma:

 /usr: kbytes in use: 65, limits (soft = 500, hard = 600)

   Os novos limites de cotas entram em vigor ao sair do editor.

   As vezes, e desejavel definir limites de cota em varios usuarios. Isso
   pode ser feito primeiro atribuindo o limite de cota desejado a um usuario.
   Em seguida, use -p para duplicar essa cota para um intervalo especificado
   de IDs de usuario (UIDs). O comando a seguir duplicara esses limites de
   cota para UIDs de 10.000 ate 19.999:

 # edquota -p test 10000-19999

   Para mais informac,oes, consulte edquota(8).

  17.11.3. Verificando Limites de Cota e Uso de Disco

   Para verificar cotas individuais de usuarios ou de grupos e uso de disco,
   use quota(1). Um usuario so pode examinar sua propria cota e a cota de um
   grupo do qual e membro. Somente o superusuario pode visualizar todas as
   cotas de usuarios e grupos. Para obter um resumo de todas as cotas e uso
   de disco para sistemas de arquivos com cotas ativadas, use repquota(8).

   Normalmente, os sistemas de arquivos nos quais o usuario nao esta usando
   nenhum espac,o em disco nao serao exibidos na saida de quota, mesmo que o
   usuario tenha um limite de cota atribuido a esse sistema de arquivos. Use
   -v para exibir esses sistemas de arquivos. A seguir esta a saida de
   amostra de quota -v para um usuario que possui limites de cota em dois
   sistemas de arquivos.

 Disk quotas for user test (uid 1002):
      Filesystem  usage    quota   limit   grace   files   quota   limit   grace
            /usr      65*     50      75   5days       7      50      60
        /usr/var       0      50      75               0      50      60

   Neste exemplo, o usuario esta atualmente 15 kbytes sobre o limite flexivel
   de 50 kbytes em /usr e tem 5 dias de periodo de carencia restante. O
   asterisco * indica que o usuario esta atualmente acima do limite de cota.

  17.11.4. Quotas sobre o NFS

   As cotas sao impostas pelo subsistema de cotas no servidor NFS. O daemon
   rpc.rquotad(8) disponibiliza informac,oes de quota para quota em clientes
   NFS, permitindo que os usuarios nessas maquinas visualizem suas
   estatisticas de cota.

   No servidor NFS, ative o rpc.rquotad removendo o # desta linha em
   /etc/inetd.conf:

 rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad

   Em seguida, reinicie o inetd:

 # service inetd restart

17.12. Criptografando Partic,oes de Disco

   Contribuido por Lucky Green.

   O FreeBSD oferece excelentes protec,oes on-line contra acesso nao
   autorizado a dados. As permissoes de arquivo e o Mandatory Access Control
   (MAC) ajudam a impedir que usuarios nao autorizados acessem dados enquanto
   o sistema operacional esta ativo e o computador esta ligado. No entanto,
   as permissoes impostas pelo sistema operacional sao irrelevantes se um
   invasor tiver acesso fisico a um computador e puder mover o disco rigido
   do computador para outro sistema para copiar e analisar os dados.

   Independentemente de como um invasor pode ter acesso a um disco rigido ou
   um computador desligado, os subsistemas criptograficos baseados em GEOM
   incorporados ao FreeBSD sao capazes de proteger os dados nos sistemas de
   arquivos do computador contra atacantes super motivados com recursos
   significativos. Ao contrario dos metodos de criptografia que criptografam
   arquivos individuais, os utilitarios incorporados gbde e geli podem ser
   usados para criptografar de forma transparente sistemas de arquivos
   inteiros. Nenhum dado aberto sequer toca na bandeja do disco rigido.

   Este capitulo demonstra como criar um sistema de arquivos criptografado no
   FreeBSD. Primeiro ele demonstra o processo usando o gbde e depois
   demonstra o mesmo exemplo usando geli.

  17.12.1. Criptografia de Disco com gbde

   O objetivo do utilitario gbde(4) e fornecer um desafio formidavel para que
   um invasor que tenha acesso ao conteudo de um dispositivo de armazenamento
   frio. No entanto, se o computador for comprometido enquanto estiver em
   funcionamento e o dispositivo de armazenamento estiver ativamente
   conectado, ou se o invasor tiver acesso a uma frase secreta valida, ele
   nao oferecera protec,ao ao conteudo do dispositivo de armazenamento.
   Portanto, e importante fornecer seguranc,a fisica enquanto o sistema esta
   em execuc,ao e proteger a frase secreta usada pelo mecanismo de
   criptografia.

   Este recurso oferece varias barreiras para proteger os dados armazenados
   em cada setor de disco. Ele criptografa o conteudo de um setor de disco
   usando o AES de 128 bits no modo CBC. Cada setor no disco e criptografado
   com uma chave AES diferente. Para obter mais informac,oes sobre o design
   criptografico, incluindo como as chaves do setor sao derivadas da frase
   secreta fornecida pelo usuario, consulte gbde(4).

   O FreeBSD fornece um modulo do kernel para gbde, que pode ser carregado
   com este comando:

 # kldload geom_bde

   Se estiver usando um arquivo de configurac,ao de kernel personalizado,
   certifique-se de que ele contenha esta linha:

   options GEOM_BDE

   O exemplo a seguir demonstra a adic,ao de um novo disco rigido a um
   sistema que contera uma unica partic,ao criptografada que sera montada
   como /private.

   Procedimento 17.3. Criptografando uma Partic,ao com gbde
    1. Adicione o Novo Disco Rigido

       Instale a nova unidade no sistema, conforme explicado em Sec,ao 17.2,
       "Adicionando Discos". Para propositos deste exemplo, uma nova
       partic,ao de disco rigido foi adicionada como /dev/ad4s1c e
       /dev/ad0s1* representa o existente partic,oes padrao do FreeBSD.

 # ls /dev/ad*
 /dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
 /dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
 /dev/ad0s1a     /dev/ad0s1d     /dev/ad4

    2. Criar um diretorio para conter os arquivos de lock do gbde

 # mkdir /etc/gbde

       O arquivo de lock gbde contem informac,oes que o gbde requer para
       acessar partic,oes criptografadas. Sem acesso ao arquivo de lock, o
       gbde nao podera descriptografar os dados contidos na partic,ao
       criptografada sem intervenc,ao manual significativa que nao seja
       suportada pelo software. Cada partic,ao criptografada usa um arquivo
       de lock separado.

    3. Inicialize a Partic,ao gbde

       Uma partic,ao gbde deve ser inicializada antes de poder ser usada.
       Essa inicializac,ao precisa ser executada apenas uma vez. Esse comando
       abrira o editor padrao, para definir varias opc,oes de configurac,ao
       em um modelo. Para uso com o sistema de arquivos UFS, defina o
       sector_size como 2048:

 # gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock
 # $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
 #
 # Sector size is the smallest unit of data which can be read or written.
 # Making it too small decreases performance and decreases available space.
 # Making it too large may prevent filesystems from working.  512 is the
 # minimum and always safe.  For UFS, use the fragment size
 #
 sector_size     =       2048
 [...]

       Depois que a edic,ao for salva, o usuario sera solicitado a digitar
       duas vezes a frase secreta usada para proteger os dados. A frase
       secreta deve ser a mesma em ambas as vezes. A capacidade de gbde de
       proteger os dados depende inteiramente da qualidade da frase secreta.
       Para obter dicas sobre como selecionar uma frase secreta que seja
       facil de lembrar, consulte
       http://world.std.com/~reinhold/diceware.htm.

       Essa inicializac,ao cria um arquivo de lock para a partic,ao do gbde.
       Neste exemplo, ele e armazenado como /etc/gbde/ad4s1c.lock. Os
       arquivos de lock devem terminar em ".lock" para serem corretamente
       detectados pelo script de inicializac,ao do /etc/rc.d/gbde.

  Cuidado:

       Arquivos de lock devem ter backups junto com o conteudo de qualquer
       partic,ao criptografada. Sem o arquivo de lock, o proprietario
       legitimo nao podera acessar os dados na partic,ao criptografada.

    4. Anexando a Partic,ao Criptografada ao Kernel

 # gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock

       Este comando solicitara a entrada da senha que foi selecionada durante
       a inicializac,ao da partic,ao criptografada. O novo dispositivo
       criptografado aparecera em /dev como /dev/device_name.bde:

 # ls /dev/ad*
 /dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
 /dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
 /dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde

    5. Criando um Sistema de Arquivos no Dispositivo Criptografado

       Uma vez que o dispositivo criptografado tenha sido anexado ao kernel,
       um sistema de arquivos pode ser criado no dispositivo. Este exemplo
       cria um sistema de arquivos UFS com atualizac,oes soft ativadas.
       Certifique-se de especificar a partic,ao que possui uma extensao
       *.bde:

 # newfs -U /dev/ad4s1c.bde

    6. Montando a Partic,ao Criptografada

       Crie um ponto de montagem e monte o sistema de arquivos
       criptografados:

 # mkdir /private
 # mount /dev/ad4s1c.bde /private

    7. Verificar se o sistema de arquivos criptografados esta disponivel

       O sistema de arquivos criptografados agora deve estar visivel e
       disponivel para uso:

 % df -H
 Filesystem        Size   Used  Avail Capacity  Mounted on
 /dev/ad0s1a      1037M    72M   883M     8%    /
 /devfs            1.0K   1.0K     0B   100%    /dev
 /dev/ad0s1f       8.1G    55K   7.5G     0%    /home
 /dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
 /dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
 /dev/ad4s1c.bde   150G   4.1K   138G     0%    /private

   Apos cada inicializac,ao, todos os sistemas de arquivos criptografados
   devem ser reconectados manualmente ao kernel, verificados quanto a erros e
   montados antes que os sistemas de arquivos possam ser usados. Para
   configurar estas etapas, adicione as seguintes linhas ao arquivo
   /etc/rc.conf:

 gbde_autoattach_all="YES"
 gbde_devices="ad4s1c"
 gbde_lockdir="/etc/gbde"

   Isso requer que a frase secreta seja inserida no console no momento da
   inicializac,ao. Depois de digitar a senha correta, a partic,ao
   criptografada sera montada automaticamente. Opc,oes adicionais de
   inicializac,ao do gbde estao disponiveis e listadas em rc.conf(5).

  Nota:

   O sysinstall e incompativel com os dispositivos criptografados com gbde.
   Todos os dispositivos *.bde devem ser desanexado do kernel antes de
   iniciar o sysinstall ou ele ira travar durante a analise inicial dos
   dispositivos. Para desanexar o dispositivo criptografado usado no exemplo,
   use o seguinte comando:

 # gbde detach /dev/ad4s1c

  17.12.2. Criptografia de Disco com geli

   Contribuido por Daniel Gerzo.

   Uma classe criptografica alternativa GEOM esta disponivel usando geli.
   Este utilitario de controle adiciona alguns recursos e usa um esquema
   diferente para fazer trabalho criptografico. Ele fornece os seguintes
   recursos:

     * Utiliza o framework crypto(9) e usa automaticamente o hardware
       criptografico quando ele esta disponivel.

     * Suporta varios algoritmos criptograficos, como AES, Blowfish e 3DES.

     * Permite que a partic,ao raiz seja criptografada. A frase secreta usada
       para acessar a partic,ao root criptografada sera solicitada durante a
       inicializac,ao do sistema.

     * Permite o uso de duas chaves independentes.

     * E rapido, pois executa criptografia simples de setor a setor.

     * Permite backup e restaurac,ao de chaves mestras. Se um usuario
       destruir suas chaves, ainda e possivel obter acesso aos dados
       restaurando as chaves do backup.

     * Permite que um disco seja anexado com uma chave unica aleatoria que e
       util para partic,oes swap e sistemas de arquivos temporarios.

   Mais recursos e exemplos de uso podem ser encontrados em geli(8).

   O exemplo a seguir descreve como gerar um arquivo de chave que sera usado
   como parte da chave mestra para o provedor criptografado montado em
   /private. O arquivo chave fornecera alguns dados aleatorios usados para
   criptografar a chave mestra. A chave mestra tambem sera protegida por uma
   frase secreta. O tamanho do setor do provedor sera de 4kB. O exemplo
   descreve como se conectar ao provedor geli, criar um sistema de arquivos,
   monta-lo, trabalhar com ele e, finalmente, como desanexa-lo.

   Procedimento 17.4. Criptografando uma Partic,ao com geli
    1. Carregando o suporte ao geli

       O suporte para geli esta disponivel como um modulo de kernel
       carregavel. Para configurar o sistema para carregar automaticamente o
       modulo no momento da inicializac,ao, adicione a seguinte linha ao
       arquivo /boot/loader.conf:

 geom_eli_load="YES"

       Para carregar o modulo do kernel agora:

 # kldload geom_eli

       Para um kernel customizado, assegure-se de que o arquivo de
       configurac,ao do kernel contenha estas linhas:

 options GEOM_ELI
 device crypto

    2. Gerando a Chave Mestra

       Os seguintes comandos geram uma chave mestra (/root/da2.key) que e
       protegida com uma frase secreta. A fonte de dados para o arquivo de
       chave e /dev/random e o tamanho do setor do provedor (/dev/da2.eli) e
       de 4kB, pois um tamanho de setor maior fornece melhor desempenho:

 # dd if=/dev/random of=/root/da2.key bs=64 count=1
 # geli init -s 4096 -K /root/da2.key /dev/da2
 Enter new passphrase:
 Reenter new passphrase:

       Nao e obrigatorio o uso de uma frase secreta e de um arquivo de chave,
       pois cada metodo de proteger a chave mestra pode ser usado
       isoladamente.

       Se o arquivo de chave e dado como "-", a entrada padrao sera usada.
       Por exemplo, este comando gera tres arquivos principais:

 # cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2

    3. Anexando o Provedor com a Chave Gerada

       Para anexar o provedor, especifique o arquivo de chave, o nome do
       disco e a frase secreta:

 # geli attach -k /root/da2.key /dev/da2
 Enter passphrase:

       Isso cria um novo dispositivo com uma extensao .eli:

 # ls /dev/da2*
 /dev/da2  /dev/da2.eli

    4. Criando o Novo Sistema de Arquivos

       Em seguida, formate o dispositivo com o sistema de arquivos UFS e
       monte-o em um ponto de montagem existente:

 # dd if=/dev/random of=/dev/da2.eli bs=1m
 # newfs /dev/da2.eli
 # mount /dev/da2.eli /private

       O sistema de arquivos criptografado agora deve estar disponivel para
       uso:

 # df -H
 Filesystem     Size   Used  Avail Capacity  Mounted on
 /dev/ad0s1a    248M    89M   139M    38%    /
 /devfs         1.0K   1.0K     0B   100%    /dev
 /dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
 /dev/ad0s1d    989M   1.5M   909M     0%    /tmp
 /dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
 /dev/da2.eli   150G   4.1K   138G     0%    /private

   Uma vez que o trabalho na partic,ao criptografada e feito, e a partic,ao
   /private nao e mais necessaria, e prudente colocar o dispositivo no
   armazenamento frio desmontando e desanexando a partic,ao geli
   criptografada do kernel:

 # umount /private
 # geli detach da2.eli

   Um script rc.d e fornecido para simplificar a montagem de dispositivos
   criptografados geli no momento da inicializac,ao. Para este exemplo,
   adicione estas linhas ao arquivo /etc/rc.conf:

 geli_devices="da2"
 geli_da2_flags="-k /root/da2.key"

   Isto configura o /dev/da2 como um provedor geli com uma chave mestra de
   /root/da2.key. O sistema ira desanexando automaticamente o provedor do
   kernel antes que o sistema seja desligado. Durante o processo de
   inicializac,ao, o script solicitara a frase secreta antes de conectar o
   provedor. Outras mensagens do kernel podem ser mostradas antes e depois do
   prompt da frase secreta. Se o processo de inicializac,ao parecer travar,
   procure cuidadosamente o prompt de senha entre as outras mensagens. Depois
   que a frase secreta correta e inserida, o provedor e anexado. O sistema de
   arquivos e entao montado, normalmente por uma entrada em /etc/fstab.
   Consulte Sec,ao 3.7, "Montando e Desmontando Sistemas de Arquivos" para
   obter instruc,oes sobre como configurar um sistema de arquivos para montar
   no momento da inicializac,ao.

17.13. Criptografando Swap

   Escrito por Christian Brueffer.

   Como a criptografia de partic,oes de disco, a criptografia do espac,o swap
   e usada para proteger informac,oes confidenciais. Considere um aplicativo
   que lida com senhas. Contanto que essas senhas permanec,am na memoria
   fisica, elas nao serao gravadas no disco e serao apagadas apos a
   reinicializac,ao. No entanto, se o FreeBSD iniciar a troca de paginas de
   memoria para liberar espac,o, as senhas podem ser gravadas no disco nao
   criptografadas. O espac,o de troca de criptografia pode ser uma soluc,ao
   para esse cenario.

   Esta sec,ao demonstra como configurar uma partic,ao swap criptografada
   usando criptografia gbde(8) ou geli(8). Ele assume que /dev/ada0s1b e a
   partic,ao swap.

  17.13.1. Configurando Swap Criptografada

   As partic,oes de swap nao sao criptografadas por padrao e devem ser limpas
   de quaisquer dados confidenciais antes de continuar. Para sobrescrever a
   partic,ao swap atual com lixo aleatorio, execute o seguinte comando:

 # dd if=/dev/random of=/dev/ada0s1b bs=1m

   Para criptografar a partic,ao swap usando gbde(8), adicione o sufixo .bde
   `a linha de swap no /etc/fstab:

 # Device                Mountpoint      FStype  Options         Dump    Pass#
 /dev/ada0s1b.bde        none            swap    sw              0       0

   Para criptografar a partic,ao swap usando geli( 8), use o sufixo .eli:

 # Device                Mountpoint      FStype  Options         Dump    Pass#
 /dev/ada0s1b.eli        none            swap    sw              0       0

   Por padrao, geli(8) usa o algoritmo AES com um comprimento de chave de 128
   bits. Normalmente, as configurac,oes padrao serao suficientes. Se
   desejado, estes padroes podem ser alterados no campo de opc,oes no arquivo
   /etc/fstab. As possiveis flags sao:

   aalgo

           Algoritmo de verificac,ao de integridade de dados usado para
           garantir que os dados criptografados nao tenham sido adulterados.
           Veja geli(8) para obter uma lista dos algoritmos suportados.

   ealgo

           Algoritmo de criptografia usado para proteger os dados. Veja
           geli(8) para obter uma lista dos algoritmos suportados.

   keylen

           O comprimento da chave usada para o algoritmo de criptografia.
           Veja geli(8) para os comprimentos de chave que sao suportados por
           cada algoritmo de criptografia.

   sectorsize

           O tamanho em que o blocos de dados e dividido antes de ser
           criptografado. Tamanhos de setor maiores aumentam o desempenho ao
           custo de maior sobrecarga de armazenamento. O tamanho recomendado
           e de 4096 bytes.

   Este exemplo configura uma partic,ao swap criptografada usando o algoritmo
   Blowfish com um comprimento de chave de 128 bits e um setor de tamanho de
   4 kilobytes:

 # Device                Mountpoint      FStype  Options                         Dump    Pass#
 /dev/ada0s1b.eli        none            swap    sw,ealgo=blowfish,keylen=128,sectorsize=4096    0       0

  17.13.2. Verificac,ao de Swap Criptografada

   Depois que o sistema for reinicializado, a operac,ao adequada da swap
   criptografada podera ser verificada usando swapinfo.

   Se gbde(8) estiver sendo usado:

 % swapinfo
 Device          1K-blocks     Used    Avail Capacity
 /dev/ada0s1b.bde   542720        0   542720     0%

   Se geli(8) estiver sendo usado:

 % swapinfo
 Device          1K-blocks     Used    Avail Capacity
 /dev/ada0s1b.eli   542720        0   542720     0%

17.14. Alta Disponibilidade de Armazenamento (HAST)

   Contribuido por Daniel Gerzo.
   Com contribuic,oes de Freddie Cash, Pawel Jakub Dawidek, Michael W. Lucas
   e Viktor Petersson.

   A alta disponibilidade e um dos principais requisitos em aplicativos de
   negocios serios e o armazenamento altamente disponivel e um
   componente-chave nesses ambientes. No FreeBSD, o framework Alta
   Disponiblidade de Armazenamento (HAST) permite o armazenamento
   transparente dos mesmos dados em varias maquinas fisicamente separadas
   conectadas por uma rede TCP/IP. HAST pode ser entendido como um RAID1
   (mirror) baseado em rede, e e similar ao sistema de armazenamento DRBD(R)
   usado na plataforma GNU/Linux(R). Em combinac,ao com outros recursos de
   alta disponibilidade do FreeBSD, como o CARP, o HAST possibilita a
   criac,ao de um cluster de armazenamento altamente disponivel, resistente a
   falhas de hardware.

   A seguir estao as principais caracteristicas do HAST:

     * Pode ser usado para mascarar erros de I/O em discos rigidos locais.

     * Agnostico a sistema de arquivos, pois funciona com qualquer sistema de
       arquivos suportado pelo FreeBSD.

     * Ressincronizac,ao eficiente e rapida, pois somente os blocos que foram
       modificados durante o tempo de inatividade de um no sao sincronizados.

     * Pode ser usado em um ambiente ja implantado para adicionar redundancia
       adicional.

     * Juntamente com o CARP, Heartbeat, ou outras ferramentas, ele pode ser
       usado para construir um sistema de armazenamento robusto e duravel.

   Depois de ler esta sec,ao, voce sabera:

     * O que e HAST, como ele funciona e quais recursos ele fornece.

     * Como configurar e usar o HAST no FreeBSD.

     * Como integrar CARP e devd(8) para criar um sistema de armazenamento
       robusto.

   Antes de ler esta sec,ao, voce deve:

     * Entender os fundamentos do UNIX(R) e do FreeBSD (Capitulo 3,
       Fundamentos do FreeBSD).

     * Saber como configurar interfaces de rede e outros subsistemas
       principais do FreeBSD (Capitulo 11, Configurac,ao e Ajuste).

     * Ter uma boa compreensao da rede do FreeBSD (Parte IV, "Comunicac,ao de
       rede").

   O projeto HAST foi patrocinado pela Fundac,ao FreeBSD com o apoio de
   http://www.omc.net/ e http://www.transip.nl/.

  17.14.1. Operac,ao HAST

   O HAST fornece replicac,ao sincrona em nivel de bloco entre duas maquinas
   fisicas: o primario, tambem conhecido como o no master, e o secundario, ou
   no slave. Essas duas maquinas juntas sao chamadas de cluster.

   Como o HAST funciona em uma configurac,ao primaria-secundaria, ele permite
   que apenas um dos nos do cluster esteja ativo a qualquer momento. O no
   primario, tambem chamado de active, e aquele que ira lidar com todas as
   solicitac,oes de I/O para dispositivos gerenciados por HAST. O no
   secundario e automaticamente sincronizado a partir do no primario.

   Os componentes fisicos do sistema HAST sao o disco local no no primario e
   o disco no no secundario remoto.

   O HAST opera de forma sincrona em um nivel de bloco, tornando-o
   transparente para sistemas de arquivos e aplicativos. O HAST fornece
   provedores GEOM regulares em /dev/hast/ para uso por outras ferramentas ou
   aplicativos. Nao ha diferenc,a entre o uso de dispositivos HAST e discos
   ou partic,oes brutas.

   Cada operac,ao de gravac,ao, exclusao ou liberac,ao e enviada para o disco
   local e para o disco remoto sobre TCP/IP . Cada operac,ao de leitura e
   fornecida a partir do disco local, a menos que o disco local nao esteja
   atualizado ou ocorra um erro de I/O. Nesses casos, a operac,ao de leitura
   e enviada para o no secundario.

   HAST tenta fornecer recuperac,ao rapida de falhas. Por esse motivo, e
   importante reduzir o tempo de sincronizac,ao apos a interrupc,ao de um no.
   Para fornecer sincronizac,ao rapida, o HAST gerencia um bitmap no disco de
   extensoes sujas e sincroniza apenas aquelas durante uma sincronizac,ao
   regular, com excec,ao da sincronizac,ao inicial.

   Existem muitas maneiras de lidar com a sincronizac,ao. O HAST implementa
   varios modos de replicac,ao para lidar com diferentes metodos de
   sincronizac,ao:

     * memsync: Este modo reporta uma operac,ao de gravac,ao como concluida
       quando a operac,ao de gravac,ao local e finalizada e quando o no
       remoto reconhece a chegada dos dados, mas antes de realmente armazenar
       os dados. Os dados no no remoto serao armazenados diretamente apos o
       envio da confirmac,ao. Este modo destina-se a reduzir a latencia, mas
       ainda fornece boa confiabilidade. Este modo e o padrao.

     * fullsync: Este modo relata uma operac,ao de gravac,ao como concluida
       quando a gravac,ao local e a gravac,ao remota sao concluidas. Este e o
       modo de replicac,ao mais seguro e mais lento.

     * async: Este modo relata uma operac,ao de gravac,ao como concluida
       quando a gravac,ao local e concluida. Este e o modo de replicac,ao
       mais rapido e mais perigoso. Ele deve ser usado somente ao replicar
       para um no distante, onde a latencia e muito alta para outros modos.

  17.14.2. Configurac,ao do HAST

   O framework HAST consiste em varios componentes:

     * O daemon hastd(8) que fornece sincronizac,ao de dados. Quando este
       daemon e iniciado, ele carregara automaticamente geom_gate.ko.

     * O utilitario de gerenciamento de usuario, hastctl(8).

     * O arquivo de configurac,ao hast.conf(5). Este arquivo deve existir
       antes de iniciar o hastd.

   Usuarios que preferem construir estaticamente o suporte a GEOM_GATE no
   kernel devem adicionar esta linha ao arquivo de configurac,ao do kernel
   personalizado e reconstruir o kernel usando as instruc,oes em Capitulo 8,
   Configurando o kernel do FreeBSD:

 options GEOM_GATE

   O exemplo a seguir descreve como configurar dois nos na operac,ao
   mestre-escravo/primario-secundario usando HAST para replicar os dados
   entre os dois. Os nos serao chamados hasta, com um enderec,o IP
   172.16.0.1, e hastb, com um enderec,o IP 172.16.0.2. Ambos os nos terao um
   disco rigido dedicado /dev/ad6 do mesmo tamanho para a operac,ao HAST. O
   conjunto HAST, por vezes referido como um recurso ou o provedor GEOM em
   /dev/hast/, sera chamado test.

   A configurac,ao do HAST e feita usando o arquivo /etc/hast.conf. Este
   arquivo deve ser identico nos dois nos. A configurac,ao mais simples e:

 resource test {
         on hasta {
                 local /dev/ad6
                 remote 172.16.0.2
         }
         on hastb {
                 local /dev/ad6
                 remote 172.16.0.1
         }
 }

   Para uma configurac,ao mais avanc,ada, consulte hast.conf(5).

  Dica:

   Tambem e possivel usar nomes de host nas instruc,oes remote se os hosts
   forem resolvidos e definidos no arquivo /etc/hosts ou no DNS local.

   Uma vez que a configurac,ao exista em ambos os nos, o conjunto HAST pode
   ser criado. Execute esses comandos nos dois nos para colocar os metadados
   iniciais no disco local e para iniciar hastd(8):

 # hastctl create test
 # service hastd onestart

  Nota:

   Nao e possivel usar os provedores GEOM com um sistema de arquivos
   existente ou converter um armazenamento existente em um pool gerenciado
   por HAST. Esse procedimento precisa armazenar alguns metadados no provedor
   e nao havera espac,o suficiente disponivel em um provedor existente.

   Um no HAST primario ou secundario e selecionado por um administrador, ou
   software como Heartbeat, usando hastctl(8). No no primario, hasta, execute
   este comando:

 # hastctl role primary test

   Execute este comando no no secundario, hastb:

 # hastctl role secondary test

   Verifique o resultado executando hastctl em cada no:

 # hastctl status test

   Verifique a linha status na saida. Se disser degraded, algo esta errado
   com o arquivo de configurac,ao. Ele deve dizer complete em cada no, o que
   significa que a sincronizac,ao entre os nos foi iniciada. A sincronizac,ao
   e concluida quando hastctl status relata 0 bytes de extensoes sujas.

   O proximo passo e criar um sistema de arquivos no provedor GEOM e
   monta-lo. Isso deve ser feito no no primario. A criac,ao do sistema de
   arquivos pode levar alguns minutos, dependendo do tamanho do disco rigido.
   Este exemplo cria um sistema de arquivos UFS em /dev/hast/test :

 # newfs -U /dev/hast/test
 # mkdir /hast/test
 # mount /dev/hast/test /hast/test

   Uma vez que o framework HAST esteja configurado corretamente, o passo
   final e garantir que o HAST seja iniciado automaticamente durante a
   inicializac,ao do sistema. Adicione esta linha ao /etc/rc.conf:

 hastd_enable="YES"

    17.14.2.1. Configurac,ao de Failover

   O objetivo deste exemplo e construir um sistema de armazenamento robusto
   que seja resistente `a falha de qualquer no. Se o no primario falhar, o no
   secundario estara la para assumir o controle, verificar e montar o sistema
   de arquivos e continuar a trabalhar sem perder um unico bit de dados.

   Para realizar essa tarefa, o Protocolo de Redundancia de Enderec,os Comuns
   (CARP) e usado para fornecer failover automatico na camada IP. O CARP
   permite que varios hosts no mesmo segmento de rede compartilhem um
   enderec,o IP. Configure o CARP em ambos os nos do cluster de acordo com a
   documentac,ao disponivel em Sec,ao 31.10, "Protocolo Comum de Redundancia
   de Enderec,os (CARP)". Neste exemplo, cada no tera seu proprio enderec,o
   de gerenciamento IP e um enderec,o IP compartilhado de 172.16.0.254. O no
   principal HAST do cluster deve ser o no mestre CARP.

   O pool HAST criado na sec,ao anterior esta agora pronto para ser exportado
   para os outros hosts da rede. Isso pode ser feito exportando-o atraves do
   NFS ou Samba, usando o enderec,o IP 172.16.0.254 compartilhado. O unico
   problema que permanece nao resolvido e um failover automatico caso o no
   primario falhe.

   Caso as interfaces do CARP subam ou desc,am, o sistema operacional FreeBSD
   gera um evento devd(8), tornando possivel observar mudanc,as de estado nas
   interfaces do CARP. Uma alterac,ao de estado na interface CARP e uma
   indicac,ao de que um dos nos falhou ou voltou a ficar online. Esses
   eventos de mudanc,a de estado tornam possivel executar um script que
   manipulara automaticamente o failover HAST.

   Para capturar mudanc,as de estado nas interfaces do CARP, adicione esta
   configurac,ao ao /etc/devd.conf em cada no:

 notify 30 {
         match "system" "IFNET";
         match "subsystem" "carp0";
         match "type" "LINK_UP";
         action "/usr/local/sbin/carp-hast-switch master";
 };

 notify 30 {
         match "system" "IFNET";
         match "subsystem" "carp0";
         match "type" "LINK_DOWN";
         action "/usr/local/sbin/carp-hast-switch slave";
 };

  Nota:

   Se os sistemas estiverem executando o FreeBSD 10 ou superior, substitua
   carp0 pelo nome da interface configurada CARP.

   Reinicie o devd(8) em ambos os nos para colocar a nova configurac,ao em
   vigor:

 # service devd restart

   Quando o estado da interface especificada e alterado subindo ou descendo,
   o sistema gera uma notificac,ao, permitindo que o subsistema devd(8)
   execute o script de failover automatico especificado,
   /usr/local/sbin/carp-hast-switch . Para maiores esclarecimentos sobre esta
   configurac,ao, consulte devd.conf(5).

   Aqui esta um exemplo de um script de failover automatizado:

 #!/bin/sh

 # Original script by Freddie Cash <fjwcash@gmail.com>
 # Modified by Michael W. Lucas <mwlucas@BlackHelicopters.org>
 # and Viktor Petersson <vpetersson@wireload.net>

 # The names of the HAST resources, as listed in /etc/hast.conf
 resources="test"

 # delay in mounting HAST resource after becoming master
 # make your best guess
 delay=3

 # logging
 log="local0.debug"
 name="carp-hast"

 # end of user configurable stuff

 case "$1" in
         master)
                 logger -p $log -t $name "Switching to primary provider for ${resources}."
                 sleep ${delay}

                 # Wait for any "hastd secondary" processes to stop
                 for disk in ${resources}; do
                         while $( pgrep -lf "hastd: ${disk} \(secondary\)" > /dev/null 2>&1 ); do
                                 sleep 1
                         done

                         # Switch role for each disk
                         hastctl role primary ${disk}
                         if [ $? -ne 0 ]; then
                                 logger -p $log -t $name "Unable to change role to primary for resource ${disk}."
                                 exit 1
                         fi
                 done

                 # Wait for the /dev/hast/* devices to appear
                 for disk in ${resources}; do
                         for I in $( jot 60 ); do
                                 [ -c "/dev/hast/${disk}" ] && break
                                 sleep 0.5
                         done

                         if [ ! -c "/dev/hast/${disk}" ]; then
                                 logger -p $log -t $name "GEOM provider /dev/hast/${disk} did not appear."
                                 exit 1
                         fi
                 done

                 logger -p $log -t $name "Role for HAST resources ${resources} switched to primary."


                 logger -p $log -t $name "Mounting disks."
                 for disk in ${resources}; do
                         mkdir -p /hast/${disk}
                         fsck -p -y -t ufs /dev/hast/${disk}
                         mount /dev/hast/${disk} /hast/${disk}
                 done

         ;;

         slave)
                 logger -p $log -t $name "Switching to secondary provider for ${resources}."

                 # Switch roles for the HAST resources
                 for disk in ${resources}; do
                         if ! mount | grep -q "^/dev/hast/${disk} on "
                         then
                         else
                                 umount -f /hast/${disk}
                         fi
                         sleep $delay
                         hastctl role secondary ${disk} 2>&1
                         if [ $? -ne 0 ]; then
                                 logger -p $log -t $name "Unable to switch role to secondary for resource ${disk}."
                                 exit 1
                         fi
                         logger -p $log -t $name "Role switched to secondary for resource ${disk}."
                 done
         ;;
 esac

   Em poucas palavras, o script executa essas ac,oes quando um no se torna
   mestre:

     * Promove o pool de HAST para primario no outro no.

     * Verifica o sistema de arquivos no pool HAST.

     * Monta o pool.

   Quando um no se torna secundario:

     * Desmonta o conjunto HAST.

     * Degrada o pool HAST para secundario.

  Cuidado:

   Este e apenas um script de exemplo que serve como prova de conceito. Ele
   nao manipula todos os cenarios possiveis e pode ser estendido ou alterado
   de qualquer forma, por exemplo, para iniciar ou interromper os servic,os
   necessarios.

  Dica:

   Para este exemplo, foi utilizado um sistema de arquivos padrao UFS. Para
   reduzir o tempo necessario para a recuperac,ao, e possivel usar um sistema
   de arquivos UFS ou ZFS com journal ativado.

   Informac,oes mais detalhadas com exemplos adicionais podem ser encontradas
   em http://wiki.FreeBSD.org/HAST.

  17.14.3. Soluc,ao de problemas

   O HAST geralmente deve funcionar sem problemas. No entanto, como acontece
   com qualquer outro produto de software, pode haver momentos em que ele nao
   funciona como deveria. As origens dos problemas podem ser diferentes, mas
   a regra geral e garantir que o horario esteja sincronizado entre os nos do
   cluster.

   Quando estiver fazendo troubleshooting no HAST, o nivel de depurac,ao de
   hastd(8) deve ser aumentado iniciando hastd com -d. Esse argumento pode
   ser especificado varias vezes para aumentar ainda mais o nivel de
   depurac,ao. Considere tambem usar -F, que inicia o hastd em primeiro
   plano.

    17.14.3.1. Recuperando-se da Condic,ao de Split-brain

   Split-brain ocorre quando os nos do cluster nao conseguem se comunicar
   entre si e ambos sao configurados como primarios. Esta e uma condic,ao
   perigosa porque permite que ambos os nos fac,am alterac,oes incompativeis
   nos dados. Esse problema deve ser corrigido manualmente pelo administrador
   do sistema.

   O administrador deve decidir qual no tem alterac,oes mais importantes ou
   executar a mesclagem manualmente. Entao, deixe o HAST executar a
   sincronizac,ao completa do no que possui os dados quebrados. Para fazer
   isso, emita esses comandos no no que precisa ser ressincronizado:

 # hastctl role init test
 # hastctl create test
 # hastctl role secondary test

Capitulo 18. GEOM: Framework de Transformac,ao de Disco Modular

   Escrito porTom Rhodes.
   Indice

   18.1. Sinopse

   18.2. RAID0 - Striping

   18.3. RAID1 - Espelhamento

   18.4. RAID3 - Distribuic,ao em Nivel de Byte com Paridade Dedicada

   18.5. Dispositivos RAID por Software

   18.6. GEOM Network Gate

   18.7. Rotulando Dispositivos de Disco

   18.8. Journaling UFS atraves do GEOM

18.1. Sinopse

   No FreeBSD, o framework GEOM permite acesso e controle `a classes, tais
   como Master Boot Records e labels BSD, atraves do uso de provedores, ou
   dos dispositivos de disco em /dev. Ao suportar varias configurac,oes de
   RAID via software, o GEOM fornece, de forma transparente, acesso ao
   sistema operacional e aos utilitarios do sistema operacional.

   Este capitulo aborda o uso de discos sob o framework do GEOM no FreeBSD.
   Isso inclui os principais utilitarios de controle RAID os quais usam o
   framework para configurac,ao. Este capitulo nao e um guia definitivo para
   as configurac,oes de RAID e somente as classificac,oes de RAID suportadas
   pelo GEOM sao discutidas.

   Depois de ler este capitulo, voce sabera:

     * Que tipo de suporte a RAID esta disponivel atraves do GEOM.

     * Como usar os utilitarios da base para configurar, manter e manipular
       os varios niveis de RAID.

     * Como espelhar, distribuir, criptografar e conectar remotamente
       dispositivos de disco por meio do GEOM.

     * Como solucionar problemas de discos conectados ao framework do GEOM.

   Antes de ler este capitulo, voce deve:

     * Entender como o FreeBSD trata os dispositivos de disco (Capitulo 17,
       Armazenamento).

     * Saber como configurar e instalar um novo kernel (Capitulo 8,
       Configurando o kernel do FreeBSD).

18.2. RAID0 - Striping

   Escrito porTom Rhodes e Murray Stokely.

   O striping combina varias unidades de disco em um unico volume. O striping
   pode ser realizado atraves do uso de hardwares controladores de RAID. O
   subsistema de disco GEOM fornece suporte de software para striping de
   disco, tambem conhecido como RAID0, sem a necessidade de um controlador
   RAID de disco.

   No RAID0, os dados sao divididos em blocos que sao gravados em todas as
   unidades do array. Como pode ser visto na ilustrac,ao a seguir, em vez de
   esperar no sistema para gravar 256k em um disco, o RAID0 pode gravar 64k
   simultaneamente em cada um dos quatro discos do array, oferecendo um
   desempenho de I/O superior. Esse desempenho pode ser aprimorado ainda mais
   usando varios controladores de disco.

                           Disk Striping Illustration

   Cada disco em um stripe RAID0 deve ser do mesmo tamanho, pois as
   solicitac,oes de I/O sao intercaladas para ler ou gravar em varios discos
   em paralelo.

  Nota:

   O RAID0 nao fornece qualquer redundancia. Isso significa que, se um disco
   no array falhar, todos os dados nos discos serao perdidos. Se os dados
   forem importantes, implemente uma estrategia de backup que salva
   regularmente os backups em um sistema ou dispositivo remoto.

   O processo para criar um RAID0 por software, baseado no GEOM, em um
   sistema FreeBSD usando discos comuns e o seguinte. Uma vez que o stripe
   tiver sido criado, consulte gstripe(8) para obter maioress informac,oes
   sobre como controlar uma stripe existente.

   Procedimento 18.1. Criando um Stripe de Discos ATA Nao Formatados
    1. Carregue o modulo geom_stripe.ko:

 # kldload geom_stripe

    2. Assegure-se de que exista um ponto de montagem adequado. Se esse
       volume se tornar uma partic,ao root, use temporariamente outro ponto
       de montagem, como /mnt.

    3. Determine os nomes dos dispositivos para os discos que serao striped e
       crie o novo dispositivo de stripe. Por exemplo, para distribuir dois
       discos ATA nao utilizados e nao particionados com nomes de
       dispositivos /dev/ad2 e /dev/ad3:

 # gstripe label -v st0 /dev/ad2 /dev/ad3
 Metadata value stored on /dev/ad2.
 Metadata value stored on /dev/ad3.
 Done.

    4. Escreva um label padrao, tambem conhecido como tabela de partic,ao, no
       novo volume e instale o codigo do bootstrap padrao:

 # bsdlabel -wB /dev/stripe/st0

    5. Este processo deve criar dois outros dispositivos em /dev/stripe alem
       de st0. Esses incluem o st0a e o st0c. Neste ponto, um sistema de
       arquivos UFS pode ser criado no st0a usando o newfs:

 # newfs -U /dev/stripe/st0a

       Muitos numeros irao deslizar pela tela e, apos alguns segundos, o
       processo sera concluido. O volume foi criado e esta pronto para ser
       montado.

    6. Para montar manualmente o stripe de disco criado:

 # mount /dev/stripe/st0a /mnt

    7. Para montar este sistema de arquivos distribuido automaticamente
       durante o processo de inicializac,ao, coloque as informac,oes do
       volume no arquivo /etc/fstab. Neste exemplo, um ponto de montagem
       permanente, chamado stripe, e criado:

 # mkdir /stripe
 # echo "/dev/stripe/st0a /stripe ufs rw 2 2" \
 >> /etc/fstab

    8. O modulo geom_stripe.ko tambem deve ser carregado automaticamente
       durante a inicializac,ao do sistema, adicionando uma linha ao arquivo
       /boot/loader.conf:

 # sysrc -f /boot/loader.conf geom_stripe_load=YES

18.3. RAID1 - Espelhamento

   O RAID1, ou espelhamento, e a tecnica de gravar os mesmos dados em mais de
   uma unidade de disco. Os espelhos sao geralmente usados para proteger
   contra perda de dados devido a falhas na unidade. Cada unidade espelhada
   contem uma copia identica dos dados. Quando uma unidade individual falha,
   o espelhamento continua a funcionar, fornecendo dados a partir das
   unidades que ainda estao funcionando. O computador continua funcionando e
   o administrador tem tempo para substituir a unidade com falha sem impactar
   o usuario.

   Duas situac,oes comuns sao ilustradas nesses exemplos. O primeiro cria um
   espelhamento de dois novos discos e usa-o como um substituto para um unico
   disco existente. O segundo exemplo cria um espelho em um unico disco novo,
   copia os dados do disco antigo para ele e insere o disco antigo no
   espelho. Embora esse procedimento seja um pouco mais complicado, ele
   requer apenas um novo disco.

   Tradicionalmente, os dois discos em um espelhamento sao identicos em
   modelo e capacidade, mas o gmirror(8) nao requer isso. Os espelhamentos
   criados com discos diferentes terao uma capacidade igual `a da menor
   unidade no espelhamento. O espac,o extra em discos maiores nao sera usado.
   Os discos inseridos posteriormente no espelhamento devem ter pelo menos a
   mesma capacidade que o menor disco ja existente no espelhamento.

  Atenc,ao:

   Os procedimentos de espelhamento mostrados aqui sao nao-destrutivos, mas
   como em qualquer grande operac,ao de disco, fac,a um backup completo
   primeiro.

  Atenc,ao:

   Embora o dump(8) seja usado nesses procedimentos para copiar sistemas de
   arquivos, ele nao funciona em sistemas de arquivos com Soft Updates
   Journaling. Consulte o tunefs(8) para obter informac,oes sobre como
   detectar e desativar o Soft Updates Journaling.

  18.3.1. Problemas de Metadados

   Muitos sistemas de disco armazenam metadados no final de cada disco.
   Metadados antigos devem ser apagados antes de reutilizar o disco em um
   espelhamento. A maioria dos problemas e causada por dois tipos
   particulares de metadados residuais: tabelas de partic,ao GPT e metadados
   antigos de um espelhamento anterior.

   Os metadados GPT podem ser apagados com gpart(8). Este exemplo apaga as
   tabelas de partic,oes primarias e de backup do GPT do disco ada8:

 # gpart destroy -F ada8

   Um disco pode ser removido de um espelhamento ativo e os metadados
   apagados em uma etapa usando gmirror(8). Aqui, o disco de exemplo ada8 e
   removido do espelhamento ativo gm4:

 # gmirror remove gm4 ada8

   Se o espelhamento nao estiver em execuc,ao, mas os metadados do
   espelhamento antigo ainda estiverem no disco, use o comando gmirror clear
   para remove-lo:

 # gmirror clear ada8

   O gmirror(8) armazena um bloco de metadados no final do disco. Como os
   esquemas de partic,ao GPT tambem armazenam metadados no final do disco,
   espelhar discos GPT inteiros com gmirror(8) nao e recomendado. O
   particionamento MBR e usado aqui porque armazena apenas uma tabela de
   partic,ao no inicio do disco e nao entra em conflito com os metadados
   espelhados.

  18.3.2. Criando um Espelhamento com Dois Discos Novos

   Neste exemplo, o FreeBSD ja foi instalado em um unico disco, ada0. Dois
   novos discos, ada1 e ada2, foram conectados ao sistema. Um novo
   espelhamento sera criado nesses dois discos e usado para substituir o
   antigo disco unico.

   O modulo do kernel geom_mirror.ko deve ser compilado no kernel ou
   carregado no boot ou em tempo de execuc,ao. Carregue manualmente o modulo
   do kernel agora:

 # gmirror load

   Crie o espelho com as duas novas unidades:

 # gmirror label -v gm0 /dev/ada1 /dev/ada2

   O gm0 e um nome de dispositivo escolhido pelo usuario atribuido ao novo
   espelhamento. Depois que o espelhamento for iniciado, o nome desse
   dispositivo aparecera em /dev/mirror/.

   As tabelas de partic,ao MBR e bsdlabel agora podem ser criadas no mirror
   com o gpart(8). Este exemplo usa um layout de sistema de arquivos
   tradicional, com partic,oes para /, swap, /var, /tmp e /usr. Um unico / e
   uma partic,ao swap tambem funcionarao.

   As partic,oes no espelho nao precisam ser do mesmo tamanho que as do disco
   existente, mas devem ser grandes o suficiente para conter todos os dados
   ja presentes no disco ada0.

 # gpart create -s MBR mirror/gm0
 # gpart add -t freebsd -a 4k mirror/gm0
 # gpart show mirror/gm0
 =>       63  156301423  mirror/gm0  MBR  (74G)
          63         63                    - free -  (31k)
         126  156301299                 1  freebsd  (74G)
   156301425         61                    - free -  (30k)

 # gpart create -s BSD mirror/gm0s1
 # gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1
 # gpart add -t freebsd-swap -a 4k -s 4g mirror/gm0s1
 # gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1
 # gpart add -t freebsd-ufs  -a 4k -s 1g mirror/gm0s1
 # gpart add -t freebsd-ufs  -a 4k       mirror/gm0s1
 # gpart show mirror/gm0s1
 =>        0  156301299  mirror/gm0s1  BSD  (74G)
           0          2                      - free -  (1.0k)
           2    4194304                   1  freebsd-ufs  (2.0G)
     4194306    8388608                   2  freebsd-swap  (4.0G)
    12582914    4194304                   4  freebsd-ufs  (2.0G)
    16777218    2097152                   5  freebsd-ufs  (1.0G)
    18874370  137426928                   6  freebsd-ufs  (65G)
   156301298          1                      - free -  (512B)

   Torne o espelhamento inicializavel instalando o bootcode no MBR e no
   bsdlabel e definindo a slice ativa:

 # gpart bootcode -b /boot/mbr mirror/gm0
 # gpart set -a active -i 1 mirror/gm0
 # gpart bootcode -b /boot/boot mirror/gm0s1

   Formate os sistemas de arquivos no novo espelhamento, habilitando as
   atualizac,oes simples.

 # newfs -U /dev/mirror/gm0s1a
 # newfs -U /dev/mirror/gm0s1d
 # newfs -U /dev/mirror/gm0s1e
 # newfs -U /dev/mirror/gm0s1f

   Os sistemas de arquivos do disco original ada0 agora podem ser copiados
   para o espelho com o dump(8) e o restore(8).

 # mount /dev/mirror/gm0s1a /mnt
 # dump -C16 -b64 -0aL -f - / | (cd /mnt && restore -rf -)
 # mount /dev/mirror/gm0s1d /mnt/var
 # mount /dev/mirror/gm0s1e /mnt/tmp
 # mount /dev/mirror/gm0s1f /mnt/usr
 # dump -C16 -b64 -0aL -f - /var | (cd /mnt/var && restore -rf -)
 # dump -C16 -b64 -0aL -f - /tmp | (cd /mnt/tmp && restore -rf -)
 # dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr && restore -rf -)

   Edite o arquivo /mnt/etc/fstab para apontar para os novos sistemas de
   arquivos espelhados:

 # Device                Mountpoint      FStype  Options Dump    Pass#
 /dev/mirror/gm0s1a      /               ufs     rw      1       1
 /dev/mirror/gm0s1b      none            swap    sw      0       0
 /dev/mirror/gm0s1d      /var            ufs     rw      2       2
 /dev/mirror/gm0s1e      /tmp            ufs     rw      2       2
 /dev/mirror/gm0s1f      /usr            ufs     rw      2       2

   Se o modulo do kernel geom_mirror.ko nao foi compilado no kernel, o
   /mnt/boot/loader.conf e editado para carregar o modulo na inicializac,ao:

 geom_mirror_load="YES"

   Reinicialize o sistema para testar o novo espelhamento e verifique se
   todos os dados foram copiados. A BIOS vera o espelhamento como duas
   unidades individuais em vez de um espelhamento. Como as unidades sao
   identicas, nao importa qual seja selecionado para inicializar.

   Veja Sec,ao 18.3.4, "Soluc,ao de problemas" se houver problemas ao
   inicializar. Desligar e desconectar o disco original ada0 permitira que
   ele seja mantido como um backup offline.

   Em uso, o espelhamento se comportara exatamente como a unidade original.

  18.3.3. Criando um Espelhamento com Uma Unidade Existente

   Neste exemplo, o FreeBSD ja foi instalado em um unico disco, ada0. Um novo
   disco, ada1, foi conectado ao sistema. Um espelhamento de um disco sera
   criado no novo disco, o sistema existente sera copiado para ele e, em
   seguida, o disco antigo sera inserido no espelho. Esse procedimento um
   pouco complexo e necessario porque o gmirror precisa colocar um bloco de
   metadados de 512 bytes no final de cada disco, e o ada0 geralmente possui
   todo o seu espac,o ja alocado.

   Carregue o modulo do kernel geom_mirror.ko:

 # gmirror load

   Verifique o tamanho da midia do disco original com diskinfo:

 # diskinfo -v ada0 | head -n3
 /dev/ada0
         512             # sectorsize
         1000204821504   # mediasize in bytes (931G)

   Crie um espelhamento no novo disco. Para garantir que a capacidade do
   espelhamento nao seja maior do que a unidade ada0 original, gnop(8) e
   usado para criar uma unidade falsa exatamente do mesmo tamanho. Esta
   unidade nao armazena dados, mas e usada apenas para limitar o tamanho do
   espelhamento. Quando o gmirror(8) cria o espelhamento, ele ira restringir
   a capacidade ao tamanho de gzero.nop , mesmo se a nova unidade ada1 tiver
   mais espac,o. Note que o 1000204821504 na segunda linha e igual ao tamanho
   de midia do ada0 como mostrado pelo comando diskinfo acima.

 # geom zero load
 # gnop create -s 1000204821504 gzero
 # gmirror label -v gm0 gzero.nop ada1
 # gmirror forget gm0

   Como o gzero.nop nao armazena nenhum dado, o espelhamento nao o ve como
   conectado. E dito para o espelhamento "esquecer" os componentes
   desconectados, removendo referencias para gzero.nop. O resultado e um
   dispositivo espelhado contendo apenas um unico disco, ada1.

   Depois de criar o gm0, veja a tabela de partic,oes em ada0. Esta saida e
   de uma unidade de 1 TB. Se houver algum espac,o nao alocado no final da
   unidade, o conteudo pode ser copiado diretamente de ada0 para o novo
   espelho.

   No entanto, se a saida mostrar que todo o espac,o no disco esta alocado,
   como na listagem a seguir, nao ha espac,o disponivel para os 512-bytes de
   metadados de espelhamento no final do disco.

 # gpart show ada0
 =>        63  1953525105        ada0  MBR  (931G)
           63  1953525105           1  freebsd  [active]  (931G)

   Neste caso, a tabela de partic,ao deve ser editada para reduzir a
   capacidade de um setor em mirror/gm0. O procedimento sera explicado mais
   tarde.

   Em qualquer um dos casos, as tabelas de partic,ao no disco principal devem
   ser primeiro copiadas usando gpart backup e gpart restore.

 # gpart backup ada0 > table.ada0
 # gpart backup ada0s1 > table.ada0s1

   Esses comandos criam dois arquivos, table.ada0 e table.ada0s1. Este
   exemplo e de uma unidade de 1 TB:

 # cat table.ada0
 MBR 4
 1 freebsd         63 1953525105   [active]

 # cat table.ada0s1
 BSD 8
 1  freebsd-ufs          0    4194304
 2 freebsd-swap    4194304   33554432
 4  freebsd-ufs   37748736   50331648
 5  freebsd-ufs   88080384   41943040
 6  freebsd-ufs  130023424  838860800
 7  freebsd-ufs  968884224  984640881

   Se nenhum espac,o livre for exibido no final do disco, o tamanho da slice
   e da ultima partic,ao deve ser reduzido por um setor. Edite os dois
   arquivos, reduzindo o tamanho da fatia e da ultima partic,ao em um. Estes
   sao os ultimos numeros em cada listagem.

 # cat table.ada0
 MBR 4
 1 freebsd         63 1953525104   [active]

 # cat table.ada0s1
 BSD 8
 1  freebsd-ufs          0    4194304
 2 freebsd-swap    4194304   33554432
 4  freebsd-ufs   37748736   50331648
 5  freebsd-ufs   88080384   41943040
 6  freebsd-ufs  130023424  838860800
 7  freebsd-ufs  968884224  984640880

   Se pelo menos um setor nao foi alocado no final do disco, esses dois
   arquivos podem ser usados sem modificac,ao.

   Agora restaure a tabela de partic,oes em mirror/gm0:

 # gpart restore mirror/gm0 < table.ada0
 # gpart restore mirror/gm0s1 < table.ada0s1

   Verifique a tabela de partic,oes com o comando gpart show. Este exemplo
   tem gm0s1a para /, gm0s1d para /var, gm0s1e para /usr, gm0s1f para /data1
   e gm0s1g para /data2.

 # gpart show mirror/gm0
 =>        63  1953525104  mirror/gm0  MBR  (931G)
           63  1953525042           1  freebsd  [active]  (931G)
   1953525105          62              - free -  (31k)

 # gpart show mirror/gm0s1
 =>         0  1953525042  mirror/gm0s1  BSD  (931G)
            0     2097152             1  freebsd-ufs  (1.0G)
      2097152    16777216             2  freebsd-swap  (8.0G)
     18874368    41943040             4  freebsd-ufs  (20G)
     60817408    20971520             5  freebsd-ufs  (10G)
     81788928   629145600             6  freebsd-ufs  (300G)
    710934528  1242590514             7  freebsd-ufs  (592G)
   1953525042          63                - free -  (31k)

   Tanto a fatia quanto a ultima partic,ao devem ter pelo menos um bloco
   livre no final do disco.

   Crie sistemas de arquivos nessas novas partic,oes. O numero de partic,oes
   varia de acordo com o disco original, ada0.

 # newfs -U /dev/mirror/gm0s1a
 # newfs -U /dev/mirror/gm0s1d
 # newfs -U /dev/mirror/gm0s1e
 # newfs -U /dev/mirror/gm0s1f
 # newfs -U /dev/mirror/gm0s1g

   Torne o espelhamento inicializavel instalando o bootcode no MBR e no
   bsdlabel e definindo a slice ativa:

 # gpart bootcode -b /boot/mbr mirror/gm0
 # gpart set -a active -i 1 mirror/gm0
 # gpart bootcode -b /boot/boot mirror/gm0s1

   Ajuste o arquivo /etc/fstab para usar as novas partic,oes no
   espelhamento.Primeiro fac,a o backup deste arquivo copiando ele para
   /etc/fstab.orig.

 # cp /etc/fstab /etc/fstab.orig

   Edite o arquivo /etc/fstab, substituindo /dev/ada0 por mirror/gm0.

 # Device                Mountpoint      FStype  Options Dump    Pass#
 /dev/mirror/gm0s1a      /               ufs     rw      1       1
 /dev/mirror/gm0s1b      none            swap    sw      0       0
 /dev/mirror/gm0s1d      /var            ufs     rw      2       2
 /dev/mirror/gm0s1e      /usr            ufs     rw      2       2
 /dev/mirror/gm0s1f      /data1          ufs     rw      2       2
 /dev/mirror/gm0s1g      /data2          ufs     rw      2       2

   Se o modulo do kernel geom_mirror.ko nao foi carregado no kernel, edite o
   arquivo /boot/loader.conf para carrega-lo no boot:

 geom_mirror_load="YES"

   Os sistemas de arquivos do disco original agora podem ser copiados para o
   espelhamento com o dump(8) e o restore(8). Cada sistema de arquivos
   copiados com o dump -L ira primeiro criar um snapshot, o que pode levar
   algum tempo.

 # mount /dev/mirror/gm0s1a /mnt
 # dump -C16 -b64 -0aL -f - /    | (cd /mnt && restore -rf -)
 # mount /dev/mirror/gm0s1d /mnt/var
 # mount /dev/mirror/gm0s1e /mnt/usr
 # mount /dev/mirror/gm0s1f /mnt/data1
 # mount /dev/mirror/gm0s1g /mnt/data2
 # dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr && restore -rf -)
 # dump -C16 -b64 -0aL -f - /var | (cd /mnt/var && restore -rf -)
 # dump -C16 -b64 -0aL -f - /data1 | (cd /mnt/data1 && restore -rf -)
 # dump -C16 -b64 -0aL -f - /data2 | (cd /mnt/data2 && restore -rf -)

   Reinicie o sistema, inicializando a partir do ada1. Se tudo estiver
   funcionando, o sistema ira inicializar a partir de mirror/gm0, que agora
   contem os mesmos dados que o ada0 tinha anteriormente. Veja Sec,ao 18.3.4,
   "Soluc,ao de problemas" se houver problemas ao inicializar.

   Neste ponto, o espelhamento ainda consiste apenas no unico disco ada1.

   Apos inicializar a partir de mirror/gm0 com sucesso, a etapa final e
   inserir ada0 no espelhamento.

  Importante:

   Quando o ada0 for inserido no espelhamento, seu conteudo anterior sera
   substituido pelos dados do espelhamento. Certifique-se de que mirror/gm0
   tenha o mesmo conteudo do ada0 antes de adicionar o ada0 ao espelhamento.
   Se o conteudo anteriormente copiado pelo dump(8) e restore(8) nao forem
   identicos ao que estava em ada0, reverta o arquivo /etc/fstab para montar
   os sistemas de arquivos em ada0, e reinicie todo o procedimento novamente.

 # gmirror insert gm0 ada0
 GEOM_MIRROR: Device gm0: rebuilding provider ada0

   A sincronizac,ao entre os dois discos sera iniciada imediatamente. Use
   gmirror status para visualizar o progresso.

 # gmirror status
       Name    Status  Components
 mirror/gm0  DEGRADED  ada1 (ACTIVE)
                       ada0 (SYNCHRONIZING, 64%)

   Depois de um tempo, a sincronizac,ao sera concluida.

 GEOM_MIRROR: Device gm0: rebuilding provider ada0 finished.
 # gmirror status
       Name    Status  Components
 mirror/gm0  COMPLETE  ada1 (ACTIVE)
                       ada0 (ACTIVE)

   O mirror/gm0 agora consiste de dois discos ada0 e ada1, e o conteudo e
   automaticamente sincronizado entre eles. Em uso, o mirror/gm0 ira se
   comportar como a unica unidade original.

  18.3.4. Soluc,ao de problemas

   Se o sistema nao inicializar mais, as configurac,oes da BIOS podem ter que
   ser alteradas para inicializar a partir de uma das novas unidades
   espelhadas. Qualquer uma das unidades espelhadas pode ser usada para
   inicializar, pois elas contem dados identicos.

   Se a inicializac,ao parar com esta mensagem, algo esta errado com o
   dispositivo espelhado:

 Mounting from ufs:/dev/mirror/gm0s1a failed with error 19.

 Loader variables:
   vfs.root.mountfrom=ufs:/dev/mirror/gm0s1a
   vfs.root.mountfrom.options=rw

 Manual root filesystem specification:
   <fstype>:<device> [options]
       Mount <device> using filesystem <fstype>
       and with the specified (optional) option list.

     eg. ufs:/dev/da0s1a
         zfs:tank
         cd9660:/dev/acd0 ro
           (which is equivalent to: mount -t cd9660 -o ro /dev/acd0 /)

   ?               List valid disk boot devices
   .               Yield 1 second (for background tasks)
   <empty line>    Abort manual input

 mountroot>

   Esquecer de carregar o modulo geom_mirror.ko no arquivo /boot/loader.conf
   pode causar este problema. Para conserta-lo, inicialize a partir de uma
   midia de instalac,ao do FreeBSD e escolha Shell no primeiro prompt. Em
   seguida, carregue o modulo de espelhamento e monte o dispositivo
   espelhado:

 # gmirror load
 # mount /dev/mirror/gm0s1a /mnt

   Edite o arquivo /mnt/boot/loader.conf, adicionando uma linha para carregar
   o modulo de espelhamento:

 geom_mirror_load="YES"

   Salve o arquivo e reinicie.

   Outros problemas que causam o error 19 requerem mais esforc,o para serem
   corrigidos. Embora o sistema deva inicializar a partir de ada0, outro
   prompt para selecionar um shell aparecera se o arquivo /etc/fstab estiver
   incorreto. Digite ufs:/dev/ada0s1a no prompt do carregador de boot e
   pressione Enter. Desfac,a as edic,oes no arquivo /etc/fstab e monte os
   sistemas de arquivos a partir do disco original (ada0) em vez do
   espelhado. Reinicialize o sistema e tente o procedimento novamente.

 Enter full pathname of shell or RETURN for /bin/sh:
 # cp /etc/fstab.orig /etc/fstab
 # reboot

  18.3.5. Recuperando de Uma Falha de Disco

   O beneficio do espelhamento de disco e que um disco individual pode falhar
   sem fazer com que o espelho perca qualquer dado. No exemplo acima, se ada0
   falhar, o espelho continuara funcionando, fornecendo dados a partir do
   disco que continua operacional, ada1.

   Para substituir a unidade com falha, desligue o sistema e substitua
   fisicamente a unidade com falha por uma nova unidade com capacidade igual
   ou maior. Os fabricantes usam valores um tanto arbitrarios ao classificar
   drives em gigabytes, e a unica maneira de realmente ter certeza e comparar
   a contagem total de setores mostrados por diskinfo -v. Uma unidade com
   maior capacidade que o espelho funcionara, embora o espac,o extra na nova
   unidade nao seja usado.

   Depois que o computador for ligado novamente, o espelho sera executado em
   um modo "degradado" com apenas uma unidade. O espelho e avisado para
   esquecer as unidades que nao estao conectadas no momento:

 # gmirror forget gm0

   Quaisquer metadados antigos devem ser apagados do disco de substituic,ao
   usando as instruc,oes em Sec,ao 18.3.1, "Problemas de Metadados". Em
   seguida, o disco de substituic,ao, ada4 para este exemplo, e inserido no
   espelho:

 # gmirror insert gm0 /dev/ada4

   A ressincronizac,ao comec,a quando a nova unidade e inserida no espelho.
   Esse processo de copiar dados espelhados para uma nova unidade pode
   demorar um pouco. O desempenho do espelho sera bastante reduzido durante a
   copia, portanto, a inserc,ao de novos discos e deve ser executada quando
   houver pouca demanda no computador.

   O progresso pode ser monitorado com o comando gmirror status , que mostra
   as unidades que estao sendo sincronizadas e a porcentagem de conclusao.
   Durante a ressincronizac,ao, o status sera DEGRADED, mudando para COMPLETE
   quando o processo for concluido.

18.4. RAID3 - Distribuic,ao em Nivel de Byte com Paridade Dedicada

   Written by Mark Gladman e Daniel Gerzo.
   Based on documentation by Tom Rhodes e Murray Stokely.

   O RAID3 e um metodo usado para combinar varias unidades de disco em um
   unico volume com um disco de paridade dedicado. Em um sistema RAID3, os
   dados sao divididos em varios bytes que sao escritos em todas as unidades
   da matriz, exceto por um disco que atua como um disco de paridade
   dedicado. Isso significa que as leituras de disco de uma implementac,ao de
   RAID3 acessam todos os discos na matriz. O desempenho pode ser aprimorado
   usando varios controladores de disco. O array RAID3 fornece uma tolerancia
   a falhas de 1 unidade, enquanto fornece uma capacidade de 1 - 1/n vezes a
   capacidade total de todas as unidades no array, onde n e o numero de
   unidades de disco rigido no array. Essa configurac,ao e adequada
   principalmente para armazenar dados de tamanhos maiores, como arquivos
   multimidia.

   Pelo menos 3 discos rigidos fisicos sao necessarios para criar um array
   RAID3. Cada disco deve ter o mesmo tamanho, pois as solicitac,oes de I/O
   sao intercaladas para ler ou gravar em varios discos em paralelo. Alem
   disso, devido `a natureza do RAID3, o numero de unidades deve ser igual a
   3, 5, 9, 17 e assim por diante, ou 2^n + 1.

   Esta sec,ao demonstra como criar um RAID3 via software em um sistema
   FreeBSD.

  Nota:

   Embora seja teoricamente possivel inicializar a partir de um array RAID3
   no FreeBSD, essa configurac,ao e incomum e nao e recomendada.

  18.4.1. Criando uma Matriz RAID3 Dedicada

   No FreeBSD, o suporte para RAID3 e implementado pela classe GEOM
   graid3(8). Criar um array dedicado de RAID3 no FreeBSD requer os seguintes
   passos.

    1. Primeiro, carregue o modulo do kernel geom_raid3.ko emitindo um dos
       seguintes comandos:

 # graid3 load

       ou:

 # kldload geom_raid3

    2. Assegure-se de que exista um ponto de montagem adequado. Este comando
       cria um novo diretorio para usar como ponto de montagem:

 # mkdir /multimedia

    3. Determine os nomes dos dispositivos para os discos que serao
       adicionados `a matriz e crie o novo dispositivo RAID3. O dispositivo
       final listado atuara como o disco de paridade dedicado. Este exemplo
       usa tres unidades ATA nao-particionadas: ada1 e ada2 para dados e ada3
       para paridade.

 # graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3
 Metadata value stored on /dev/ada1.
 Metadata value stored on /dev/ada2.
 Metadata value stored on /dev/ada3.
 Done.

    4. Particione o dispositivo gr0 recem-criado e coloque um sistema de
       arquivos UFS:

 # gpart create -s GPT /dev/raid3/gr0
 # gpart add -t freebsd-ufs /dev/raid3/gr0
 # newfs -j /dev/raid3/gr0p1

       Muitos numeros irao ser exibios na tela e, apos algum tempo, o
       processo sera concluido. O volume foi criado e esta pronto para ser
       montado:

 # mount /dev/raid3/gr0p1 /multimedia/

       A matriz RAID3 esta agora pronta para uso.

   Uma configurac,ao adicional e necessaria para manter essa configurac,ao
   nas reinicializac,oes do sistema.

    1. O modulo geom_raid3.ko deve ser carregado antes que o array possa ser
       montado. Para carregar automaticamente o modulo do kernel durante a
       inicializac,ao do sistema, adicione a seguinte linha ao arquivo
       /boot/loader.conf:

 geom_raid3_load="YES"

    2. As seguintes informac,oes de volume devem ser adicionadas ao arquivo
       /etc/fstab para montar automaticamente o sistema de arquivos do array
       durante o processo de inicializac,ao do sistema:

 /dev/raid3/gr0p1        /multimedia     ufs     rw      2       2

18.5. Dispositivos RAID por Software

   Originalmente contribuido por Warren Block.

   Algumas placas-mae e placas de expansao adicionam um hardware simples,
   geralmente apenas uma ROM, que permite que o computador inicialize a
   partir de um array RAID. Apos a inicializac,ao, o acesso ao array RAID e
   feito pelo software em execuc,ao no processador principal do computador.
   Este "RAID via software assistido por hardware" fornece arrays RAID que
   nao dependem de nenhum sistema operacional em particular, e que sao
   funcionais antes mesmo de um sistema operacional ser carregado.

   Varios niveis de RAID sao suportados, dependendo do hardware em uso. Veja
   graid(8) para uma lista completa.

   O graid(8) requer o modulo do kernel geom_raid.ko, que esta incluido no
   kernel GENERIC a partir do FreeBSD 9.1. Se necessario, ele pode ser
   carregado manualmente com o comando graid load.

  18.5.1. Criando um Array

   Os dispositivos de RAID via software geralmente tem um menu que pode ser
   acessado pressionando teclas especiais quando o computador esta
   inicializando. O menu pode ser usado para criar e excluir arrays RAID. O
   graid(8) tambem pode criar arrays diretamente a partir da linha de
   comando.

   O graid label e usado para criar um novo array. A placa-mae usada neste
   exemplo tem um chipset RAID da Intel, portanto, o formato de metadados da
   Intel e especificado. A nova matriz recebe um rotulo de gm0, e um
   espelhamento (RAID1) e usa as unidades ada0 e ada1.

  Cuidado:

   Algum espac,o nas unidades sera sobrescrito quando elas forem
   transformadas em um novo array. Fac,a o backup dos dados existentes
   primeiro!

 # graid label Intel gm0 RAID1 ada0 ada1
 GEOM_RAID: Intel-a29ea104: Array Intel-a29ea104 created.
 GEOM_RAID: Intel-a29ea104: Disk ada0 state changed from NONE to ACTIVE.
 GEOM_RAID: Intel-a29ea104: Subdisk gm0:0-ada0 state changed from NONE to ACTIVE.
 GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
 GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to ACTIVE.
 GEOM_RAID: Intel-a29ea104: Array started.
 GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from STARTING to OPTIMAL.
 Intel-a29ea104 created
 GEOM_RAID: Intel-a29ea104: Provider raid/r0 for volume gm0 created.

   Uma verificac,ao de status mostra que o novo espelhamento esta pronto para
   uso:

 # graid status
    Name   Status  Components
 raid/r0  OPTIMAL  ada0 (ACTIVE (ACTIVE))
                   ada1 (ACTIVE (ACTIVE))

   O dispositivo de array aparece em /dev/raid/. O primeiro array e chamado
   de r0. Arrays adicionais, se presentes, serao r1, r2 e assim por diante.

   O menu da BIOS em alguns desses dispositivos pode criar arrays com
   caracteres especiais em seus nomes. Para evitar problemas com esses
   caracteres especiais, os arrays recebem nomes numerados simples como r0.
   Para mostrar os rotulos reais, como gm0 no exemplo acima, use o sysctl(8):

 # sysctl kern.geom.raid.name_format=1

  18.5.2. Multiplos Volumes

   Alguns dispositivos de RAID via software suportam mais de um volume em um
   array. Os volumes funcionam como partic,oes, permitindo que o espac,o nas
   unidades fisicas seja dividido e usado de diferentes maneiras. Por
   exemplo, os dispositivos RAID via software Intel suportam dois volumes.
   Este exemplo cria um espelho de 40G para armazenar com seguranc,a o
   sistema operacional, seguido por um volume de 20G RAID0 (stripe) para
   armazenamento temporario rapido:

 # graid label -S 40G Intel gm0 RAID1 ada0 ada1
 # graid add -S 20G gm0 RAID0

   Os volumes aparecem como entradas adicionais rX em /dev/raid/. Um array
   com dois volumes mostrara r0 e r1.

   Veja graid(8) para o numero de volumes suportados por diferentes
   dispositivos RAID via software.

  18.5.3. Convertendo uma Unica Unidade em um Espelho

   Sob certas condic,oes especificas, e possivel converter uma unica unidade
   existente em um array graid(8) sem reformatar. Para evitar a perda de
   dados durante a conversao, a unidade existente deve atender a esses
   requisitos minimos:

     * A unidade deve ser particionada com o esquema de particionamento MBR.
       O GPT ou outros esquemas de particionamento com metadados no final da
       unidade serao sobrescritos e corrompidos pelos metadados do graid(8).

     * Deve haver espac,o nao particionado e nao utilizado o suficiente no
       final da unidade para conter os metadados do graid(8). Esses metadados
       variam em tamanho, mas o maior ocupa 64M, entao pelo menos este
       espac,o livre e recomendado.

   Se a unidade atender a esses requisitos, comece fazendo um backup
   completo. Em seguida, crie um espelhamento de unidade unica com essa
   unidade:

 # graid label Intel gm0 RAID1 ada0 NONE

   Os metadados do graid(8) foram gravados no final da unidade no espac,o nao
   utilizado. Uma segunda unidade pode agora ser inserida no espelhamento:

 # graid insert raid/r0 ada1

   Os dados da unidade original comec,arao imediatamente a ser copiados para
   a segunda unidade. O espelhamento operara em status degradado ate que a
   copia seja concluida.

  18.5.4. Inserindo Novos Discos no Array

   As unidades podem ser inseridas em uma matriz como substitutos de unidades
   que falharam ou estao faltando. Se nao houver unidades com falha ou
   ausentes, a nova unidade se tornara uma reserva. Por exemplo, inserir uma
   nova unidade em um espelhamento de duas unidades de trabalho resulta em um
   espelhamento de duas unidades com uma unidade sobressalente, nao em um
   espelhamento de tres unidades.

   No array de espelho do exemplo, os dados comec,am a ser copiados
   imediatamente para a unidade recem-inserida. Qualquer informac,ao
   existente na nova unidade sera substituida.

 # graid insert raid/r0 ada1
 GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
 GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to NEW.
 GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NEW to REBUILD.
 GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 rebuild start at 0.

  18.5.5. Removendo Discos do Array

   Discos individuais podem ser permanentemente removidos de um array e seus
   metadados apagados:

 # graid remove raid/r0 ada1
 GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from ACTIVE to OFFLINE.
 GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-[unknown] state changed from ACTIVE to NONE.
 GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from OPTIMAL to DEGRADED.

  18.5.6. Parando o Array

   Um array pode ser interrompido sem remover os metadados das unidades. O
   array sera reiniciado quando o sistema for inicializado.

 # graid stop raid/r0

  18.5.7. Verificando o Status do Array

   O status do array pode ser verificado a qualquer momento. Depois que um
   disco foi adicionado ao espelho no exemplo acima, os dados estarao sendo
   copiados do disco original para o novo disco:

 # graid status
    Name    Status  Components
 raid/r0  DEGRADED  ada0 (ACTIVE (ACTIVE))
                    ada1 (ACTIVE (REBUILD 28%))

   Alguns tipos de arrays, como RAID0 ou CONCAT, podem nao ser mostrados no
   relatorio de status se os discos falharem. Para ver esses arrays com
   falhas parciais, adicione -ga:

 # graid status -ga
           Name  Status  Components
 Intel-e2d07d9a  BROKEN  ada6 (ACTIVE (ACTIVE))

  18.5.8. Excluindo Arrays

   Arrays sao destruidos, excluindo todos os volumes deles. Quando o ultimo
   volume presente e excluido, o array e interrompido e os metadados sao
   removidos dos discos:

 # graid delete raid/r0

  18.5.9. Excluindo Arrays Inesperados

   Os discos podem conter metadados graid(8) inesperados, originados no seu
   uso anterior ou em testes do fabricante. O graid(8) detectara estes discos
   e criara um array, interferindo no acesso ao disco individual. Para
   remover os metadados indesejados:

    1. Inicialize o sistema. No menu de inicializac,ao, selecione 2 para o
       prompt do utilitario de boot. Entre:

 OK set kern.geom.raid.enable=0
 OK boot

       O sistema inicializara com o graid(8) desativado.

    2. Fazer backup de todos os dados na unidade afetada.

    3. Como soluc,ao alternativa, a detecc,ao de arrays graid(8) pode ser
       desativada incluindo se a variavel

 kern.geom.raid.enable=0

       no arquivo /boot/loader.conf.

       Para remover permanentemente os metadados graid(8) do disco afetado,
       inicialize uma instalac,ao do FreeBSD usando um CD-ROM ou um memory
       stick e selecione a opc,ao Shell. Use o comando status para encontrar
       o nome do array, normalmente raid/r0:

 # graid status
    Name   Status  Components
 raid/r0  OPTIMAL  ada0 (ACTIVE (ACTIVE))
                   ada1 (ACTIVE (ACTIVE))

       Exclua o volume pelo nome:

 # graid delete raid/r0

       Se houver mais de um volume exibido, repita o processo para cada
       volume. Apos o ultimo array ter sido excluido, o volume sera
       destruido.

       Reinicialize e verifique os dados, restaurando a partir do backup, se
       necessario. Depois que os metadados forem removidos, a entrada
       kern.geom.raid.enable=0 no arquivo /boot/loader.conf tambem pode ser
       removida.

18.6. GEOM Network Gate

   O GEOM fornece um mecanismo simples para fornecer acesso remoto a
   dispositivos como discos, CDs e sistemas de arquivos atraves do uso do
   daemon GEOM Network Gate, ggated. O sistema com o dispositivo executa o
   daemon do servidor que manipula solicitac,oes feitas por clientes usando o
   ggatec. Os dispositivos nao devem conter dados confidenciais, pois a
   conexao entre o cliente e o servidor nao e criptografada.

   Semelhante ao NFS, que e discutido em Sec,ao 29.3, "Network File System
   (NFS)", o ggated e configurado usando um arquivo de exportac,ao. Este
   arquivo especifica quais sistemas tem permissao para acessar os recursos
   exportados e em qual nivel de acesso eles sao oferecidos. Por exemplo,
   para fornecer ao cliente 192.168.1.5 acesso de leitura e gravac,ao `a
   quarta slice do primeiro disco SCSI, crie o arquivo /etc/gg.exports com
   esta linha:

 192.168.1.5 RW /dev/da0s4d

   Antes de exportar o dispositivo, verifique se ele nao esta montado no
   momento. Em seguida, inicie o ggated:

 # ggated

   Varias opc,oes estao disponiveis para especificar uma porta de escuta
   alternativa ou para alterar o local padrao do arquivo de exportac,ao.
   Consulte ggated(8) para maiores detalhes.

   Para acessar o dispositivo exportado na maquina cliente, primeiro use o
   comando ggatec para especificar o enderec,o IP do servidor e o nome do
   dispositivo exportado. Se bem sucedido, este comando ira exibir um nome de
   dispositivo ggate para montar. Monte esse nome de dispositivo especificado
   em um ponto de montagem livre. Este exemplo conecta-se `a partic,ao
   /dev/da0s4d no 192.168.1.1, em seguida, monta o /dev/ggate0 em /mnt:

 # ggatec create -o rw 192.168.1.1 /dev/da0s4d
 ggate0
 # mount /dev/ggate0 /mnt

   O dispositivo no servidor pode agora ser acessado por meio do /mnt no
   cliente. Para maiores detalhes sobre o ggatec e alguns exemplos de uso,
   consulte ggatec(8).

  Nota:

   A montagem falhara se o dispositivo estiver atualmente montado no servidor
   ou em qualquer outro cliente na rede. Se for necessario acesso simultaneo
   aos recursos de rede, use o NFS.

   Quando o dispositivo nao for mais necessario, desmonte-o com o umount para
   que o recurso fique disponivel para outros clientes.

18.7. Rotulando Dispositivos de Disco

   Durante a inicializac,ao do sistema, o kernel do FreeBSD cria nos de
   dispositivos conforme os dispositivos sao encontrados. Esse metodo de
   detectar dispositivos gera alguns problemas. Por exemplo, e se um novo
   dispositivo de disco for adicionado via USB? E provavel que um dispositivo
   flash receba o nome do dispositivo da0 e o da0 original alterado para da1.
   Isso causara problemas ao montar sistemas de arquivos se eles estiverem
   listados no /etc/fstab, o que tambem pode impedir que o sistema seja
   inicializado.

   Uma soluc,ao e encadear os dispositivos SCSI para que um novo dispositivo
   adicionado `a placa SCSI receba numeros de dispositivo nao utilizados. Mas
   e os dispositivos USB que podem substituir o disco principal SCSI? Isso
   acontece porque os dispositivos USB geralmente sao examinados antes da
   placa SCSI. Uma soluc,ao e inserir esses dispositivos apenas apos o
   sistema ter sido inicializado. Outro metodo e usar apenas uma unica
   unidade ATA e nunca listar os dispositivos SCSI no arquivo /etc/fstab.

   Uma soluc,ao melhor e usar o glabel para rotular os dispositivos de disco
   e usar os rotulos no arquivo /etc/fstab. Como o glabel armazena o rotulo
   no ultimo setor de um determinado provedor, o rotulo permanecera
   persistente nas reinicializac,oes. Ao usar esse rotulo como um
   dispositivo, o sistema de arquivos pode sempre ser montado
   independentemente do no do dispositivo pelo qual ele e acessado.

  Nota:

   O glabel pode criar rotulos transitorios e permanentes. Somente rotulos
   permanentes sao consistentes nas reinicializac,oes. Consulte glabel(8)
   para obter mais informac,oes sobre as diferenc,as entre os rotulos.

  18.7.1. Tipos de Rotulos e Exemplos

   Os rotulos permanentes podem ser um rotulo generico ou de um sistema de
   arquivos. Rotulos de sistema de arquivos permanentes podem ser criados com
   tunefs(8) ou newfs(8). Esses tipos de rotulos sao criados em um
   subdiretorio /dev e serao nomeados de acordo com o tipo de sistema de
   arquivos. Por exemplo, os rotulos do sistema de arquivos UFS2 serao
   criados em /dev/ufs. Rotulos permanentes genericos podem ser criados com o
   glabel label. Estes nao sao especificos do sistema de arquivos e serao
   criados em /dev/label.

   Os rotulos temporarios sao destruidos na proxima reinicializac,ao. Esses
   rotulos sao criados em /dev/label e sao adequados para experimentac,ao. Um
   rotulo temporario pode ser criado usando glabel create.

   Para criar um rotulo permanente para um sistema de arquivos UFS2 sem
   destruir nenhum dado, emita o seguinte comando:

 # tunefs -L home /dev/da3

   Um rotulo deve agora existir em /dev/ufs que pode ser adicionado ao
   arquivo /etc/fstab:

 /dev/ufs/home           /home            ufs     rw              2      2

  Nota:

   O sistema de arquivos nao deve ser montado durante a tentativa de executar
   o tunefs.

   Agora o sistema de arquivos pode ser montado:

 # mount /home

   A partir deste ponto, desde que o modulo do kernel geom_label.ko seja
   carregado na inicializac,ao com o /boot/loader.conf ou com a opc,ao do
   kernel GEOM_LABEL estando presente, o no do dispositivo pode mudar sem
   qualquer efeito negativo no sistema.

   Os sistemas de arquivos tambem podem ser criados com um rotulo padrao
   usando a flag -L com o comando newfs. Consulte newfs(8) para obter maiores
   informac,oes.

   O seguinte comando pode ser usado para destruir o rotulo:

 # glabel destroy home

   O exemplo a seguir mostra como rotular as partic,oes de um disco de
   inicializac,ao.

   Exemplo 18.1. Rotulando Partic,oes no Disco de Inicializac,ao

   Ao marcar permanentemente as partic,oes no disco de inicializac,ao, o
   sistema deve poder continuar a inicializar normalmente, mesmo se o disco
   for movido para outro controlador ou transferido para um sistema
   diferente. Para este exemplo, presume-se que um unico disco ATA e usado,
   que e atualmente reconhecido pelo sistema como ad0. Tambem e assumido que
   o esquema de partic,ao padrao do FreeBSD e usado, com /, /var , /usr e
   /tmp, bem como uma partic,ao de swap.

   Reinicialize o sistema e, no prompt do loader(8), pressione 4 para
   inicializar no modo de usuario unico. Em seguida, insira os seguintes
   comandos:

 # glabel label rootfs /dev/ad0s1a
 GEOM_LABEL: Label for provider /dev/ad0s1a is label/rootfs
 # glabel label var /dev/ad0s1d
 GEOM_LABEL: Label for provider /dev/ad0s1d is label/var
 # glabel label usr /dev/ad0s1f
 GEOM_LABEL: Label for provider /dev/ad0s1f is label/usr
 # glabel label tmp /dev/ad0s1e
 GEOM_LABEL: Label for provider /dev/ad0s1e is label/tmp
 # glabel label swap /dev/ad0s1b
 GEOM_LABEL: Label for provider /dev/ad0s1b is label/swap
 # exit

   O sistema continuara com a inicializac,ao multiusuario. Depois que a
   inicializac,ao terminar, edite o arquivo /etc/fstab e substitua os nomes
   de dispositivos convencionais por seus respectivos rotulos. No final o
   /etc/fstab ficara assim:

 # Device                Mountpoint      FStype  Options         Dump    Pass#
 /dev/label/swap         none            swap    sw              0       0
 /dev/label/rootfs       /               ufs     rw              1       1
 /dev/label/tmp          /tmp            ufs     rw              2       2
 /dev/label/usr          /usr            ufs     rw              2       2
 /dev/label/var          /var            ufs     rw              2       2

   O sistema agora pode ser reinicializado. Se tudo correr bem, ele aparecera
   normalmente e o comando mount mostrara:

 # mount
 /dev/label/rootfs on / (ufs, local)
 devfs on /dev (devfs, local)
 /dev/label/tmp on /tmp (ufs, local, soft-updates)
 /dev/label/usr on /usr (ufs, local, soft-updates)
 /dev/label/var on /var (ufs, local, soft-updates)

   A classe glabel(8) suporta um tipo de rotulo para sistemas de arquivos
   UFS, com base no ID do sistema de arquivos exclusivo ufsid. Esses rotulos
   podem ser encontrados em /dev/ufsid e sao criados automaticamente durante
   a inicializac,ao do sistema. E possivel usar rotulos ufsid para montar
   partic,oes usando o /etc/fstab. Use o glabel status para receber uma lista
   de sistemas de arquivos e seus rotulos ufsid correspondentes:

 % glabel status
                   Name  Status  Components
 ufsid/486b6fc38d330916     N/A  ad4s1d
 ufsid/486b6fc16926168e     N/A  ad4s1f

   No exemplo acima, ad4s1d representa /var, enquanto ad4s1f representa /usr.
   Usando os valores ufsid mostrados, essas partic,oes podem agora ser
   montadas com as seguintes entradas em /etc/fstab:

 /dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      2
 /dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      2

   Quaisquer partic,oes com rotulos ufsid podem ser montadas dessa forma,
   eliminando a necessidade de criar manualmente rotulos permanentes,
   enquanto ainda desfruta dos beneficios da montagem independente do nome do
   dispositivo.

18.8. Journaling UFS atraves do GEOM

   Suporte para journaling em sistemas de arquivos UFS esta disponivel no
   FreeBSD. A implementac,ao e fornecida atraves do subsistema GEOM e e
   configurada usando o comando gjournal. Ao contrario de outras
   implementac,oes de journaling de sistemas de arquivos, o metodo gjournal e
   baseado em blocos e nao e implementado como parte do sistema de arquivos.
   E uma extensao do GEOM.

   O jornaling armazena um log de transac,oes do sistema de arquivos, como
   alterac,oes que compoem uma operac,ao de gravac,ao em disco completa,
   antes que os metadados e as gravac,oes de arquivos sejam confirmados no
   disco. Esse log de transac,ao pode ser repetido posteriormente para
   refazer as transac,oes do sistema de arquivos, evitando inconsistencias no
   sistema de arquivos.

   Esse metodo fornece outro mecanismo para proteger contra perda de dados e
   inconsistencias do sistema de arquivos. Ao contrario das Soft Updates, que
   rastreiam e impoem atualizac,oes de metadados e snapshots, que criam uma
   imagem do sistema de arquivos, um log e armazenado no espac,o em disco
   especificamente para essa tarefa. Para melhor desempenho, o journal pode
   ser armazenado em outro disco. Nessa configurac,ao, o provedor do journal
   ou o dispositivo de armazenamento deve ser listado apos o dispositivo para
   ativar o journaling.

   O kernel GENERIC fornece suporte para o gjournal. Para carregar
   automaticamente o modulo do kernel geom_journal.ko no momento da
   inicializac,ao, adicione a seguinte linha ao arquivo /boot/loader.conf:

 geom_journal_load="YES"

   Se um kernel personalizado for usado, certifique-se de que a linha a
   seguir esteja no arquivo de configurac,ao do kernel:

 options GEOM_JOURNAL

   Depois que o modulo e carregado, um journal pode ser criado em um novo
   sistema de arquivos usando as etapas a seguir. Neste exemplo, da4 e um
   novo disco SCSI:

 # gjournal load
 # gjournal label /dev/da4

   Isto ira carregar o modulo e criar um no de dispositivo /dev/da4.journal
   em /dev/da4.

   Um sistema de arquivos UFS pode agora ser criado no dispositivo journaled
   e depois montado em um ponto de montagem existente:

 # newfs -O 2 -J /dev/da4.journal
 # mount /dev/da4.journal /mnt

  Nota:

   No caso de varias slices, sera criado um journal para cada slice
   individual. Por exemplo, se ad4s1 e ad4s2 forem slices, o gjournal criara
   ad4s1.journal e ad4s2.journal.

   O journaling tambem pode ser ativado nos sistemas de arquivos atuais
   usando o tunefs. No entanto, sempre fac,a um backup antes de tentar
   alterar um sistema de arquivos existente. Na maioria dos casos, o gjournal
   falhara se nao for possivel criar o registro de log, mas isso nao protege
   contra a perda de dados incorrida como resultado do uso indevido do
   tunefs. Consulte gjournal(8) e tunefs(8) para maiores informac,oes sobre
   esses comandos.

   E possivel fazer o journaling do disco de inicializac,ao de um sistema
   FreeBSD. Consulte o artigo Implementando o journaling do UFS em um PC de
   mesa para obter instruc,oes detalhadas.

Capitulo 19. O sistema de arquivos Z (ZFS)

   Escrito porTom Rhodes, Allan Jude , Benedict Reuschling e Warren Block .
   Indice

   19.1. O que torna o ZFS diferente

   19.2. Guia de Inicio Rapido

   19.3. Administrac,ao zpool

   19.4. Administrac,ao do zfs

   19.5. Administrac,ao Delegada

   19.6. Topicos Avanc,ados

   19.7. Recursos adicionais

   19.8. Recursos e terminologia do ZFS

   O Sistema de Arquivos Z, ou ZFS, e um sistema de arquivos avanc,ado
   projetado para superar muitos dos principais problemas encontrados em
   projetos anteriores.

   Originalmente desenvolvido pela Sun(TM), o desenvolvimento continuo do ZFS
   em codigo aberto foi movido para o Projeto OpenZFS.

   O ZFS tem tres metas principais de design:

     * Integridade de dados: Todos os dados incluem um checksum dos dados.
       Quando os dados sao gravados, o checksum e calculado e gravado junto
       com eles. Quando esses dados sao lidos posteriormente, o checksum e
       calculado novamente. Se os checksum's nao corresponderem, um erro de
       dados foi detectado. O ZFS tentara corrigir automaticamente os erros
       quando houver redundancia de dados disponivel.

     * Armazenamento em pool: os dispositivos de armazenamento fisico sao
       adicionados em um pool e o espac,o de armazenamento e alocado a partir
       desse pool compartilhado. O espac,o esta disponivel para todos os
       sistemas de arquivos e pode ser aumentado pela adic,ao de novos
       dispositivos de armazenamento ao pool.

     * Performance: varios mecanismos de cache fornecem uma maior
       performance. O ARC e um avanc,ado cache de leitura baseado em memoria.
       Um segundo nivel de cache de leitura baseado em disco pode ser
       adicionado com o L2ARC, e o cache sincrono de escrita baseado em disco
       esta disponivel com ZIL.

   Uma lista completa de features e terminologias e mostrada em Sec,ao 19.8,
   "Recursos e terminologia do ZFS ".

19.1. O que torna o ZFS diferente

   O ZFS e significativamente diferente de qualquer outro sistema de arquivos
   existente, porque ele e mais do que apenas um simples sistema de arquivos.
   A combinac,ao das func,oes tradicionalmente separadas de gerenciamento de
   volume e de sistema de arquivos, fornece ao ZFS vantagens exclusivas. O
   sistema de arquivos agora conhece a estrutura abaixo dos discos. Os
   sistemas de arquivos tradicionais so podem ser criados em um unico disco
   por vez. Se houvesse dois discos, dois sistemas de arquivos separados
   teriam que ser criados. Em uma configurac,ao de hardware tradicional RAID,
   esse problema foi contornado apresentando ao sistema operacional um unico
   disco logico composto pelo espac,o fornecido por varios discos fisicos,
   sobre o qual o sistema operacional colocava um sistema de arquivos. Mesmo
   no caso de soluc,oes de software RAID como as fornecidas pelo GEOM, o
   sistema de arquivos UFS, que esta no topo da transformac,ao RAID,
   acreditava que estava lidando com um unico dispositivo fisico. A
   combinac,ao feita pelo ZFS do gerenciador de volumes e do sistema de
   arquivos resolve isso e permite a criac,ao de varios sistemas de arquivos,
   todos compartilhando um pool de armazenamento disponivel. Uma das maiores
   vantagens do reconhecimento do layout fisico dos discos pelo ZFS e que os
   sistemas de arquivos existentes podem ser expandidos automaticamente
   quando novos discos sao adicionados ao pool. Esse novo espac,o e
   disponibilizado para todos os sistemas de arquivos. O ZFS tambem possui
   varias propriedades diferentes que podem ser aplicadas a cada sistema de
   arquivos, oferecendo muitas vantagens para a criac,ao de varios sistemas
   de arquivos e datasets diferentes, em vez de um unico sistema de arquivos
   monolitico.

19.2. Guia de Inicio Rapido

   Existe um mecanismo de inicializac,ao que permite ao FreeBSD montar pools
   do ZFS durante a inicializac,ao do sistema. Para habilita-lo, adicione
   esta linha ao /etc/rc.conf:

 zfs_enable="YES"

   Entao inicie o servic,o:

 # service zfs start

   Os exemplos nesta sec,ao assumem tres discos SCSI com os seguintes nomes
   de dispositivo da0, da1 e da2. Usuarios de hardware do tipo SATA devem
   usar nomes de dispositivo ada.

  19.2.1. Pool de Disco Unico

   Para criar um pool simples e nao-redundante usando um unico disco:

 # zpool create example /dev/da0

   Para visualizar o novo pool, verifique a saida do comando df:

 # df
 Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
 /dev/ad0s1a   2026030  235230  1628718    13%    /
 devfs               1       1        0   100%    /dev
 /dev/ad0s1d  54098308 1032846 48737598     2%    /usr
 example      17547136       0 17547136     0%    /example

   Esta saida mostra que o pool example foi criado e montado e agora esta
   acessivel como um sistema de arquivos. Arquivos podem ser criados nele e
   os usuarios podem navegar nele:

 # cd /example
 # ls
 # touch testfile
 # ls -al
 total 4
 drwxr-xr-x   2 root  wheel    3 Aug 29 23:15 .
 drwxr-xr-x  21 root  wheel  512 Aug 29 23:12 ..
 -rw-r--r--   1 root  wheel    0 Aug 29 23:15 testfile

   No entanto, esse pool nao esta aproveitando nenhuma feature do ZFS. Para
   criar um dataset neste pool com a compressao ativada:

 # zfs create example/compressed
 # zfs set compression=gzip example/compressed

   O dataset example/compressed e agora um sistema de arquivos ZFS
   compactado. Tente copiar alguns arquivos grandes para /example/compressed.

   A compactac,ao pode ser desativada com:

 # zfs set compression=off example/compressed

   Para desmontar um sistema de arquivos, use zfs umount e, em seguida,
   verifique com df:

 # zfs umount example/compressed
 # df
 Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
 /dev/ad0s1a   2026030  235232  1628716    13%    /
 devfs               1       1        0   100%    /dev
 /dev/ad0s1d  54098308 1032864 48737580     2%    /usr
 example      17547008       0 17547008     0%    /example

   Para remontar o sistema de arquivos para torna-lo acessivel novamente, use
   zfs mount e verifique com o df:

 # zfs mount example/compressed
 # df
 Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
 /dev/ad0s1a          2026030  235234  1628714    13%    /
 devfs                      1       1        0   100%    /dev
 /dev/ad0s1d         54098308 1032864 48737580     2%    /usr
 example             17547008       0 17547008     0%    /example
 example/compressed  17547008       0 17547008     0%    /example/compressed

   O pool e o sistema de arquivos tambem podem ser observados visualizando a
   saida do comando mount:

 # mount
 /dev/ad0s1a on / (ufs, local)
 devfs on /dev (devfs, local)
 /dev/ad0s1d on /usr (ufs, local, soft-updates)
 example on /example (zfs, local)
 example/compressed on /example/compressed (zfs, local)

   Apos a criac,ao, os datasets do ZFS podem ser usados como qualquer sistema
   de arquivos. No entanto, muitos outros recursos estao disponiveis, e podem
   ser definidos por conjunto de dados. No exemplo abaixo, um novo sistema de
   arquivos chamado data e criado. Arquivos importantes serao armazenados
   nele, portanto, ele e configurado para manter duas copias de cada bloco de
   dados:

 # zfs create example/data
 # zfs set copies=2 example/data

   Agora e possivel ver o sistema de arquivos data e o espac,o utilizado
   atraves do comando df:

 # df
 Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
 /dev/ad0s1a          2026030  235234  1628714    13%    /
 devfs                      1       1        0   100%    /dev
 /dev/ad0s1d         54098308 1032864 48737580     2%    /usr
 example             17547008       0 17547008     0%    /example
 example/compressed  17547008       0 17547008     0%    /example/compressed
 example/data        17547008       0 17547008     0%    /example/data

   Observe que cada sistema de arquivos no pool tem a mesma quantidade de
   espac,o disponivel. Esta e a razao para usar o df nestes exemplos, para
   mostrar que os sistemas de arquivos usam apenas a quantidade de espac,o de
   que precisam e todos utilizam o mesmo pool. O ZFS elimina conceitos como
   volumes e partic,oes e permite que varios sistemas de arquivos ocupem o
   mesmo pool.

   Para destruir os sistemas de arquivos e, em seguida, destruir o pool, se
   ele nao for mais necessario:

 # zfs destroy example/compressed
 # zfs destroy example/data
 # zpool destroy example

  19.2.2. RAID-Z

   Discos falham. Um metodo para evitar perda de dados devido a falhas no
   disco e implementar RAID. O ZFS suporta esse recurso em seu design de
   pool. Os pools RAID-Z exigem tres ou mais discos, mas fornecem mais
   espac,o utilizavel do que os pools espelhados.

   Este exemplo cria um pool RAID-Z, especificando os discos a serem
   adicionados ao pool:

 # zpool create storage raidz da0 da1 da2

  Nota:

   A Sun(TM) recomenda que o numero de dispositivos usados em uma
   configurac,ao RAID-Z seja entre tres e nove. Para ambientes que exigem um
   unico conjunto de 10 discos ou mais, considere dividi-lo em grupos menores
   de RAID-Z. Se apenas dois discos estiverem disponiveis e a redundancia for
   um requisito, considere usar o ZFS mirror. Consulte zpool(8 ) para obter
   maiores detalhes.

   O exemplo anterior criou o zpool storage. Este exemplo cria um novo
   sistema de arquivos chamado home neste pool:

 # zfs create storage/home

   A compressao e a criac,ao de copias extras de diretorios e arquivos podem
   ser ativadas:

 # zfs set copies=2 storage/home
 # zfs set compression=gzip storage/home

   Para tornar este o novo diretorio home para usuarios, copie os dados de
   usuarios para este diretorio e crie os links simbolicos apropriados:

 # cp -rp /home/* /storage/home
 # rm -rf /home /usr/home
 # ln -s /storage/home /home
 # ln -s /storage/home /usr/home

   Os dados dos usuarios agora sao armazenados no recem-criado diretorio
   /storage/home. Teste adicionando um novo usuario e efetuando login como
   este usuario.

   Tente criar um snapshot do sistema de arquivos que possa ser revertido
   posteriormente:

 # zfs snapshot storage/home@08-30-08

   Os snapshots so podem ser realizados de um sistema de arquivos completo,
   nao de um unico diretorio ou arquivo.

   O caractere @ e um delimitador entre o nome do sistema de arquivos ou o
   nome do volume. Se um diretorio importante tiver sido excluido
   acidentalmente, o backup do sistema de arquivos podera ser feito e, em
   seguida, revertido para um snapshot anterior, quando o diretorio ainda
   existia:

 # zfs rollback storage/home@08-30-08

   Para listar todos os snapshots disponiveis, execute ls no diretorio
   .zfs/snapshot no sistema de arquivos. Por exemplo, para ver o snapshot
   obtido anteriormente:

 # ls /storage/home/.zfs/snapshot

   E possivel escrever um script para criar snapshots frequentes dos dados do
   usuario. No entanto, com o tempo, os snapshots podem consumir muito
   espac,o em disco. O snapshot anterior pode ser removido usando o comando:

 # zfs destroy storage/home@08-30-08

   Apos o teste, /storage/home pode ser o verdadeiro /home usando este
   comando:

 # zfs set mountpoint=/home storage/home

   Execute o df e o mount para confirmar que o sistema agora trata o sistema
   de arquivos como o real /home:

 # mount
 /dev/ad0s1a on / (ufs, local)
 devfs on /dev (devfs, local)
 /dev/ad0s1d on /usr (ufs, local, soft-updates)
 storage on /storage (zfs, local)
 storage/home on /home (zfs, local)
 # df
 Filesystem   1K-blocks    Used    Avail Capacity  Mounted on
 /dev/ad0s1a    2026030  235240  1628708    13%    /
 devfs                1       1        0   100%    /dev
 /dev/ad0s1d   54098308 1032826 48737618     2%    /usr
 storage       26320512       0 26320512     0%    /storage
 storage/home  26320512       0 26320512     0%    /home

   Isso conclui a configurac,ao do RAID-Z. Atualizac,oes de status diarias
   sobre os sistemas de arquivos criados podem ser geradas como parte das
   execuc,oes noturnas doperiodic(8). Adicione esta linha ao
   /etc/periodic.conf :

 daily_status_zfs_enable="YES"

  19.2.3. Recuperando o RAID-Z

   Todo software RAID tem um metodo de monitorar seu status . O status dos
   dispositivos RAID-Z pode ser visualizado com este comando:

 # zpool status -x

   Se todos os pools estiverem Online e tudo estiver normal, a mensagem
   mostrara:

 all pools are healthy

   Se houver um problema, talvez um disco que esteja no estado Offline, o
   status do pool sera semelhante a:

   pool: storage
  state: DEGRADED
 status: One or more devices has been taken offline by the administrator.
         Sufficient replicas exist for the pool to continue functioning in a
         degraded state.
 action: Online the device using 'zpool online' or replace the device with
         'zpool replace'.
  scrub: none requested
 config:

         NAME        STATE     READ WRITE CKSUM
         storage     DEGRADED     0     0     0
           raidz1    DEGRADED     0     0     0
             da0     ONLINE       0     0     0
             da1     OFFLINE      0     0     0
             da2     ONLINE       0     0     0

 errors: No known data errors

   Isso indica que o dispositivo foi colocado off-line anteriormente pelo
   administrador com este comando:

 # zpool offline storage da1

   Agora o sistema pode ser desligado para substituir o da1. Quando o sistema
   estiver novamente online, o disco com falha podera ser substituido no
   pool:

 # zpool replace storage da1

   Agora, o status pode ser verificado novamente, desta vez sem -x, para que
   todos os pools sejam mostrados:

 # zpool status storage
  pool: storage
  state: ONLINE
  scrub: resilver completed with 0 errors on Sat Aug 30 19:44:11 2008
 config:

         NAME        STATE     READ WRITE CKSUM
         storage     ONLINE       0     0     0
           raidz1    ONLINE       0     0     0
             da0     ONLINE       0     0     0
             da1     ONLINE       0     0     0
             da2     ONLINE       0     0     0

 errors: No known data errors

   Neste exemplo, tudo esta normal.

  19.2.4. Verificac,ao de dados

   O ZFS utiliza checksums para verificar a integridade dos dados
   armazenados. Estes sao ativados automaticamente na criac,ao dos sistemas
   de arquivos.

  Atenc,ao:

   Os checksums podem ser desabilitados, mas isto nao e recomendado! Os
   checksums ocupam muito pouco espac,o de armazenamento e fornecem
   integridade dos dados. Muitos recursos do ZFS nao funcionarao
   adequadamente com os checksums desabilitados. Nao ha nenhum ganho
   perceptivel de desempenho ao desativar os checksums.

   A verificac,ao de checksum e conhecida como scrubbing. Verifique a
   integridade dos dados do pool storage com este comando:

 # zpool scrub storage

   A durac,ao de um scrub depende da quantidade de dados armazenados.
   Quantidades maiores de dados levarao proporcionalmente mais tempo para
   serem verificadas. Scrubs utilizam muito I/O, e apenas um scrub tem
   permissao para ser executado por vez. Apos a conclusao do scrub, o status
   pode ser visualizado com status:

 # zpool status storage
  pool: storage
  state: ONLINE
  scrub: scrub completed with 0 errors on Sat Jan 26 19:57:37 2013
 config:

         NAME        STATE     READ WRITE CKSUM
         storage     ONLINE       0     0     0
           raidz1    ONLINE       0     0     0
             da0     ONLINE       0     0     0
             da1     ONLINE       0     0     0
             da2     ONLINE       0     0     0

 errors: No known data errors

   A data de conclusao da ultima operac,ao de scrub e exibida para ajudar a
   rastrear quando outro scrub e necessario. Uma rotina recorrente de scrubs
   ajuda a proteger os dados contra corrupc,ao silenciosa e garante a
   integridade do pool.

   Consulte zfs(8) e zpool(8) para outras opc,oes do ZFS.

19.3. Administrac,ao zpool

   A administrac,ao do ZFS e dividida entre dois utilitarios principais. O
   utilitario zpool controla a operac,ao do pool e trata da adic,ao,
   remoc,ao, substituic,ao e gerenciamento de discos. O utilitario zfs lida
   com a criac,ao, destruic,ao e gerenciamento de datasets, tanto para
   sistemas de arquivos quanto para volumes.

  19.3.1. Criando e destruindo pools de armazenamento

   A criac,ao de um pool de armazenamento do ZFS (zpool) envolve a tomada de
   varias decisoes que sao relativamente permanentes porque a estrutura do
   pool nao pode ser alterada depois que o pool e criado. A decisao mais
   importante e quais tipos de vdevs usar para agrupar os discos fisicos.
   Consulte a lista de tipos vdev para obter detalhes sobre as opc,oes
   possiveis. Apos o pool ter sido criado, a maioria dos tipos de vdev nao
   permite que discos adicionais sejam adicionados ao vdev. As excec,oes sao
   os mirrors, que permitem que discos adicionais sejam adicionados ao vdev,
   e stripes, que podem ser atualizados para mirrors ao anexar um disco
   adicional ao vdev. Embora vdevs adicionais possam ser adicionados para
   expandir um pool, o layout do pool nao pode ser alterado apos a criac,ao
   do pool. Em vez disso, os dados devem ser salvos em um backup e o pool
   destruido e recriado.

   Crie um pool do tipo mirror simples:

 # zpool create mypool mirror /dev/ada1 /dev/ada2
 # zpool status
   pool: mypool
  state: ONLINE
   scan: none requested
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           mirror-0  ONLINE       0     0     0
             ada1    ONLINE       0     0     0
             ada2    ONLINE       0     0     0

 errors: No known data errors

   Varios vdevs podem ser criados de uma so vez. Especifique varios grupos de
   discos separados pela palavra-chave do tipo vdev, mirror neste exemplo:

 # zpool create mypool mirror /dev/ada1 /dev/ada2 mirror /dev/ada3 /dev/ada4
   pool: mypool
  state: ONLINE
   scan: none requested
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           mirror-0  ONLINE       0     0     0
             ada1    ONLINE       0     0     0
             ada2    ONLINE       0     0     0
           mirror-1  ONLINE       0     0     0
             ada3    ONLINE       0     0     0
             ada4    ONLINE       0     0     0

 errors: No known data errors

   Os pools tambem podem ser construidos usando partic,oes em vez de discos
   inteiros. Colocar o ZFS em uma partic,ao separada permite que o mesmo
   disco tenha outras partic,oes para outras finalidades. Em particular,
   partic,oes com bootcode e sistemas de arquivos necessarios para a
   inicializac,ao podem ser adicionadas. Isso permite inicializar a partir de
   discos que tambem sao membros de um pool. Nao ha penalidade de desempenho
   no FreeBSD ao usar uma partic,ao em vez de um disco inteiro. O uso de
   partic,oes tambem permite ao administrador sub-provisionar os discos,
   usando menos que a capacidade total. Se um disco de substituic,ao futuro
   com o mesmo tamanho nominal do original tiver uma capacidade ligeiramente
   menor, a partic,ao menor ainda se ajustara e o disco de substituic,ao
   ainda podera ser usado.

   Crie um pool RAID-Z2 usando partic,oes:

 # zpool create mypool raidz2 /dev/ada0p3 /dev/ada1p3 /dev/ada2p3 /dev/ada3p3 /dev/ada4p3 /dev/ada5p3
 # zpool status
   pool: mypool
  state: ONLINE
   scan: none requested
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           raidz2-0  ONLINE       0     0     0
             ada0p3  ONLINE       0     0     0
             ada1p3  ONLINE       0     0     0
             ada2p3  ONLINE       0     0     0
             ada3p3  ONLINE       0     0     0
             ada4p3  ONLINE       0     0     0
             ada5p3  ONLINE       0     0     0

 errors: No known data errors

   Um pool que nao e mais necessario pode ser destruido para que os discos
   possam ser reutilizados. Destruir um pool envolve primeiro desmontar todos
   os datasets nesse pool. Se os datasets estiverem em uso, a operac,ao de
   desmontagem falhara e o pool nao sera destruido. A destruic,ao do pool
   pode ser forc,ada com -f, mas isso pode causar um comportamento indefinido
   em aplicac,oes que tiverem arquivos abertos nesses datasets.

  19.3.2. Adicionando e Removendo Dispositivos

   Existem dois casos para adicionar discos a um zpool: anexar um disco a um
   vdev existente com zpool attach ou incluir vdevs ao pool com zpool add .
   Apenas alguns vdev types permitem que discos sejam adicionados ao vdev
   apos a criac,ao.

   Um pool criado com um unico disco nao tem redundancia. Dados corrompidos
   podem ser detectados, mas nao reparados, porque nao ha outra copia dos
   dados. A propriedade copies pode ser capaz de se recuperar de uma pequena
   falha, como um setor defeituoso, mas nao fornece o mesmo nivel de
   protec,ao que o mirror ou o RAID-Z. Comec,ando com um pool de um unico
   disco vdev, o zpool attach pode ser usado para adicionar um disco
   adicional ao vdev, criando um mirror. O zpool attach tambem pode ser usado
   para adicionar discos adicionais a um mirror group, aumentando a
   redundancia e o desempenho de leitura. Se os discos usados para o pool
   forem particionados, replicar o layout do primeiro disco para o segundo,
   gpart backup e gpart restore pode ser usado para facilitar esse processo .

   Atualize o disco unico (stripe) vdev ada0p3 para um mirror anexando
   ada1p3:

 # zpool status
   pool: mypool
  state: ONLINE
   scan: none requested
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           ada0p3    ONLINE       0     0     0

 errors: No known data errors
 # zpool attach mypool ada0p3 ada1p3
 Make sure to wait until resilver is done before rebooting.

 If you boot from pool 'mypool', you may need to update
 boot code on newly attached disk 'ada1p3'.

 Assuming you use GPT partitioning and 'da0' is your new boot disk
 you may use the following command:

         gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 da0
 # gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada1
 bootcode written to ada1
 # zpool status
   pool: mypool
  state: ONLINE
 status: One or more devices is currently being resilvered.  The pool will
         continue to function, possibly in a degraded state.
 action: Wait for the resilver to complete.
   scan: resilver in progress since Fri May 30 08:19:19 2014
         527M scanned out of 781M at 47.9M/s, 0h0m to go
         527M resilvered, 67.53% done
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           mirror-0  ONLINE       0     0     0
             ada0p3  ONLINE       0     0     0
             ada1p3  ONLINE       0     0     0  (resilvering)

 errors: No known data errors
 # zpool status
   pool: mypool
  state: ONLINE
   scan: resilvered 781M in 0h0m with 0 errors on Fri May 30 08:15:58 2014
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           mirror-0  ONLINE       0     0     0
             ada0p3  ONLINE       0     0     0
             ada1p3  ONLINE       0     0     0

 errors: No known data errors

   Quando adicionar discos ao vdev existente nao e uma opc,ao, como para
   RAID-Z, um metodo alternativo e adicionar outro vdev ao pool. Vdevs
   adicionais fornecem desempenho mais alto, distribuindo as operac,oes de
   escrita nos vdevs. Cada vdev e responsavel por fornecer a sua propria
   redundancia. E possivel, mas desencorajado, misturar tipos de vdev, como
   mirror e RAID-Z. Adicionar um vdev nao-redundante a um pool que contenha
   um vdev mirror ou o RAID-Z arrisca os dados em todo o pool. As gravac,oes
   sao distribuidas, portanto, a falha do disco nao-redundante resultara na
   perda de uma frac,ao de cada bloco que foi gravado no pool.

   Os dados sao distribuidos em cada um dos vdevs. Por exemplo, com dois
   vdevs mirror, esse e efetivamente um RAID 10 que escreve em dois conjuntos
   de mirrors. O espac,o e alocado de forma que cada vdev chegue a 100% de
   uso ao mesmo tempo. Ha uma penalidade de desempenho se os vdevs tiverem
   quantidades diferentes de espac,o livre, pois uma quantidade
   desproporcional dos dados e gravada no vdev menos cheio.

   Ao anexar dispositivos adicionais a um pool de inicializac,ao, lembre-se
   de atualizar o bootcode.

   Anexe um segundo grupo de mirror's (ada2p3 and ada3p3) ao mirror
   existente:

 # zpool status
   pool: mypool
  state: ONLINE
   scan: resilvered 781M in 0h0m with 0 errors on Fri May 30 08:19:35 2014
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           mirror-0  ONLINE       0     0     0
             ada0p3  ONLINE       0     0     0
             ada1p3  ONLINE       0     0     0

 errors: No known data errors
 # zpool add mypool mirror ada2p3 ada3p3
 # gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada2
 bootcode written to ada2
 # gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada3
 bootcode written to ada3
 # zpool status
   pool: mypool
  state: ONLINE
   scan: scrub repaired 0 in 0h0m with 0 errors on Fri May 30 08:29:51 2014
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           mirror-0  ONLINE       0     0     0
             ada0p3  ONLINE       0     0     0
             ada1p3  ONLINE       0     0     0
           mirror-1  ONLINE       0     0     0
             ada2p3  ONLINE       0     0     0
             ada3p3  ONLINE       0     0     0

 errors: No known data errors

   Atualmente, os vdevs nao podem ser removidos de um pool e os discos so
   podem ser removidos de um mirror se houver redundancia restante
   suficiente. Se apenas um disco em um grupo de mirror's permanecer, ele
   deixara de ser um mirror e voltara a ser um srtipe, arriscando todo o pool
   se o disco restante falhar.

   Remova um disco de um grupo de mirror's triplo:

 # zpool status
   pool: mypool
  state: ONLINE
   scan: scrub repaired 0 in 0h0m with 0 errors on Fri May 30 08:29:51 2014
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           mirror-0  ONLINE       0     0     0
             ada0p3  ONLINE       0     0     0
             ada1p3  ONLINE       0     0     0
             ada2p3  ONLINE       0     0     0

 errors: No known data errors
 # zpool detach mypool ada2p3
 # zpool status
   pool: mypool
  state: ONLINE
   scan: scrub repaired 0 in 0h0m with 0 errors on Fri May 30 08:29:51 2014
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           mirror-0  ONLINE       0     0     0
             ada0p3  ONLINE       0     0     0
             ada1p3  ONLINE       0     0     0

 errors: No known data errors

  19.3.3. Verificando o status de um pool

   O status do pool e importante. Se uma unidade ficar off-line ou for
   detectado um erro de leitura, gravac,ao ou de checksum, a contagem de
   erros correspondente aumentara. A saida status mostra a configurac,ao e o
   status de cada dispositivo no pool e o status de todo o pool. Ac,oes que
   precisam ser tomadas e detalhes sobre o ultimo scrub tambem sao mostrados.

 # zpool status
   pool: mypool
  state: ONLINE
   scan: scrub repaired 0 in 2h25m with 0 errors on Sat Sep 14 04:25:50 2013
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           raidz2-0  ONLINE       0     0     0
             ada0p3  ONLINE       0     0     0
             ada1p3  ONLINE       0     0     0
             ada2p3  ONLINE       0     0     0
             ada3p3  ONLINE       0     0     0
             ada4p3  ONLINE       0     0     0
             ada5p3  ONLINE       0     0     0

 errors: No known data errors

  19.3.4. Limpando Erros

   Quando um erro e detectado, os contadores de leitura, escrita ou checksum
   sao incrementados. A mensagem de erro pode ser apagada e os contadores
   resetados com zpool clear mypool. Limpar o estado de erro pode ser
   importante para scripts automatizados que alertam o administrador quando o
   pool encontra um erro. Erros adicionais podem nao ser relatados se os
   erros antigos nao forem apagados.

  19.3.5. Substituindo um dispositivo em funcionamento

   Ha varias situac,oes em que pode ser desejavel substituir um disco por um
   disco diferente. Ao substituir um disco em funcionamento, o processo
   mantem o disco antigo online durante a substituic,ao. O pool nunca entra
   no estado degradado , reduzindo o risco de perda de dados. zpool replace
   copia todos os dados do disco antigo para o novo. Apos a conclusao da
   operac,ao, o disco antigo e desconectado do vdev. Se o novo disco for
   maior que o disco antigo, pode ser possivel aumentar o zpool usando o novo
   espac,o. Veja Aumentando um Pool .

   Substitua um dispositivo em funcionamento no pool:

 # zpool status
   pool: mypool
  state: ONLINE
   scan: none requested
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           mirror-0  ONLINE       0     0     0
             ada0p3  ONLINE       0     0     0
             ada1p3  ONLINE       0     0     0

 errors: No known data errors
 # zpool replace mypool ada1p3 ada2p3
 Make sure to wait until resilver is done before rebooting.

 If you boot from pool 'zroot', you may need to update
 boot code on newly attached disk 'ada2p3'.

 Assuming you use GPT partitioning and 'da0' is your new boot disk
 you may use the following command:

         gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 da0
 # gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada2
 # zpool status
   pool: mypool
  state: ONLINE
 status: One or more devices is currently being resilvered.  The pool will
         continue to function, possibly in a degraded state.
 action: Wait for the resilver to complete.
   scan: resilver in progress since Mon Jun  2 14:21:35 2014
         604M scanned out of 781M at 46.5M/s, 0h0m to go
         604M resilvered, 77.39% done
 config:

         NAME             STATE     READ WRITE CKSUM
         mypool           ONLINE       0     0     0
           mirror-0       ONLINE       0     0     0
             ada0p3       ONLINE       0     0     0
             replacing-1  ONLINE       0     0     0
               ada1p3     ONLINE       0     0     0
               ada2p3     ONLINE       0     0     0  (resilvering)

 errors: No known data errors
 # zpool status
   pool: mypool
  state: ONLINE
   scan: resilvered 781M in 0h0m with 0 errors on Mon Jun  2 14:21:52 2014
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           mirror-0  ONLINE       0     0     0
             ada0p3  ONLINE       0     0     0
             ada2p3  ONLINE       0     0     0

 errors: No known data errors

  19.3.6. Lidando com dispositivos com falha

   Quando um disco em um pool falha, o vdev ao qual o disco pertence entra no
   estado degradado. Todos os dados ainda estao disponiveis, mas o desempenho
   pode ser reduzido porque os dados ausentes devem ser calculados a partir
   da redundancia disponivel. Para restaurar o vdev para um estado totalmente
   funcional, o dispositivo fisico com falha deve ser substituido. O ZFS e
   entao instruido a iniciar a operac,ao resilver. Os dados que estavam no
   dispositivo com falha sao recalculados da redundancia disponivel e
   gravados no dispositivo de substituic,ao. Apos a conclusao, o vdev retorna
   ao status online.

   Se o vdev nao tiver redundancia, ou se varios dispositivos falharem e nao
   houver redundancia suficiente para compensar, o pool entrara no estado
   failed. Se um numero suficiente de dispositivos nao puder ser reconectado
   ao pool, o pool se tornara inoperante e os dados deverao ser restaurados
   dos backups.

   Ao substituir um disco com falha, o nome do disco com falha e substituido
   pelo GUID do dispositivo. Um novo parametro de nome de dispositivo para o
   zpool replace nao e necessario se o dispositivo de substituic,ao tiver o
   mesmo nome de dispositivo.

   Substitua um disco com falha usando o zpool replace:

 # zpool status
   pool: mypool
  state: DEGRADED
 status: One or more devices could not be opened.  Sufficient replicas exist for
         the pool to continue functioning in a degraded state.
 action: Attach the missing device and online it using 'zpool online'.
    see: http://illumos.org/msg/ZFS-8000-2Q
   scan: none requested
 config:

         NAME                    STATE     READ WRITE CKSUM
         mypool                  DEGRADED     0     0     0
           mirror-0              DEGRADED     0     0     0
             ada0p3              ONLINE       0     0     0
             316502962686821739  UNAVAIL      0     0     0  was /dev/ada1p3

 errors: No known data errors
 # zpool replace mypool 316502962686821739 ada2p3
 # zpool status
   pool: mypool
  state: DEGRADED
 status: One or more devices is currently being resilvered.  The pool will
         continue to function, possibly in a degraded state.
 action: Wait for the resilver to complete.
   scan: resilver in progress since Mon Jun  2 14:52:21 2014
         641M scanned out of 781M at 49.3M/s, 0h0m to go
         640M resilvered, 82.04% done
 config:

         NAME                        STATE     READ WRITE CKSUM
         mypool                      DEGRADED     0     0     0
           mirror-0                  DEGRADED     0     0     0
             ada0p3                  ONLINE       0     0     0
             replacing-1             UNAVAIL      0     0     0
               15732067398082357289  UNAVAIL      0     0     0  was /dev/ada1p3/old
               ada2p3                ONLINE       0     0     0  (resilvering)

 errors: No known data errors
 # zpool status
   pool: mypool
  state: ONLINE
   scan: resilvered 781M in 0h0m with 0 errors on Mon Jun  2 14:52:38 2014
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           mirror-0  ONLINE       0     0     0
             ada0p3  ONLINE       0     0     0
             ada2p3  ONLINE       0     0     0

 errors: No known data errors

  19.3.7. Limpeza do Pool

   Recomenda-se que os pools sejam regularmente scrubbed, idealmente pelo
   menos uma vez por mes. A operac,ao scrub requer muito disco e reduzira o
   desempenho durante a execuc,ao. Evite periodos de alta demanda ao agendar
   o scrub ou use vfs.zfs.scrub_delay para ajustar a prioridade relativa do
   scrub para evitar que ele interfira com outras cargas de trabalho.

 # zpool scrub mypool
 # zpool status
   pool: mypool
  state: ONLINE
   scan: scrub in progress since Wed Feb 19 20:52:54 2014
         116G scanned out of 8.60T at 649M/s, 3h48m to go
         0 repaired, 1.32% done
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           raidz2-0  ONLINE       0     0     0
             ada0p3  ONLINE       0     0     0
             ada1p3  ONLINE       0     0     0
             ada2p3  ONLINE       0     0     0
             ada3p3  ONLINE       0     0     0
             ada4p3  ONLINE       0     0     0
             ada5p3  ONLINE       0     0     0

 errors: No known data errors

   No caso de uma operac,ao de limpeza precisar ser cancelada, emita zpool
   scrub -s mypool.

  19.3.8. Auto Cura (Self-Healing)

   Os checksums armazenados com os blocos de dados habilitam o sistema de
   arquivos a se autocorrigirem. Esse recurso reparara automaticamente os
   dados cujo checksum nao corresponde `a registrada em outro dispositivo que
   faz parte do pool de armazenamento. Por exemplo, um espelho com dois
   discos em que uma unidade esta comec,ando a funcionar incorretamente e nao
   pode armazenar os dados adequadamente. Isso e ainda pior quando os dados
   nao sao acessados ha muito tempo, como no armazenamento de arquivos de
   longo prazo. Os sistemas de arquivos tradicionais precisam executar
   algoritmos que verificam e reparam os dados como o fsck(8). Esses comandos
   levam tempo e, em casos graves, um administrador precisa decidir
   manualmente qual operac,ao de reparo deve ser executada. Quando o ZFS
   detecta um bloco de dados com um checksum que nao corresponde, ele tenta
   ler os dados do disco de espelhamento. Se esse disco puder fornecer os
   dados corretos, ele nao apenas fornecera esses dados ao aplicativo que os
   esta solicitando, mas tambem corrigira os dados errados no disco que
   continha o checksum incorreto. Isso acontece sem qualquer interac,ao de um
   administrador do sistema durante a operac,ao normal do pool.

   O proximo exemplo demonstra esse comportamento de autocura. Um conjunto
   espelhado de discos /dev/ada0 e /dev/ada1 e criado.

 # zpool create healer mirror /dev/ada0 /dev/ada1
 # zpool status healer
   pool: healer
  state: ONLINE
   scan: none requested
 config:

     NAME        STATE     READ WRITE CKSUM
     healer      ONLINE       0     0     0
       mirror-0  ONLINE       0     0     0
        ada0     ONLINE       0     0     0
        ada1     ONLINE       0     0     0

 errors: No known data errors
 # zpool list
 NAME     SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
 healer   960M  92.5K   960M         -         -     0%    0%  1.00x  ONLINE  -

   Alguns dados importantes que devem ser protegidos de erros de dados usando
   o recurso de correc,ao automatica sao copiados para o pool. E criado um
   checksum do pool para comparac,ao posterior.

 # cp /some/important/data /healer
 # zfs list
 NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT
 healer   960M  67.7M   892M     7%  1.00x  ONLINE  -
 # sha1 /healer > checksum.txt
 # cat checksum.txt
 SHA1 (/healer) = 2753eff56d77d9a536ece6694bf0a82740344d1f

   A corrupc,ao de dados e simulada escrevendo dados aleatorios no inicio de
   um dos discos no espelho. Para evitar que o ZFS cure os dados assim que
   forem detectados, o pool e exportado antes da corrupc,ao e importado
   novamente depois.

  Atenc,ao:

   Esta e uma operac,ao perigosa que pode destruir dados vitais. Ele e
   mostrado aqui apenas para fins demonstrativos e nao deve ser tentado
   durante a operac,ao normal de um pool de armazenamento. Nem este exemplo
   de corrupc,ao intencional deve ser executado em qualquer disco com um
   sistema de arquivos diferente. Nao use outros nomes de dispositivos de
   disco diferentes daqueles que fazem parte do pool. Certifique-se de que os
   backups apropriados do pool sejam criados antes de executar o comando!

 # zpool export healer
 # dd if=/dev/random of=/dev/ada1 bs=1m count=200
 200+0 records in
 200+0 records out
 209715200 bytes transferred in 62.992162 secs (3329227 bytes/sec)
 # zpool import healer

   O status do pool mostra que um dispositivo teve um erro. Observe que os
   aplicativos que leem dados do pool nao receberam dados incorretos. O ZFS
   forneceu dados do dispositivo ada0 com os checksums corretos. O
   dispositivo com o checksum incorreto pode ser encontrado facilmente, pois
   a coluna CKSUM contem um valor diferente de zero.

 # zpool status healer
     pool: healer
    state: ONLINE
   status: One or more devices has experienced an unrecoverable error.  An
           attempt was made to correct the error.  Applications are unaffected.
   action: Determine if the device needs to be replaced, and clear the errors
           using 'zpool clear' or replace the device with 'zpool replace'.
      see: http://illumos.org/msg/ZFS-8000-4J
     scan: none requested
   config:

       NAME        STATE     READ WRITE CKSUM
       healer      ONLINE       0     0     0
         mirror-0  ONLINE       0     0     0
          ada0     ONLINE       0     0     0
          ada1     ONLINE       0     0     1

 errors: No known data errors

   O erro foi detectado e tratado usando a redundancia presente no disco de
   espelhamento ada0 nao afetado. Uma comparac,ao de checksum com o original
   ira revelar se o pool esta consistente novamente.

 # sha1 /healer >> checksum.txt
 # cat checksum.txt
 SHA1 (/healer) = 2753eff56d77d9a536ece6694bf0a82740344d1f
 SHA1 (/healer) = 2753eff56d77d9a536ece6694bf0a82740344d1f

   Os dois checksums que foram gerados antes e depois da adulterac,ao
   intencional dos dados do conjunto ainda correspondem. Isso mostra como o
   ZFS e capaz de detectar e corrigir erros automaticamente quando os
   checksums sao diferentes. Observe que isso so e possivel quando ha
   redundancia suficiente presente no pool. Um pool que consiste em um unico
   dispositivo nao possui recursos de autocorrec,ao. Essa tambem e a razao
   pela qual os cheksuma sao tao importantes no ZFS e nao devem ser
   desabilitados por nenhum motivo. Nenhum fsck(8) ou programa semelhante de
   verificac,ao de consistencia do sistema de arquivos e necessario para
   detectar e corrigir isso e o pool ainda estava disponivel durante o
   problema. Uma operac,ao de scrub agora e necessaria para sobrescrever os
   dados corrompidos em ada1.

 # zpool scrub healer
 # zpool status healer
   pool: healer
  state: ONLINE
 status: One or more devices has experienced an unrecoverable error.  An
             attempt was made to correct the error.  Applications are unaffected.
 action: Determine if the device needs to be replaced, and clear the errors
             using 'zpool clear' or replace the device with 'zpool replace'.
    see: http://illumos.org/msg/ZFS-8000-4J
   scan: scrub in progress since Mon Dec 10 12:23:30 2012
         10.4M scanned out of 67.0M at 267K/s, 0h3m to go
         9.63M repaired, 15.56% done
 config:

     NAME        STATE     READ WRITE CKSUM
     healer      ONLINE       0     0     0
       mirror-0  ONLINE       0     0     0
        ada0     ONLINE       0     0     0
        ada1     ONLINE       0     0   627  (repairing)

 errors: No known data errors

   A operac,ao scrub le os dados do ada0 e reescreve todos os dados com um
   checksum incorreto no ada1. Isso e indicado pela saida (repairing) do
   zpool status. Apos a conclusao da operac,ao, o status do conjunto e
   alterado para:

 # zpool status healer
   pool: healer
  state: ONLINE
 status: One or more devices has experienced an unrecoverable error.  An
         attempt was made to correct the error.  Applications are unaffected.
 action: Determine if the device needs to be replaced, and clear the errors
              using 'zpool clear' or replace the device with 'zpool replace'.
    see: http://illumos.org/msg/ZFS-8000-4J
   scan: scrub repaired 66.5M in 0h2m with 0 errors on Mon Dec 10 12:26:25 2012
 config:

     NAME        STATE     READ WRITE CKSUM
     healer      ONLINE       0     0     0
       mirror-0  ONLINE       0     0     0
        ada0     ONLINE       0     0     0
        ada1     ONLINE       0     0 2.72K

 errors: No known data errors

   Apos a conclusao da operac,ao scrub e todos os dados terem sido
   sincronizados de ada0 para ada1, as mensagens de erro podem ser ??? do
   status do pool executando zpool clear.

 # zpool clear healer
 # zpool status healer
   pool: healer
  state: ONLINE
   scan: scrub repaired 66.5M in 0h2m with 0 errors on Mon Dec 10 12:26:25 2012
 config:

     NAME        STATE     READ WRITE CKSUM
     healer      ONLINE       0     0     0
       mirror-0  ONLINE       0     0     0
        ada0     ONLINE       0     0     0
        ada1     ONLINE       0     0     0

 errors: No known data errors

   O pool esta agora de volta a um estado totalmente funcional e todos os
   erros foram apagados.

  19.3.9. Crescendo um Pool

   O tamanho utilizavel de um pool redundante e limitado pela capacidade do
   menor dispositivo em cada vdev. O menor dispositivo pode ser substituido
   por um dispositivo maior. Depois de concluir uma operac,ao replace ou
   resilver, o pool pode crescer para usar a capacidade do Novo dispositivo.
   Por exemplo, considere um espelho de uma unidade de 1 TB e uma unidade de
   2 TB. O espac,o utilizavel e de 1 TB. Quando a unidade de 1 TB e
   substituida por outra unidade de 2 TB, o processo de resilverizac,ao copia
   os dados existentes para a nova unidade. Como os dois dispositivos agora
   tem capacidade para 2 TB, o espac,o disponivel do espelho pode ser
   aumentado para 2 TB.

   A expansao e acionada usando o zpool online -e em cada dispositivo. Apos a
   expansao de todos os dispositivos, o espac,o adicional fica disponivel
   para o pool.

  19.3.10. Importando e exportando pools

   Os pools sao exportados antes de serem movidos para outro sistema. Todos
   os conjuntos de dados sao desmontados e cada dispositivo e marcado como
   exportado, mas ainda estarao bloqueados, para que nao possam ser usados
   por outros subsistemas de disco. Isso permite que pools sejam importados
   em outras maquinas, outros sistemas operacionais que suportem ZFS , e ate
   mesmo arquiteturas de hardware diferentes (com algumas advertencias, veja
   zpool(8)). Quando um conjunto de dados tem arquivos abertos, o zpool
   export -f pode ser usado para forc,ar a exportac,ao de um pool. Use isso
   com cautela. Os conjuntos de dados sao forc,osamente desmontados,
   resultando potencialmente em um comportamento inesperado dos aplicativos
   que tinham arquivos abertos nesses conjuntos de dados.

   Exportar um pool que nao esta em uso:

 # zpool export mypool

   Importar um pool automaticamente monta os conjuntos de dados. Este pode
   nao ser o comportamento desejado e pode ser evitado com zpool import -N. O
   zpool import -o define propriedades temporarias apenas para esta
   importac,ao. O zpool import altroot= permite importar um pool com um ponto
   base de montagem em vez da raiz do sistema de arquivos. Se o pool foi
   usado pela ultima vez em um sistema diferente e nao foi exportado
   corretamente, uma importac,ao pode ter que ser forc,ada com zpool import
   -f. O zpool import -a importa todos os pools que nao parecem estar em uso
   por outro sistema.

   Listar todos os pools disponiveis para importac,ao:

 # zpool import
    pool: mypool
      id: 9930174748043525076
   state: ONLINE
  action: The pool can be imported using its name or numeric identifier.
  config:

         mypool      ONLINE
           ada2p3    ONLINE

   Importe o pool com um diretorio raiz alternativo:

 # zpool import -o altroot=/mnt mypool
 # zfs list
 zfs list
 NAME                 USED  AVAIL  REFER  MOUNTPOINT
 mypool               110K  47.0G    31K  /mnt/mypool

  19.3.11. Atualizando um pool de armazenamento

   Apos a atualizac,ao do FreeBSD, ou se um pool foi importado de um sistema
   usando uma versao mais antiga do ZFS, o pool pode ser atualizado
   manualmente para a versao mais recente do ZFS para suportar as
   funcionalidades mais recentes. Considere se o pool pode precisar ser
   importado em um sistema antigo antes de atualizar. A atualizac,ao e um
   processo unidirecional. Os pools mais antigos podem ser atualizados, mas
   os pools com funcionalidades mais recentes nao podem ser desatualizados.

   Atualize um pool v28 para suportar Feature Flags:

 # zpool status
   pool: mypool
  state: ONLINE
 status: The pool is formatted using a legacy on-disk format.  The pool can
         still be used, but some features are unavailable.
 action: Upgrade the pool using 'zpool upgrade'.  Once this is done, the
         pool will no longer be accessible on software that does not support feat
         flags.
   scan: none requested
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           mirror-0  ONLINE       0     0     0
             ada0    ONLINE       0     0     0
             ada1    ONLINE       0     0     0

 errors: No known data errors
 # zpool upgrade
 This system supports ZFS pool feature flags.

 The following pools are formatted with legacy version numbers and can
 be upgraded to use feature flags.  After being upgraded, these pools
 will no longer be accessible by software that does not support feature
 flags.

 VER  POOL
 ---  ------------
 28   mypool

 Use 'zpool upgrade -v' for a list of available legacy versions.
 Every feature flags pool has all supported features enabled.
 # zpool upgrade mypool
 This system supports ZFS pool feature flags.

 Successfully upgraded 'mypool' from version 28 to feature flags.
 Enabled the following features on 'mypool':
   async_destroy
   empty_bpobj
   lz4_compress
   multi_vdev_crash_dump

   Os recursos mais recentes do ZFS nao estarao disponiveis ate que o zpool
   upgrade seja concluido. O zpool upgrade -v pode ser usado para ver quais
   os novos recursos que serao fornecidos pela atualizac,ao, bem como quais
   recursos ja sao suportados.

   Atualize um pool para suportar feature flags adicionais:

 # zpool status
   pool: mypool
  state: ONLINE
 status: Some supported features are not enabled on the pool. The pool can
         still be used, but some features are unavailable.
 action: Enable all features using 'zpool upgrade'. Once this is done,
         the pool may no longer be accessible by software that does not support
         the features. See zpool-features(7) for details.
   scan: none requested
 config:

         NAME        STATE     READ WRITE CKSUM
         mypool      ONLINE       0     0     0
           mirror-0  ONLINE       0     0     0
             ada0    ONLINE       0     0     0
             ada1    ONLINE       0     0     0

 errors: No known data errors
 # zpool upgrade
 This system supports ZFS pool feature flags.

 All pools are formatted using feature flags.


 Some supported features are not enabled on the following pools. Once a
 feature is enabled the pool may become incompatible with software
 that does not support the feature. See zpool-features(7) for details.

 POOL  FEATURE
 ---------------
 zstore
       multi_vdev_crash_dump
       spacemap_histogram
       enabled_txg
       hole_birth
       extensible_dataset
       bookmarks
       filesystem_limits
 # zpool upgrade mypool
 This system supports ZFS pool feature flags.

 Enabled the following features on 'mypool':
   spacemap_histogram
   enabled_txg
   hole_birth
   extensible_dataset
   bookmarks
   filesystem_limits

  Atenc,ao:

   O boot code em sistemas que inicializam a partir de um pool deve ser
   atualizado para suportar a nova versao do pool. Use gpart bootcode na
   partic,ao que contem o boot code. Existem dois tipos de bootcode
   disponiveis, dependendo da forma como o sistema inicializa: GPT (a opc,ao
   mais comum) e EFI (para sistemas mais modernos).

   Para inicializac,ao legada usando o GPT, use o seguinte comando:

 # gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada1

   Para sistemas que usam o EFI para inicializar, execute o seguinte comando:

 # gpart bootcode -p /boot/boot1.efifat -i 1 ada1

   Aplique o bootcode a todos os discos inicializaveis no pool. Veja gpart(8)
   para obter maiores informac,oes.

  19.3.12. Exibindo o historico gravado do pool

   Comandos que modificam o pool sao registrados. As ac,oes registradas
   incluem a criac,ao de conjuntos de dados, a alterac,ao de propriedades ou
   a substituic,ao de um disco. Esse historico e util para revisar como um
   pool foi criado e qual usuario executou uma ac,ao especifica e quando. O
   historico nao e mantido em um arquivo de log, mas faz parte do proprio
   pool. O comando para revisar este historico e apropriadamente chamado de
   zpool history:

 # zpool history
 History for 'tank':
 2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1
 2013-02-27.18:50:58 zfs set atime=off tank
 2013-02-27.18:51:09 zfs set checksum=fletcher4 tank
 2013-02-27.18:51:18 zfs create tank/backup

   A saida mostra os comandos zpool e zfs que foram executados no pool
   juntamente com um registro de data e hora. Somente comandos que alteram o
   pool de alguma forma sao registrados. Comandos como zfs list nao estao
   incluidos. Quando nenhum nome de pool e especificado, e exibido o
   historico de todos os pools.

   O zpool history pode mostrar ainda mais informac,oes quando as opc,oes -i
   ou -l sao fornecidas. A opc,ao -i exibe eventos iniciados pelo usuario,
   bem como eventos do ZFS registrados internamente.

 # zpool history -i
 History for 'tank':
 2013-02-26.23:02:35 [internal pool create txg:5] pool spa 28; zfs spa 28; zpl 5;uts  9.1-RELEASE 901000 amd64
 2013-02-27.18:50:53 [internal property set txg:50] atime=0 dataset = 21
 2013-02-27.18:50:58 zfs set atime=off tank
 2013-02-27.18:51:04 [internal property set txg:53] checksum=7 dataset = 21
 2013-02-27.18:51:09 zfs set checksum=fletcher4 tank
 2013-02-27.18:51:13 [internal create txg:55] dataset = 39
 2013-02-27.18:51:18 zfs create tank/backup

   Mais detalhes podem ser mostrados adicionando a opc,ao -l. Os registros de
   historico sao mostrados em um formato longo, incluindo informac,oes como o
   nome do usuario que emitiu o comando e o nome do host no qual a alterac,ao
   foi feita.

 # zpool history -l
 History for 'tank':
 2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1 [user 0 (root) on :global]
 2013-02-27.18:50:58 zfs set atime=off tank [user 0 (root) on myzfsbox:global]
 2013-02-27.18:51:09 zfs set checksum=fletcher4 tank [user 0 (root) on myzfsbox:global]
 2013-02-27.18:51:18 zfs create tank/backup [user 0 (root) on myzfsbox:global]

   A saida mostra que o usuario root criou o pool espelhado com os discos
   /dev/ada0 e /dev/ada1. O nome do host myzfsbox tambem e mostrado nos
   comandos apos a criac,ao do pool. A exibic,ao do nome do host se torna
   importante quando o pool e exportado de um sistema e importado para outro.
   Os comandos que sao emitidos no outro sistema podem claramente ser
   distinguidos pelo nome do host que e registrado para cada comando.

   Ambas as opc,oes para o zpool history podem ser combinadas para fornecer
   as informac,oes mais detalhadas possiveis para qualquer pool. O historico
   do pool fornece informac,oes valiosas ao rastrear as ac,oes que foram
   executadas ou quando e necessaria uma saida mais detalhada para a
   depurac,ao.

  19.3.13. Monitoramento de Desempenho

   Um sistema de monitoramento integrado pode exibir estatisticas de I/O do
   pool em tempo real. Ele mostra a quantidade de espac,o livre e usado no
   pool, quantas operac,oes de leitura e gravac,ao estao sendo executadas por
   segundo e quanto de largura de banda de I/O esta sendo utilizada no
   momento. Por padrao, todos os pools no sistema sao monitorados e exibidos.
   Um nome de pool pode ser fornecido para limitar o monitoramento apenas a
   esse pool. Um exemplo basico:

 # zpool iostat
                capacity     operations    bandwidth
 pool        alloc   free   read  write   read  write
 ----------  -----  -----  -----  -----  -----  -----
 data         288G  1.53T      2     11  11.3K  57.1K

   Para monitorar continuamente a atividade de I/O, um numero pode ser
   especificado como o ultimo parametro, indicando um intervalo em segundos
   para aguardar entre as atualizac,oes. A proxima linha de estatistica e
   impressa apos cada intervalo. PressioneCtrl+C para interromper este
   monitoramento continuo. Como alternativa, fornec,a um segundo numero na
   linha de comando apos o intervalo para especificar o numero total de
   estatisticas a serem exibidas.

   Estatisticas mais detalhadas de I/O podem ser exibidas com a opc,ao -v.
   Cada dispositivo no pool e mostrado com uma linha de estatisticas. Isso e
   util para ver quantas operac,oes de leitura e gravac,ao estao sendo
   executadas em cada dispositivo e pode ajudar a determinar se algum
   dispositivo individual esta reduzindo a velocidade do pool. Este exemplo
   mostra um pool espelhado com dois dispositivos:

 # zpool iostat -v
                             capacity     operations    bandwidth
 pool                     alloc   free   read  write   read  write
 -----------------------  -----  -----  -----  -----  -----  -----
 data                      288G  1.53T      2     12  9.23K  61.5K
   mirror                  288G  1.53T      2     12  9.23K  61.5K
     ada1                     -      -      0      4  5.61K  61.7K
     ada2                     -      -      1      4  5.04K  61.7K
 -----------------------  -----  -----  -----  -----  -----  -----

  19.3.14. Dividindo um pool de armazenamento

   Um pool que consiste em um ou mais vdevs espelhados pode ser dividido em
   dois conjuntos. A menos que seja especificado de outra forma, o ultimo
   membro de cada espelho e desanexado e usado para criar um novo pool
   contendo os mesmos dados. A operac,ao deve primeiro ser tentada com -n. Os
   detalhes da operac,ao proposta sao exibidos sem que sejam realmente
   executados. Isso ajuda a confirmar que a operac,ao fara o que o usuario
   pretende.

19.4. Administrac,ao do zfs

   O utilitario zfs e responsavel por criar, destruir e gerenciar todos os
   conjuntos de dados ZFS existentes em um pool. O pool e gerenciado usando o
   zpool.

  19.4.1. Criando e destruindo conjuntos de dados

   Ao contrario dos discos tradicionais e gerenciadores de volume, o espac,o
   no ZFS nao e pre-alocado. Nos sistemas de arquivos tradicionais, depois
   que todo o espac,o e particionado e atribuido, nao ha como adicionar um
   sistema de arquivos adicional sem adicionar um novo disco. Com o ZFS,
   novos sistemas de arquivos podem ser criados a qualquer momento. Cada
   conjunto de dados tem propriedades incluindo recursos como compactac,ao,
   deduplicac,ao, armazenamento em cache e cotas, bem como outras
   propriedades uteis como somente leitura, diferenciac,ao de maiusculas e
   minusculas , compartilhamento de arquivos de rede e um ponto de montagem.
   Os conjuntos de dados podem ser aninhados uns dentro dos outros e os
   conjuntos de dados filhos herdarao propriedades de seus pais. Cada
   conjunto de dados pode ser administrado, delegado, replicado, preservado
   por um snapshot, preso, e destruido como uma unidade. Ha muitas vantagens
   em criar um conjunto de dados separado para cada tipo ou conjunto de
   arquivos diferente. A unica desvantagem de ter um numero extremamente
   grande de conjuntos de dados e que alguns comandos como zfs list serao
   mais lentos, e a montagem de centenas ou mesmo milhares de conjuntos de
   dados pode retardar o processo de inicializac,ao do FreeBSD.

   Crie um novo conjunto de dados e ative a compactac,ao LZ4 nele:

 # zfs list
 NAME                  USED  AVAIL  REFER  MOUNTPOINT
 mypool                781M  93.2G   144K  none
 mypool/ROOT           777M  93.2G   144K  none
 mypool/ROOT/default   777M  93.2G   777M  /
 mypool/tmp            176K  93.2G   176K  /tmp
 mypool/usr            616K  93.2G   144K  /usr
 mypool/usr/home       184K  93.2G   184K  /usr/home
 mypool/usr/ports      144K  93.2G   144K  /usr/ports
 mypool/usr/src        144K  93.2G   144K  /usr/src
 mypool/var           1.20M  93.2G   608K  /var
 mypool/var/crash      148K  93.2G   148K  /var/crash
 mypool/var/log        178K  93.2G   178K  /var/log
 mypool/var/mail       144K  93.2G   144K  /var/mail
 mypool/var/tmp        152K  93.2G   152K  /var/tmp
 # zfs create -o compress=lz4 mypool/usr/mydataset
 # zfs list
 NAME                   USED  AVAIL  REFER  MOUNTPOINT
 mypool                 781M  93.2G   144K  none
 mypool/ROOT            777M  93.2G   144K  none
 mypool/ROOT/default    777M  93.2G   777M  /
 mypool/tmp             176K  93.2G   176K  /tmp
 mypool/usr             704K  93.2G   144K  /usr
 mypool/usr/home        184K  93.2G   184K  /usr/home
 mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset
 mypool/usr/ports       144K  93.2G   144K  /usr/ports
 mypool/usr/src         144K  93.2G   144K  /usr/src
 mypool/var            1.20M  93.2G   610K  /var
 mypool/var/crash       148K  93.2G   148K  /var/crash
 mypool/var/log         178K  93.2G   178K  /var/log
 mypool/var/mail        144K  93.2G   144K  /var/mail
 mypool/var/tmp         152K  93.2G   152K  /var/tmp

   A destruic,ao de um conjunto de dados e muito mais rapida que a exclusao
   de todos os arquivos que residem no conjunto de dados, pois nao envolve a
   verificac,ao de todos os arquivos e a atualizac,ao de todos os metadados
   correspondentes.

   Destrua o conjunto de dados criado anteriormente:

 # zfs list
 NAME                   USED  AVAIL  REFER  MOUNTPOINT
 mypool                 880M  93.1G   144K  none
 mypool/ROOT            777M  93.1G   144K  none
 mypool/ROOT/default    777M  93.1G   777M  /
 mypool/tmp             176K  93.1G   176K  /tmp
 mypool/usr             101M  93.1G   144K  /usr
 mypool/usr/home        184K  93.1G   184K  /usr/home
 mypool/usr/mydataset   100M  93.1G   100M  /usr/mydataset
 mypool/usr/ports       144K  93.1G   144K  /usr/ports
 mypool/usr/src         144K  93.1G   144K  /usr/src
 mypool/var            1.20M  93.1G   610K  /var
 mypool/var/crash       148K  93.1G   148K  /var/crash
 mypool/var/log         178K  93.1G   178K  /var/log
 mypool/var/mail        144K  93.1G   144K  /var/mail
 mypool/var/tmp         152K  93.1G   152K  /var/tmp
 # zfs destroy mypool/usr/mydataset
 # zfs list
 NAME                  USED  AVAIL  REFER  MOUNTPOINT
 mypool                781M  93.2G   144K  none
 mypool/ROOT           777M  93.2G   144K  none
 mypool/ROOT/default   777M  93.2G   777M  /
 mypool/tmp            176K  93.2G   176K  /tmp
 mypool/usr            616K  93.2G   144K  /usr
 mypool/usr/home       184K  93.2G   184K  /usr/home
 mypool/usr/ports      144K  93.2G   144K  /usr/ports
 mypool/usr/src        144K  93.2G   144K  /usr/src
 mypool/var           1.21M  93.2G   612K  /var
 mypool/var/crash      148K  93.2G   148K  /var/crash
 mypool/var/log        178K  93.2G   178K  /var/log
 mypool/var/mail       144K  93.2G   144K  /var/mail
 mypool/var/tmp        152K  93.2G   152K  /var/tmp

   Nas versoes modernas do ZFS, o zfs destroy e assincrono, e o espac,o livre
   pode levar varios minutos para aparecer no pool. Use o zpool get freeing
   poolname para ver a propriedade freeing, indicando quantos conjuntos de
   dados estao tendo seus blocos liberados em segundo plano. Se houver
   conjuntos de dados filhos, como snapshots ou outros conjuntos de dados, o
   pai nao podera ser destruido. Para destruir um conjunto de dados e todos
   os seus filhos, use -r para destruir recursivamente o conjunto de dados e
   todos os seus filhos. Use -n -v para listar os conjuntos de dados e
   snapshots que seriam destruidos por esta operac,ao, mas na verdade nao
   destruirao nada. O espac,o que seria recuperado pela destruic,ao dos
   snapshots tambem e mostrado.

  19.4.2. Criando e Destruindo Volumes

   Um volume e um tipo especial de conjunto de dados. Em vez de ser montado
   como um sistema de arquivos, ele e exposto como um dispositivo de bloco em
   /dev/zvol/poolname/dataset. Isso permite que o volume seja usado para
   outros sistemas de arquivos, para fazer backup dos discos de uma maquina
   virtual ou para ser exportado usando protocolos como iSCSI ou HAST.

   Um volume pode ser formatado com qualquer sistema de arquivos ou usado sem
   um sistema de arquivos para armazenar dados brutos. Para o usuario, um
   volume parece ser um disco normal. Colocar sistemas de arquivos comuns
   nesses zvols fornece recursos que os discos comuns ou sistemas de arquivos
   normalmente nao possuem. Por exemplo, o uso da propriedade de compactac,ao
   em um volume de 250 MB permite a criac,ao de um sistema de arquivos FAT
   compactado.

 # zfs create -V 250m -o compression=on tank/fat32
 # zfs list tank
 NAME USED AVAIL REFER MOUNTPOINT
 tank 258M  670M   31K /tank
 # newfs_msdos -F32 /dev/zvol/tank/fat32
 # mount -t msdosfs /dev/zvol/tank/fat32 /mnt
 # df -h /mnt | grep fat32
 Filesystem           Size Used Avail Capacity Mounted on
 /dev/zvol/tank/fat32 249M  24k  249M     0%   /mnt
 # mount | grep fat32
 /dev/zvol/tank/fat32 on /mnt (msdosfs, local)

   Destruir um volume e o mesmo que destruir um conjunto de dados regular do
   sistema de arquivos. A operac,ao e quase instantanea, mas pode levar
   varios minutos para que o espac,o livre seja recuperado em segundo plano.

  19.4.3. Renomeando um Conjunto de Dados

   O nome de um conjunto de dados pode ser alterado com zfs rename. O pai de
   um conjunto de dados tambem pode ser alterado com esse comando. A
   renomeac,ao de um conjunto de dados para um conjunto de dados pai
   diferente alterara o valor das propriedades herdadas do conjunto de dados
   pai. Quando um conjunto de dados e renomeado, ele e desmontado e, em
   seguida, remontado no novo local (que e herdado do novo conjunto de dados
   pai). Esse comportamento pode ser evitado com -u.

   Renomeie um conjunto de dados e mova-o para um conjunto de dados pai
   diferente:

 # zfs list
 NAME                   USED  AVAIL  REFER  MOUNTPOINT
 mypool                 780M  93.2G   144K  none
 mypool/ROOT            777M  93.2G   144K  none
 mypool/ROOT/default    777M  93.2G   777M  /
 mypool/tmp             176K  93.2G   176K  /tmp
 mypool/usr             704K  93.2G   144K  /usr
 mypool/usr/home        184K  93.2G   184K  /usr/home
 mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset
 mypool/usr/ports       144K  93.2G   144K  /usr/ports
 mypool/usr/src         144K  93.2G   144K  /usr/src
 mypool/var            1.21M  93.2G   614K  /var
 mypool/var/crash       148K  93.2G   148K  /var/crash
 mypool/var/log         178K  93.2G   178K  /var/log
 mypool/var/mail        144K  93.2G   144K  /var/mail
 mypool/var/tmp         152K  93.2G   152K  /var/tmp
 # zfs rename mypool/usr/mydataset mypool/var/newname
 # zfs list
 NAME                  USED  AVAIL  REFER  MOUNTPOINT
 mypool                780M  93.2G   144K  none
 mypool/ROOT           777M  93.2G   144K  none
 mypool/ROOT/default   777M  93.2G   777M  /
 mypool/tmp            176K  93.2G   176K  /tmp
 mypool/usr            616K  93.2G   144K  /usr
 mypool/usr/home       184K  93.2G   184K  /usr/home
 mypool/usr/ports      144K  93.2G   144K  /usr/ports
 mypool/usr/src        144K  93.2G   144K  /usr/src
 mypool/var           1.29M  93.2G   614K  /var
 mypool/var/crash      148K  93.2G   148K  /var/crash
 mypool/var/log        178K  93.2G   178K  /var/log
 mypool/var/mail       144K  93.2G   144K  /var/mail
 mypool/var/newname   87.5K  93.2G  87.5K  /var/newname
 mypool/var/tmp        152K  93.2G   152K  /var/tmp

   Os snapshots tambem podem ser renomeados dessa maneira. Devido `a natureza
   dos snapshots, eles nao podem ser renomeados para um conjunto de dados pai
   diferente. Para renomear um snapshot recursivo, especifique -r e todos os
   snapshots com o mesmo nome nos conjuntos de dados filho tambem serao
   renomeados.

 # zfs list -t snapshot
 NAME                                USED  AVAIL  REFER  MOUNTPOINT
 mypool/var/newname@first_snapshot      0      -  87.5K  -
 # zfs rename mypool/var/newname@first_snapshot new_snapshot_name
 # zfs list -t snapshot
 NAME                                   USED  AVAIL  REFER  MOUNTPOINT
 mypool/var/newname@new_snapshot_name      0      -  87.5K  -

  19.4.4. Configurando Propriedades do Conjunto de Dados

   Cada conjunto de dados do ZFS possui varias propriedades que controlam seu
   comportamento. A maioria das propriedades e herdada automaticamente do
   conjunto de dados pai, mas pode ser substituida localmente. Defina uma
   propriedade em um conjunto de dados com zfs set property=value dataset. A
   maioria das propriedades tem um conjunto limitado de valores validos, o
   zfs get exibira cada propriedade e valor valido possivel. A maioria das
   propriedades pode ser revertida para seus valores herdados usando zfs
   inherit.

   Propriedades definidas pelo usuario tambem podem ser definidas. Eles se
   tornam parte da configurac,ao do conjunto de dados e podem ser usados para
   fornecer informac,oes adicionais sobre o conjunto de dados ou seu
   conteudo. Para distinguir essas propriedades personalizadas daquelas
   fornecidas como parte do ZFS, dois pontos (:) sao usados para criar um
   namespace personalizado para a propriedade.

 # zfs set custom:costcenter=1234 tank
 # zfs get custom:costcenter tank
 NAME PROPERTY           VALUE SOURCE
 tank custom:costcenter  1234  local

   Para remover uma propriedade customizada, use o zfs inherit com -r. Se a
   propriedade personalizada nao estiver definida em nenhum dos conjuntos de
   dados pai, ela sera removida completamente (embora as alterac,oes ainda
   sejam registradas no historico do pool).

  #   zfs inherit -r  customizado :  costcenter   tanque 
  #   zfs  customizado :  costcenter   tank 
 NAME PROPERTY VALUE SOURCE
 tanque personalizado: costcenter - -
  #   zfs obtem todos  tank  | grep  personalizado :  costcenter 
  #

    19.4.4.1. Obtendo e definindo propriedades de compartilhamento

   Duas propriedades de conjunto de dados comumente usadas e uteis sao as
   opc,oes de compartilhamento NFS e SMB. Configurar estas define se e como
   os conjuntos de dados do ZFS podem ser compartilhados na rede. Atualmente,
   apenas o compartilhamento de configurac,oes via NFS e suportado no
   FreeBSD. Para obter o status atual de um compartilhamento, insira:

 # zfs get sharenfs mypool/usr/home
 NAME             PROPERTY  VALUE    SOURCE
 mypool/usr/home  sharenfs  on       local
 # zfs get sharesmb mypool/usr/home
 NAME             PROPERTY  VALUE    SOURCE
 mypool/usr/home  sharesmb  off      local

   Para ativar o compartilhamento de um conjunto de dados, insira:

 #  zfs set sharenfs=on mypool/usr/home

   Tambem e possivel definir opc,oes adicionais para compartilhar conjuntos
   de dados por meio do NFS, como -alldirs, -maproot e -network. Para definir
   opc,oes adicionais para um conjunto de dados compartilhado por meio do
   NFS, insira:

 #  zfs set sharenfs="-alldirs,-maproot=root,-network=192.168.1.0/24" mypool/usr/home

  19.4.5. Gerenciando Snapshots

   Os snapshots sao um dos recursos mais poderosos do ZFS. Um snapshot
   fornece uma copia point-in-time somente leitura do conjunto de dados. Com
   Copy-On-Write (COW), os snapshots podem ser criados rapidamente,
   preservando a versao mais antiga dos dados no disco. Se nao houver
   snapshots, o espac,o sera recuperado para uso futuro quando os dados forem
   reconfigurados ou excluidos. Os snapshots preservam o espac,o em disco
   gravando apenas as diferenc,as entre o conjunto de dados atual e uma
   versao anterior. Os snapshots sao permitidos apenas em conjuntos de dados
   completos, nao em arquivos ou diretorios individuais. Quando um snapshot e
   criado a partir de um conjunto de dados, tudo contido nele e duplicado.
   Isso inclui as propriedades do sistema de arquivos, arquivos, diretorios,
   permissoes e assim por diante. Os snapshots nao usam espac,o adicional
   quando sao criados pela primeira vez, consumindo espac,o apenas quando os
   blocos de referencia sao alterados. Snapshots recursivos obtidos com -r
   criam um instantaneo com o mesmo nome no conjunto de dados e em todos os
   seus filhos, fornecendo um snapshot moment-in-time de todos os sistemas de
   arquivos no momento. Isso pode ser importante quando um aplicativo possui
   arquivos em varios conjuntos de dados relacionados ou dependentes um do
   outro. Sem snapshots, um backup teria copias dos arquivos de diferentes
   pontos no tempo.

   Os snapshots no ZFS fornecem uma variedade de recursos que ate mesmo
   outros sistemas de arquivos com a funcionalidade de snapshots nao tem. Um
   exemplo tipico de uso de snapshots e ter uma maneira rapida de fazer
   backup do estado atual do sistema de arquivos quando uma ac,ao arriscada,
   como uma instalac,ao de software ou uma atualizac,ao do sistema, e
   executada. Se a ac,ao falhar, o snapshot podera ser revertido e o sistema
   tera o mesmo estado de quando o snapshot foi criado. Se a atualizac,ao foi
   bem sucedida, o instantaneo pode ser excluido para liberar espac,o. Sem
   snapshots, uma atualizac,ao com falha geralmente requer uma restaurac,ao
   de backup, o que e tedioso, consome tempo e pode exigir tempo de
   inatividade durante o qual o sistema nao pode ser usado. Os snapshots
   podem ser revertidos rapidamente, mesmo enquanto o sistema esta sendo
   executado em operac,ao normal, com pouco ou nenhum tempo de inatividade. A
   economia de tempo e enorme com sistemas de armazenamento de varios
   terabytes e o tempo necessario para copiar os dados a partir do backup. Os
   snapshots nao substituem um backup completo de um pool, mas podem ser
   usados de maneira rapida e facil para armazenar uma copia do conjunto de
   dados em um momento especifico.

    19.4.5.1. Criando Snapshots

   Os snapshots sao criados com zfs snapshot dataset@snapshotname. Adicionar
   a opc,ao -r cria um snapshot recursivamente, com o mesmo nome em todos os
   conjuntos de dados filho.

   Crie um Snapshot recursivo de todo o pool:

 # zfs list -t all
 NAME                                   USED  AVAIL  REFER  MOUNTPOINT
 mypool                                 780M  93.2G   144K  none
 mypool/ROOT                            777M  93.2G   144K  none
 mypool/ROOT/default                    777M  93.2G   777M  /
 mypool/tmp                             176K  93.2G   176K  /tmp
 mypool/usr                             616K  93.2G   144K  /usr
 mypool/usr/home                        184K  93.2G   184K  /usr/home
 mypool/usr/ports                       144K  93.2G   144K  /usr/ports
 mypool/usr/src                         144K  93.2G   144K  /usr/src
 mypool/var                            1.29M  93.2G   616K  /var
 mypool/var/crash                       148K  93.2G   148K  /var/crash
 mypool/var/log                         178K  93.2G   178K  /var/log
 mypool/var/mail                        144K  93.2G   144K  /var/mail
 mypool/var/newname                    87.5K  93.2G  87.5K  /var/newname
 mypool/var/newname@new_snapshot_name      0      -  87.5K  -
 mypool/var/tmp                         152K  93.2G   152K  /var/tmp
 # zfs snapshot -r mypool@my_recursive_snapshot
 # zfs list -t snapshot
 NAME                                        USED  AVAIL  REFER  MOUNTPOINT
 mypool@my_recursive_snapshot                   0      -   144K  -
 mypool/ROOT@my_recursive_snapshot              0      -   144K  -
 mypool/ROOT/default@my_recursive_snapshot      0      -   777M  -
 mypool/tmp@my_recursive_snapshot               0      -   176K  -
 mypool/usr@my_recursive_snapshot               0      -   144K  -
 mypool/usr/home@my_recursive_snapshot          0      -   184K  -
 mypool/usr/ports@my_recursive_snapshot         0      -   144K  -
 mypool/usr/src@my_recursive_snapshot           0      -   144K  -
 mypool/var@my_recursive_snapshot               0      -   616K  -
 mypool/var/crash@my_recursive_snapshot         0      -   148K  -
 mypool/var/log@my_recursive_snapshot           0      -   178K  -
 mypool/var/mail@my_recursive_snapshot          0      -   144K  -
 mypool/var/newname@new_snapshot_name           0      -  87.5K  -
 mypool/var/newname@my_recursive_snapshot       0      -  87.5K  -
 mypool/var/tmp@my_recursive_snapshot           0      -   152K  -

   Os snapshots nao sao mostrados por uma operac,ao normal do zfs list. Para
   listar snapshots , a opc,ao -t snapshot e anexado ao zfs list. A opc,ao -t
   all exibe os sistemas de arquivos e snapshots.

   Os snapshots nao sao montados diretamente, portanto, nenhum caminho e
   mostrado na coluna MOUNTPOINT. Nao ha menc,ao ao espac,o disponivel em
   disco na coluna AVAIL, ja que os snapshots nao podem ser gravados apos
   serem criados. Compare o snapshot com o conjunto de dados original a
   partir do qual foi criado:

 # zfs list -rt all mypool/usr/home
 NAME                                    USED  AVAIL  REFER  MOUNTPOINT
 mypool/usr/home                         184K  93.2G   184K  /usr/home
 mypool/usr/home@my_recursive_snapshot      0      -   184K  -

   A exibic,ao do conjunto de dados e dos snapshots juntos revela como os
   snapshots funcionam no modo COW. Eles salvam apenas as alterac,oes
   (deltas) que foram feitas e nao o conteudo completo do sistema de arquivos
   novamente. Isso significa que os snapshots ocupam pouco espac,o quando
   poucas alterac,oes sao feitas. O uso do espac,o pode se tornar ainda mais
   aparente copiando um arquivo para o conjunto de dados e fazendo um segundo
   snapshots:

 # cp /etc/passwd /var/tmp
 # zfs snapshot mypool/var/tmp@after_cp
 # zfs list -rt all mypool/var/tmp
 NAME                                   USED  AVAIL  REFER  MOUNTPOINT
 mypool/var/tmp                         206K  93.2G   118K  /var/tmp
 mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
 mypool/var/tmp@after_cp                   0      -   118K  -

   O segundo snapshot contem apenas as alterac,oes feitas no conjunto de
   dados apos a operac,ao de copia. Isso resulta numa enorme economia de
   espac,o. Observe que o tamanho do snapshot
   mypool/var/tmp@my_recursive_snapshot tambem foi alterado na coluna USED
   para indicar as alterac,oes entre ela mesma e o snapshot obtido
   posteriormente.

    19.4.5.2. Comparando Snapshots

   O ZFS fornece um comando interno para comparar as diferenc,as de conteudo
   entre dois snapshots. Isso e util quando muitos snapshots foram gerados
   com o passar do tempo e o usuario deseja ver como o sistema de arquivos
   mudou ao longo do tempo. Por exemplo, o zfs diff permite que um usuario
   localize o ultimo snapshot que ainda contem um arquivo que foi
   acidentalmente excluido. Fazer isso para os dois snapshots criados na
   sec,ao anterior produz essa saida:

 # zfs list -rt all mypool/var/tmp
 NAME                                   USED  AVAIL  REFER  MOUNTPOINT
 mypool/var/tmp                         206K  93.2G   118K  /var/tmp
 mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
 mypool/var/tmp@after_cp                   0      -   118K  -
 # zfs diff mypool/var/tmp@my_recursive_snapshot
 M       /var/tmp/
 +       /var/tmp/passwd

   O comando lista as alterac,oes entre o snapshot especificado (neste caso
   mypool/var/tmp@my_recursive_snapshot) e o sistema de arquivos ativo. A
   primeira coluna mostra o tipo de mudanc,a:

   +------------------------------------------------------------------------+
   | +                | O caminho ou arquivo foi adicionado.                |
   |------------------+-----------------------------------------------------|
   | -                | O caminho ou arquivo foi excluido.                  |
   |------------------+-----------------------------------------------------|
   | M                | O caminho ou arquivo foi modificado.                |
   |------------------+-----------------------------------------------------|
   | R                | O caminho ou arquivo foi renomeado.                 |
   +------------------------------------------------------------------------+

   Comparando a saida com a tabela, fica claro que o passwd foi adicionado
   apos o snapshot mypool/var/tmp@my_recursive_snapshot ter sido criado. Isso
   tambem resultou em uma modificac,ao no diretorio pai montado em /var/tmp.

   A comparac,ao de dois snapshots e util ao usar o recurso de replicac,ao do
   ZFS para transferir um conjunto de dados para um host diferente para fins
   de backup.

   Compare dois snapshots fornecendo o nome completo do conjunto de dados e o
   nome do snapshot de ambos os conjuntos de dados:

 # cp /var/tmp/passwd /var/tmp/passwd.copy
 # zfs snapshot mypool/var/tmp@diff_snapshot
 # zfs diff mypool/var/tmp@my_recursive_snapshot mypool/var/tmp@diff_snapshot
 M       /var/tmp/
 +       /var/tmp/passwd
 +       /var/tmp/passwd.copy
 # zfs diff mypool/var/tmp@my_recursive_snapshot mypool/var/tmp@after_cp
 M       /var/tmp/
 +       /var/tmp/passwd

   Um administrador de backup pode comparar dois snapshots recebidos do host
   de envio e determinar as alterac,oes reais no conjunto de dados. Consulte
   a sec,ao Replicac,ao para obter maiores informac,oes.

    19.4.5.3. Reversao de um Snapshot

   Quando pelo menos um snapshot estiver disponivel, ele podera ser revertido
   a qualquer momento. Na maioria das vezes, esse e o caso quando o estado
   atual do conjunto de dados nao e mais necessario e uma versao mais antiga
   e preferida. Cenarios em que testes de desenvolvimento local deram errado,
   atualizac,oes de sistemas com falhas que dificultam o funcionamento geral
   do sistema ou a necessidade de restaurar arquivos ou diretorios excluidos
   acidentalmente sao ocorrencias muito comuns. Felizmente, reverter um
   snapshot e tao facil quanto digitar zfs rollback snapshotname. Dependendo
   de quantas alterac,oes estao envolvidas, a operac,ao sera concluida em um
   determinado periodo de tempo. Durante esse periodo, o conjunto de dados
   permanece sempre em um estado consistente, da mesma forma que um banco de
   dados em conformidade com os principios do ACID ao realizar uma reversao.
   Isso esta acontecendo enquanto o conjunto de dados esta ativo e acessivel,
   sem exigir um tempo de inatividade. Depois que o snapshot for revertido, o
   conjunto de dados tera o mesmo estado de quando o snapshot foi
   originalmente criado. Todos os outros dados nesse conjunto de dados que
   nao faziam parte do snapshot sao descartados. Criar um snapshot do estado
   atual do conjunto de dados antes de reverter para um anterior e uma boa
   ideia quando alguns dos dados sao necessarios mais tarde. Desta forma, o
   usuario pode alternar entre os snapshots sem perder dados que ainda sao
   valiosos.

   No primeiro exemplo, um snapshot e revertido por causa de uma operac,ao
   descuidada com o comando rm que removeu muito mais dados do que o
   pretendido.

 # zfs list -rt all mypool/var/tmp
 NAME                                   USED  AVAIL  REFER  MOUNTPOINT
 mypool/var/tmp                         262K  93.2G   120K  /var/tmp
 mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
 mypool/var/tmp@after_cp               53.5K      -   118K  -
 mypool/var/tmp@diff_snapshot              0      -   120K  -
 # ls /var/tmp
 passwd          passwd.copy     vi.recover
 # rm /var/tmp/passwd*
 # ls /var/tmp
 vi.recover

   Neste ponto, o usuario percebeu que muitos arquivos foram excluidos e os
   quer de volta. O ZFS fornece uma maneira facil de recupera-los usando
   reversoes, mas somente quando os snapshots de dados importantes sao
   executados regularmente. Para recuperar os arquivos e recomec,ar a partir
   do ultimo snapshot, emita o comando:

 # zfs rollback mypool/var/tmp@diff_snapshot
 # ls /var/tmp
 passwd          passwd.copy     vi.recover

   A operac,ao de reversao restaurou o conjunto de dados para o estado do
   ultimo snapshot. Tambem e possivel reverter para um snapshot que foi
   gerado muito antes e que possui outros snapshots criados apos ele. Ao
   tentar fazer isso, o ZFS ira emitir este aviso:

 # zfs list -rt snapshot mypool/var/tmp
 AME                                   USED  AVAIL  REFER  MOUNTPOINT
 mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
 mypool/var/tmp@after_cp               53.5K      -   118K  -
 mypool/var/tmp@diff_snapshot              0      -   120K  -
 # zfs rollback mypool/var/tmp@my_recursive_snapshot
 cannot rollback to 'mypool/var/tmp@my_recursive_snapshot': more recent snapshots exist
 use '-r' to force deletion of the following snapshots:
 mypool/var/tmp@after_cp
 mypool/var/tmp@diff_snapshot

   Esse aviso significa que existem snapshots entre o estado atual do
   conjunto de dados e o snapshot para o qual o usuario deseja retroceder.
   Para concluir a reversao, esses snapshots devem ser excluidos. O ZFS nao
   pode rastrear todas as alterac,oes entre estados diferentes do conjunto de
   dados, porque os snapshots sao somente de leitura. O ZFS nao excluira os
   snapshots afetados, a menos que o usuario especifique a opc,ao -r para
   indicar que essa e a ac,ao desejada. Se essa for a intenc,ao e as
   consequencias da perda de todos os snapshots intermediarios forem
   compreendidas, o comando podera ser emitido:

 # zfs rollback -r mypool/var/tmp@my_recursive_snapshot
 # zfs list -rt snapshot mypool/var/tmp
 NAME                                   USED  AVAIL  REFER  MOUNTPOINT
 mypool/var/tmp@my_recursive_snapshot     8K      -   152K  -
 # ls /var/tmp
 vi.recover

   A saida de zfs list -t snapshot confirma que os snapshots intermediarios
   foram removidos como resultado do zfs rollback -r.

    19.4.5.4. Restaurando arquivos individuais a partir de Snapshots

   Os snapshots sao montados em um diretorio oculto no conjunto de dados pai:
   .zfs/snapshots/snapshotname. Por padrao, esses diretorios nao serao
   exibidos mesmo quando um ls -a padrao for executado. Embora o diretorio
   nao seja exibido, ele esta la e pode ser acessado como qualquer diretorio
   normal. A propriedade denominada snapdir controla se esses diretorios
   ocultos aparecem em uma listagem de diretorios. Definir a propriedade como
   visible permite que eles aparec,am na saida do ls e de outros comandos que
   lidam com o conteudo do diretorio.

 # zfs get snapdir mypool/var/tmp
 NAME            PROPERTY  VALUE    SOURCE
 mypool/var/tmp  snapdir   hidden   default
 # ls -a /var/tmp
 .               ..              passwd          vi.recover
 # zfs set snapdir=visible mypool/var/tmp
 # ls -a /var/tmp
 .               ..              .zfs            passwd          vi.recover

   Arquivos individuais podem ser facilmente restaurados para um estado
   anterior, copiando-os do snapshot de volta para o conjunto de dados pai. A
   estrutura de diretorios abaixo de .zfs/snapshot tem um diretorio nomeado
   exatamente como os instantaneos criados anteriormente para facilitar sua
   identificac,ao. No proximo exemplo, presume-se que um arquivo deve ser
   restaurado a partir do diretorio .zfs oculto, copiando-o do snapshot que
   continha a versao mais recente do arquivo:

 # rm /var/tmp/passwd
 # ls -a /var/tmp
 .               ..              .zfs            vi.recover
 # ls /var/tmp/.zfs/snapshot
 after_cp                my_recursive_snapshot
 # ls /var/tmp/.zfs/snapshot/after_cp
 passwd          vi.recover
 # cp /var/tmp/.zfs/snapshot/after_cp/passwd /var/tmp

   Quando o comando ls .zfs/snapshot foi emitido, a propriedade snapdir pode
   ter sido definida como oculta, mas ainda seria possivel listar o conteudo
   desse diretorio. Cabe ao administrador decidir se esses diretorios serao
   exibidos. E possivel exibi-los para determinados conjuntos de dados e
   impedi-los para outros. Copiar arquivos ou diretorios deste diretorio
   .zfs/snapshot oculto e bastante simples. Tentar o contrario, resulta neste
   erro:

 # cp /etc/rc.conf /var/tmp/.zfs/snapshot/after_cp/
 cp: /var/tmp/.zfs/snapshot/after_cp/rc.conf: Read-only file system

   O erro lembra ao usuario que os snapshots sao somente de leitura e nao
   podem ser alterados apos a criac,ao. Os arquivos nao podem ser copiados
   para ou removidos dos diretorios de snapshot porque isso alteraria o
   estado do conjunto de dados que eles representam.

   Os snapshots consomem espac,o com base em quanto o sistema de arquivos pai
   foi alterado desde o momento da criac,ao do snapshot. A propriedade
   written de um snapshot rastreia quanto espac,o esta sendo usado pelo
   snapshot.

   Snapshots sao destruidos e o espac,o recuperado com o zfs destroy
   dataset@snapshot. Adicionar -r remove recursivamente todos os snapshots
   com o mesmo nome sob o conjunto de dados pai. Adicionar -n -v ao comando
   exibe uma lista dos snapshots que seriam excluidos e uma estimativa de
   quanto espac,o seria recuperado sem executar a operac,ao de destruic,ao
   real.

  19.4.6. Gerenciando Clones

   Um clone e uma copia de um snapshot que e tratado mais como um conjunto de
   dados regular. Ao contrario de um snapshot, um clone nao e somente de
   leitura, ele pode ser montado e pode ter suas proprias propriedades. Uma
   vez que um clone tenha sido criado usando zfs clone, o snapshot do qual
   ele foi criado nao pode ser destruido. O relacionamento filho/pai entre o
   clone e o snapshot pode ser revertido usando zfs promote. Depois que um
   clone e promovido, o snapshot se torna um filho do clone, em vez de filho
   do conjunto de dados pai original. Isso mudara a maneira como o espac,o e
   contabilizado, mas nao mudara a quantidade de espac,o consumida. O clone
   pode ser montado em qualquer ponto dentro da hierarquia do sistema de
   arquivos ZFS, nao apenas abaixo do local original do snapshot.

   Para demonstrar o recurso de clonagem, este conjunto de dados de exemplo e
   usado:

 # zfs list -rt all camino/home/joe
 NAME                    USED  AVAIL  REFER  MOUNTPOINT
 camino/home/joe         108K   1.3G    87K  /usr/home/joe
 camino/home/joe@plans    21K      -  85.5K  -
 camino/home/joe@backup    0K      -    87K  -

   Um uso tipico de clones e experimentar um conjunto de dados especifico,
   mantendo o snapshot em volta, para o caso de algo dar errado. Como os
   snapshots nao podem ser alterados, um clone de leitura/gravac,ao de um
   snapshot e criado. Depois que o resultado desejado e alcanc,ado no clone,
   o clone pode ser promovido para se tornar um conjunto de dados e o sistema
   de arquivos antigo e removido. Isso nao e estritamente necessario, pois o
   clone e o conjunto de dados podem coexistir sem problemas.

 # zfs clone camino/home/joe@backup camino/home/joenew
 # ls /usr/home/joe*
 /usr/home/joe:
 backup.txz     plans.txt

 /usr/home/joenew:
 backup.txz     plans.txt
 # df -h /usr/home
 Filesystem          Size    Used   Avail Capacity  Mounted on
 usr/home/joe        1.3G     31k    1.3G     0%    /usr/home/joe
 usr/home/joenew     1.3G     31k    1.3G     0%    /usr/home/joenew

   Depois que um clone e criado, ele e uma copia exata do estado em que o
   conjunto de dados estava quando o snapshot foi criado. O clone agora pode
   ser alterado independentemente de seu conjunto de dados de origem. A unica
   conexao entre os dois e o snapshot. O ZFS registra essa conexao na
   propriedade origin. Uma vez que a dependencia entre o snapshot e o clone
   foi removida promovendo-se o clone usando zfs promote, a origem do clone e
   removida, pois agora ele e um conjunto de dados independente. Este exemplo
   demonstra isso:

 # zfs get origin camino/home/joenew
 NAME                  PROPERTY  VALUE                     SOURCE
 camino/home/joenew    origin    camino/home/joe@backup    -
 # zfs promote camino/home/joenew
 # zfs get origin camino/home/joenew
 NAME                  PROPERTY  VALUE   SOURCE
 camino/home/joenew    origin    -       -

   Depois de fazer algumas alterac,oes, como copiar o loader.conf para o
   clone promovido, por exemplo, o diretorio antigo torna-se obsoleto nesse
   caso. Em vez disso, o clone promovido pode substitui-lo. Isso pode ser
   conseguido por dois comandos consecutivos: zfs destroy no dataset antigo e
   zfs rename no clone para nomea-lo como o conjunto de dados antigo (ele
   tambem poderia ter um nome totalmente diferente).

 # cp /boot/defaults/loader.conf /usr/home/joenew
 # zfs destroy -f camino/home/joe
 # zfs rename camino/home/joenew camino/home/joe
 # ls /usr/home/joe
 backup.txz     loader.conf     plans.txt
 # df -h /usr/home
 Filesystem          Size    Used   Avail Capacity  Mounted on
 usr/home/joe        1.3G    128k    1.3G     0%    /usr/home/joe

   O snapshot clonado agora e tratado como um conjunto de dados comum. Ele
   contem todos os dados do snapshot original mais os arquivos que foram
   adicionados a ele como o loader.conf. Os clones podem ser usados em
   diferentes cenarios para fornecer recursos uteis aos usuarios do ZFS. Por
   exemplo, os jails podem ser disponibilizados como snapshots contendo
   diferentes conjuntos de aplicativos instalados. Os usuarios podem clonar
   esses snapshots e adicionar seus proprios aplicativos como acharem melhor.
   Uma vez satisfeitos com as alterac,oes, os clones podem ser promovidos a
   conjuntos de dados completos e fornecidos aos usuarios finais para que
   trabalhem como se estivessem com um conjunto de dados real. Fornecer estes
   jails economiza tempo e sobrecarga administrativa.

  19.4.7. Replicac,ao

   Manter os dados em um unico pool e em um unico local o expoe a riscos como
   roubo e desastres naturais ou humanos. Fazer backups regulares de todo o
   pool e vital. O ZFS fornece um recurso de serializac,ao integrado que pode
   enviar uma representac,ao de fluxo dos dados para a saida padrao. Usando
   essa tecnica, e possivel nao apenas armazenar os dados em outro pool
   conectado ao sistema local, mas tambem envia-los por uma rede para outro
   sistema. Os snapshots sao a base para essa replicac,ao (consulte a sec,ao
   sobre snapshots ZFS). Os comandos usados para replicar dados sao zfs send
   e zfs receive.

   Estes exemplos demonstram a replicac,ao do ZFS com estes dois pools:

 # zpool list
 NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
 backup  960M    77K   896M         -         -     0%    0%  1.00x  ONLINE  -
 mypool  984M  43.7M   940M         -         -     0%    4%  1.00x  ONLINE  -

   O pool chamado mypool e o pool principal no qual os dados sao gravados e
   lidos regularmente. Um segundo pool, backup e usado como standby, caso o
   pool principal fique indisponivel. Observe que esse failover nao e feito
   automaticamente pelo ZFS, mas deve ser feito manualmente por um
   administrador do sistema, quando necessario. Um snapshot e usado para
   fornecer uma versao consistente do sistema de arquivos a ser replicado.
   Depois que um snapshot de mypool tiver sido criado, ele podera ser copiado
   para o pool backup. Apenas snapshots podem ser replicados. As alterac,oes
   feitas desde o snapshot mais recente nao serao incluidas.

 # zfs snapshot mypool@backup1
 # zfs list -t snapshot
 NAME                    USED  AVAIL  REFER  MOUNTPOINT
 mypool@backup1             0      -  43.6M  -

   Agora que existe um snapshot, o zfs send pode ser usado para criar um
   fluxo representando o conteudo do snapshot. Esse fluxo pode ser armazenado
   como um arquivo ou recebido por outro pool. O fluxo e gravado na saida
   padrao, mas deve ser redirecionado para um arquivo ou canal ou um erro
   sera produzido:

 # zfs send mypool@backup1
 Error: Stream can not be written to a terminal.
 You must redirect standard output.

   Para fazer backup de um conjunto de dados com o zfs send, redirecione para
   um arquivo localizado no pool de backup montado. Assegure-se de que o pool
   tenha espac,o livre suficiente para acomodar o tamanho do snapshot que
   esta sendo enviado, o que significa todos os dados contidos no snapshot,
   nao apenas as mudanc,as do snapshot anterior.

 # zfs send mypool@backup1 > /backup/backup1
 # zpool list
 NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
 backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -
 mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -

   O zfs send transferiu todos os dados do snapshot chamado backup1 para o
   pool chamado backup. Criar e enviar esses snapshots pode ser feito
   automaticamente com uma tarefa agendada do cron(8).

   Em vez de armazenar os backups como arquivos compactados, o ZFS pode
   recebe-los como um sistema de arquivos ativo, permitindo que os dados de
   backup sejam acessados diretamente. Para obter os dados reais contidos
   nesses fluxos, o zfs receive e usado para transformar os fluxos novamente
   em arquivos e diretorios. O exemplo a seguir combina o zfs send e o zfs
   receive usando um canal para copiar os dados de um pool para outro. Os
   dados podem ser usados diretamente no pool de recebimento apos a conclusao
   da transferencia. Um conjunto de dados so pode ser replicado para um
   conjunto de dados vazio.

 # zfs snapshot mypool@replica1
 # zfs send -v mypool@replica1 | zfs receive backup/mypool
 send from @ to mypool@replica1 estimated size is 50.1M
 total estimated size is 50.1M
 TIME        SENT   SNAPSHOT

 # zpool list
 NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
 backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -
 mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -

    19.4.7.1. Backups Incrementais

   O zfs send tambem pode determinar a diferenc,a entre dois snapshots e
   enviar apenas as diferenc,as entre os dois. Isso economiza espac,o em
   disco e tempo de transferencia. Por exemplo:

 # zfs snapshot mypool@replica2
 # zfs list -t snapshot
 NAME                    USED  AVAIL  REFER  MOUNTPOINT
 mypool@replica1         5.72M      -  43.6M  -
 mypool@replica2             0      -  44.1M  -
 # zpool list
 NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
 backup  960M  61.7M   898M         -         -     0%    6%  1.00x  ONLINE  -
 mypool  960M  50.2M   910M         -         -     0%    5%  1.00x  ONLINE  -

   Um segundo snapshot chamado replica2 foi criado. Este segundo snapshot
   contem apenas as alterac,oes feitas no sistema de arquivos entre o
   snapshot atual e o anterior, replica1. O uso do zfs send -i e a indicac,ao
   do par de snapshots gera um fluxo de replica incremental contendo apenas
   os dados que foram alterados. Isso so sera bem-sucedido se o snapshot
   inicial ja existir no lado do recebimento.

 # zfs send -v -i mypool@replica1 mypool@replica2 | zfs receive /backup/mypool
 send from @replica1 to mypool@replica2 estimated size is 5.02M
 total estimated size is 5.02M
 TIME        SENT   SNAPSHOT

 # zpool list
 NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG  CAP  DEDUP  HEALTH  ALTROOT
 backup  960M  80.8M   879M         -         -     0%   8%  1.00x  ONLINE  -
 mypool  960M  50.2M   910M         -         -     0%   5%  1.00x  ONLINE  -

 # zfs list
 NAME                         USED  AVAIL  REFER  MOUNTPOINT
 backup                      55.4M   240G   152K  /backup
 backup/mypool               55.3M   240G  55.2M  /backup/mypool
 mypool                      55.6M  11.6G  55.0M  /mypool

 # zfs list -t snapshot
 NAME                                         USED  AVAIL  REFER  MOUNTPOINT
 backup/mypool@replica1                       104K      -  50.2M  -
 backup/mypool@replica2                          0      -  55.2M  -
 mypool@replica1                             29.9K      -  50.0M  -
 mypool@replica2                                 0      -  55.0M  -

   O fluxo incremental foi transferido com sucesso. Apenas os dados que foram
   alterados foram replicados, em vez da totalidade da replica1. Somente as
   diferenc,as foram enviadas, o que levou muito menos tempo para transferir
   e economizou espac,o em disco por nao copiar o pool completo novamente.
   Isso e util quando se precisa confiar em redes lentas ou quando os custos
   por byte transferido devem ser considerados.

   Um novo sistema de arquivos, backup/mypool, esta disponivel com todos os
   arquivos e dados do pool mypool. Se -P for especificado, as propriedades
   do dataset serao copiadas, incluindo configurac,oes de compactac,ao, cotas
   e pontos de montagem. Quando -R e especificado, todos os conjuntos de
   dados filho do dataset indicado serao copiados, juntamente com todas as
   suas propriedades. O envio e o recebimento podem ser automatizados para
   que backups regulares sejam criados no segundo pool.

    19.4.7.2. Envio de backups criptografados pelo SSH

   O envio de fluxos pela rede e uma boa maneira de manter um backup remoto,
   mas apresenta uma desvantagem. Os dados enviados pelo link de rede nao sao
   criptografados, permitindo que qualquer pessoa intercepte e transforme os
   fluxos de volta em dados sem o conhecimento do usuario remetente. Isso e
   indesejavel, especialmente ao enviar os fluxos pela Internet para um host
   remoto. O SSH pode ser usado para criptografar com seguranc,a os dados
   enviados por uma conexao de rede. Como o ZFS requer apenas que o fluxo
   seja redirecionado da saida padrao, e relativamente facil transmiti-lo
   atraves do SSH. Para manter o conteudo do sistema de arquivos
   criptografado em transito e no sistema remoto, considere o uso do PEFS.

   Algumas configurac,oes e precauc,oes de seguranc,a devem ser concluidas
   primeiro. Apenas as etapas necessarias para a operac,ao do zfs send sao
   mostradas aqui. Para mais informac,oes sobre o SSH, consulte Sec,ao 13.8,
   "OpenSSH".

   Essa configurac,ao e necessaria:

     * Acesso SSH sem senha entre o host de envio e recebimento usando chaves
       SSH

     * Normalmente, os privilegios do usuario root sao necessarios para
       enviar e receber fluxos. Isso requer o login no sistema de recebimento
       como root. No entanto, o login como root vem desabilitado por padrao
       por motivos de seguranc,a. O sistema ZFS Delegation pode ser usado
       para permitir que um usuario nao root em cada sistema execute as
       respectivas operac,oes de envio e recebimento.

     * No sistema de envio:

 # zfs allow -u someuser send,snapshot mypool

     * Para montar o pool, o usuario nao privilegiado deve ser o dono do
       diretorio e os usuarios regulares devem poder montar sistemas de
       arquivos. No sistema de recebimento:

 # sysctl vfs.usermount=1
 vfs.usermount: 0 -> 1
 # sysrc -f /etc/sysctl.conf vfs.usermount=1
 # zfs create recvpool/backup
 # zfs allow -u someuser create,mount,receive recvpool/backup
 # chown someuser /recvpool/backup

   O usuario sem privilegios agora tem a capacidade de receber e montar
   conjuntos de dados, e o conjunto de dados home pode ser replicado para o
   sistema remoto:

 % zfs snapshot -r mypool/home@monday
 % zfs send -R mypool/home@monday | ssh someuser@backuphost zfs recv -dvu recvpool/backup

   Um snapshot recursivo chamado monday e composto do conjunto de dados do
   sistema de arquivos home que reside no pool mypool. Em seguida, ele e
   enviado com o zfs send -R para incluir o conjunto de dados, todos os
   conjuntos de dados filho, snapshots, clones e configurac,oes no fluxo. A
   saida e canalizada para o zfs receive em espera no host remoto backuphost
   atraves do SSH. Recomenda-se a utilizac,ao de um nome de dominio
   totalmente qualificado ou do enderec,o IP. A maquina receptora grava os
   dados no conjunto de dados backup no pool recvpool. Adicionar -d ao zfs
   recv sobrescreve o nome do pool no lado de recebimento com o nome do
   snapshot. A opc,ao -u faz com que os sistemas de arquivos nao sejam
   montados no lado do recebimento. Quando -v e incluido, mais detalhes sobre
   a transferencia sao mostrados, incluindo o tempo decorrido e a quantidade
   de dados transferidos.

  19.4.8. Cotas para Datasets, Usuarios e Grupos

   As cotas para dataset sao usadas para restringir a quantidade de espac,o
   que pode ser consumida por um determinado conjunto de dados. As cotas de
   referencia funcionam basicamente da mesma maneira, mas contam apenas o
   espac,o usado pelo proprio conjunto de dados, excluindo snapshots e
   conjuntos de dados filho. Da mesma forma, as cotas para usuario e para
   grupo podem ser usadas para impedir que usuarios ou grupos usem todo o
   espac,o do pool ou do conjunto de dados.

   Para impor uma cota de dataser de 10 GB para o storage/home/bob:

 # zfs set quota=10G storage/home/bob

   Para impor uma cota de referencia de 10 GB para storage/home/bob:

 # zfs set refquota=10G storage/home/bob

   Para remover uma cota de 10 GB do storage/home/bob:

 # zfs set quota=none storage/home/bob

   O formato geral e userquota@user=size e o nome do usuario deve estar em um
   destes formatos:

     * nome compativel com o POSIX, como joe.

     * ID numerico POSIX, como 789.

     * nome SID, como joe.bloggs@example.com.

     * ID numerico SID , como S-1-123-456-789.

   Por exemplo, para impor uma cota de usuario de 50 GB para o usuario
   chamado joe:

 # zfs set userquota@joe=50G

   Para remover qualquer cota:

 # zfs set userquota@joe=none

  Nota:

   As propriedades da cota do usuario nao sao exibidas pelo zfs get all. Os
   usuarios que nao sao o root so podem ver suas proprias cotas, a menos que
   tenham recebido o privilegio userquota. Os usuarios com esse privilegio
   podem visualizar e definir a cota de todos.

   O formato geral para definir uma cota de grupo e: groupquota@group=size.

   Para definir a cota do grupo firstgroup para 50 GB, use:

 # zfs set groupquota@firstgroup=50G

   Para remover a cota do grupo firstgroup ou para certificar-se de que uma
   nao esta definida, use:

 # zfs set groupquota@firstgroup=none

   Assim como a propriedade de cota do usuario, os usuarios que nao sao root
   so podem ver as cotas associadas aos grupos aos quais eles pertencem. No
   entanto, o root ou um usuario com o privilegio groupquota pode visualizar
   e definir todas as cotas para todos os grupos.

   Para exibir a quantidade de espac,o utilizada por cada usuario em um
   sistema de arquivos ou snapshot junto com quaisquer cotas, use zfs
   userspace. Para informac,oes de grupo, use zfs groupspace. Para obter
   maiores informac,oes sobre opc,oes suportadas ou sobre como exibir apenas
   opc,oes especificas, consulte zfs(1).

   Usuarios com privilegios suficientes, e o root, podem listar a cota para
   storage/home/bob usando:

 # zfs get quota storage/home/bob

  19.4.9. Reservas

   As reservas garantem uma quantidade minima de espac,o sempre disponivel em
   um conjunto de dados. O espac,o reservado nao estara disponivel para
   nenhum outro conjunto de dados. Esse recurso pode ser especialmente util
   para garantir que haja espac,o livre disponivel para um conjunto de dados
   ou arquivos de log importantes.

   O formato geral da propriedade reservation e reservation=size, portanto,
   para definir uma reserva de 10 GB em storage/home/bob, use:

 # zfs set reservation=10G storage/home/bob

   Para cancelar qualquer reserva:

 # zfs set reservation=none storage/home/bob

   O mesmo principio pode ser aplicado `a propriedade refreservation para
   definir uma Reserva de Referencia, com o formato geral
   refreservation=size.

   Este comando mostra todas as reservas ou atualizac,oes existentes
   nostorage/home/bob:

 # zfs get reservation storage/home/bob
 # zfs get refreservation storage/home/bob

  19.4.10. Compressao

   O ZFS fornece compactac,ao transparente. A compactac,ao de dados no nivel
   do bloco a medida que ele e escrito, nao apenas economiza espac,o, mas
   tambem pode aumentar a performance do disco. Se os dados forem compactados
   em 25%, mas os dados compactados forem gravados no disco na mesma taxa da
   versao descompactada, resulta em uma velocidade efetiva de gravac,ao de
   125%. A compactac,ao tambem pode ser uma otima alternativa para
   Deduplicac,ao porque nao requer memoria adicional.

   O ZFS oferece varios algoritmos de compactac,ao diferentes, cada um com
   diferentes compensac,oes. Com a introduc,ao da compactac,ao LZ4 no ZFS
   v5000, e possivel ativar a compactac,ao para todo o pool sem o trade-off
   de desempenho de outros algoritmos. A maior vantagem do LZ4 e o recurso
   early abort. Se o LZ4 nao atingir pelo menos 12,5% de compactac,ao na
   primeira parte dos dados, o bloco sera gravado descompactado para evitar o
   desperdicio de ciclos da CPU que tentam compactar dados ja compactados ou
   nao compactaveis. Para obter detalhes sobre os diferentes algoritmos de
   compactac,ao disponiveis no ZFS, consulte a entrada Compactac,ao na sec,ao
   de terminologia.

   O administrador pode monitorar a eficacia da compactac,ao usando varias
   propriedades do conjunto de dados.

 # zfs get used,compressratio,compression,logicalused mypool/compressed_dataset
 NAME        PROPERTY          VALUE     SOURCE
 mypool/compressed_dataset  used              449G      -
 mypool/compressed_dataset  compressratio     1.11x     -
 mypool/compressed_dataset  compression       lz4       local
 mypool/compressed_dataset  logicalused       496G      -

   O conjunto de dados esta usando atualmente 449 GB de espac,o (a
   propriedade used). Sem compressao, seriam necessarios 496 GB de espac,o (a
   propriedade logicalused). Isso resulta na taxa de compactac,ao de 1,11: 1.

   A compactac,ao pode ter um efeito colateral inesperado quando combinada
   com cotas de usuario. As cotas de usuarios restringem a quantidade de
   espac,o que um usuario pode consumir em um conjunto de dados, mas as
   medidas sao baseadas em quanto espac,o e usado apos a compactac,ao.
   Portanto, se um usuario tiver uma cota de 10 GB e gravar 10 GB de dados
   compactaveis, eles ainda poderao armazenar dados adicionais. Se,
   posteriormente, atualizarem um arquivo, digamos um banco de dados, com
   dados mais ou menos compactaveis, a quantidade de espac,o disponivel para
   eles sera alterada. Isso pode resultar na situac,ao impar em que um
   usuario nao aumentou a quantidade real de dados (a propriedade
   logicalused), mas a alterac,ao na compactac,ao fez com que eles atingissem
   seu limite de cota.

   A compactac,ao pode ter uma interac,ao inesperada semelhante com backups.
   Muitas vezes, as cotas sao usadas para limitar a quantidade de dados que
   podem ser armazenados para garantir que haja espac,o de backup suficiente
   disponivel. No entanto, uma vez que as cotas nao consideram a
   compactac,ao, mais dados podem ser gravados do que caberia com os backups
   descompactados.

  19.4.11. Desduplicac,ao

   Quando ativado, a deduplicac,ao usa o checksum de cada bloco para detectar
   blocos duplicados. Quando um novo bloco e uma duplicata de um bloco
   existente, o ZFS grava uma referencia adicional aos dados existentes, em
   vez de todo o bloco duplicado. Uma enorme economia de espac,o e possivel
   se os dados contiverem muitos arquivos duplicados ou informac,oes
   repetidas. Esteja avisado: a desduplicac,ao requer uma quantidade
   extremamente grande de memoria, e a maior parte da economia de espac,o
   pode ser obtida sem o custo extra, permitindo a compactac,ao.

   Para ativar a deduplicac,ao, defina a propriedade dedup no pool de
   destino:

 # zfs set dedup=on pool

   Somente novos dados sendo gravados no pool serao desduplicados. Os dados
   que ja foram gravados no pool nao serao desduplicados simplesmente
   ativando essa opc,ao. Um pool com uma propriedade de desduplicac,ao
   ativada recentemente sera semelhante a este exemplo:

 # zpool list
 NAME  SIZE ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG   CAP   DEDUP   HEALTH   ALTROOT
 pool 2.84G 2.19M 2.83G         -         -     0%    0%   1.00x   ONLINE   -

   A coluna DEDUP mostra a taxa real de deduplicac,ao para o pool. Um valor
   de 1.00x mostra que os dados ainda nao foram desduplicados. No proximo
   exemplo, a arvore de ports e copiada tres vezes em diretorios diferentes
   no pool desduplicado criado acima.

 # for d in dir1 dir2 dir3; do
 > mkdir $d && cp -R /usr/ports $d &
 > done

   Dados redundantes sao detectados e desduplicados:

 # zpool list
 NAME SIZE  ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG  CAP   DEDUP   HEALTH   ALTROOT
 pool 2.84G 20.9M 2.82G         -         -     0%   0%   3.00x   ONLINE   -

   A coluna DEDUP mostra um fator de 3.00x. Varias copias dos dados da arvore
   de ports foram detectadas e desduplicadas, usando apenas um terc,o do
   espac,o. O potencial de economia de espac,o pode ser enorme, mas com o
   custo de ter memoria suficiente para rastrear os blocos desduplicados.

   A desduplicac,ao nem sempre e benefica, especialmente quando os dados em
   um pool nao sao redundantes. O ZFS pode mostrar uma possivel economia de
   espac,o ao simular a desduplicac,ao em um pool existente:

 # zdb -S pool
 Simulated DDT histogram:

 bucket              allocated                       referenced
 ______   ______________________________   ______________________________
 refcnt   blocks   LSIZE   PSIZE   DSIZE   blocks   LSIZE   PSIZE   DSIZE
 ------   ------   -----   -----   -----   ------   -----   -----   -----
      1    2.58M    289G    264G    264G    2.58M    289G    264G    264G
      2     206K   12.6G   10.4G   10.4G     430K   26.4G   21.6G   21.6G
      4    37.6K    692M    276M    276M     170K   3.04G   1.26G   1.26G
      8    2.18K   45.2M   19.4M   19.4M    20.0K    425M    176M    176M
     16      174   2.83M   1.20M   1.20M    3.33K   48.4M   20.4M   20.4M
     32       40   2.17M    222K    222K    1.70K   97.2M   9.91M   9.91M
     64        9     56K   10.5K   10.5K      865   4.96M    948K    948K
    128        2   9.50K      2K      2K      419   2.11M    438K    438K
    256        5   61.5K     12K     12K    1.90K   23.0M   4.47M   4.47M
     1K        2      1K      1K      1K    2.98K   1.49M   1.49M   1.49M
  Total    2.82M    303G    275G    275G    3.20M    319G    287G    287G

 dedup = 1.05, compress = 1.11, copies = 1.00, dedup * compress / copies = 1.16

   Depois que o zdb -S termina de analisar o pool, ele mostra a taxa de
   reduc,ao de espac,o que seria obtida ativando a deduplicac,ao. Nesse caso,
   1.16 e uma taxa de economia de espac,o muito baixa e que poderia ser
   obtida apenas com a compactac,ao. A ativac,ao da deduplicac,ao neste pool
   nao salvaria uma quantidade significativa de espac,o e nao vale a
   quantidade de memoria necessaria para ativar a deduplicac,ao. Usando a
   formula ratio = dedup * compress / copies, os administradores do sistema
   podem planejar a alocac,ao de armazenamento, decidindo se a carga de
   trabalho contera blocos duplicados suficientes para justificar os
   requisitos de memoria. Se os dados forem razoavelmente compactaveis, a
   economia de espac,o podera ser muito boa. Recomenda-se ativar a
   compactac,ao primeiro pois ela tambem pode aumentar significativamente a
   performance do sistema. Ative a deduplicac,ao somente nos casos em que a
   economia adicional sera consideravel e se houver memoria suficiente para o
   DDT.

  19.4.12. ZFS e Jails

   O zfs jail e a propriedade jailed correspondente sao usadas para delegar
   um conjunto de dados ZFS para uma Jail. O zfs jail jailid anexa um dataset
   `a jail especificada, e o zfs unjail o desanexa. Para que o conjunto de
   dados seja controlado de dentro de um jail, a propriedade jailed deve ser
   configurada. Depois que um conjunto de dados e anexado a um jail, ele nao
   pode mais ser montado no host porque ele podera ter pontos de montagem que
   comprometam a seguranc,a do host.

19.5. Administrac,ao Delegada

   Um sistema abrangente de delegac,ao de permissao permite que usuarios sem
   privilegios realizem func,oes de administrac,ao do ZFS. Por exemplo, se o
   diretorio pessoal de cada usuario for um conjunto de dados, os usuarios
   poderao receber permissao para criar e destruir snapshots de seus
   diretorios pessoais. Um usuario de backup pode receber permissao para usar
   recursos de replicac,ao. Um script de estatisticas de uso pode ter
   permissao para ser executado com acesso apenas aos dados de utilizac,ao de
   espac,o para todos os usuarios. E ainda possivel delegar a capacidade de
   delegar permissoes. A delegac,ao de permissao e possivel para cada
   subcomando e para a maioria das propriedades.

  19.5.1. Delegando a criac,ao de conjunto de dados

   O zfs allow someuser create mydataset concede ao usuario especificado
   permissao para criar conjuntos de dados filho sob o conjunto de dados pai
   selecionado. Ha uma ressalva: criar um novo conjunto de dados envolve
   monta-lo. Isso requer configurar o vfs.usermount sysctl(8) do FreeBSD para
   1 para permitir que usuarios nao-root montem um sistema de arquivos.
   Existe outra restric,ao que visa impedir o abuso: os usuarios que nao sao
   root devem ser donos do ponto de montagem onde o sistema de arquivos deve
   ser montado.

  19.5.2. Delegando a delegac,ao de permissao

   O zfs allow someuser allow mydataset permite ao usuario especificado
   atribuir qualquer permissao que tenha no conjunto de dados de destino, ou
   nos seus filhos, para outros usuarios . Se um usuario tiver a permissao
   snapshot e a permissao allow, esse usuario podera conceder a permissao
   snapshot para outros usuarios.

19.6. Topicos Avanc,ados

  19.6.1. Otimizac,oes

   Existem varios parametros que podem ser ajustados para tornar o ZFS melhor
   para diferentes cargas de trabalho.

     * vfs.zfs.arc_max - Tamanho maximo do ARC. O padrao e toda a memoria RAM
       menos 1 GB, ou metade da RAM, o que for maior. No entanto, um valor
       menor deve ser usado se o sistema estiver executando quaisquer outros
       daemons ou processos que possam requerer memoria. Este valor pode ser
       ajustado em tempo de execuc,ao com sysctl(8) e pode ser configurado no
       /boot/loader.conf ou /etc/sysctl.conf.

     * vfs.zfs.arc_meta_limit - Limita a parte do ARC que pode ser usado para
       armazenar metadados. O padrao e um quarto de vfs.zfs.arc_max. Aumentar
       esse valor melhorara o desempenho se a carga de trabalho envolver
       operac,oes em um grande numero de arquivos e diretorios ou operac,oes
       de metadados frequentes, ao custo de caber menos dados de arquivo no
       ARC. Este valor pode ser ajustado em tempo de execuc,ao com sysctl(8)
       e pode ser configurado em /boot/loader.conf ou /etc/sysctl.conf.

     * vfs.zfs.arc_min - Tamanho minimo do ARC. O padrao e metade de
       vfs.zfs.arc_meta_limit. Ajuste esse valor para evitar que outros
       aplicativos pressionem o ARC inteiro. Este valor pode ser ajustado em
       tempo de execuc,ao com sysctl(8) e pode ser configurado em
       /boot/loader.conf ou /etc/sysctl.conf.

     * vfs.zfs.vdev.cache.size - Uma quantidade pre-alocada de memoria
       reservada como um cache para cada dispositivo no pool. A quantidade
       total de memoria usada sera esse valor multiplicado pelo numero de
       dispositivos. Este valor so pode ser ajustado no momento da
       inicializac,ao e e definido em /boot/loader.conf.

     * vfs.zfs.min_auto_ashift - Minimo ashift (tamanho do setor) que sera
       usado automaticamente no momento da criac,ao do pool. O valor e uma
       potencia de dois. O valor padrao de 9 representa 2^9 = 512, um tamanho
       de setor de 512 bytes. Para evitar amplificac,ao de escrita e para
       obter o melhor desempenho, defina esse valor para o maior tamanho de
       setor usado por um dispositivo no pool.

       Muitas unidades possuem setores de 4 KB. Usar o ashift padrao 9 com
       esses drives resulta em amplificac,ao de gravac,ao nesses
       dispositivos. Os dados que podem estar contidos em uma unica gravac,ao
       de 4 KB devem, em vez disso, ser gravados em oito gravac,oes de 512
       bytes. O ZFS tenta ler o tamanho do setor nativo de todos os
       dispositivos ao criar um pool, mas muitas unidades com setores de 4 KB
       relatam que seus setores tem 512 bytes para compatibilidade. Configure
       o vfs.zfs.min_auto_ashift para 12 (2^12=4096) antes de criar um pool
       ira forc,ar o ZFS a usar blocos de 4 KB para melhor desempenho nessas
       unidades.

       Forc,ar blocos de 4 KB tambem e util em pools em que as atualizac,oes
       de disco sao planejadas. Os discos futuros provavelmente usarao
       setores de 4 KB, e os valores de ashift nao poderao ser alterados
       depois que um pool for criado.

       Em alguns casos especificos, o menor tamanho de bloco de 512 bytes
       pode ser preferivel. Quando usado com discos de 512 bytes para bancos
       de dados, ou como armazenamento para maquinas virtuais, menos dados
       sao transferidos durante pequenas leituras aleatorias. Isso pode
       fornecer melhor desempenho, especialmente ao usar um tamanho de
       registro ZFS menor.

     * vfs.zfs.prefetch_disable - Desabilita a pre-busca. Um valor de 0 esta
       ativado e 1 esta desativado. O padrao e 0, a menos que o sistema tenha
       menos de 4 GB de RAM. A pre-busca funciona lendo blocos maiores do que
       os que foram solicitados no ARC na esperanc,a de que os dados sejam
       necessarios em breve. Se a carga de trabalho tiver um grande numero de
       leituras aleatorias, a desativac,ao da pre-busca podera melhorar o
       desempenho reduzindo leituras desnecessarias. Este valor pode ser
       ajustado a qualquer momento com sysctl(8).

     * vfs.zfs.vdev.trim_on_init - Controla se os novos dispositivos
       adicionados ao pool tem o comando TRIM executado neles. Isso garante o
       melhor desempenho e a longevidade dos SSDs, mas leva um tempo extra.
       Se o dispositivo ja tiver sido apagado de forma segura, a desativac,ao
       dessa configurac,ao tornara o acrescimo do novo dispositivo mais
       rapido. Este valor pode ser ajustado a qualquer momento com sysctl(8).

     * vfs.zfs.vdev.max_pending - Limita o numero de solicitac,oes de I/O
       pendentes por dispositivo. Um valor mais alto mantera a fila de
       comandos do dispositivo cheia e podera resultar em maior rendimento.
       Um valor menor reduzira a latencia. Este valor pode ser ajustado a
       qualquer momento com o sysctl(8).

     * vfs.zfs.top_maxinflight - Numero maximo de I/Os pendentes por vdev de
       nivel superior. Limita a profundidade da fila de comandos para evitar
       alta latencia. O limite e por vdev de nivel superior, o que significa
       que o limite se aplica a cada Mirror, RAID-Z, ou outro vdev
       independentemente. Este valor pode ser ajustado a qualquer momento com
       sysctl(8).

     * vfs.zfs.l2arc_write_max - Limita a quantidade de dados gravados no
       L2ARC por segundo. Este ajuste foi projetado para estender a
       longevidade de SSDs limitando a quantidade de dados gravados no
       dispositivo. Este valor pode ser ajustado a qualquer momento com
       sysctl(8).

     * vfs.zfs.l2arc_write_boost - O valor deste ajuste e adicionado ao
       vfs.zfs.l2arc_write_max e aumenta a velocidade de gravac,ao para o SSD
       ate que o primeiro bloco seja removido do L2ARC. Esta "Turbo Warmup
       Phase" e projetada para reduzir a perda de desempenho de um L2ARC
       vazio apos uma reinicializac,ao. Este valor pode ser ajustado a
       qualquer momento com sysctl(8).

     * vfs.zfs.scrub_delay - Numero de ticks a serem atrasados entre cada
       operac,ao de I/O durante um scrub. Para garantir que um scrub nao
       interfira com a operac,ao normal do pool, se qualquer outra I/O
       estiver acontecendo, o scrub sera atrasado entre cada comando. Esse
       valor controla o limite no total de IOPS (I/Os por segundo) gerados
       pelo scrub. A granularidade da configurac,ao e determinada pelo valor
       de kern.hz, cujo padrao e de 1.000 ticks por segundo. Essa
       configurac,ao pode ser alterada, resultando em um limite efetivo de
       IOPS diferente. O valor padrao e 4, resultando em um limite de: 1000
       ticks/seg/4 = 250 IOPS. Usar um valor de 20 daria um limite de: 1000
       ticks/seg/20 = 50 IOPS. A velocidade de scrub e limitada apenas quando
       houver atividade recente no pool, conforme determinado por
       vfs.zfs.scan_idle. Esse valor pode ser ajustado a qualquer momento com
       sysctl(8).

     * vfs.zfs.resilver_delay - Numero de milissegundos de atraso inserido
       entre cada I/O durante um resilver . Para garantir que um resilver nao
       interfira com a operac,ao normal do pool, se qualquer outro I/O
       estiver acontecendo, o resilver ira atrasar entre cada comando. Esse
       valor controla o limite de total de IOPS (I/Os por segundo) gerados
       pelo resilver. A granularidade da configurac,ao e determinada pelo
       valor de kern.hz, cujo padrao e de 1.000 marcac,oes por segundo. Essa
       configurac,ao pode ser alterada, resultando em um limite efetivo de
       IOPS diferente. O valor padrao e 2, resultando em um limite de: 1000
       ticks / seg / 2 = 500 IOPS. Retornar o pool a um estado Online pode
       ser mais importante se a falha outro dispositivo levar o pool ao
       estado de Fault, causando perda de dados. Um valor de 0 dara `a
       operac,ao de resilver a mesma prioridade que outras operac,oes,
       acelerando o processo de recuperac,ao. A velocidade do resilver e
       limitada apenas quando houver outra atividade recente no pool,
       conforme determinado por vfs.zfs.scan_idle. Este valor pode ser
       ajustado a qualquer momento com sysctl(8).

     * vfs.zfs.scan_idle - Numero de milissegundos desde a ultima operac,ao
       antes do pool ser considerado ocioso. Quando o pool estiver ocioso, a
       taxa limite para scrub e resilver fica desativada. Este valor pode ser
       ajustado a qualquer momento com sysctl(8).

     * vfs.zfs.txg.timeout - Numero maximo de segundos entre os grupos de
       transac,oes. O grupo de transac,oes atual sera gravado no pool e um
       novo grupo de transac,oes sera iniciado se esse periodo de tempo tiver
       decorrido desde o grupo de transac,oes anterior. Um grupo de
       transac,oes pode ser acionado antes se dados suficientes forem
       gravados. O valor padrao e de 5 segundos. Um valor maior pode melhorar
       o desempenho de leitura atrasando gravac,oes assincronas, mas isso
       pode causar um desempenho irregular quando o grupo de transac,oes e
       gravado. Este valor pode ser ajustado a qualquer momento com
       sysctl(8).

  19.6.2. ZFS em i386

   Alguns dos recursos fornecidos pelo ZFS consomem muita memoria, e podem
   exigir ajuste para maxima eficiencia em sistemas com RAM limitada.

    19.6.2.1. Memoria

   Como minimo, a memoria total do sistema deve ter pelo menos um gigabyte. A
   quantidade de RAM recomendada depende do tamanho do pool e dos recursos do
   ZFS usados. Uma regra geral e 1 GB de RAM para cada 1 TB de armazenamento.
   Se o recurso de deduplicac,ao for usado, uma regra geral e 5 GB de RAM por
   TB de armazenamento para ser desduplicado. Enquanto alguns usuarios usam
   com sucesso o ZFS com menos RAM, os sistemas sob carga pesada podem entrar
   em panic devido ao esgotamento da memoria. Outros ajustes podem ser
   necessarios para sistemas com uma quantia de memoria RAM inferior ao
   recomendado.

    19.6.2.2. Configurac,ao do Kernel

   Devido `as limitac,oes de espac,o de enderec,o da plataforma i386(TM), os
   usuarios do ZFS na arquitetura i386(TM) devem adicionar essa opc,ao a um
   arquivo de configurac,ao de kernel personalizado, reconstruir o kernel e
   reiniciar:

 options        KVA_PAGES=512

   Isso expande o espac,o de enderec,o do kernel, permitindo que o parametro
   vm.kvm_size seja ajustado alem do limite imposto atualmente de 1 GB ou o
   limite de 2 GB para PAE. Para encontrar o valor mais adequado para essa
   opc,ao, divida o espac,o de enderec,o desejado em megabytes por quatro.
   Neste exemplo, e 512 para 2 GB.

    19.6.2.3. Ajustes do Carregador

   O espac,o de enderec,amento kmem pode ser aumentado em todas as
   arquiteturas do FreeBSD. Em um sistema de teste com 1 GB de memoria
   fisica, o sucesso foi alcanc,ado com essas opc,oes abaixo adicionadas ao
   /boot/loader.conf, e o sistema reiniciado:

 vm.kmem_size="330M"
 vm.kmem_size_max="330M"
 vfs.zfs.arc_max="40M"
 vfs.zfs.vdev.cache.size="5M"

   Para obter uma lista mais detalhada de recomendac,oes para otimizac,oes
   relacionadas ao ZFS, consulte https://wiki.freebsd.org/ZFSTuningGuide.

19.7. Recursos adicionais

     * OpenZFS

     * FreeBSD Wiki - ZFS Tuning

     * Oracle Solaris ZFS Administration Guide

     * Calomel Blog - ZFS Raidz Performance, Capacity and Integrity

19.8. Recursos e terminologia do ZFS

   O ZFS e um sistema de arquivos fundamentalmente diferente, porque e mais
   do que apenas um sistema de arquivos. O ZFS combina as func,oes do sistema
   de arquivos e do gerenciador de volume, permitindo que dispositivos de
   armazenamento adicionais sejam adicionados a um sistema ativo e torne o
   novo espac,o disponivel em todos os sistemas de arquivos existentes nesse
   pool imediatamente. Combinando os papeis tradicionalmente separados, o ZFS
   e capaz de superar limitac,oes anteriores que impediam o crescimento de
   grupos RAID. Cada dispositivo de nivel superior em um pool e chamado de
   vdev, que pode ser um disco simples ou uma transformac,ao RAID como um
   espelho ou array RAID-Z. Os sistemas de arquivos ZFS (chamados datasets)
   tem acesso ao espac,o livre combinado de todo o pool. A medida que os
   blocos sao alocados do pool, o espac,o disponivel para cada sistema de
   arquivos diminui. Essa abordagem evita a armadilha comum com o
   particionamento extensivo onde o espac,o livre se torna fragmentado nas
   partic,oes.

   +------------------------------------------------------------------------+
   | pool                  | Um pool de armazenamento e o bloco de          |
   |                       | construc,ao mais basico do ZFS. Um pool e      |
   |                       | composto de um ou mais vdevs, os dispositivos  |
   |                       | subjacentes que armazenam os dados. Um pool e  |
   |                       | entao usado para criar um ou mais sistemas de  |
   |                       | arquivos (datasets) ou dispositivos de bloco   |
   |                       | (volumes). Esses conjuntos de dados e volumes  |
   |                       | compartilham o espac,o livre restante do pool. |
   |                       | Cada pool e identificado exclusivamente por um |
   |                       | nome e um GUID. Os recursos disponiveis sao    |
   |                       | determinados pelo numero da versao do ZFS no   |
   |                       | pool.                                          |
   |-----------------------+------------------------------------------------|
   | vdev Types            | Um pool e composto de um ou mais vdevs, que    |
   |                       | podem ser um unico disco ou um grupo de        |
   |                       | discos, no caso de uma transformac,ao RAID.    |
   |                       | Quando varios vdevs sao usados, o ZFS propaga  |
   |                       | dados entre os vdevs para aumentar o           |
   |                       | desempenho e maximizar o espac,o utilizavel.   |
   |                       |   * Disk - O tipo mais basico de vdev e um     |
   |                       |     dispositivo de bloco padrao. Isso pode ser |
   |                       |     um disco inteiro (como /dev/ada0 ou        |
   |                       |     /dev/da0) ou uma partic,ao (/dev/ada0p3).  |
   |                       |     No FreeBSD, nao ha penalidade de           |
   |                       |     desempenho por usar uma partic,ao em vez   |
   |                       |     de todo o disco. Isso difere das           |
   |                       |     recomendac,oes feitas pela documentac,ao   |
   |                       |     do Solaris.                                |
   |                       |                                                |
   |                       |  Cuidado:                                      |
   |                       |                                                |
   |                       |     Usar um disco inteiro como parte de um     |
   |                       |     pool inicializavel e altamente             |
   |                       |     desencorajado, pois isso pode tornar o     |
   |                       |     pool nao inicializavel. Da mesma forma,    |
   |                       |     voce nao deve usar um disco inteiro como   |
   |                       |     parte de um mirror ou um RAID-Z vdev. Isso |
   |                       |     ocorre porque e impossivel determinar com  |
   |                       |     seguranc,a o tamanho de um disco nao       |
   |                       |     particionado no momento da inicializac,ao  |
   |                       |     e porque nao ha lugar para inserir codigo  |
   |                       |     de inicializac,ao.                         |
   |                       |                                                |
   |                       |   * File - Alem dos discos, os pools do ZFS    |
   |                       |     podem ser suportados por arquivos          |
   |                       |     regulares, o que e especialmente util para |
   |                       |     testes e experimentac,ao. Use o caminho    |
   |                       |     completo para o arquivo como o caminho do  |
   |                       |     dispositivo no zpool create. Todos os      |
   |                       |     vdevs devem ter pelo menos 128 MB de       |
   |                       |     tamanho.                                   |
   |                       |                                                |
   |                       |   * Mirror - Ao criar um espelho, especifique  |
   |                       |     a palavra-chave mirror seguida pela lista  |
   |                       |     de dispositivos membros para o espelho. Um |
   |                       |     espelho consiste em dois ou mais           |
   |                       |     dispositivos, todos os dados serao         |
   |                       |     gravados em todos os dispositivos membros. |
   |                       |     Um espelho vdev so armazenara tantos dados |
   |                       |     quanto seu menor membro. Um espelho vdev   |
   |                       |     pode suportar a falha de todos, exceto um  |
   |                       |     de seus membros, sem perder nenhum dado.   |
   |                       |                                                |
   |                       |  Nota:                                         |
   |                       |                                                |
   |                       |     Um vdev de disco unico regular pode ser    |
   |                       |     atualizado para um vdev de espelho a       |
   |                       |     qualquer momento com zpool attach.         |
   |                       |                                                |
   |                       |   * RAID-Z - O ZFS implementa o RAID-Z, uma    |
   |                       |     variac,ao do padrao RAID-5 que oferece uma |
   |                       |     melhor distribuic,ao de paridade e elimina |
   |                       |     o furo de escrita do "RAID-5" no qual os   |
   |                       |     dados e informac,oes de paridade tornam-se |
   |                       |     inconsistentes apos um reinicio            |
   |                       |     inesperado. O ZFS suporta tres niveis de   |
   |                       |     RAID-Z, que fornecem varios niveis de      |
   |                       |     redundancia em troca de niveis             |
   |                       |     decrescentes de armazenamento utilizavel.  |
   |                       |     Os tipos sao nomeados de RAID-Z1 ate       |
   |                       |     RAID-Z3 com base no numero de dispositivos |
   |                       |     de paridade na matriz e no numero de       |
   |                       |     discos que podem falhar enquanto o pool    |
   |                       |     permanece operacional.                     |
   |                       |                                                |
   |                       |     Em uma configurac,ao de RAID-Z1 com quatro |
   |                       |     discos, cada um com 1 TB, resultara em um  |
   |                       |     volume com armazenamento utilizavel de 3   |
   |                       |     TB e o pool ainda podera operar em modo    |
   |                       |     degradado com um disco com falha. Se um    |
   |                       |     disco adicional ficar off-line antes que o |
   |                       |     disco com falha seja substituido e que o   |
   |                       |     resilver tenha sido executado, todos os    |
   |                       |     dados no pool poderao ser perdidos.        |
   |                       |                                                |
   |                       |     Em uma configurac,ao de RAID-Z3 com oito   |
   |                       |     discos de 1 TB, o volume fornecera 5 TB de |
   |                       |     espac,o utilizavel e ainda podera operar   |
   |                       |     com tres discos com falha. A Sun(TM)       |
   |                       |     recomenda no maximo nove discos em um      |
   |                       |     unico vdev. Se a configurac,ao tiver mais  |
   |                       |     discos, e recomendavel dividi-los em vdevs |
   |                       |     separados e os dados do conjunto serao     |
   |                       |     divididos entre eles.                      |
   |                       |                                                |
   |                       |     Uma configurac,ao de dois vdevs RAID-Z2    |
   |                       |     consistindo de 8 discos cada criaria algo  |
   |                       |     similar a um array RAID-60. A capacidade   |
   |                       |     de armazenamento do grupo RAID-Z e         |
   |                       |     aproximadamente o tamanho do menor disco   |
   |                       |     multiplicado pelo numero de discos sem     |
   |                       |     paridade. Quatro discos de 1 TB em RAID-Z1 |
   |                       |     tem um tamanho efetivo de aproximadamente  |
   |                       |     3 TB, e uma matriz de oito discos de 1 TB  |
   |                       |     em RAID-Z3 produzira 5 TB de espac,o       |
   |                       |     utilizavel .                               |
   |                       |                                                |
   |                       |   * Spare - O ZFS tem um tipo especial de      |
   |                       |     pseudo-vdev para controlar os discos hot   |
   |                       |     spares disponiveis. Observe que as pec,as  |
   |                       |     de reposic,ao instaladas nao sao           |
   |                       |     implantadas automaticamente; eles devem    |
   |                       |     ser configurados manualmente para          |
   |                       |     substituir o dispositivo com falha usando  |
   |                       |     o comando zfs replace.                     |
   |                       |                                                |
   |                       |   * Log - ZFS Dispositivos de log, tambem      |
   |                       |     conhecidos como ZFS Intent Log (ZIL) move  |
   |                       |     o log de intenc,ao dos dispositivos comuns |
   |                       |     do pool para um dispositivo dedicado,      |
   |                       |     normalmente um SSD. Ter um dispositivo de  |
   |                       |     log dedicado pode melhorar                 |
   |                       |     significativamente o desempenho de         |
   |                       |     aplicativos com um alto volume de          |
   |                       |     gravac,oes sincronas, especialmente bancos |
   |                       |     de dados. Os dispositivos de log podem ser |
   |                       |     espelhados, mas o RAID-Z nao e suportado.  |
   |                       |     Se varios dispositivos de log forem        |
   |                       |     usados, as gravac,oes serao balanceadas    |
   |                       |     entre eles.                                |
   |                       |                                                |
   |                       |   * Cache - Adicionar um cache vdev a um pool  |
   |                       |     adicionara o armazenamento do cache ao     |
   |                       |     L2ARC. Dispositivos de cache nao podem ser |
   |                       |     espelhados. Como um dispositivo de cache   |
   |                       |     armazena apenas copias adicionais de dados |
   |                       |     existentes, nao ha risco de perda de       |
   |                       |     dados.                                     |
   |-----------------------+------------------------------------------------|
   | Transaction Group     | Grupos de transac,oes sao a forma como os      |
   | (TXG)                 | blocos alterados sao agrupados e eventualmente |
   |                       | gravados no pool. Grupos de transac,ao sao a   |
   |                       | unidade atomica que o ZFS usa para garantir a  |
   |                       | consistencia. Cada grupo de transac,oes recebe |
   |                       | um identificador consecutivo exclusivo de 64   |
   |                       | bits. Pode haver ate tres grupos de            |
   |                       | transac,oes ativos por vez, um em cada um      |
   |                       | desses tres estados:                           |
   |                       |   * Open - Quando um novo grupo de transac,oes |
   |                       |     e criado, ele esta no estado aberto e      |
   |                       |     aceita novas gravac,oes. Ha sempre um      |
   |                       |     grupo de transac,oes no estado aberto, no  |
   |                       |     entanto, o grupo de transac,oes pode       |
   |                       |     recusar novas gravac,oes se tiver atingido |
   |                       |     um limite. Quando o grupo de transac,oes   |
   |                       |     abertas tiver atingido um limite ou o      |
   |                       |     vfs.zfs.txg.timeout tiver sido alcanc,ado, |
   |                       |     o grupo de transac,oes avanc,a para o      |
   |                       |     proximo estado.                            |
   |                       |                                                |
   |                       |   * Quiescing - Um estado curto que permite    |
   |                       |     que qualquer operac,ao pendente termine    |
   |                       |     sem bloquear a criac,ao de um novo grupo   |
   |                       |     de transac,oes abertas. Depois que todas   |
   |                       |     as transac,oes no grupo forem concluidas,  |
   |                       |     o grupo de transac,oes avanc,ara para o    |
   |                       |     estado final.                              |
   |                       |                                                |
   |                       |   * Syncing - Todos os dados no grupo de       |
   |                       |     transac,oes sao gravados no armazenamento  |
   |                       |     estavel. Esse processo, por sua vez,       |
   |                       |     modificara outros dados, como metadados e  |
   |                       |     mapas de espac,o, que tambem precisarao    |
   |                       |     ser gravados no armazenamento estavel. O   |
   |                       |     processo de sincronizac,ao envolve varios  |
   |                       |     passos. O primeiro e o maior, e trata de   |
   |                       |     todos os blocos de dados alterados,        |
   |                       |     seguido pelos metadados, que podem levar   |
   |                       |     varios passos para serem concluidos. Como  |
   |                       |     a alocac,ao de espac,o para os blocos de   |
   |                       |     dados gera novos metadados, o estado de    |
   |                       |     sincronizac,ao nao pode ser concluido ate  |
   |                       |     que um passo seja concluido e nao aloque   |
   |                       |     espac,o adicional. O estado de             |
   |                       |     sincronizac,ao tambem e onde as synctasks  |
   |                       |     sao concluidas. As operac,oes de           |
   |                       |     sincronizac,ao sao operac,oes              |
   |                       |     administrativas, como criar ou destruir    |
   |                       |     snapshots e datasets, que modificam o      |
   |                       |     uberblock. Quando o estado de              |
   |                       |     sincronizac,ao estiver concluido, o grupo  |
   |                       |     de transac,oes no estado de quiesce e      |
   |                       |     avanc,ado para o estado de sincronizac,ao. |
   |                       |                                                |
   |                       | Todas as func,oes administrativas, tal como    |
   |                       | snapshot sao gravados como parte do grupo de   |
   |                       | transac,oes. Quando uma tarefa de              |
   |                       | sincronizac,ao e criada, ela e adicionada ao   |
   |                       | grupo de transac,oes atualmente aberto e esse  |
   |                       | grupo e avanc,ado o mais rapido possivel para  |
   |                       | o estado de sincronizac,ao para reduzir a      |
   |                       | latencia de comandos administrativos.          |
   |-----------------------+------------------------------------------------|
   | Adaptive Replacement  | O ZFS usa um Cache Adaptativo de Substituic,ao |
   | Cache (ARC)           | (ARC), em vez de um mais tradicional como o    |
   |                       | Least Recently Used (LRU). Um cache LRU e uma  |
   |                       | lista simples de itens no cache, classificados |
   |                       | por quando cada objeto foi usado mais          |
   |                       | recentemente. Novos itens sao adicionados ao   |
   |                       | topo da lista. Quando o cache esta cheio, os   |
   |                       | itens da parte inferior da lista sao           |
   |                       | despejados para liberar espac,o para mais      |
   |                       | objetos ativos. Um ARC consiste em quatro      |
   |                       | listas; os objetos Mais Recentes Utilizados    |
   |                       | (MRU) e Mais Frequentemente Usados (MFU), alem |
   |                       | de uma lista fantasma para cada um. Essas      |
   |                       | listas fantasmas rastreiam objetos             |
   |                       | recentemente despejados para evitar que sejam  |
   |                       | adicionados de volta ao cache. Isso aumenta a  |
   |                       | taxa de acertos do cache evitando objetos que  |
   |                       | tem um historico de serem usados apenas        |
   |                       | ocasionalmente. Outra vantagem de usar um MRU  |
   |                       | e um MFU e que a verificac,ao de um sistema de |
   |                       | arquivos inteiro normalmente despejaria todos  |
   |                       | os dados de um MRU ou LRU do cache em favor    |
   |                       | deste conteudo recem-acessado. Com o ZFS, ha   |
   |                       | tambem um MFU que rastreia apenas os objetos   |
   |                       | usados com mais frequ:encia, e o cache dos     |
   |                       | blocos acessados com mais frequencia           |
   |                       | permanece.                                     |
   |-----------------------+------------------------------------------------|
   | L2ARC                 | O L2ARC e o segundo nivel do sistema de        |
   |                       | armazenamento em cache do ZFS. O ARC principal |
   |                       | e armazenado em RAM. Como a quantidade de RAM  |
   |                       | disponivel e limitada, o ZFS tambem pode usar  |
   |                       | cache vdevs. Discos de estado solido (SSDs)    |
   |                       | geralmente sao usados como esses dispositivos  |
   |                       | de cache devido `a sua maior velocidade e      |
   |                       | menor latencia em comparac,ao aos discos       |
   |                       | mecanicos tradicionais. O L2ARC e totalmente   |
   |                       | opcional, mas um deles aumentara               |
   |                       | significativamente a velocidade de leitura dos |
   |                       | arquivos armazenados em cache no SSD em vez de |
   |                       | precisar ser lido nos discos normais. O L2ARC  |
   |                       | tambem pode acelerar a desduplicac,ao porque   |
   |                       | um DDT que nao cabe na RAM mas cabe no L2ARC   |
   |                       | sera muito mais rapido que um DDT que deve ser |
   |                       | lido do disco. A taxa na qual os dados sao     |
   |                       | adicionados aos dispositivos de cache e        |
   |                       | limitada para evitar o desgaste prematuro dos  |
   |                       | SSDs com muitas gravac,oes. Ate que o cache    |
   |                       | esteja cheio (o primeiro bloco foi removido    |
   |                       | para liberar espac,o), a gravac,ao no L2ARC e  |
   |                       | limitada `a soma do limite de gravac,ao e do   |
   |                       | limite de aumento e depois limitada ao limite  |
   |                       | de gravac,ao. Um par de valores sysctl(8)      |
   |                       | controla esses limites de taxa. A              |
   |                       | vfs.zfs.l2arc_write_max controla quantos bytes |
   |                       | sao gravados no cache por segundo, enquanto    |
   |                       | vfs.zfs.l2arc_write_boost adiciona a este      |
   |                       | limite durante a "Turbo Warmup Phase "         |
   |                       | (aumento de gravac,ao).                        |
   |-----------------------+------------------------------------------------|
   | ZIL                   | O ZIL acelera as transac,oes sincronas usando  |
   |                       | dispositivos de armazenamento como SSDs mais   |
   |                       | rapidos do que os usados no pool de            |
   |                       | armazenamento principal. Quando um aplicativo  |
   |                       | solicita uma gravac,ao sincrona (uma garantia  |
   |                       | de que os dados foram armazenados com          |
   |                       | seguranc,a no disco, em vez de simplesmente    |
   |                       | serem gravados posteriormente), os dados sao   |
   |                       | gravados no armazenamento mais rapido de ZIL   |
   |                       | e, depois, liberados aos discos regulares.     |
   |                       | Isso reduz enormemente a latencia e melhora o  |
   |                       | desempenho. Apenas cargas de trabalho          |
   |                       | sincronas, como bancos de dados, serao         |
   |                       | beneficiadas com um ZIL. Gravac,oes            |
   |                       | assincronas regulares, como copiar arquivos,   |
   |                       | nao usarao o ZIL.                              |
   |-----------------------+------------------------------------------------|
   | Copy-On-Write         | Ao contrario de um sistema de arquivos         |
   |                       | tradicional, quando os dados sao sobrescritos  |
   |                       | no ZFS, os novos dados sao gravados em um      |
   |                       | bloco diferente, em vez de sobrescrever os     |
   |                       | dados antigos no lugar. Somente quando essa    |
   |                       | gravac,ao for concluida, os metadados serao    |
   |                       | atualizados para apontar para o novo local. No |
   |                       | caso de uma gravac,ao simplificada (uma falha  |
   |                       | do sistema ou perda de energia no meio da      |
   |                       | gravac,ao de um arquivo), todo o conteudo      |
   |                       | original do arquivo ainda estara disponivel e  |
   |                       | a gravac,ao incompleta sera descartada. Isso   |
   |                       | tambem significa que o ZFS nao requer um       |
   |                       | fsck(8) apos um desligamento inesperado.       |
   |-----------------------+------------------------------------------------|
   | Dataset               | Dataset e o termo generico para um sistema de  |
   |                       | arquivos ZFS, volume, snapshot ou clone. Cada  |
   |                       | dataset tem um nome exclusivo no formato       |
   |                       | poolname/path@snapshot. A raiz do pool e       |
   |                       | tecnicamente um dataset tambem. Dataset filhos |
   |                       | sao nomeados hierarquicamente como diretorios. |
   |                       | Por exemplo, mypool/home, o dataset inicial, e |
   |                       | um filho de mypool e herda propriedades dele.  |
   |                       | Isso pode ser expandido ainda mais criando o   |
   |                       | mypool/home/user. Este dataset neto herdara    |
   |                       | propriedades do pai e do avo. As propriedades  |
   |                       | de um filho podem ser definidas para           |
   |                       | substituir os padroes herdados dos pais e      |
   |                       | avos. A administrac,ao de datasets e seus      |
   |                       | filhos pode ser delegada.                      |
   |-----------------------+------------------------------------------------|
   | File system           | Um dataset ZFS e mais frequentemente usado     |
   |                       | como um sistema de arquivos. Como a maioria    |
   |                       | dos outros sistemas de arquivos, um sistema de |
   |                       | arquivos ZFS e montado em algum lugar na       |
   |                       | hierarquia de diretorios do sistema e contem   |
   |                       | arquivos e diretorios proprios com permissoes, |
   |                       | sinalizadores e outros metadados.              |
   |-----------------------+------------------------------------------------|
   | Volume                | Alem dos datasets regulares do sistema de      |
   |                       | arquivos, o ZFS tambem pode criar volumes, que |
   |                       | sao dispositivos de bloco. Os volumes tem      |
   |                       | muitos dos mesmos recursos, incluindo          |
   |                       | copy-on-write, snapshots, clones e checksum.   |
   |                       | Os volumes podem ser uteis para executar       |
   |                       | outros formatos de sistema de arquivos sobre o |
   |                       | ZFS, tal como a virtualizac,ao do UFS ou a     |
   |                       | exportac,ao de extensoes iSCSI.                |
   |-----------------------+------------------------------------------------|
   | Snapshot              | O design copy-on-write (COW) do ZFS permite    |
   |                       | snapshots quase instantaneos e consistentes    |
   |                       | com nomes arbitrarios. Depois de obter um      |
   |                       | snapshot de um dataset ou um snapshot          |
   |                       | recursivo de um dataset pai que incluira todos |
   |                       | os datasets filho, novos dados serao gravados  |
   |                       | em novos blocos, mas os blocos antigos nao     |
   |                       | serao recuperados como espac,o livre. O        |
   |                       | snapshot contem a versao original do sistema   |
   |                       | de arquivos e o sistema de arquivos em tempo   |
   |                       | real contem as alterac,oes feitas desde que o  |
   |                       | snapshot foi feito. Nenhum espac,o adicional e |
   |                       | usado. Conforme novos dados sao gravados no    |
   |                       | sistema de arquivos ao vivo, novos blocos sao  |
   |                       | alocados para armazenar esses dados. O tamanho |
   |                       | aparente do snapshot aumentara `a medida que   |
   |                       | os blocos nao forem mais usados no sistema de  |
   |                       | arquivos ativo, mas apenas no snapshot. Estes  |
   |                       | snapshots podem ser montados somente como      |
   |                       | leitura para permitir a recuperac,ao de        |
   |                       | versoes anteriores de arquivos. Tambem e       |
   |                       | possivel reverter um sistema de arquivos ativo |
   |                       | para um snapshot especifico, desfazendo        |
   |                       | quaisquer alterac,oes que ocorreram depois que |
   |                       | o snapshot foi tirado. Cada bloco no pool tem  |
   |                       | um contador de referencia que registra quantos |
   |                       | snapshots, clones, datasets ou volumes fazem   |
   |                       | uso desse bloco. A medida que arquivos e       |
   |                       | snapshots sao excluidos, a contagem de         |
   |                       | referencia e diminuida. Quando um bloco nao e  |
   |                       | mais referenciado, ele e recuperado como       |
   |                       | espac,o livre. Os snapshots tambem podem ser   |
   |                       | marcados com um hold. Quando um snapshot e     |
   |                       | mantido, qualquer tentativa de destrui-lo      |
   |                       | retornara um erro EBUSY. Cada snapshot pode    |
   |                       | ter varias retenc,oes, cada uma com um nome    |
   |                       | exclusivo. O comando release remove a          |
   |                       | retenc,ao para que o snapshot possa ser        |
   |                       | excluido. Snapshots podem ser obtidos de       |
   |                       | volumes, mas eles so podem ser clonados ou     |
   |                       | revertidos, nao montados independentemente.    |
   |-----------------------+------------------------------------------------|
   | Clone                 | Os snapshots tambem podem ser clonados. Um     |
   |                       | clone e uma versao gravavel de um snapshot,    |
   |                       | permitindo que o sistema de arquivos seja      |
   |                       | bifurcado como um novo dataset. Como com um    |
   |                       | snapshot, um clone inicialmente nao consome    |
   |                       | espac,o adicional. Conforme novos dados sao    |
   |                       | gravados em um clone e novos blocos sao        |
   |                       | alocados, o tamanho aparente do clone aumenta. |
   |                       | Quando os blocos sao sobrescritos no sistema   |
   |                       | de arquivos ou no volume clonado, a contagem   |
   |                       | de referencia no bloco anterior e diminuida. O |
   |                       | snapshot no qual um clone e baseado nao pode   |
   |                       | ser excluido porque o clone depende dele. O    |
   |                       | snapshot e o pai e o clone e o filho. Os       |
   |                       | clones podem ser promovidos, invertendo essa   |
   |                       | dependencia e tornando o clone o pai e o pai   |
   |                       | anterior, o filho. Esta operac,ao nao requer   |
   |                       | espac,o adicional. Como a quantidade de        |
   |                       | espac,o usada pelo pai e pelo filho e          |
   |                       | revertida, as cotas e reservas existentes      |
   |                       | podem ser afetadas.                            |
   |-----------------------+------------------------------------------------|
   | Checksum              | Cada bloco alocado tambem e verificado. O      |
   |                       | algoritmo de checksum usado e uma propriedade  |
   |                       | por dataset, consulte set. O checksum de cada  |
   |                       | bloco e validado de forma transparente `a      |
   |                       | medida que e lido, permitindo que o ZFS        |
   |                       | detecte a corrupc,ao silenciosa. Se os dados   |
   |                       | lidos nao corresponderem `a checksum esperada, |
   |                       | o ZFS tentara recuperar os dados de qualquer   |
   |                       | redundancia disponivel, como espelhos ou       |
   |                       | RAID-Z). A validac,ao de todos os checksums    |
   |                       | pode ser acionada com o scrub. Os algoritmos   |
   |                       | de checksum incluem:                           |
   |                       |   * fletcher2                                  |
   |                       |                                                |
   |                       |   * fletcher4                                  |
   |                       |                                                |
   |                       |   * sha256                                     |
   |                       |                                                |
   |                       | Os algoritmos fletcher sao mais rapidos, mas o |
   |                       | sha256 e um hash criptografico forte e tem uma |
   |                       | chance muito menor de colisoes ao custo de     |
   |                       | algum desempenho. Checksums podem ser          |
   |                       | desativados, mas isso nao e recomendado.       |
   |-----------------------+------------------------------------------------|
   | Compressao            | Cada dataset tem uma propriedade de            |
   |                       | compactac,ao, cujo padrao e off. Essa          |
   |                       | propriedade pode ser definida como um dos      |
   |                       | varios algoritmos de compactac,ao. Isso fara   |
   |                       | com que todos os novos dados gravados no       |
   |                       | dataset sejam compactados. Alem de uma         |
   |                       | reduc,ao no espac,o usado, a taxa de leitura e |
   |                       | gravac,ao geralmente aumenta porque menos      |
   |                       | blocos sao lidos ou gravados.                  |
   |                       |   * LZ4 - Adicionado na versao 5000 do pool do |
   |                       |     ZFS (feature flags), o LZ4 e agora o       |
   |                       |     algoritmo de compressao recomendado. O LZ4 |
   |                       |     compacta aproximadamente 50% mais rapido   |
   |                       |     do que o LZJB ao operar em dados           |
   |                       |     compactaveis e e tres vezes mais rapido ao |
   |                       |     operar em dados nao compactaveis. O LZ4    |
   |                       |     tambem descompacta aproximadamente 80%     |
   |                       |     mais rapido que o LZJB. Nas CPUs modernas, |
   |                       |     o LZ4 pode frequentemente comprimir a mais |
   |                       |     de 500 MB/s e descompactar a mais de 1,5   |
   |                       |     GB/s (por nucleo de CPU).                  |
   |                       |                                                |
   |                       |   * LZJB - O algoritmo de compressao padrao.   |
   |                       |     Criado por Jeff Bonwick (um dos criadores  |
   |                       |     originais do ZFS). O LZJB oferece boa      |
   |                       |     compactac,ao com menos sobrecarga de CPU   |
   |                       |     em comparac,ao com o GZIP. No futuro, o    |
   |                       |     algoritmo de compactac,ao padrao           |
   |                       |     provavelmente sera alterado para LZ4.      |
   |                       |                                                |
   |                       |   * GZIP - Um algoritmo popular de compressao  |
   |                       |     de fluxo disponivel no ZFS. Uma das        |
   |                       |     principais vantagens de usar o GZIP e seu  |
   |                       |     nivel configuravel de compactac,ao. Ao     |
   |                       |     definir a propriedade compress, o          |
   |                       |     administrador pode escolher o nivel de     |
   |                       |     compactac,ao, desde gzip1, o nivel mais    |
   |                       |     baixo de compactac,ao, ate gzip9, o maior  |
   |                       |     nivel de compressao. Isso da ao            |
   |                       |     administrador o controle sobre quanto      |
   |                       |     tempo CPU sera dedicado para economizar    |
   |                       |     espac,o em disco.                          |
   |                       |                                                |
   |                       |   * ZLE - A codificac,ao de comprimento zero e |
   |                       |     um algoritmo de compressao especial que    |
   |                       |     apenas comprime sequencias continuas de    |
   |                       |     zeros. Esse algoritmo de compactac,ao e    |
   |                       |     util apenas quando o dataset contem        |
   |                       |     grandes blocos de zeros.                   |
   |-----------------------+------------------------------------------------|
   | Copies                | Quando configurada para um valor maior que 1,  |
   |                       | a propriedade copies instrui o ZFS a manter    |
   |                       | varias copias de cada bloco no sistema de      |
   |                       | arquivos ou volume. Definir essa propriedade   |
   |                       | em datasets importantes fornece redundancia    |
   |                       | adicional a partir da qual recuperar um bloco  |
   |                       | que nao corresponde ao seu checksum. Em pools  |
   |                       | sem redundancia, o recurso de copias e a unica |
   |                       | forma de redundancia. O recurso de copias pode |
   |                       | se recuperar de um unico setor defeituoso ou   |
   |                       | de outras formas de corrupc,ao menor, mas nao  |
   |                       | protege o pool da perda de um disco inteiro.   |
   |-----------------------+------------------------------------------------|
   | Desduplicac,ao        | Os checksums permitem detectar blocos          |
   |                       | duplicados de dados `a medida que sao          |
   |                       | escritos. Com a deduplicac,ao, a contagem de   |
   |                       | referencia de um bloco existente e identico e  |
   |                       | aumentada, economizando espac,o de             |
   |                       | armazenamento. Para detectar blocos            |
   |                       | duplicados, uma tabela de deduplicac,ao (DDT)  |
   |                       | e mantida na memoria. A tabela contem uma      |
   |                       | lista de checksums exclusivas, a localizac,ao  |
   |                       | desses blocos e uma contagem de referencia.    |
   |                       | Quando novos dados sao gravados, o checksum e  |
   |                       | calculado e comparado `a lista. Se uma         |
   |                       | correspondencia for encontrada, o bloco        |
   |                       | existente sera usado. O algoritmo de checksum  |
   |                       | SHA256 e usado com deduplicac,ao para fornecer |
   |                       | um hash criptografico seguro. A desduplicac,ao |
   |                       | e configuravel. Se dedup for on, um checksum   |
   |                       | correspondente sera considerado como           |
   |                       | significando que os dados sao identicos. Se    |
   |                       | dedup for definido como verify, os dados nos   |
   |                       | dois blocos serao verificados byte por byte    |
   |                       | para garantir que sejam realmente identicos.   |
   |                       | Se os dados nao forem identicos, a colisao de  |
   |                       | hash sera anotada e os dois blocos serao       |
   |                       | armazenados separadamente. Como o DDT deve     |
   |                       | armazenar o hash de cada bloco unico, ele      |
   |                       | consome uma quantidade muito grande de         |
   |                       | memoria. Uma regra geral e 5-6 GB de RAM por 1 |
   |                       | TB de dados desduplicados). Em situac,oes em   |
   |                       | que nao e pratico ter RAM suficiente para      |
   |                       | manter todo o DDT na memoria, o desempenho     |
   |                       | sofrera muito, pois o DDT deve ser lido do     |
   |                       | disco antes que cada novo bloco seja gravado.  |
   |                       | A desduplicac,ao pode usar o L2ARC para        |
   |                       | armazenar o DDT, fornecendo um meio termo      |
   |                       | entre a memoria rapida do sistema e os discos  |
   |                       | mais lentos. Considere a possibilidade de usar |
   |                       | a compactac,ao, que geralmente oferece quase a |
   |                       | mesma economia de espac,o sem o requisito de   |
   |                       | memoria adicional.                             |
   |-----------------------+------------------------------------------------|
   | Scrub                 | Em vez de uma verificac,ao de consistencia     |
   |                       | como o fsck(8), o ZFS tem o scrub. O scrub le  |
   |                       | todos os blocos de dados armazenados no pool e |
   |                       | verifica seus checksums em relac,ao checksums  |
   |                       | bons conhecidos armazenados nos metadados. Uma |
   |                       | verificac,ao periodica de todos os dados       |
   |                       | armazenados no pool garante a recuperac,ao de  |
   |                       | quaisquer blocos corrompidos antes que eles    |
   |                       | sejam necessarios. Um scrub nao e necessario   |
   |                       | apos um desligamento inadequado do sistema,    |
   |                       | mas e recomendado pelo menos uma vez a cada    |
   |                       | tres meses. O checksum de cada bloco e         |
   |                       | verificado `a medida que os blocos sao lidos   |
   |                       | durante o uso normal, mas um scrub garante que |
   |                       | mesmo os blocos usados com pouca frequ:encia   |
   |                       | sejam verificados quanto a sua corrupc,ao      |
   |                       | silenciosa. A seguranc,a dos dados e           |
   |                       | aprimorada, especialmente em situac,oes de     |
   |                       | armazenamento de arquivos. A prioridade        |
   |                       | relativa do scrub pode ser ajustada por meio   |
   |                       | da variavel vfs.zfs.scrub_delay para evitar    |
   |                       | que o scrub degrade o desempenho de outras     |
   |                       | cargas de trabalho no pool.                    |
   |-----------------------+------------------------------------------------|
   | Dataset Quota         | O ZFS fornece datasets rapidos e precisos,     |
   |                       | contabilidade de espac,o de usuarios e grupos, |
   |                       | alem de cotas e reservas de espac,o. Isso da   |
   |                       | ao administrador um controle refinado sobre    |
   |                       | como o espac,o e alocado e permite que o       |
   |                       | espac,o seja reservado para sistemas de        |
   |                       | arquivos criticos.                             |
   |                       |                                                |
   |                       | ZFS supports different types of quotas: the    |
   |                       | dataset quota, the reference quota (refquota), |
   |                       | the user quota, and the group quota.           |
   |                       |                                                |
   |                       | As cotas limitam a quantidade de espac,o que   |
   |                       | um dataset e todos os seus descendentes,       |
   |                       | incluindo snapshots do dataset, datasets       |
   |                       | filhos e snapshots desses datasets, podem      |
   |                       | consumir.                                      |
   |                       |                                                |
   |                       |  Nota:                                         |
   |                       |                                                |
   |                       | Cotas nao podem ser definidas em volumes, pois |
   |                       | a propriedade volsize atua como uma cota       |
   |                       | implicita.                                     |
   |-----------------------+------------------------------------------------|
   | Reference Quota       | Uma cota de referencia limita a quantidade de  |
   |                       | espac,o que um dataset pode consumir impondo   |
   |                       | um limite rigido. No entanto, esse limite      |
   |                       | rigido inclui apenas o espac,o ao qual o       |
   |                       | dataset faz referencia e nao inclui o espac,o  |
   |                       | usado pelos descendentes, como sistemas de     |
   |                       | arquivos ou snapshots.                         |
   |-----------------------+------------------------------------------------|
   | User Quota            | Cotas de usuarios sao uteis para limitar a     |
   |                       | quantidade de espac,o que pode ser usada pelo  |
   |                       | usuario especificado.                          |
   |-----------------------+------------------------------------------------|
   | Group Quota           | A cota de grupo limita a quantidade de espac,o |
   |                       | que um grupo especificado pode consumir.       |
   |-----------------------+------------------------------------------------|
   | Dataset Reservation   | A propriedade reservation torna possivel       |
   |                       | garantir uma quantidade minima de espac,o para |
   |                       | um dataset especifico e seus descendentes. Se  |
   |                       | uma reserva de 10 GB estiver definida em       |
   |                       | storage/home/bob, e outro dataset tentar usar  |
   |                       | todo o espac,o livre, pelo menos 10 GB de      |
   |                       | espac,o serao reservados para este dataset. Se |
   |                       | um snapshot for criado de storage/home/bob, o  |
   |                       | espac,o usado por esse snapshot sera           |
   |                       | contabilizado contra a reserva. A propriedade  |
   |                       | refreservation funciona de maneira semelhante, |
   |                       | mas exclui os descendentes como os snapshots.  |
   |                       |                                                |
   |                       | Reservas de qualquer tipo sao uteis em muitas  |
   |                       | situac,oes, como planejar e testar a           |
   |                       | adequac,ao da alocac,ao de espac,o em disco em |
   |                       | um novo sistema ou garantindo espac,o          |
   |                       | suficiente nos sistemas de arquivos para logs  |
   |                       | de audio ou procedimentos e arquivos de        |
   |                       | recuperac,ao do sistema.                       |
   |-----------------------+------------------------------------------------|
   | Reference Reservation | A propriedade refreservation torna possivel    |
   |                       | garantir uma quantidade minima de espac,o para |
   |                       | o uso de dataset especifico excluindo seus     |
   |                       | descendentes. Isso significa que, se uma       |
   |                       | reserva de 10 GB estiver definida em           |
   |                       | storage/home/bob, e outro dataset tentar usar  |
   |                       | todo o espac,o livre, pelo menos 10 GB de      |
   |                       | espac,o serao reservados para este dataset. Em |
   |                       | contraste com uma reserva regular, o espac,o   |
   |                       | usado por snapshots e datasets descendentes    |
   |                       | nao e contado contra a reserva. Por exemplo,   |
   |                       | se um snapshot for criado do storage/home/bob, |
   |                       | deve haver espac,o em disco suficiente fora da |
   |                       | quantia de refreservation para que a operac,ao |
   |                       | seja bem-sucedida. Descendentes do dataset     |
   |                       | principal nao sao contados na quantia de       |
   |                       | refreservation e, portanto, nao invadem o      |
   |                       | espac,o definido.                              |
   |-----------------------+------------------------------------------------|
   | Resilver              | Quando um disco falha e e substituido, o novo  |
   |                       | disco deve ser preenchido com os dados         |
   |                       | perdidos. O processo de usar as informac,oes   |
   |                       | de paridade distribuidas entre as unidades     |
   |                       | restantes para calcular e gravar os dados      |
   |                       | ausentes na nova unidade e chamado de          |
   |                       | resilvering.                                   |
   |-----------------------+------------------------------------------------|
   | Online                | Um pool ou vdev no estado Online tem todos os  |
   |                       | seus dispositivos membros conectados e         |
   |                       | totalmente operacionais. Dispositivos          |
   |                       | individuais no estado Online estao funcionando |
   |                       | normalmente.                                   |
   |-----------------------+------------------------------------------------|
   | Offline               | Dispositivos individuais podem ser colocados   |
   |                       | em um estado Offline pelo administrador se     |
   |                       | houver redundancia suficiente para evitar      |
   |                       | colocar o pool ou vdev em um estado Faulted.   |
   |                       | Um administrador pode optar por colocar um     |
   |                       | disco off-line como preparac,ao para           |
   |                       | substitui-lo ou para facilitar sua             |
   |                       | identificac,ao.                                |
   |-----------------------+------------------------------------------------|
   | Degraded              | Um pool ou vdev no estado Degraded possui um   |
   |                       | ou mais discos que foram desconectados ou      |
   |                       | falharam. O pool ainda e utilizavel, mas se    |
   |                       | dispositivos adicionais falharem, o pool       |
   |                       | podera se tornar irrecuperavel. Reconectar os  |
   |                       | dispositivos ausentes ou substituir os discos  |
   |                       | com falha retornara o pool a um estado Online  |
   |                       | depois que o dispositivo reconectado ou novo   |
   |                       | tiver concluido o processo de Resilver.        |
   |-----------------------+------------------------------------------------|
   | Faulted               | Um pool ou vdev no estado Faulted nao esta     |
   |                       | mais operacional. Os dados nele nao podem mais |
   |                       | ser acessados. Um pool ou vdev entra no estado |
   |                       | Faulted quando o numero de dispositivos        |
   |                       | ausentes ou com falha excede o nivel de        |
   |                       | redundancia no vdev. Se os dispositivos        |
   |                       | ausentes puderem ser reconectados, o pool      |
   |                       | retornara ao estado Online. Se houver          |
   |                       | redundancia insuficiente para compensar o      |
   |                       | numero de discos com falha, o conteudo do pool |
   |                       | sera perdido e devera ser restaurado a partir  |
   |                       | de um backup.                                  |
   +------------------------------------------------------------------------+

Capitulo 20. Outros Sistemas de Arquivos

   Escrito por Tom Rhodes.
   Indice

   20.1. Sinopse

   20.2. Sistemas de arquivos do Linux(R)

20.1. Sinopse

   Os sistemas de arquivos sao parte integrante de qualquer sistema
   operacional. Eles permitem que os usuarios carreguem e armazenem arquivos,
   fornec,em acesso a dados e tornam os discos rigidos uteis. Diferentes
   sistemas operacionais diferem em seu sistema de arquivos nativo.
   Tradicionalmente, o sistema de arquivo nativo do FreeBSD tem sido o
   Sistema de Arquivos Unix (Unix File System) UFS o qual foi modernizado
   como UFS2. Desde o FreeBSD 7.0, o Sistema de Arquivos Z (ZFS) tambem esta
   disponivel como um sistema de arquivos nativo. Veja Capitulo 19, O sistema
   de arquivos Z (ZFS) para maiores informac,oes.

   Alem dos seus sistemas de arquivos nativos, o FreeBSD suporta uma
   infinidade de outros sistemas de arquivos para que dados de outros
   sistemas operacionais possam ser acessados localmente, tais como dados
   armazenados em dispositivos de armazenamento USB conectados localmente,
   drives flash e discos rigidos. Isto inclui suporte para o sistema de
   arquivos estendidos do Linux(R) (EXT).

   Existem diferentes niveis de suporte do FreeBSD para os varios sistemas de
   arquivos. Alguns exigem que um modulo do kernel seja carregado e outros
   podem requerer que um conjunto de ferramentas seja instalado. O suporte a
   alguns dos sistemas de arquivos nao nativos e completo, suportando
   leitura/gravac,ao, enquanto o suporte a outros e somente de leitura.

   Depois de ler este capitulo, voce sabera:

     * A diferenc,a entre sistemas de arquivos nativos e suportados.

     * Quais sistemas de arquivos sao suportados pelo FreeBSD.

     * Como ativar, configurar, acessar e usar sistemas de arquivos nao
       nativos.

   Antes de ler este capitulo, voce deve:

     * Compreender o UNIX(R) e ter noc,oes basicas de FreeBSD.

     * Estar familiarizado com o basico da configurac,ao e compilac,ao do
       kernel.

     * Sinta-se confortavel instalando software no FreeBSD.

     * Tenha alguma familiaridade com discos, armazenamento e nomes de
       dispositivos no FreeBSD.

20.2. Sistemas de arquivos do Linux(R)

   O FreeBSD fornece suporte built-in para varios sistemas de arquivos do
   Linux(R). Esta sec,ao demonstra como carregar o suporte e como montar os
   sistemas de arquivos suportados do Linux(R).

  20.2.1. ext2

   O suporte no kernel para sistemas de arquivos ext2 esta disponivel desde o
   FreeBSD 2.2. No FreeBSD 8.x e anterior, o codigo esta licenciado sob a
   GPL. Desde o FreeBSD 9.0, o codigo foi reescrito e agora e licenciado sob
   a licenc,a BSD.

   O driver ext2fs(5) permite que o kernel do FreeBSD leia e grave em
   sistemas de arquivos ext2.

  Nota:

   Esse driver tambem pode ser usado para acessar os sistemas de arquivos
   ext3 e ext4. O sistema de arquivos ext2fs(5) possui suporte completo para
   leitura e gravac,ao para o ext4 a partir do FreeBSD 12.0-RELEASE. Alem
   disso, os atributos estendidos e as ACLs tambem sao suportados, enquanto o
   journalling e a criptografia nao sao. Comec,ando com o FreeBSD
   12.1-RELEASE, um provedor do DTrace tambem estara disponivel. Versoes
   anteriores do FreeBSD podem acessar o ext4 no modo de leitura e gravac,ao
   usando sysutils/fusefs-ext2.

   Para acessar um sistema de arquivos ext, primeiro carregue o modulo
   correspondente do kernel:

 # kldload ext2fs

   Em seguida, monte o volume ext especificando seu nome de partic,ao no
   FreeBSD e um ponto de montagem existente. Este exemplo monta /dev/ad1s1 em
   /mnt:

 # mount -t ext2fs /dev/ad1s1 /mnt

Capitulo 21. Virtualizac,ao

   Contribuido por Murray Stokely.
   sec,ao bhyve por Allan Jude.
   Sec,ao Xen por Benedict Reuschling.
   Indice

   21.1. Sinopse

   21.2. FreeBSD como Sistema Operacional Convidado no Parallels para Mac
   OS(R) X

   21.3. FreeBSD como sistema convidado no Virtual PC para Windows(R)

   21.4. FreeBSD como Sistema Operacional Convidado no VMware Fusion para Mac
   OS(R)

   21.5. FreeBSD como Sistema Operacional Convidado no VirtualBox(TM)

   21.6. FreeBSD como Host com VirtualBox(TM)

   21.7. FreeBSD como um Host bhyve

   21.8. FreeBSD como Host Xen(TM)

21.1. Sinopse

   O software de virtualizac,ao permite que varios sistemas operacionais
   sejam executados simultaneamente no mesmo computador. Tais sistemas de
   software para PCs geralmente envolvem um sistema operacional host que
   executa o software de virtualizac,ao e suporta qualquer numero de sistemas
   operacionais convidados.

   Depois de ler este capitulo, voce sabera:

     * A diferenc,a entre um sistema operacional host e um sistema
       operacional convidado.

     * Como instalar o FreeBSD em um computador baseado em um Intel(R)
       Apple(R) Mac(R).

     * Como instalar o FreeBSD no Microsoft(R) Windows(R) com Virtual PC.

     * Como instalar o FreeBSD como um host convidado no bhyve.

     * Como ajustar um sistema FreeBSD para melhor desempenho sob
       virtualizac,ao.

   Antes de ler este capitulo, voce deve:

     * Entender o basico sobre sistemas UNIX(R) e sobre o FreeBSD.

     * Saber como instalar o FreeBSD.

     * Saber como configurar uma conexao de rede.

     * Saber como instalar software adicional de terceiros.

21.2. FreeBSD como Sistema Operacional Convidado no Parallels para Mac OS(R) X

   O Parallels Desktop para Mac(R) e um produto de software comercial
   disponivel para computadores baseados em Intel(R) Apple(R) Mac(R) rodando
   Mac OS(R) 10.4.6 ou superior. O FreeBSD e um sistema operacional convidado
   completamente suportado. Uma vez que o Parallels tiver sido instalado no
   Mac OS(R) X, o usuario deve configurar uma maquina virtual e entao
   instalar o sistema operacional convidado desejado.

  21.2.1. Instalando o FreeBSD no Parallels/Mac OS(R) X

   O primeiro passo para instalar o FreeBSD no Parallels e criar uma nova
   maquina virtual para instalar o FreeBSD. Selecione FreeBSD como o Guest OS
   Type quando solicitado:

   Escolha uma quantidade razoavel de disco e memoria, dependendo dos planos
   para esta instancia virtual do FreeBSD. 4GB de espac,o em disco e 512MB de
   RAM funcionam bem para a maioria dos usos do FreeBSD executando sob o
   Parallels:

   Selecione o tipo de rede e uma interface de rede:

   Salve e finalize a configurac,ao:

   Apos a criac,ao da maquina virtual do FreeBSD, o FreeBSD pode ser
   instalado nela. Isto e feito melhor com um CD/DVD oficial do FreeBSD ou
   com uma imagem ISO baixada de um site FTP oficial. Copie a imagem ISO
   apropriada para o sistema de arquivos local do Mac(R) ou insira um CD/DVD
   na unidade de CD-ROM do Mac(R). Clique no icone do disco no canto inferior
   direito da janela do FreeBSD no Parallels. Isso abrira uma janela a qual
   pode ser usada para associar a unidade de CD-ROM na maquina virtual com o
   arquivo ISO no disco ou com drive CD.

   Uma vez que esta associac,ao com a fonte do CD-ROM estiver feita,
   reinicialize a maquina virtual do FreeBSD clicando no icone de
   reinicializac,ao. O Parallels ira reiniciar com um BIOS especial o qual
   primeiro ira verificar se existe um CD-ROM.

   Neste caso, ele encontrara a midia de instalac,ao do FreeBSD e iniciara
   uma instalac,ao normal do FreeBSD. Execute a instalac,ao, mas nao tente
   configurar o Xorg neste momento.

   Quando a instalac,ao estiver concluida, reinicie a maquina virtual FreeBSD
   recem-instalada.

  21.2.2. Configurando o FreeBSD no Parallels

   Depois que o FreeBSD foi instalado com sucesso no Mac OS(R) X com o
   Parallels , existem varias etapas de configurac,ao que podem ser
   executadas para otimizar o sistema para operar virtualizado.

    1. Definir variaveis do Boot Loader

       O passo mais importante e reduzir o kern.hz ajustavel para reduzir a
       utilizac,ao de CPU no FreeBSD sob ambiente Parallels. Isso e feito
       adicionando a seguinte linha ao /boot/loader.conf:

 kern.hz=100

       Sem essa configurac,ao, um sistema convidado inativo do FreeBSD no
       Parallels usara aproximadamente 15% da CPU de um unico processador
       iMac(R). Apos essa alterac,ao, o uso ficara mais proximo de 5%.

    2. Criar um novo arquivo de configurac,ao do kernel

       Todos os drivers de dispositivos SCSI, FireWire e USB podem ser
       removidos de um arquivo de configurac,ao de kernel personalizado. O
       Parallels fornece um adaptador de rede virtual usado pelo driver
       ed(4), portanto, todos os dispositivos de rede, exceto o ed(4) e o
       miibus(4) podem ser removidos do kernel .

    3. Configure a rede

       A configurac,ao de rede mais basica usa o DHCP para conectar a maquina
       virtual `a mesma rede local que o host Mac(R). Isso pode ser feito
       adicionando ifconfig_ed0="DHCP" ao /etc/rc.conf . Configurac,oes de
       rede mais avanc,adas sao descritas em Capitulo 31, Rede Avanc,ada.

21.3. FreeBSD como sistema convidado no Virtual PC para Windows(R)

   O Virtual PC para Windows(R) e um software da Microsoft(R) disponivel para
   download gratuito. Consulte este site para os requisitos do sistema.
   Depois que o Virtual PC tiver sido instalado no Microsoft(R) Windows(R), o
   usuario podera configurar uma maquina virtual e depois instalar o sistema
   operacional convidado desejado.

  21.3.1. Instalando o FreeBSD no Virtual PC

   O primeiro passo para instalar o FreeBSD no Virtual PC e criar uma nova
   maquina virtual para instalar o FreeBSD. Selecione Criar uma maquina
   virtual quando solicitado:

   Selecione a opc,ao Outro para o Sistema operacional quando solicitado:

   Em seguida, escolha uma quantidade razoavel de disco e de memoria,
   dependendo dos planos para esta instancia virtual do FreeBSD. 4GB de
   espac,o em disco e 512MB de RAM funcionam bem para a maioria dos usos do
   FreeBSD sob o Virtual PC:

   Salve e finalize a configurac,ao:

   Selecione a maquina virtual do FreeBSD e clique em Configurac,oes, em
   seguida, defina o tipo de rede e uma interface de rede:

   Apos a criac,ao da maquina virtual do FreeBSD, o FreeBSD pode ser
   instalado nela. Isso e feito da melhor maneira com um CD/DVD oficial ou
   com uma imagem ISO baixada de um site FTP oficial. Copie a imagem ISO
   apropriada para o sistema de arquivos local do Windows(R) ou insira um
   CD/DVD na unidade de CD-ROM, entao clique duas vezes na maquina virtual
   FreeBSD para inicializar. Em seguida, clique em CD e escolha Capturar
   imagem ISO... na janela do Virtual PC. Isso abrira uma janela na qual a
   unidade de CD-ROM na maquina virtual podera ser associada a um arquivo ISO
   no disco ou com o drive de CD-ROM real.

   Uma vez que a associac,ao com a fonte do CD-ROM estiver feita, reinicie a
   maquina virtual do FreeBSD clicando em Action e depois em Reset. O Virtual
   PC sera reiniciado com um BIOS especial que ira procurar por um CD-ROM
   para inicializar.

   Neste caso, ele encontrara a midia de instalac,ao do FreeBSD e iniciara
   uma instalac,ao normal do FreeBSD. Continue com a instalac,ao, mas nao
   tente configurar o Xorg neste momento.

   Quando a instalac,ao estiver concluida, lembre-se de ejetar o CD/DVD ou de
   liberar a imagem ISO. Finalmente, reinicie a maquina virtual FreeBSD
   recem-instalada.

  21.3.2. Configuring FreeBSD on Virtual PC

   Depois que o FreeBSD tiver sido instalado com sucesso no Microsoft(R)
   Windows(R) com o Virtual PC, existem varias etapas de configurac,oes que
   podem ser executadas para otimizar o sistema para operac,ao virtualizada.

    1. Definir variaveis do Boot Loader

       O passo mais importante e reduzir o valor do parametro kern.hz para
       reduzir a utilizac,ao da CPU do FreeBSD sob o ambiente do Virtual PC.
       Isso e feito adicionando a seguinte linha ao /boot/loader.conf:

 kern.hz=100

       Sem esta configurac,ao, uma VM idle do FreeBSD rodando sob o Virtual
       PC utilizara aproximadamente 40% da CPU de um computador com um unico
       processador. Apos essa mudanc,a, o uso ficara mais proximo de 3%.

    2. Criar um novo arquivo de configurac,ao do kernel

       Todos os drivers de dispositivos SCSI, FireWire e USB podem ser
       removidos do arquivo de configurac,ao do kernel personalizado. O
       Virtual PC fornece um adaptador de rede virtual usado pelo driver
       de(4), portanto, todos os dispositivos de rede, exceto o de(4) e o
       miibus(4) podem ser removidos do kernel.

    3. Configure a rede

       A configurac,ao de rede mais basica usa o DHCP para conectar a maquina
       virtual `a mesma rede local que o host Microsoft(R) Windows(R). Isso
       pode ser feito adicionando ifconfig_de0="DHCP" ao /etc/rc.conf.
       Configurac,oes de rede mais avanc,adas sao descritas em Capitulo 31,
       Rede Avanc,ada.

21.4. FreeBSD como Sistema Operacional Convidado no VMware Fusion para Mac OS(R)

   O VMware Fusion para Mac(R) e um software comercial disponivel para
   computadores Apple(R) Mac(R) baseados em processadores Intel(R) e que
   rodam o Mac OS(R) 10.4.9 ou superior. O FreeBSD e um sistema operacional
   convidado totalmente suportado. Depois que o VMware Fusion for instalado
   no Mac OS(R) X, o usuario podera configurar uma maquina virtual e, em
   seguida, instalar o sistema operacional convidado desejado.

  21.4.1. Instalando o FreeBSD no VMware Fusion

   A primeira etapa e iniciar o VMware Fusion, que ira carregar a biblioteca
   de maquinas virtuais. Clique em Novo para criar a maquina virtual:

   Isto ira carregar o Assistente de Nova Maquina Virtual. Clique em
   Continuar para prosseguir:

   Selecione Outro como o Sistema Operacional e FreeBSD ou FreeBSD 64-bit,
   como Versao quando solicitado:

   Escolha o nome da maquina virtual e o diretorio onde ela deve ser salva:

   Escolha o tamanho do disco rigido virtual para a maquina virtual:

   Escolha o metodo para instalar a maquina virtual, a partir de uma imagem
   ISO ou de um CD/DVD:

   Clique em Concluir e a maquina virtual inicializara:

   Instale o FreeBSD como de costume:

   Quando a instalac,ao estiver concluida, as configurac,oes da maquina
   virtual poderao ser modificadas, como o uso de memoria:

  Nota:

   As configurac,oes de hardware do sistema da maquina virtual nao podem ser
   modificadas enquanto a maquina virtual estiver em execuc,ao.

   O numero de CPUs a que a maquina virtual tera acesso:

   O status do dispositivo CD-ROM. Normalmente, o CD/DVD/ISO e desconectado
   da maquina virtual quando nao e mais necessario.

   A ultima coisa a mudar e como a maquina virtual se conectara `a rede. Para
   permitir conexoes `a maquina virtual de outras maquinas alem do host,
   escolha Conectar diretamente `a rede fisica (Bridged). Caso contrario,
   Compartilhar a conexao de internet do host (NAT) e preferivel para que a
   maquina virtual possa ter acesso `a Internet, porem sem que as demais
   maquinas da rede possam acessa-la.

   Depois de modificar as configurac,oes, inicialize a maquina virtual
   FreeBSD recem-instalada.

  21.4.2. Configurando o FreeBSD no VMware Fusion

   Depois que o FreeBSD for instalado com sucesso no Mac OS(R) X rodando o
   VMware Fusion, existem varias etapas de configurac,ao que podem ser
   executadas para otimizar o sistema para operar virtualizado.

    1. Definir variaveis do Boot Loader

       O passo mais importante e reduzir o valor do parametro kern.hz para
       reduzir a utilizac,ao da CPU do FreeBSD sob o ambiente do VMware
       Fusion. Isso e feito adicionando a seguinte linha ao
       /boot/loader.conf:

 kern.hz=100

       Sem esta configurac,ao, uma VM idle do FreeBSD rodando sob o VMware
       Fusion usara aproximadamente 15% da CPU de um unico processador
       iMac(R). Apos esta mudanc,a, o uso ficara proximo de 5%.

    2. Criar um novo arquivo de configurac,ao do kernel

       Todos os drivers de dispositivos FireWire e USB podem ser removidos do
       arquivo de configurac,ao do kernel personalizado. O VMware Fusion
       fornece um adaptador de rede virtual usado pelo driver em(4),
       portanto, todos os dispositivos de rede, exceto o em(4) podem ser
       removidos do kernel.

    3. Configure a rede

       A configurac,ao de rede mais basica usa o DHCP para conectar a maquina
       virtual `a mesma rede local que o host Mac(R). Isso pode ser feito
       adicionando ifconfig_em0="DHCP" ao /etc/rc.conf. Configurac,oes de
       rede mais avanc,adas estao descritas em Capitulo 31, Rede Avanc,ada.

21.5. FreeBSD como Sistema Operacional Convidado no VirtualBox(TM)

   O FreeBSD funciona bem como um sistema operacional convidado no
   VirtualBox(TM). O software de virtualizac,ao esta disponivel para a
   maioria dos sistemas operacionais comuns, incluindo o proprio FreeBSD.

   Os complementos de sistema operacional convidado do VirtualBox(TM)
   fornecem suporte para:

     * Compartilhamento de area de transferencia.

     * Integrac,ao do ponteiro do mouse.

     * Sincronizac,ao de hora com o host.

     * Redimensionamento de janela.

     * Modo Seamless.

  Nota:

   Estes comandos sao executados na instancia virtualizada do FreeBSD.

   Primeiro, instale o pacote ou o port emulators/virtualbox-ose-additions na
   instancia virtualizada do FreeBSD. Isso ira instalar o port:

 # cd /usr/ports/emulators/virtualbox-ose-additions && make install clean

   Adicione estas linhas ao /etc/rc.conf:

 vboxguest_enable="YES"
 vboxservice_enable="YES"

   Se o ntpd(8) ou o ntpdate(8) estiver sendo utilizado, desabilite a
   sincronizac,ao de horario com o host:

 vboxservice_flags="--disable-timesync"

   O Xorg reconhecera automaticamente o driver vboxvideo. Ele tambem pode ser
   inserido manualmente no /etc/X11/xorg.conf:

 Section "Device"
         Identifier "Card0"
         Driver "vboxvideo"
         VendorName "InnoTek Systemberatung GmbH"
         BoardName "VirtualBox Graphics Adapter"
 EndSection

   Para usar o driver vboxmouse, ajuste a sec,ao do mouse no
   /etc/X11/xorg.conf:

 Section "InputDevice"
         Identifier "Mouse0"
         Driver "vboxmouse"
 EndSection

   Usuarios do HAL devem criar o arquivo
   /usr/local/etc/hal/fdi/policy/90-vboxguest.fdi com o conteudo abaixo ou
   copia-lo de /usr/local/share/hal/fdi/policy/10osvendor/90-vboxguest.fdi:

 <?xml version="1.0" encoding="utf-8"?>
 <!--
 # Sun VirtualBox
 # Hal driver description for the vboxmouse driver
 # $Id: chapter.xml,v 1.33 2012-03-17 04:53:52 eadler Exp $

         Copyright (C) 2008-2009 Sun Microsystems, Inc.

         This file is part of VirtualBox Open Source Edition (OSE, as
         available from http://www.virtualbox.org. This file is free software;
         you can redistribute it and/or modify it under the terms of the GNU
         General Public License (GPL) as published by the Free Software
         Foundation, in version 2 as it comes in the "COPYING" file of the
         VirtualBox OSE distribution. VirtualBox OSE is distributed in the
         hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.

         Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
         Clara, CA 95054 USA or visit http://www.sun.com if you need
         additional information or have any questions.
 -->
 <deviceinfo version="0.2">
   <device>
     <match key="info.subsystem" string="pci">
       <match key="info.product" string="VirtualBox guest Service">
         <append key="info.capabilities" type="strlist">input</append>
         <append key="info.capabilities" type="strlist">input.mouse</append>
         <merge key="input.x11_driver" type="string">vboxmouse</merge>
         <merge key="input.device" type="string">/dev/vboxguest</merge>
       </match>
     </match>
   </device>
 </deviceinfo>

   Pastas compartilhadas para transferencias de arquivos entre o host e a VM
   sao acessiveis montando-as usando mount_vboxvfs. Uma pasta compartilhada
   pode ser criada no host usando a GUI do VirtualBox ou via vboxmanage. Por
   exemplo, para criar uma pasta compartilhada chamada myshare em
   /mnt/bsdboxshare para a VM denominada BSDBox, execute :

 # vboxmanage sharedfolder add 'BSDBox' --name myshare --hostpath /mnt/bsdboxshare

   Observe que o nome da pasta compartilhada nao deve conter espac,os. Monte
   a pasta compartilhada de dentro do sistema convidado desta forma:

 # mount_vboxvfs -w myshare /mnt

21.6. FreeBSD como Host com VirtualBox(TM)

   O VirtualBox(TM) e um pacote de virtualizac,ao completo e ativamente
   desenvolvido, disponivel para a maioria dos sistemas operacionais,
   incluindo Windows(R), Mac OS(R), Linux(R) e FreeBSD. Ele e igualmente
   capaz de executar sistemas operacionais convidados como o Windows(R) ou
   UNIX(R)-like. Ele e distribuido como um software de codigo aberto, mas com
   componentes de codigo fechado disponiveis em um pacote de extensao
   separado. Esses componentes incluem suporte para dispositivos USB 2.0.
   Maiores informac,oes podem ser encontradas na pagina wiki sobre
   "Downloads" do VirtualBox(TM). Atualmente, essas extensoes nao estao
   disponiveis para o FreeBSD.

  21.6.1. Instalando o VirtualBox(TM)

   O VirtualBox(TM) esta disponivel como um pacote ou port do FreeBSD em
   emulators/virtualbox-ose. O port pode ser instalado usando estes comandos:

 # cd /usr/ports/emulators/virtualbox-ose
 # make install clean

   Uma opc,ao util no menu de configurac,ao do port e o conjunto de programas
   GuestAdditions. Eles fornecem varios recursos uteis em sistemas
   operacionais convidados, como integrac,ao de ponteiro de mouse (permitindo
   que o mouse seja compartilhado entre host e o sistema convidado sem a
   necessidade de pressionar um atalho de teclado especial para alternar) e
   renderizac,ao de video mais rapida, especialmente em sistemas convidados
   Windows(R). Os complementos para os sistemas convidados estao disponiveis
   no menu Dispositivos, apos a conclusao da instalac,ao do sistema
   convidado.

   Algumas alterac,oes de configurac,ao sao necessarias antes do
   VirtualBox(TM) ser iniciado pela primeira vez. O port instala um modulo de
   kernel em /boot/modules o qual deve ser carregado no kernel em execuc,ao:

 # kldload vboxdrv

   Para garantir que o modulo seja sempre carregado apos uma
   reinicializac,ao, adicione esta linha ao /boot/loader.conf:

 vboxdrv_load="YES"

   Para usar os modulos do kernel que permitem conexoes de rede bridged ou
   host-only, adicione esta linha ao /etc/rc.conf e reinicie o computador:

 vboxnet_enable="YES"

   O grupo vboxusers e criado durante a instalac,ao do VirtualBox(TM). Todos
   os usuarios que precisam acessar o VirtualBox(TM) deverao ser adicionados
   como membros desse grupo. O comando pw pode ser usado para adicionar novos
   membros:

 # pw groupmod vboxusers -m yourusername

   As permissoes padrao para o /dev/vboxnetctl sao restritivas e precisam ser
   alteradas para redes em modo Bridged:

 # chown root:vboxusers /dev/vboxnetctl
 # chmod 0660 /dev/vboxnetctl

   Para tornar esta permissao permanente, adicione estas linhas ao
   /etc/devfs.conf:

 own     vboxnetctl root:vboxusers
 perm    vboxnetctl 0660

   Para iniciar o VirtualBox(TM), digite a partir de uma sessao Xorg:

 % VirtualBox

   Para mais informac,oes sobre como configurar e usar o VirtualBox(TM),
   consulte o site oficial. Para obter informac,oes especificas sobre o
   FreeBSD e instruc,oes para a soluc,ao de problemas, consulte a pagina
   relevante no wiki do FreeBSD.

  21.6.2. Suporte USB no VirtualBox(TM)

   O VirtualBox(TM) pode ser configurado para passar dispositivos USB para o
   sistema operacional convidado. O controlador host da versao do OSE esta
   limitado a emular dispositivos USB 1.1 ate que o pacote de extensao que
   suporta dispositivos USB 2.0 e 3.0 esteja disponivel no FreeBSD.

   Para que o VirtualBox(TM) esteja ciente dos dispositivos USB conectados `a
   maquina, o usuario precisa ser um membro do grupo operator.

 # pw groupmod operator -m yourusername

   Em seguida, adicione as seguintes linhas ao /etc/rc.conf:

 [system=10]
 add path 'usb/*' mode 0660 group operator

   Em seguida, adicione as seguintes linhas ao /etc/rc.conf:

 devfs_system_ruleset="system"

   Entao reinicie o devfs:

 # service devfs restart

   Reinicie a sessao de login e o VirtualBox(TM) para que essas alterac,oes
   entrem em vigor e crie os filtros USB conforme necessario.

  21.6.3. Acesso ao drive de DVD/CD no Host VirtualBox(TM)

   O acesso `as unidades de DVD/CD do Host a partir dos convidados e obtido
   atraves do compartilhamento das unidades fisicas. Dentro do
   VirtualBox(TM), isso e configurado a partir da janela Armazenamento nas
   Configurac,oes da maquina virtual. Se necessario, crie primeiro um
   dispositivo vazio IDE CD/DVD. Em seguida, escolha a unidade do host no
   menu pop-up para a selec,ao de unidade virtual de CD/DVD. Uma caixa de
   selec,ao rotulada como Passthrough sera exibida. Isso permitira que a
   maquina virtual use o hardware diretamente. Por exemplo, CDs de audio ou o
   gravador so funcionara se esta opc,ao estiver selecionada.

   O HAL precisa ser executado para que as func,oes de DVD/CD do
   VirtualBox(TM) funcionem, entao habilite-o no /etc/rc.conf e inicie-o se
   ele ainda nao estiver em execuc,ao:

 hald_enable="YES"

 # service hald start

   Para que os usuarios possam usar as func,oes de DVD/CD do VirtualBox(TM),
   eles precisam acessar /dev/xpt0, /dev/cdN, e /dev/passN. Isso geralmente e
   obtido tornando o usuario um membro do grupo operator. As permissoes para
   esses dispositivos devem ser corrigidas adicionando estas linhas ao
   /etc/devfs.conf :

 perm cd* 0660
 perm xpt0 0660
 perm pass* 0660

 # service devfs restart

21.7. FreeBSD como um Host bhyve

   O hypervisor bhyve BSD-licensed tornou-se parte do sistema base com o
   FreeBSD 10.0-RELEASE. Este hypervisor suporta uma grande variedade de
   sistemas operacionais convidados, incluindo FreeBSD, OpenBSD e muitas
   distribuic,oes Linux(R). Por padrao, o bhyve fornece acesso ao console
   serial e nao emula um console grafico. Os recursos de offload de
   virtualizac,ao das CPUs mais recentes sao usados para evitar os metodos
   legados de traduc,ao de instruc,oes e de gerenciamento manual de
   mapeamentos de memoria.

   O design do bhyve requer um processador que suporte tabelas de paginas
   estendidas da Intel(R) (EPT) ou a Indexac,ao Rapida de Virtualizac,ao da
   AMD(R) (RVI) ou Tabelas de Paginas Aninhadas (NPT). Hospedar sistemas
   operacionais convidados Linux(R) ou convidados FreeBSD com mais de uma
   vCPU requer suporte a modo irrestrito de VMX (UG). A maioria dos
   processadores mais recentes, especificamente o Intel(R) Core(TM) i3/i5/i7
   e o Intel(R) Xeon(TM) E3/E5/E7, suportam esses recursos. O suporte UG foi
   introduzido com a microarquitetura Westmere da Intel. Para obter uma lista
   completa dos processadores Intel(R) que suportam EPT, consulte
   https://ark.intel.com/content/www/us/en/ark/search/featurefilter.html?productType=873&0_ExtendedPageTables=True.
   O RVI e encontrado na terceira gerac,ao e depois nos processadores AMD
   Opteron(TM) (Barcelona). A maneira mais facil de saber se um processador
   suporta o bhyve e executar o dmesg ou procurar no /var/run/dmesg.boot pelo
   o Sinalizador de recurso do processador POPCNT na linha Features2 para
   processadores AMD(R) ou EPT e UG na linha VT-x para os processadores
   Intel(R).

  21.7.1. Preparando o host

   O primeiro passo para criar uma maquina virtual no bhyve e configurar o
   sistema host. Primeiro, carregue o modulo do kernel bhyve:

 # kldload vmm

   Em seguida, crie uma interface tap para o dispositivo de rede na maquina
   virtual para anexar. Para que o dispositivo de rede participe da rede,
   crie tambem uma interface de bridge contendo a interface tap e a interface
   fisica como membros. Neste exemplo, a interface fisica e igb0:

 # ifconfig tap0 create
 # sysctl net.link.tap.up_on_open=1
 net.link.tap.up_on_open: 0 -> 1
 # ifconfig bridge0 create
 # ifconfig bridge0 addm igb0 addm tap0
 # ifconfig bridge0 up

  21.7.2. Criando um Sistema Operacional Convidado do FreeBSD

   Crie um arquivo para usar como o disco virtual da maquina convidada.
   Especifique o tamanho e o nome do disco virtual:

 # truncate -s 16G guest.img

   Baixe uma imagem de instalac,ao do FreeBSD para instalar:

 # fetch ftp://ftp.freebsd.org/pub/FreeBSD/releases/ISO-IMAGES/10.3/FreeBSD-10.3-RELEASE-amd64-bootonly.iso
 FreeBSD-10.3-RELEASE-amd64-bootonly.iso       100% of  230 MB  570 kBps 06m17s

   O FreeBSD vem com um script de exemplo para executar uma maquina virtual
   com o bhyve. O script iniciara a maquina virtual e a executara em um loop,
   para que ela seja reiniciada automaticamente se houver falha. O script usa
   varias opc,oes para controlar a configurac,ao da maquina: -c controla o
   numero de CPUs virtuais, -m limita a quantidade de memoria disponivel para
   o sistema operacional convidado, -t define qual dispositivo tap usar, -d
   indica qual imagem de disco usar, -i indica ao bhyve para inicializar a
   partir da imagem CD em vez do disco, e -I define qual imagem de CD deve
   ser usada. O ultimo parametro e o nome da maquina virtual, usada para
   rastrear as maquinas em execuc,ao. Este exemplo inicia a maquina virtual
   no modo de instalac,ao:

 # sh /usr/share/examples/bhyve/vmrun.sh -c 1 -m 1024M -t tap0 -d guest.img -i -I FreeBSD-10.3-RELEASE-amd64-bootonly.iso guestname

   A maquina virtual inicializara e iniciara o instalador. Depois de instalar
   um sistema na maquina virtual, quando o sistema perguntar sobre a
   inserc,ao em um shell no final da instalac,ao, escolha Yes.

   Reinicialize a maquina virtual. Enquanto a reinicializac,ao da maquina
   virtual fara o bhyve finalizar, o script vmrun.sh executa o bhyve em um
   loop e o reiniciara automaticamente. Quando isso acontecer, escolha a
   opc,ao de reinicializac,ao no menu do carregador de inicializac,ao para
   escapar do loop. Agora o convidado pode ser iniciado a partir do disco
   virtual:

 # sh /usr/share/examples/bhyve/vmrun.sh -c 4 -m 1024M -t tap0 -d guest.img guestname

  21.7.3. Criando um Sistema Operacional convidado Linux(R)

   Para inicializar sistemas operacionais diferentes do FreeBSD, o port
   sysutils/grub2-bhyve deve ser instalada primeiro.

   Em seguida, crie um arquivo para usar como o disco virtual da maquina
   convidada:

 # truncate -s 16G linux.img

   Iniciar uma maquina virtual com o bhyve e um processo de duas etapas.
   Primeiro um kernel deve ser carregado, entao o sistema operacional
   convidado pode ser iniciado. O kernel Linux(R) e carregado com o
   sysutils/grub2-bhyve. Crie um device.map que o grub usara para mapear os
   dispositivos virtuais para os arquivos no sistema host:

 (hd0) ./linux.img
 (cd0) ./somelinux.iso

   Use o sysutils/grub2-bhyve para carregar o kernel Linux(R) de uma imagem
   ISO:

 # grub-bhyve -m device.map -r cd0 -M 1024M linuxguest

   Isto ira iniciar o grub. Se o CD de instalac,ao contiver um grub.cfg, um
   menu sera exibido. Caso contrario, os arquivos vmlinuz e initrd devem ser
   localizados e carregados manualmente:

 grub> ls
 (hd0) (cd0) (cd0,msdos1) (host)
 grub> ls (cd0)/isolinux
 boot.cat boot.msg grub.conf initrd.img isolinux.bin isolinux.cfg memtest
 splash.jpg TRANS.TBL vesamenu.c32 vmlinuz
 grub> linux (cd0)/isolinux/vmlinuz
 grub> initrd (cd0)/isolinux/initrd.img
 grub> boot

   Agora que o kernel Linux(R) esta carregado, o sistema convidado pode ser
   iniciado:

 # bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s 3:0,virtio-blk,./linux.img \
     -s 4:0,ahci-cd,./somelinux.iso -l com1,stdio -c 4 -m 1024M linuxguest

   O sistema inicializara e iniciara o instalador. Depois de instalar um
   sistema na maquina virtual, reinicialize a maquina virtual. Isso fara com
   que o bhyve seja encerrado. A instancia da maquina virtual precisa ser
   destruida antes de poder ser iniciada novamente:

 # bhyvectl --destroy --vm=linuxguest

   Agora, o sistema convidado pode ser iniciado diretamente do disco virtual.
   Carregue o kernel:

 # grub-bhyve -m device.map -r hd0,msdos1 -M 1024M linuxguest
 grub> ls
 (hd0) (hd0,msdos2) (hd0,msdos1) (cd0) (cd0,msdos1) (host)
 (lvm/VolGroup-lv_swap) (lvm/VolGroup-lv_root)
 grub> ls (hd0,msdos1)/
 lost+found/ grub/ efi/ System.map-2.6.32-431.el6.x86_64 config-2.6.32-431.el6.x
 86_64 symvers-2.6.32-431.el6.x86_64.gz vmlinuz-2.6.32-431.el6.x86_64
 initramfs-2.6.32-431.el6.x86_64.img
 grub> linux (hd0,msdos1)/vmlinuz-2.6.32-431.el6.x86_64 root=/dev/mapper/VolGroup-lv_root
 grub> initrd (hd0,msdos1)/initramfs-2.6.32-431.el6.x86_64.img
 grub> boot

   Inicialize a maquina virtual:

 # bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 \
     -s 3:0,virtio-blk,./linux.img -l com1,stdio -c 4 -m 1024M linuxguest

   O Linux(R) iniciara agora na maquina virtual e, eventualmente, apresentara
   o prompt de login. Fac,a o login e use a maquina virtual. Quando terminar,
   reinicialize a maquina virtual para sair do bhyve. Destrua a instancia da
   maquina virtual:

 # bhyvectl --destroy --vm=linuxguest

  21.7.4. Inicializando maquinas virtuais bhyve com Firmware UEFI

   Alem do bhyveload e do grub-bhyve, o hypervisor bhyve tambem pode
   inicializar maquinas virtuais usando o firmware do espac,o de usuario UEFI
   . Esta opc,ao pode suportar sistemas operacionais convidados que nao sao
   suportados pelos outros carregadores.

   Para utilizar o suporte ao UEFI no bhyve, primeiro obtenha as imagens de
   firmware UEFI. Isto pode ser feito instalando o port ou pacote
   sysutils/bhyve-firmware .

   Com o firmware no lugar, adicione os sinalizadores -l
   bootrom,/path/to/firmware `a linha de comando do bhyve. A sintaxe real do
   bhyve pode se parecer com a seguinte:

 # bhyve -AHP -s 0:0,hostbridge -s 1:0,lpc \
 -s 2:0,virtio-net,tap1 -s 3:0,virtio-blk,./disk.img \
 -s 4:0,ahci-cd,./install.iso -c 4 -m 1024M \
 -l bootrom,/usr/local/share/uefi-firmware/BHYVE_UEFI.fd \
 guest

   O sysutils/bhyve-firmware tambem contem um firmware habilitado para CSM,
   para inicializar sistemas operacionais hospedes sem suporte `a UEFI no
   modo de BIOS legado:

 # bhyve -AHP -s 0:0,hostbridge -s 1:0,lpc \
 -s 2:0,virtio-net,tap1 -s 3:0,virtio-blk,./disk.img \
 -s 4:0,ahci-cd,./install.iso -c 4 -m 1024M \
 -l bootrom,/usr/local/share/uefi-firmware/BHYVE_UEFI_CSM.fd \
 guest

  21.7.5. Framebuffer UEFI Grafico para bhyve

   O suporte ao firmware UEFI e particularmente util em sistemas operacionais
   convidados predominantemente graficos, como o Microsoft Windows(R).

   O suporte para o framebuffer UEFI-GOP tambem pode ser ativado com os
   sinalizadores -s 29,fbuf,tcp=0.0.0.0:5900. A resoluc,ao do framebuffer
   pode ser configurada com w=800 e h=600 e o bhyve pode ser instruido para
   aguardar uma conexao VNC antes de inicializar o sistema operacional
   convidado adicionando wait. O framebuffer pode ser acessado pelo host ou
   pela rede atraves do protocolo VNC.

   O comando bhyve resultante ficaria assim:

 # bhyve -AHP -s 0:0,hostbridge -s 31:0,lpc \
 -s 2:0,virtio-net,tap1 -s 3:0,virtio-blk,./disk.img \
 -s 4:0,ahci-cd,./install.iso -c 4 -m 1024M \
 -s 29,fbuf,tcp=0.0.0.0:5900,w=800,h=600,wait \
 -l bootrom,/usr/local/share/uefi-firmware/BHYVE_UEFI.fd \
 guest

   Observe que, no modo de emulac,ao do BIOS, o framebuffer deixara de
   receber atualizac,oes quando o controle for passado do firmware para o
   sistema operacional convidado.

  21.7.6. Usando o ZFS com os sistemas operacionais convidados no bhyve

   Se o ZFS estiver disponivel na maquina host, o uso de volumes ZFS em vez
   de arquivos de imagem de disco pode fornecer beneficios significativos de
   desempenho para as VMs convidadas. Um volume ZFS pode ser criado por:

 # zfs create -V16G -o volmode=dev zroot/linuxdisk0

   Ao iniciar a VM, especifique o volume ZFS como a unidade de disco:

 # bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s3:0,virtio-blk,/dev/zvol/zroot/linuxdisk0 \
     -l com1,stdio -c 4 -m 1024M linuxguest

  21.7.7. Consoles de maquinas virtuais

   E vantajoso executar o console do bhyve em uma ferramenta de gerenciamento
   de sessao, como o sysutils/tmux ou sysutils/screen, para que possa
   desanexar e reanexar o console. Tambem e possivel ter o console do bhyve
   como um dispositivo de modem nulo o qual pode ser acessado com o comando
   cu. Para fazer isso, carregue o modulo do kernel nmdm e substitua -l
   com1,stdio with -l com1,/dev/nmdm0A. Os dispositivos /dev/nmdm sao criados
   automaticamente conforme necessario, onde cada um e um par, correspondente
   `as duas extremidades do cabo de modem nulo (/dev/nmdm0A e /dev/nmdm0B).
   Veja nmdm(4) para maiores informac,oes.

 # kldload nmdm
 # bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s 3:0,virtio-blk,./linux.img \
     -l com1,/dev/nmdm0A -c 4 -m 1024M linuxguest
 # cu -l /dev/nmdm0B
 Connected

 Ubuntu 13.10 handbook ttyS0

 handbook login:

  21.7.8. Gerenciando Maquinas Virtuais

   Um no de dispositivo e criado em /dev/vmm para cada maquina virtual. Isso
   permite que o administrador veja facilmente uma lista das maquinas
   virtuais em execuc,ao:

 # ls -al /dev/vmm
 total 1
 dr-xr-xr-x   2 root  wheel    512 Mar 17 12:19 ./
 dr-xr-xr-x  14 root  wheel    512 Mar 17 06:38 ../
 crw-------   1 root  wheel  0x1a2 Mar 17 12:20 guestname
 crw-------   1 root  wheel  0x19f Mar 17 12:19 linuxguest
 crw-------   1 root  wheel  0x1a1 Mar 17 12:19 otherguest

   Uma maquina virtual especificada pode ser destruida usando bhyvectl:

 # bhyvectl --destroy --vm=guestname

  21.7.9. Configurac,ao Persistente

   Para configurar o sistema para iniciar os sistemas operacionais convidados
   do bhyve no momento da inicializac,ao, as seguintes configurac,oes devem
   ser feitas nos arquivos especificados:

    1. /etc/sysctl.conf

 net.link.tap.up_on_open=1

    2. /etc/rc.conf

 cloned_interfaces="bridge0 tap0"
 ifconfig_bridge0="addm igb0 addm tap0"
 kld_list="nmdm vmm"

21.8. FreeBSD como Host Xen(TM)

   O Xen e um hypervisor tipo 1 licenciado sob a GPLv2 para arquiteturas
   Intel(R) e ARM(R). O FreeBSD suporta dominios nao privilegiados (maquina
   virtual) nas plataformas i386(TM) e AMD(R) 64-Bit DomU e Amazon EC2 desde
   o FreeBSD 8.0 e incluiu o suporte ao dominio de controle Dom0 (host) no
   FreeBSD 11.0. O suporte para dominios para-virtualizados (PV) foi removido
   do FreeBSD 11 em favor de dominios virtualizados de hardware (HVM), o que
   proporciona melhor desempenho.

   O Xen(TM) e um hypervisor bare-metal, o que significa que e o primeiro
   programa carregado apos o BIOS. Um convidado especial privilegiado chamado
   Domain-0 (Dom0 para abreviar) e entao iniciado. O Dom0 usa seus
   privilegios especiais para acessar diretamente o hardware fisico
   subjacente, tornando-o uma soluc,ao de alto desempenho. Ele e capaz de
   acessar os controladores de disco e adaptadores de rede diretamente. As
   ferramentas de gerenciamento do Xen(TM) para gerenciar e controlar o
   hypervisor Xen(TM) tambem sao usadas pelo Dom0 para criar, listar e
   destruir VMs. Dom0 fornece discos virtuais e recursos de rede para
   dominios sem privilegios, geralmente chamados de DomU. O Xen(TM) Dom0 pode
   ser comparado ao console de servic,o de outras soluc,oes de hypervisor ,
   enquanto o DomU e onde as VMs convidadas sao executadas.

   O Xen(TM) pode migrar VMs entre diferentes servidores Xen(TM). Quando os
   dois hosts xen compartilham o mesmo armazenamento subjacente, a migrac,ao
   pode ser feita sem a necessidade de primeiro desligar a VM. Em vez disso,
   a migrac,ao e executada ao vivo enquanto o DomU esta em execuc,ao e nao ha
   necessidade de reinicia-lo ou planejar um tempo de inatividade. Isso e
   util em cenarios de manutenc,ao ou em janelas de atualizac,ao para
   garantir que os servic,os fornecidos pelo DomU continuem disponiveis.
   Muitos outros recursos do Xen(TM) estao listados na pagina wiki com a
   visao global sobre o Xen. Note que ainda nem todos os recursos sao
   suportados no FreeBSD.

  21.8.1. Requisitos de hardware para o Xen(TM) Dom0

   Para executar o hypervisor Xen(TM) em um host, sao necessarias certas
   funcionalidades de hardware. Os dominios virtualizados de hardware
   requerem o suporte `a Tabela de Paginas Estendidas (EPT) e `a Unidade de
   Gerenciamento de Memoria de Entrada / Saida (IOMMU) no processador do
   host.

  Nota:

   Para executar um Xen(TM) Dom0 no FreeBSD, a maquina deve ser inicializada
   usando o boot legado (BIOS).

  21.8.2. Configurac,ao do Xen(TM) Dom0 Dominio de Controle

   Os usuarios do FreeBSD 11 devem instalar os pacotes emulators/xen-kernel47
   e sysutils/xen-tools47 que sao baseados no Xen versao 4.7. Sistemas
   rodando o FreeBSD-12.0 ou mais novo podem usar o Xen 4.11 fornecido por
   emulators/xen-kernel411 e sysutils/xen-tools411, respectivamente.

   Os arquivos de configurac,ao devem ser editados para preparar o host para
   a integrac,ao do Dom0 apos a instalac,ao dos pacotes do Xen. Uma entrada
   para /etc/sysctl.conf desabilita o limite de quantas paginas de memoria
   podem ser conectadas. Caso contrario, as VMs do DomU com requisitos de
   memoria mais altos nao serao executadas.

 # echo 'vm.max_wired=-1' >> /etc/sysctl.conf

   Outra configurac,ao relacionada `a memoria envolve a alterac,ao do
   /etc/login.conf, configurando a opc,ao memorylocked para unlimited. Caso
   contrario, a criac,ao de dominios DomU podera falhar com erros Cannot
   allocate memory. Depois de fazer a mudanc,a no /etc/login.conf, execute o
   comando cap_mkdb para atualizar o banco de dados de recursos. Veja
   Sec,ao 13.13, "Limites de Recursos" para detalhes.

 # sed -i '' -e 's/memorylocked=64K/memorylocked=unlimited/' /etc/login.conf
 # cap_mkdb /etc/login.conf

   Adicione uma entrada para o console do Xen(TM) ao /etc/ttys:

 # echo 'xc0     "/usr/libexec/getty Pc"         xterm   onifconsole  secure' >> /etc/ttys

   A selec,ao de um kernel Xen(TM) no /boot/loader.conf ativa o Dom0. O
   Xen(TM) tambem requer recursos como CPU e memoria da maquina host para ele
   mesmo e para outros dominios DomU. Quanto de CPU e memoria depende dos
   requisitos individuais e das capacidades de hardware. Neste exemplo, 8 GB
   de memoria e 4 CPUs virtuais sao disponibilizados para o Dom0. O console
   serial tambem e ativado e as opc,oes de log sao definidas.

   O seguinte comando e usado para pacotes Xen 4.7:

 # sysrc -f /boot/loader.conf hw.pci.mcfg=0
 # sysrc -f /boot/loader.conf if_tap_load="YES"
 # sysrc -f /boot/loader.conf xen_kernel="/boot/xen"
 # sysrc -f /boot/loader.conf xen_cmdline="dom0_mem=8192M dom0_max_vcpus=4 dom0pvh=1 console=com1,vga com1=115200,8n1 guest_loglvl=all loglvl=all"

   Para as versoes Xen 4.11 e superiores, o seguinte comando deve ser usado:

 # sysrc -f /boot/loader.conf if_tap_load="YES"
 # sysrc -f /boot/loader.conf xen_kernel="/boot/xen"
 # sysrc -f /boot/loader.conf xen_cmdline="dom0_mem=8192M dom0_max_vcpus=4 dom0=pvh console=com1,vga com1=115200,8n1 guest_loglvl=all loglvl=all"

  Dica:

   Os arquivos de log criados pelo Xen(TM) para as VMs do DomU sao
   armazenados em /var/log/xen. Por favor, certifique-se de verificar o
   conteudo do diretorio em caso de problemas.

   Ative o servic,o xencommons durante a inicializac,ao do sistema:

 # sysrc xencommons_enable=yes

   Essas configurac,oes sao suficientes para iniciar um sistema habilitado
   para Dom0. No entanto, falta a funcionalidade de rede para as maquinas
   DomU. Para corrigir isso, defina uma interface em bridge com a NIC
   principal do sistema que as VMs DomU poderao usar para se conectar `a
   rede. Substitua em0 pelo nome da interface de rede do host.

 # sysrc cloned_interfaces="bridge0"
 # sysrc ifconfig_bridge0="addm em0 SYNCDHCP"
 # sysrc ifconfig_em0="up"

   Reinicie o host para carregar o kernel Xen(TM) e inicie o Dom0.

 # reboot

   Apos inicializar com sucesso o kernel Xen(TM) e efetuar login no sistema
   novamente, a ferramenta de gerenciamento do Xen(TM), xl e usada para
   mostrar informac,oes sobre os dominios.

 # xl list
 Name                                        ID   Mem VCPUs      State   Time(s)
 Domain-0                                     0  8192     4     r-----     962.0

   A saida confirma que o Dom0 (chamado Domain-0) tem o ID 0 e esta em
   execuc,ao. Ele tambem possui a memoria e as CPUs virtuais que foram
   definidas anteriormente no /boot/loader.conf. Mais informac,oes podem ser
   encontradas na Documentac,ao do Xen(TM). Agora as VMs convidadas do DomU
   podem ser criadas.

  21.8.3. Configurac,ao da VM Convidada Xen(TM) DomU

   Dominios desprivilegiados consistem em um arquivo de configurac,ao e
   discos rigidos virtuais ou fisicos. Os discos virtuais para armazenamento
   do DomU podem ser arquivos criados pelo truncate(1) ou volumes ZFS,
   conforme descrito em Sec,ao 19.4.2, "Criando e Destruindo Volumes". Neste
   exemplo, um volume de 20 GB e usado. Uma VM e criada com o volume ZFS, uma
   imagem ISO do FreeBSD, 1 GB de RAM e duas CPUs virtuais. O arquivo ISO de
   instalac,ao e obtido com o fetch(1) e salvo localmente em um arquivo
   chamado freebsd.iso.

 # fetch ftp://ftp.freebsd.org/pub/FreeBSD/releases/ISO-IMAGES/12.0/FreeBSD-12.0-RELEASE-amd64-bootonly.iso -o freebsd.iso

   Um volume de 20 GB do ZFS chamado xendisk0 e criado para servir como
   espac,o em disco para a VM.

 # zfs create -V20G -o volmode=dev zroot/xendisk0

   A nova VM DomU convidada e definida em um arquivo. Algumas definic,oes
   especificas, como nome, mapa de teclado e detalhes da conexao VNC, tambem
   sao definidas. O seguinte freebsd.cfg contem uma configurac,ao minima de
   DomU para este exemplo:

 # cat freebsd.cfg
 builder = "hvm" 1
 name = "freebsd" 2
 memory = 1024 3
 vcpus = 2 4
 vif = [ 'mac=00:16:3E:74:34:32,bridge=bridge0' ] 5
 disk = [
 '/dev/zvol/tank/xendisk0,raw,hda,rw', 6
 '/root/freebsd.iso,raw,hdc:cdrom,r' 7
   ]
 vnc = 1 8
 vnclisten = "0.0.0.0"
 serial = "pty"
 usbdevice = "tablet"

   Estas linhas sao explicadas com mais detalhes:

   1 Isso define que tipo de virtualizac,ao usar. hvm refere-se `a            
     virtualizac,ao assistida por hardware ou `a maquina virtual de hardware. 
     Os sistemas operacionais convidados podem ser executados sem             
     modificac,ao em CPUs com extensoes de virtualizac,ao, fornecendo quase o 
     mesmo desempenho que a execuc,ao em hardware fisico. generic e o valor   
     padrao e cria um dominio PV.                                             
   2 Nome desta maquina virtual para distingui-la de outras executadas no     
     mesmo Dom0. Requerido.                                                   
   3 Quantidade de RAM em megabytes para disponibilizar para a VM. Esse valor 
     e subtraido da memoria total disponivel do hypervisor, nao da memoria do 
     Dom0.                                                                    
   4 Numero de CPUs virtuais disponiveis para a VM convidada. Para um melhor  
     desempenho, nao crie convidados com mais CPUs virtuais do que o numero   
     de CPUs fisicas no host.                                                 
   5 Adaptador de rede virtual. Esta e a bridge conectada `a interface de     
     rede do host. O parametro mac e o enderec,o MAC definido na interface de 
     rede virtual. Este parametro e opcional, se nenhum MAC for fornecido, o  
     Xen(TM) ira gerar um aleatorio.                                          
   6 Caminho completo para o disco, arquivo ou volume ZFS do armazenamento em 
     disco para essa VM. As opc,oes e as varias definic,oes de disco sao      
     separadas por virgulas.                                                  
   7 Define o meio de inicializac,ao a partir do qual o sistema operacional   
     inicial e instalado. Neste exemplo, e a imagem ISO baixada               
     anteriormente. Consulte a documentac,ao do Xen(TM) para outros tipos de  
     dispositivos e outras opc,oes para configurar.                           
   8 Opc,oes que controlam a conectividade do VNC para o console serial do    
     DomU. Em ordem, estes sao: ativa suporte ao VNC, define o enderec,o IP   
     no qual escutar, device node para o console serial e o metodo de entrada 
     para posicionamento preciso do mouse e outros metodos de entrada. keymap 
     define qual mapa de teclas usar, sendo english por padrao.               

   Apos o arquivo ter sido criado com todas as opc,oes necessarias, o DomU e
   criado passando-o como um parametro para o comando xl create.

 # xl create freebsd.cfg

  Nota:

   Cada vez que o Dom0 e reiniciado, o arquivo de configurac,ao deve ser
   passado para xl create novamente para recriar o DomU. Por padrao, somente
   o Dom0 e criado apos uma reinicializac,ao, nao as VMs individuais. As VMs
   podem continuar de onde pararam, pois armazenaram o sistema operacional no
   disco virtual. A configurac,ao da maquina virtual pode mudar com o tempo
   (por exemplo, ao adicionar mais memoria). Os arquivos de configurac,ao da
   maquina virtual devem ter um backup e manter-se disponiveis para poder
   recriar a VM convidada quando necessario.

   A saida de xl list confirma que o DomU foi criado.

 # xl list
 Name                                        ID   Mem VCPUs      State   Time(s)
 Domain-0                                     0  8192     4     r-----  1653.4
 freebsd                                      1  1024     1     -b----   663.9

   Para iniciar a instalac,ao do sistema operacional base, inicie o cliente
   VNC, direcionando-o para o enderec,o de rede principal do host ou para o
   enderec,o IP definido na linha vnclisten do freebsd.cfg. Depois que o
   sistema operacional tiver sido instalado, desligue o DomU e desconecte o
   visualizador VNC. Edite o freebsd.cfg, removendo a linha com a definic,ao
   cdrom ou comentando-a inserindo um caractere # no inicio da linha. Para
   carregar esta nova configurac,ao, e necessario remover o DomU antigo com
   xl destroy, passando o nome ou o id como parametro. Depois, recrie-o
   usando o freebsd.cfg modificado.

 # xl destroy freebsd
 # xl create freebsd.cfg

   A maquina pode entao ser acessada novamente usando o visualizador VNC.
   Desta vez, ele sera inicializado a partir do disco virtual em que o
   sistema operacional foi instalado e pode ser usado como uma maquina
   virtual.

  21.8.4. Soluc,ao de problemas

   Esta sec,ao contem informac,oes basicas para ajudar a solucionar problemas
   encontrados ao usar o FreeBSD como host ou convidado do Xen(TM).

    21.8.4.1. Soluc,ao de problemas de inicializac,ao do host

   Observe que as dicas de soluc,ao de problemas a seguir sao destinadas ao
   Xen(TM) 4.11 ou mais recente. Se voce ainda estiver usando o Xen(TM) 4.7 e
   tendo problemas, considere migrar para uma versao mais recente do Xen(TM).

   Para solucionar problemas de inicializac,ao do host, voce provavelmente
   precisara de um cabo serial ou de um cabo USB de depurac,ao. Uma saida de
   boot verbosa do Xen(TM) pode ser obtida adicionando-se parametros `a
   opc,ao xen_cmdline encontrada no loader.conf. Alguns parametros de
   depurac,ao relevantes sao:

     * iommu=debug: pode ser usado para imprimir informac,oes de diagnostico
       adicionais sobre o iommu.

     * dom0=verbose: pode ser usado para imprimir informac,oes de diagnostico
       adicionais sobre o processo de compilac,ao dom0.

     * sync_console: flag para forc,ar a saida sincrona do console. Util para
       depurac,ao para evitar a perda de mensagens devido `a limitac,ao de
       taxa. Nunca use essa opc,ao em ambientes de produc,ao, pois ela pode
       permitir que convidados mal-intencionados realizem ataques DoS contra
       o Xen(TM) usando o console.

   O FreeBSD tambem deve ser inicializado no modo verbose para identificar
   quaisquer problemas. Para ativar a inicializac,ao detalhada, execute este
   comando:

 # sysrc -f /boot/loader.conf boot_verbose="YES"

   Se nenhuma dessas opc,oes ajudar a resolver o problema, envie o registro
   de inicializac,ao serial para <freebsd-xen@FreeBSD.org> e <
   xen-devel@lists.xenproject.org> para uma analise mais aprofundada.

    21.8.4.2. Soluc,ao de problemas na criac,ao de VMs convidadas

   Problemas tambem podem surgir ao criar convidados, as informac,oes a
   seguir tentam fornecer alguma ajuda para aqueles que precisarem
   diagnosticar problemas de criac,ao de convidados.

   A causa mais comum de falhas na criac,ao de convidados e o comando xl
   cuspindo algum erro e saindo com um codigo de retorno diferente de 0. Se o
   erro fornecido nao for suficiente para ajudar a identificar o problema,
   uma saida mais detalhada pode ser obtida do comando xl usando-se a opc,ao
   v repetidamente.

 # xl -vvv create freebsd.cfg
 Parsing config from freebsd.cfg
 libxl: debug: libxl_create.c:1693:do_domain_create: Domain 0:ao 0x800d750a0: create: how=0x0 callback=0x0 poller=0x800d6f0f0
 libxl: debug: libxl_device.c:397:libxl__device_disk_set_backend: Disk vdev=xvda spec.backend=unknown
 libxl: debug: libxl_device.c:432:libxl__device_disk_set_backend: Disk vdev=xvda, using backend phy
 libxl: debug: libxl_create.c:1018:initiate_domain_create: Domain 1:running bootloader
 libxl: debug: libxl_bootloader.c:328:libxl__bootloader_run: Domain 1:not a PV/PVH domain, skipping bootloader
 libxl: debug: libxl_event.c:689:libxl__ev_xswatch_deregister: watch w=0x800d96b98: deregister unregistered
 domainbuilder: detail: xc_dom_allocate: cmdline="", features=""
 domainbuilder: detail: xc_dom_kernel_file: filename="/usr/local/lib/xen/boot/hvmloader"
 domainbuilder: detail: xc_dom_malloc_filemap    : 326 kB
 libxl: debug: libxl_dom.c:988:libxl__load_hvm_firmware_module: Loading BIOS: /usr/local/share/seabios/bios.bin
 ...

   Se a saida detalhada nao ajudar a diagnosticar o problema, verifique
   tambem os logs do toolstack QEMU e do Xen(TM) em /var/log/xen. Observe que
   o nome do dominio e anexado ao nome do registro, portanto, se o dominio
   tiver o nome freebsd, voce devera encontrar um /var/log/xen/xl-freebsd.log
   e provavelmente um /var/log/xen/qemu-dm-freebsd.log . Ambos os arquivos de
   log podem conter informac,oes uteis para a depurac,ao. Se nada disso
   ajudar a resolver o problema, envie a descric,ao do problema que voce esta
   enfrentando e o maximo de informac,oes possiveis para
   <freebsd-xen@FreeBSD.org> e <xen-devel@lists.xenproject.org> para obter
   ajuda.

Capitulo 22. Localizac,ao - Uso e Configurac,ao do i18n/L10n

   Contributed by Andrey Chernov.
   Rewritten by Michael C. Wu.
   Indice

   22.1. Sinopse

   22.2. Usando Localizac,ao

   22.3. Encontrando Aplicac,oes i18n

   22.4. Configurac,ao de Localizac,ao para Idiomas Especificos

22.1. Sinopse

   O FreeBSD e um projeto distribuido com usuarios e colaboradores
   localizados em todo o mundo. Como tal, o FreeBSD suporta a localizac,ao em
   muitos idiomas, permitindo aos usuarios visualizar, inserir ou processar
   dados em idiomas diferentes do ingles. Pode-se escolher entre a maioria
   dos principais idiomas, incluindo, mas nao se limitando a: Chines, Alemao,
   Japones, Coreano, Frances, Russo e Vietnamita.

   O termo internacionalizac,ao foi encurtado para i18n, que representa o
   numero de letras entre a primeira e a ultima letra da
   internacionalizac,ao. L10n usa o mesmo esquema de nomes, mas a partir da
   localizac,ao. Os metodos, protocolos e aplicativos i18n/L10n permitem que
   os usuarios usem os idiomas de sua escolha.

   Este capitulo discute os recursos de internacionalizac,ao e localizac,ao
   do FreeBSD. Depois de ler este capitulo, voce sabera:

     * Como os nomes de localidade sao construidos.

     * Como definir a localidade para um login shell.

     * Como configurar o console para idiomas diferentes do ingles.

     * Como configurar o Xorg para diferentes idiomas.

     * Como encontrar aplicativos compativeis com i18n.

     * Onde encontrar mais informac,oes para configurar idiomas especificos.

   Antes de ler este capitulo, voce deve:

     * Saber como instalar aplicativos adicionais de terceiros .

22.2. Usando Localizac,ao

   As configurac,oes de localizac,ao sao baseadas em tres componentes: o
   codigo do idioma, o codigo do pais e a codificac,ao. Nomes de localidade
   sao construidos a partir dessas partes da seguinte maneira:

 LanguageCode_CountryCode.Encoding

   O LanguageCode e o CountryCode sao usados para determinar o pais e a
   variac,ao de linguagem especifica. A Tabela 22.1, "Idiomas Comum e Codigos
   de Pais" apresenta alguns exemplos de LanguageCode_CountryCode:

   Tabela 22.1. Idiomas Comum e Codigos de Pais

        LanguageCode_Country Code                    Descric,ao               
   en_US                                Ingles, Estados Unidos                
   ru_RU                                Russo, Russia                         
   zh_TW                                Chines Tradicional, Taiwan            

   Uma lista completa de localidades disponiveis pode ser encontrada
   digitando:

 % locale -a | more

   Para determinar a configurac,ao atual de localidade:

 % locale

   Conjuntos de caracteres especificos de idioma, como ISO8859-1, ISO8859-15,
   KOI8-R e CP437, sao descritos em multibyte(3). A lista ativa de conjuntos
   de caracteres pode ser encontrada no IANA Registry.

   Alguns idiomas, como Chines ou Japones, nao podem ser representados usando
   caracteres ASCII e requerem uma codificac,ao de idioma estendida usando
   caracteres wide ou multibyte. Exemplos de codificac,oes de wide ou
   multibyte incluem EUC e Big5. Aplicativos mais antigos podem confundir
   essas codificac,oes com caracteres de controle, enquanto aplicativos mais
   novos geralmente reconhecem esses caracteres. Dependendo da
   implementac,ao, os usuarios podem ser obrigados a compilar um aplicativo
   com suporte a caracteres wide ou multibyte, ou configura-lo corretamente.

  Nota:

   O FreeBSD usa codificac,oes de locale compativeis com o Xorg.

   O restante desta sec,ao descreve os varios metodos para configurar a
   localidade em um sistema FreeBSD. A proxima sec,ao discutira as
   considerac,oes para encontrar e compilar aplicativos com suporte a i18n.

  22.2.1. Definindo a Localidade para o Login Shell

   As configurac,oes de localidade sao configuradas no ~/.login_conf do
   usuario ou no arquivo de inicializac,ao do shell do usuario: ~/.profile,
   ~/.bashrc, or ~/.cshrc.

   Duas variaveis de ambiente devem ser definidas:

     * LANG, que define o idioma

     * MM_CHARSET, que define o conjunto de caracteres MIME usado pelos
       aplicativos

   Alem da configurac,ao do shell do usuario, essas variaveis tambem devem
   ser definidas para configurac,oes especificas de aplicativos e
   configurac,oes do Xorg.

   Dois metodos estao disponiveis para fazer as atribuic,oes de variaveis
   necessarias: o metodo classes de login, que e o metodo recomendado, e o
   metodo arquivo de inicializac,ao. As proximas duas sec,oes demonstram como
   usar os dois metodos.

    22.2.1.1. Metodo de Classes de Login

   Este primeiro metodo e o metodo recomendado, pois atribui as variaveis de
   ambiente necessarias para o nome da localidade e os conjuntos de
   caracteres MIME para todos os shell possiveis. Essa configurac,ao pode ser
   executada para cada usuario ou pode ser configurada para todos os usuarios
   pelo superusuario.

   Esse exemplo minimo define as duas variaveis para a codificac,ao Latin-1
   no .login_conf do diretorio inicial de um usuario individual:

 me:\
         :charset=ISO-8859-1:\
         :lang=de_DE.ISO8859-1:

   Aqui esta um exemplo de ~/.login_conf de um usuario que define as
   variaveis para o Chines Tradicional na codificac,ao BIG-5. Mais variaveis
   sao necessarias porque alguns aplicativos nao respeitam corretamente
   variaveis de idioma para o Chines, Japones e Coreano:

 #Users who do not wish to use monetary units or time formats
 #of Taiwan can manually change each variable
 me:\
         :lang=zh_TW.Big5:\
         :setenv=LC_ALL=zh_TW.Big5,LC_COLLATE=zh_TW.Big5,LC_CTYPE=zh_TW.Big5,LC_MESSAGES=zh_TW.Big5,LC_MONETARY=zh_TW.Big5,LC_NUMERIC=zh_TW.Big5,LC_TIME=zh_TW.Big5:\
         :charset=big5:\
         :xmodifiers="@im=gcin": #Set gcin as the XIM Input Server

   Como alternativa, o superusuario pode configurar a localizac,ao para todos
   os usuarios do sistema. As seguintes variaveis no /etc/login.conf sao
   usadas para definir a localidade e o conjunto de caracteres MIME:

 language_name|Account Type Description:\
         :charset=MIME_charset:\
         :lang=locale_name:\
         :tc=default:

   Entao, o exemplo anterior do Latin-1 ficaria assim:

 german|German Users Accounts:\
         :charset=ISO-8859-1:\
         :lang=de_DE.ISO8859-1:\
         :tc=default:

   Veja o login.conf(5) para mais detalhes sobre estas variaveis. Observe que
   ele ja contem a classe russian predefinida.

   Sempre que /etc/login.conf for editado, lembre-se de executar o seguinte
   comando para atualizar o banco de dados de recursos:

 # cap_mkdb /etc/login.conf

      22.2.1.1.1. Utilitarios que Alteram as Classes de Login

   Alem de editar manualmente o /etc/login.conf, varios utilitarios estao
   disponiveis para definir a localidade de usuarios recem-criados.

   Ao usar o vipw para adicionar novos usuarios, especifique o idioma para
   definir a localidade:

 user:password:1111:11:language:0:0:User Name:/home/user:/bin/sh

   Ao usar o adduser para adicionar novos usuarios, o idioma padrao pode ser
   pre-configurado para todos os novos usuarios ou especificado para um
   usuario individual.

   Se todos os novos usuarios usarem o mesmo idioma, configure
   defaultclass=language em /etc/adduser.conf.

   Para substituir essa configurac,ao ao criar um usuario, insira a
   localidade necessaria neste prompt:

 Enter login class: default []:

   ou especifique a localidade ao executar o adduser:

 # adduser -class language

   Se o pw for usado para adicionar novos usuarios, especifique a localidade
   da seguinte forma:

 # pw useradd user_name -L language

   Para alterar a classe de login de um usuario existente, chpass pode ser
   usado. Execute-o como superusuario e fornec,a o nome do usuario para
   edic,ao como argumento.

 # chpass user_name

    22.2.1.2. Metodo de Arquivo de Inicializac,ao do Shell

   Esse segundo metodo nao e recomendado, pois cada shell usado requer
   configurac,ao manual, e cada shell tem um arquivo de configurac,ao
   diferente e uma sintaxe diferente. Como exemplo, para definir o idioma
   Alemao para o shell sh, essas linhas podem ser adicionadas ao ~/.profile
   para definir o shell apenas para esse usuario. Essas linhas tambem podem
   ser adicionadas ao /etc/profile ou /usr/share/skel/dot.profile para
   definir esse shell para todos os usuarios:

 LANG=de_DE.ISO8859-1; export LANG
 MM_CHARSET=ISO-8859-1; export MM_CHARSET

   No entanto, o nome do arquivo de configurac,ao e a sintaxe usada sao
   diferentes para o shell csh. Estas sao as configurac,oes equivalentes para
   o ~/.csh.login, /etc/csh.login, ou /usr/share/skel/dot.login:

 setenv LANG de_DE.ISO8859-1
 setenv MM_CHARSET ISO-8859-1

   Para complicar, a sintaxe necessaria para configurar o Xorg no ~/.xinitrc
   tambem depende do shell. O primeiro exemplo e para o shell sh e o segundo
   e para o shell csh:

 LANG=de_DE.ISO8859-1; export LANG

 setenv LANG de_DE.ISO8859-1

  22.2.2. Configurac,ao do Console

   Varias fontes de localizac,ao estao disponiveis para o console. Para ver
   uma lista de fontes disponiveis, digite ls /usr/share/syscons/fonts. Para
   configurar a fonte do console, especifique o font_name, sem o sufixo .fnt,
   em /etc/rc.conf:

 font8x16=font_name
 font8x14=font_name
 font8x8=font_name

   O keymap e o screenmap podem ser definidos adicionando o seguinte ao
   /etc/rc.conf:

 scrnmap=screenmap_name
 keymap=keymap_name
 keychange="fkey_number sequence"

   Para ver a lista de screenmaps disponiveis, digite ls
   /usr/share/syscons/scrnmaps. Nao inclua o sufixo .scm ao especificar
   screenmap_name. Um screenmap com uma fonte mapeada correspondente
   geralmente e necessario como uma soluc,ao alternativa para expandir o bit
   8 para o 9 na matriz de caracteres de fonte de um adaptador VGA para que
   as letras sejam movidas para fora da area de pseudo-grafia se a fonte da
   tela usar uma coluna de 8 bits.

   Para ver a lista de mapas de teclado disponiveis, digite ls
   /usr/share/syscons/keymaps. Ao especificar o keymap_name, nao inclua o
   sufixo .kbd. Para testar os mapas de teclado sem reinicializar o sistema,
   use kbdmap(1).

   A entrada keychange geralmente e necessaria para programar as teclas de
   func,ao para corresponder ao tipo de terminal selecionado, porque as
   sequencias de teclas de func,ao nao podem ser definidas no mapa de teclas.

   Em seguida, defina o tipo de terminal do console correto em /etc/ttys para
   todas as entradas do terminal virtual. Tabela 22.2, "Tipos de Terminal
   Definidos para Conjuntos de Caracteres" resume os tipos de terminais
   disponiveis:

   Tabela 22.2. Tipos de Terminal Definidos para Conjuntos de Caracteres

            Conjunto de Caracteres                  Tipo de Terminal          
   ISO8859-1 ou ISO8859-15                  cons25l1                          
   ISO8859-2                                cons25l2                          
   ISO8859-7                                cons25l7                          
   KOI8-R                                   cons25r                           
   KOI8-U                                   cons25u                           
   CP437 (VGA padrao)                       cons25                            
   US-ASCII                                 cons25w                           

   Para idiomas com caracteres wide ou multibyte, instale um console para
   esse idioma a partir da Colec,ao de Ports do FreeBSD. Os ports disponiveis
   estao resumidos em Tabela 22.3, "Consoles Disponiveis pela Colec,ao de
   Ports". Uma vez instalado, consulte o pkg-message dos ports ou as paginas
   de manual para instruc,oes de configurac,ao e uso.

   Tabela 22.3. Consoles Disponiveis pela Colec,ao de Ports

                    Idioma                        Localizac,ao do Port        
   Chines Tradicional (BIG-5)               chinese/big5con                   
   Chines/Japones/Coreano                   chinese/cce                       
   Chines/Japones/Coreano                   chinese/zhcon                     
   Japones                                  chinese/kon2                      
   Japones                                  japanese/kon2-14dot               
   Japones                                  japanese/kon2-16dot               

   Se o moused estiver ativado no /etc/rc.conf, uma configurac,ao adicional
   pode ser necessaria. Por padrao, o cursor do mouse do driver syscons(4)
   ocupa o intervalo 0xd0-0xd3 no conjunto de caracteres. Se o idioma usar
   esse intervalo, mova o intervalo do cursor adicionando a seguinte linha ao
   /etc/rc.conf:

 mousechar_start=3

  22.2.3. Configurac,ao do Xorg

   O Capitulo 5, O sistema X Window descreve como instalar e configurar o
   Xorg. Ao configurar localizac,oes no Xorg, fontes adicionais e metodos de
   entrada estao disponiveis na Colec,ao de Ports do FreeBSD. Configurac,oes
   especificas de i18n para aplicac,oes como fontes e menus podem ser tunadas
   em ~/.Xresources e devem permitir que os usuarios visualizem o idioma
   selecionado nos menus das aplicac,oes graficas.

   O protocolo X Input Method (XIM) e um padrao Xorg para inserir caracteres
   nao Ingleses. Tabela 22.4, "Metodos de Entrada Disponiveis" resume os
   metodos de entrada de aplicac,oes que estao disponiveis na Colec,ao de
   Ports do FreeBSD. Aplicativos adicionais Fcitx e Uim tambem estao
   disponiveis.

   Tabela 22.4. Metodos de Entrada Disponiveis

            Idioma                          Metodo de Entrada                 
   Chines                    chinese/gcin                                     
   Chines                    chinese/ibus-chewing                             
   Chines                    chinese/ibus-pinyin                              
   Chines                    chinese/oxim                                     
   Chines                    chinese/scim-fcitx                               
   Chines                    chinese/scim-pinyin                              
   Chines                    chinese/scim-tables                              
   Japones                   japanese/ibus-anthy                              
   Japones                   japanese/ibus-mozc                               
   Japones                   japanese/ibus-skk                                
   Japones                   japanese/im-ja                                   
   Japones                   japanese/kinput2                                 
   Japones                   japanese/scim-anthy                              
   Japones                   japanese/scim-canna                              
   Japones                   japanese/scim-honoka                             
   Japones                   japanese/scim-honoka-plugin-romkan               
   Japones                   japanese/scim-honoka-plugin-wnn                  
   Japones                   japanese/scim-prime                              
   Japones                   japanese/scim-skk                                
   Japones                   japanese/scim-tables                             
   Japones                   japanese/scim-tomoe                              
   Japones                   japanese/scim-uim                                
   Japones                   japanese/skkinput                                
   Japones                   japanese/skkinput3                               
   Japones                   japanese/uim-anthy                               
   Coreano                   korean/ibus-hangul                               
   Coreano                   korean/imhangul                                  
   Coreano                   korean/nabi                                      
   Coreano                   korean/scim-hangul                               
   Coreano                   korean/scim-tables                               
   Vietnamita                vietnamese/xvnkb                                 
   Vietnamita                vietnamese/x-unikey                              

22.3. Encontrando Aplicac,oes i18n

   Aplicac,oes i18n sao programadas usando kits i18n em bibliotecas. Isso
   permite que os desenvolvedores escrevam um arquivo simples e traduzam
   menus e textos exibidos para cada idioma.

   A Colec,ao de Ports do FreeBSD contem muitos aplicativos com suporte
   embutido para caracteres wide ou multibyte para varios idiomas. Tais
   aplicativos incluem i18n em seus nomes para facil identificac,ao. No
   entanto, eles nem sempre suportam o idioma necessario.

   Alguns aplicativos podem ser compilados com o conjunto de caracteres
   especifico. Isso geralmente e feito no Makefile do port ou passando um
   parametro para o configure. Consulte a documentac,ao i18n no codigo fonte
   do respectivo port do FreeBSD para obter mais informac,oes sobre como
   determinar o parametro do configure necessario ou o Makefile do port para
   determinar quais opc,oes de compilac,ao para usar ao compilar o port.

22.4. Configurac,ao de Localizac,ao para Idiomas Especificos

   Esta sec,ao fornece exemplos de configurac,ao para definir a localizac,ao
   de um sistema FreeBSD para o idioma Russo. Em seguida, ele fornece alguns
   recursos adicionais para definir a localizac,ao com outros idiomas.

  22.4.1. Idioma Russo (Codificac,ao KOI8-R)

   Originally contributed by Andrey Chernov.

   Esta sec,ao mostra as configurac,oes especificas necessarias para definir
   a localizac,ao de um sistema FreeBSD para o idioma Russo. Consulte Usando
   Localizac,ao para obter uma descric,ao mais completa de cada tipo de
   configurac,ao.

   Para definir esta localidade para o login shell, adicione as seguintes
   linhas ao ~/.login_conf de cada usuario:

 me:My Account:\
         :charset=KOI8-R:\
         :lang=ru_RU.KOI8-R:

   Para configurar o console, adicione as seguintes linhas ao /etc/rc.conf:

 keymap="ru.koi8-r"
 scrnmap="koi8-r2cp866"
 font8x16="cp866b-8x16"
 font8x14="cp866-8x14"
 font8x8="cp866-8x8"
 mousechar_start=3

   Para cada entrada ttyv em /etc/ttys, use cons25r como o tipo de terminal.

   Para configurar a impressao, e necessario um filtro de saida especial para
   converter de KOI8-R para CP866, pois a maioria das impressoras com
   caracteres Russos vem com a pagina de codigo de hardware CP866. O FreeBSD
   inclui um filtro padrao para este proposito, /usr/libexec/lpr/ru/koi2alt.
   Para usar este filtro, adicione esta entrada ao /etc/printcap:

 lp|Russian local line printer:\
         :sh:of=/usr/libexec/lpr/ru/koi2alt:\
         :lp=/dev/lpt0:sd=/var/spool/output/lpd:lf=/var/log/lpd-errs:

   Consulte printcap(5) para obter uma explicac,ao mais detalhada.

   Para configurar o suporte a nomes de arquivos Russos em sistemas de
   arquivos montados do MS-DOS(R), inclua -L e o nome da localidade ao
   adicionar uma entrada ao /etc/fstab:

 /dev/ad0s2      /dos/c  msdos   rw,-Lru_RU.KOI8-R 0 0

   Consulte mount_msdosfs(8) para mais detalhes.

   Para configurar fontes Russas no Xorg, instale o pacote
   x11-fonts/xorg-fonts-cyrillic. Em seguida, verifique a sec,ao "Files" em
   /etc/X11/xorg.conf. A seguinte linha deve ser adicionada antes de qualquer
   outra entrada FontPath:

 FontPath   "/usr/local/lib/X11/fonts/cyrillic"

   Fontes Cirilicos adicionais estao disponiveis na Colec,ao de Ports.

   Para ativar um teclado Russo, adicione o seguinte `a sec,ao "Keyboard" do
   /etc/xorg.conf:

 Option "XkbLayout"   "us,ru"
 Option "XkbOptions"  "grp:toggle"

   Certifique-se de que XkbDisable esteja comentado nesse arquivo.

   Para grp:toggle use Right Alt, para grp:ctrl_shift_toggle use Ctrl+Shift.
   Para grp:caps_toggle use CapsLock. A antiga func,ao CapsLock ainda esta
   disponivel no modo LAT apenas usando Shift+CapsLock. grp:caps_toggle nao
   funciona no Xorg por alguma razao desconhecida.

   Se o teclado tiver as teclas "Windows(R)" e algumas teclas nao alfabeticas
   mapeadas incorretamente, adicione a seguinte linha ao /etc/xorg.conf:

 Option "XkbVariant" ",winkeys"

  Nota:

   O teclado Russo XKB pode nao funcionar com aplicativos nao localizados.
   Aplicativos minimamente localizados devem chamar uma func,ao
   XtSetLanguageProc (NULL, NULL, NULL); no inicio do programa.

   Veja http://koi8.pp.ru/xwin.html para mais instruc,oes sobre como definir
   a localizac,ao em aplicac,oes Xorg. Para mais informac,oes gerais sobre a
   codificac,ao KOI8-R, consulte http://koi8.pp.ru/.

  22.4.2. Recursos Especificos de Idioma Adicionais

   Esta sec,ao lista alguns recursos adicionais para a configurac,ao de
   outras localidades.

   Chines Tradicional para Taiwan

           O projeto FreeBSD-Taiwan tem um HOWTO em Chines para o FreeBSD em
           http://netlab.cse.yzu.edu.tw/~statue/freebsd/zh-tut/.

   Localizac,ao do Idioma Grego

           Um artigo completo sobre o suporte Grego no FreeBSD esta
           disponivel aqui, somente em Grego, como parte da documentac,ao
           oficial do FreeBSD em Grego.

   Localizac,ao do Idioma Japones e Coreano

           Para Japones, consulte http://www.jp.FreeBSD.org/ e, para Coreano,
           consulte http://www.kr.FreeBSD.org/.

   Documentac,ao do FreeBSD em Outros Idiomas

           Alguns colaboradores do FreeBSD traduziram partes da documentac,ao
           do FreeBSD para outros idiomas. Elas estao disponiveis atraves de
           links no site do FreeBSD ou em /usr/share/doc.

Capitulo 23. Atualizac,ao e Upgrade do FreeBSD

   Reestruturado, reorganizado e partes atualizadas por Jim Mock.
   Trabalho original de Jordan Hubbard , Poul-Henning Kamp, John Polstra e
   Nik Clayton.
   Indice

   23.1. Sinopse

   23.2. Atualizac,ao do FreeBSD

   23.3. Atualizando o Conjunto de Documentac,ao

   23.4. Acompanhando um ramo de desenvolvimento

   23.5. Atualizando o FreeBSD a partir do codigo fonte

   23.6. Atualizac,ao de varias maquinas

23.1. Sinopse

   O FreeBSD esta em constante desenvolvimento entre os releases. Algumas
   pessoas preferem usar as versoes lanc,adas oficialmente, enquanto outras
   preferem se manter em sincronia com os ultimos desenvolvimentos. No
   entanto, ate mesmo versoes oficiais sao atualizadas com patches de
   seguranc,a e outras correc,oes criticas. Independentemente da versao
   usada, o FreeBSD fornece todas as ferramentas necessarias para manter o
   sistema atualizado e permite atualizac,oes faceis entre as versoes. Este
   capitulo descreve como acompanhar o sistema de desenvolvimento e o uso das
   ferramentas basicas para manter um sistema FreeBSD atualizado.

   Depois de ler este capitulo, voce sabera:

     * Como manter um sistema FreeBSD atualizado com o freebsd-update ou com
       o Subversion.

     * Como comparar o estado de um sistema instalado com uma copia original.

     * Como manter a documentac,ao instalada atualizada com o Subversion ou
       com o port da documentac,ao.

     * A diferenc,a entre os dois ramos de desenvolvimento: FreeBSD-STABLE e
       FreeBSD-CURRENT.

     * Como recompilar e reinstalar todo o sistema basico.

   Antes de ler este capitulo, voce deve:

     * Configurar corretamente a conexao de rede (Capitulo 31, Rede
       Avanc,ada).

     * Saber como instalar software adicional de terceiros (Capitulo 4,
       Instalando Aplicativos: Pacotes e Ports).

  Nota:

   Ao longo deste capitulo, o svnlite e usado para obter e atualizar o codigo
   fonte do FreeBSD. Opcionalmente, o port ou pacote devel/subversion pode
   ser usado.

23.2. Atualizac,ao do FreeBSD

   Escrito porTom Rhodes.
   Com base nas notas fornecidas por Colin Percival.

   A aplicac,ao de patches de seguranc,a em tempo habil e a atualizac,ao para
   uma versao mais recente de um sistema operacional sao aspectos importantes
   da administrac,ao continua do sistema. O FreeBSD inclui um utilitario
   chamado freebsd-update o qual pode ser usado para executar ambas as
   tarefas.

   Este utilitario suporta atualizac,oes binarias de seguranc,a e de erratas
   para o FreeBSD, sem a necessidade de compilar e instalar manualmente o
   patch ou um novo kernel. Atualizac,oes binarias estao disponiveis para
   todas as arquiteturas e versoes atualmente suportadas pela equipe de
   seguranc,a. A lista de versoes suportadas e suas datas estimadas de fim de
   vida estao listadas em https://www.FreeBSD.org/security/.

   Este utilitario tambem suporta upgrades do sistema operacional para
   releases menores (ponto x), bem como atualizac,oes para outro ramo de
   release. Antes de atualizar para uma nova versao, revise o seu anuncio de
   lanc,amento, pois ele contem informac,oes importantes pertinentes ao
   release. Os anuncios de lanc,amento estao disponiveis em
   https://www.FreeBSD.org/releases/.

  Nota:

   Se um crontab utilizando os recursos do freebsd-update(8) existir, ele
   deve ser desativado antes de atualizar o sistema operacional .

   Esta sec,ao descreve o arquivo de configurac,ao usado pelo freebsd-update,
   demonstra como aplicar um patch de seguranc,a e como atualizar para um
   release menor ou principal do sistema operacional e discute algumas das
   considerac,oes ao atualizar o sistema operacional .

  23.2.1. O Arquivo de Configurac,ao

   O arquivo de configurac,ao padrao do freebsd-update funciona como esta.
   Alguns usuarios podem querer ajustar a configurac,ao padrao no
   /etc/freebsd-update.conf, permitindo um melhor controle do processo. Os
   comentarios neste arquivo explicam as opc,oes disponiveis, mas os
   seguintes podem exigir um pouco mais de explicac,ao:

 # Componentes do sistema base que devem ser mantidos atualizados.
 Components world kernel

   Este parametro controla quais partes do FreeBSD serao mantidas
   atualizadas. O padrao e atualizar todo o sistema basico e o kernel.
   Componentes individuais podem ser especificados, como src/base ou src/sys.
   No entanto, a melhor opc,ao e deixar isso no padrao, pois altera-lo para
   incluir itens especificos requer que todos os itens necessarios sejam
   listados. Com o tempo, isso pode ter consequencias desastrosas, pois o
   codigo-fonte e os binarios podem ficar fora de sincronia.

 # Caminhos que comec,am com qualquer coisa que corresponda a uma entrada em uma
 # declarac,ao IgnorePaths sera ignorada.
 IgnorePaths /boot/kernel/linker.hints

   Para deixar diretorios especificados, como /bin ou /sbin, intocados
   durante o processo de atualizac,ao, adicione seus caminhos a esta
   instruc,ao. Esta opc,ao pode ser usada para evitar que o freebsd-update
   substitua as modificac,oes locais.

 # Caminhos que comec,am com qualquer coisa que corresponda a uma entrada em uma declarac,ao 
 # UpdateIfUnmodified so sera atualizada se o conteudo do arquivo nao tiver sido
 # modificado pelo usuario (a menos que as alterac,oes sejam mescladas; veja abaixo).
 UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile

   Esta opc,ao atualizara apenas os arquivos de configurac,ao nao modificados
   nos diretorios especificados. Quaisquer alterac,oes feitas pelo usuario
   impedirao a atualizac,ao automatica desses arquivos. Existe outra opc,ao,
   KeepModifiedMetadata, que instruira o freebsd-update para salvar as
   alterac,oes durante a mesclagem.

 # Ao fazer o upgrade para uma nova versao do FreeBSD, os arquivos que forem especificados no MergeChanges
 # terao quaisquer alterac,oes locais mescladas na versao da nova release.
 MergeChanges /etc/ /var/named/etc/ /boot/device.hints

   Lista de diretorios com arquivos de configurac,ao que o freebsd-update
   deve tentar mesclar. O processo de mesclagem de arquivos e uma serie de
   patches diff(1) semelhantes a mergemaster(8), mas com menos opc,oes. As
   mesclagens sao aceitas, abrem um editor ou fazem com que o freebsd-update
   aborte. Em caso de duvida, fac,a backup do /etc e apenas aceite as
   mesclagens. Veja mergemaster(8) para maiores informac,oes sobre o
   mergemaster.

 # Diretorio no qual armazenar atualizac,oes baixadas e arquivos
 # temporarios usados pelo FreeBSD Update.
 # WorkDir /var/db/freebsd-update

   Este diretorio e onde todos os patches e arquivos temporarios sao
   colocados. Nos casos em que o usuario estiver fazendo uma atualizac,ao de
   versao, esse local devera ter pelo menos um gigabyte de espac,o em disco
   disponivel.

 # Ao atualizar entre releases, a lista de Componentes deve ser lida de forma estrita (StrictComponents yes)
 # ou meramente como uma lista de componentes que *podem* ser instalados de quais atualizac,oes do
 # FreeBSD devem ser instaladas e atualizadas (StrictComponents no)?
 # StrictComponents no

   Quando esta opc,ao estiver definida como yes, o freebsd-update assumira
   que a lista Componentes esta completa e nao tentara fazer alterac,oes fora
   da lista. Efetivamente, o freebsd-update tentara atualizar todos os
   arquivos que pertencem `a lista Componentes.

  23.2.2. Aplicando Patches de Seguranc,a

   O processo de aplicac,ao de patches de seguranc,a do FreeBSD foi
   simplificado, permitindo que um administrador mantenha um sistema
   totalmente corrigido usando o freebsd-update. Maiores informac,oes sobre
   os avisos de seguranc,a do FreeBSD podem ser encontradas em Sec,ao 13.11,
   "Avisos de Seguranc,a do FreeBSD".

   Patches de seguranc,a do FreeBSD podem ser baixados e instalados usando os
   seguintes comandos. O primeiro comando determinara se algum patch pendente
   esta disponivel e, em caso afirmativo, listara os arquivos que serao
   modificados se os patches forem aplicados. O segundo comando aplicara os
   patches.

 # freebsd-update fetch
 # freebsd-update install

   Se a atualizac,ao aplicar alguma correc,ao de kernel, o sistema precisara
   de uma reinicializac,ao para inicializar no kernel corrigido. Se o patch
   for aplicado a qualquer binario em execuc,ao, os aplicativos afetados
   devem ser reiniciados para que a versao corrigida do binario seja usada.

  Nota:

   Normalmente, o usuario precisa estar preparado para reiniciar o sistema.
   Para saber se uma reinicializac,ao e necessaria por uma atualizac,ao do
   kernel, execute os comandos freebsd-version -k e uname -r e se eles forem
   diferentes, e necessario reiniciar.

   O sistema pode ser configurado para verificar automaticamente as
   atualizac,oes uma vez por dia, adicionando esta entrada ao /etc/crontab:

 @daily                                  root    freebsd-update cron

   Se houver patches, eles serao automaticamente baixados, mas nao serao
   aplicados. O usuario root recebera um email para que os patches possam ser
   revisados e instalados manualmente com o freebsd-update install.

   Se algo der errado, o freebsd-update tera a capacidade de reverter o
   ultimo conjunto de alterac,oes com o seguinte comando:

 # freebsd-update rollback
 Uninstalling updates... done.

   Novamente, o sistema deve ser reiniciado se o kernel ou qualquer modulo do
   kernel for modificado e quaisquer binarios afetados devem ser reiniciados.

   Apenas o kernel GENERIC pode ser atualizado automaticamente pelo
   freebsd-update. Se um kernel personalizado estiver instalado, ele tera que
   ser recompilado e reinstalado depois que o freebsd-update terminar de
   instalar as atualizac,oes. No entanto, o freebsd-update detectara e
   atualizara o kernel GENERIC se /boot/GENERIC existir, mesmo que nao seja o
   kernel atual em execuc,ao no sistema. Para verificar detalhes desta
   instalac,ao utilize o comando uname(1).

  Nota:

   Sempre mantenha uma copia do kernel GENERIC em /boot/GENERIC. Sera util no
   diagnostico de varios problemas e na execuc,ao de atualizac,oes de versao.
   Consulte Sec,ao 23.2.3.1, "Kernels personalizados com o FreeBSD 9.X e
   posteriores" para obter instruc,oes sobre como obter uma copia do kernel
   GENERIC.

   A menos que a configurac,ao padrao em /etc/freebsd-update.conf tenha sido
   alterada, o freebsd-update instalara o codigo fonte atualizado do kernel
   juntamente com o restante das atualizac,oes. O processo de recompilac,ao e
   reinstalac,ao de um novo kernel personalizado podera ser executado da
   maneira usual.

   As atualizac,oes distribuidas pelo freebsd-update nem sempre envolvem o
   kernel. Nao e necessario recompilar um kernel personalizado se o codigo
   fonte do kernel nao tiverem sido modificado pelo freebsd-update install.
   No entanto, o freebsd-update sempre atualizara o
   /usr/src/sys/conf/newvers.sh. O nivel de patch atual, conforme indicado
   pelo numero -p relatado pelo uname -r, e obtido desse arquivo. Recompilar
   um kernel personalizado, mesmo que nada mais tenha sido alterado, permite
   que o uname relate com precisao o nivel de patch atual do sistema. Isso e
   particularmente util ao manter varios sistemas, pois permite uma
   avaliac,ao rapida das atualizac,oes instaladas em cada um deles.

  23.2.3. Realizando Upgrades de Versao Principais e Menores

   Atualizac,oes de uma versao menor do FreeBSD para outra, como do FreeBSD
   9.0 para o FreeBSD 9.1, sao chamadas de upgrades de versao menor.
   Atualizac,oes de versoes principais ocorrem quando o FreeBSD e atualizado
   de uma versao principal para outra, como do FreeBSD 9.X para o FreeBSD
   10.X. Ambos os tipos de atualizac,oes podem ser executados fornecendo um
   target de versao de release para o freebsd-update .

  Nota:

   Se o sistema estiver executando um kernel personalizado, certifique-se de
   que uma copia do kernel GENERIC exista em /boot/GENERIC antes de iniciar o
   upgrade. Consulte Sec,ao 23.2.3.1, "Kernels personalizados com o FreeBSD
   9.X e posteriores" para obter instruc,oes sobre como obter uma copia do
   kernel GENERIC.

   O seguinte comando, quando executado em um sistema FreeBSD 9.0, ira
   atualiza-lo para o FreeBSD 9.1:

 # freebsd-update -r 9.1-RELEASE upgrade

   Depois que o comando for recebido, o freebsd-update avaliara o arquivo de
   configurac,ao e o sistema atual na tentativa de reunir as informac,oes
   necessarias para executar a atualizac,ao. Uma listagem de tela exibira
   quais componentes foram e quais nao foram detectados. Por exemplo:

 Looking up update.FreeBSD.org mirrors... 1 mirrors found.
 Fetching metadata signature for 9.0-RELEASE from update1.FreeBSD.org... done.
 Fetching metadata index... done.
 Inspecting system... done.

 The following components of FreeBSD seem to be installed:
 kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
 src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
 src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
 world/base world/info world/lib32 world/manpages

 The following components of FreeBSD do not seem to be installed:
 kernel/generic world/catpages world/dict world/doc world/games
 world/proflibs

 Does this look reasonable (y/n)? y

   Neste ponto, o freebsd-update tentara baixar todos os arquivos necessarios
   para a atualizac,ao. Em alguns casos, o usuario pode ser questionado sobre
   o que instalar ou como proceder.

   Ao usar um kernel personalizado, a etapa acima produzira um aviso
   semelhante ao seguinte:

 WARNING: This system is running a "MYKERNEL" kernel, which is not a
 kernel configuration distributed as part of FreeBSD 9.0-RELEASE.
 This kernel will not be updated: you MUST update the kernel manually
 before running "/usr/sbin/freebsd-update install"

   Este aviso pode ser ignorado com seguranc,a neste momento. O kernel
   GENERIC atualizado sera usado como uma etapa intermediaria no processo de
   atualizac,ao.

   Depois que todos os patches tiverem sido baixados para o sistema local,
   eles serao aplicados. Esse processo pode demorar um pouco, dependendo da
   velocidade e da carga de trabalho da maquina. Os arquivos de configurac,ao
   serao entao mesclados. O processo de mesclagem requer alguma intervenc,ao
   do usuario, pois um arquivo pode ser mesclado ou um editor pode aparecer
   na tela para uma mesclagem manual. Os resultados de cada mesclagem
   bem-sucedida serao mostrados para o usuario enquanto o processo continua.
   Um merge falho ou ignorado fara com que o processo seja abortado. Os
   usuarios podem desejar fazer um backup de /etc e mesclar manualmente os
   arquivos importantes, como o master.passwd ou o group posteriormente.

  Nota:

   O sistema nao esta sendo alterado, ja que todos os patches e merges estao
   acontecendo em outro diretorio. Uma vez que todas as correc,oes tenham
   sido aplicadas com sucesso, e todos os arquivos de configurac,ao foram
   mesclados e tudo indicar que o processo ocorrera sem problemas, as
   alterac,oes poderao ser confirmadas pelo usuario usando o seguinte
   comando:

 # freebsd-update install

   O kernel e os modulos do kernel serao atualizados primeiro. Se o sistema
   estiver sendo executado com um kernel personalizado, use o nextboot(8)
   para definir que o kernel para a proxima inicializac,ao sera o
   /boot/GENERIC:

 # nextboot -k GENERIC

  Atenc,ao:

   Antes de reinicializar com o kernel GENERIC, verifique se ele contem todos
   os drivers necessarios para o sistema inicializar corretamente e se
   conectar `a rede, se a maquina que esta sendo atualizada for acessada
   remotamente. Em particular, se o kernel customizado em execuc,ao contiver
   funcionalidades internas normalmente fornecidas pelos modulos do kernel,
   certifique-se de carregar temporariamente estes modulos no kernel GENERIC
   usando o /boot/loader.conf. Recomenda-se desabilitar os servic,os nao
   essenciais, bem como todas as montagens de disco e de rede, ate que o
   processo de atualizac,ao seja concluido.

   A maquina agora deve ser reiniciada com o kernel atualizado:

 # shutdown -r now

   Quando o sistema estiver on-line, reinicie o freebsd-update usando o
   comando a seguir. Como o estado do processo foi salvo, o freebsd-update
   nao sera iniciado desde o inicio, mas passara para a proxima fase e
   removera todas as bibliotecas compartilhadas e os arquivos de objetos
   antigos.

 # freebsd-update install

  Nota:

   Dependendo se os numeros de versao de uma biblioteca foram incrementados
   ou nao, pode haver apenas duas fases de instalac,ao em vez de tres.

   A atualizac,ao esta completa agora. Se esta for uma atualizac,ao de versao
   principal, reinstale todas os ports e pacotes conforme descrito em
   Sec,ao 23.2.3.2, "Atualizando pacotes apos atualizar para uma versao
   principal (Major Release)".

    23.2.3.1. Kernels personalizados com o FreeBSD 9.X e posteriores

   Antes de usar o freebsd-update, assegure-se de que uma copia do kernel
   GENERIC exista em /boot/GENERIC. Se um kernel personalizado foi compilado
   apenas uma vez, o kernel em /boot/kernel.old e o kernel GENERIC.
   Simplesmente renomeie este diretorio para /boot/kernel.

   Se um kernel personalizado foi compilado mais de uma vez ou se e
   desconhecido quantas vezes o kernel personalizado foi compilado, obtenha
   uma copia do kernel GENERIC que corresponda `a versao atual do sistema
   operacional. Se o acesso fisico ao sistema estiver disponivel, uma copia
   do kernel GENERIC pode ser instalada a partir da midia de instalac,ao:

 # mount /cdrom
 # cd /cdrom/usr/freebsd-dist
 # tar -C/ -xvf kernel.txz boot/kernel/kernel

   Como alternativa, o kernel GENERIC pode ser recriado e instalado a partir
   da do codigo fonte:

 # cd /usr/src
 # make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null

   Para que este kernel seja identificado como o kernel GENERIC pelo
   freebsd-update, o arquivo de configurac,ao GENERIC nao deve ter sido
   modificado de forma alguma. Tambem e sugerido que o kernel seja compilado
   sem outras opc,oes especiais.

   A reinicializac,ao no kernel GENERIC nao e necessaria, pois o
   freebsd-update so precisa que o /boot/GENERIC exista.

    23.2.3.2. Atualizando pacotes apos atualizar para uma versao principal
    (Major Release)

   Geralmente, os aplicativos instalados continuarao funcionando sem
   problemas apos atualizac,oes de versoes menores. As versoes principais
   usam diferentes interfaces binarias de aplicativos (ABIs), que quebram a
   maioria dos aplicativos de terceiros. Apos uma atualizac,ao de versao
   principal, todos os pacotes e ports instalados precisam ser atualizados.
   Pacotes podem ser atualizados usando pkg upgrade. Para atualizar os ports
   instalados, use um utilitario como o ports-mgmt/portmaster.

   Uma atualizac,ao forc,ada de todos os pacotes instalados substituira os
   pacotes por novas versoes a partir do repositorio, mesmo que o numero da
   versao nao tenha aumentado. Isso e necessario por causa da alterac,ao da
   versao do ABI que ocorre ao atualizar entre versoes principais do FreeBSD.
   A atualizac,ao forc,ada pode ser realizada executando:

 # pkg-static upgrade -f

   Uma recompilac,ao de todos os aplicativos instalados pode ser realizada
   com este comando:

 # portmaster -af

   Este comando exibira as telas de configurac,ao de cada aplicativo que
   possui opc,oes configuraveis e aguardara que o usuario interaja com estas
   telas. Para evitar esse comportamento e usar apenas as opc,oes padroes,
   inclua -G no comando acima.

   Quando as atualizac,oes de software estiverem concluidas, conclua o
   processo de atualizac,ao com uma chamada final para o freebsd-update para
   amarrar todas as pontas soltas no processo de atualizac,ao:

 # freebsd-update install

   Se o kernel GENERIC foi usado temporariamente, este e o momento de
   construir e instalar um novo kernel personalizado usando as instruc,oes do
   Capitulo 8, Configurando o kernel do FreeBSD.

   Reinicialize a maquina na nova versao do FreeBSD. O processo de
   atualizac,ao esta concluido agora.

  23.2.4. Comparac,ao do estado do sistema

   O estado da versao instalada do FreeBSD em relac,ao a uma boa copia
   conhecida pode ser testado usando o freebsd-update IDS. Este comando
   avalia a versao atual dos utilitarios do sistema, bibliotecas e arquivos
   de configurac,ao e pode ser usado como um Sistema de Detecc,ao de Intrusao
   embutido (IDS).

  Atenc,ao:

   Este comando nao e um substituto para um IDS real como o security/snort.
   Como o freebsd-update armazena dados no disco, a possibilidade de
   adulterac,ao e evidente. Embora esta possibilidade possa ser reduzida
   usando o kern.securelevel e armazenando os dados do freebsd-update em um
   sistema de arquivos read-only quando nao estiver em uso, uma soluc,ao
   melhor seria comparar o sistema com um disco seguro, como um DVD ou
   dispositivo de disco externo USB armazenado em seguranc,a. Um metodo
   alternativo para fornecer a funcionalidade de IDS usando um utilitario
   interno e descrito em Sec,ao 13.2.6, "Verificac,ao Binaria"

   Para comec,ar a comparac,ao, especifique um arquivo de saida para salvar
   os resultados:

 # freebsd-update IDS >> outfile.ids

   O sistema agora sera inspecionado e uma longa lista de arquivos, junto com
   os valores de hash SHA256 tanto para o valor conhecido na release e como
   na instalac,ao atual, sera enviada para o arquivo de saida especificado.

   As entradas na listagem sao extremamente longas, mas o formato de saida
   pode ser facilmente analisado. Por exemplo, para obter uma lista de todos
   os arquivos que diferem daqueles na release, execute o seguinte comando:

 # cat outfile.ids | awk '{ print $1 }' | more
 /etc/master.passwd
 /etc/motd
 /etc/passwd
 /etc/pf.conf

   Este exemplo de saida foi truncado, pois existem muito mais arquivos.
   Alguns arquivos possuem modificac,oes naturais. Por exemplo, o /etc/passwd
   sera modificado se usuarios tiverem sido adicionados ao sistema. Modulos
   de kernel podem diferir pois o freebsd-update pode te-los atualizado. Para
   excluir arquivos ou diretorios especificos, adicione-os `a opc,ao
   IDSIgnorePaths em /etc/freebsd-update.conf.

23.3. Atualizando o Conjunto de Documentac,ao

   A documentac,ao e parte integrante do sistema operacional FreeBSD.
   Enquanto uma versao atualizada da documentac,ao do FreeBSD esta sempre
   disponivel no site do FreeBSD (https://www.freebsd.org/doc/), pode ser
   util ter uma copia local atualizada do site do FreeBSD, manuais, FAQ e
   artigos.

   Esta sec,ao descreve como usar os fontes ou a Colec,ao de Ports do FreeBSD
   para manter uma copia local da documentac,ao do FreeBSD atualizada.

   Para obter informac,oes sobre como editar e enviar correc,oes para a
   documentac,ao, consulte o Primer do Projeto de Documentac,ao do FreeBSD
   para Novos Colaboradores
   (https://www.freebsd.org/doc/en_US.ISO8859-1/books/fdp-primer/).

  23.3.1. Atualizando a documentac,ao a partir do codigo-fonte

   Recompilar a documentac,ao do FreeBSD a partir do codigo-fonte requer uma
   colec,ao de ferramentas que nao fazem parte do sistema basico do FreeBSD.
   As ferramentas necessarias podem ser instaladas a partir do pacote
   textproc/docproj ou do port desenvolvido pelo Projeto de Documentac,ao do
   FreeBSD.

   Uma vez instalado, use o svnlite para buscar uma copia limpa dos fontes da
   documentac,ao:

 # svnlite checkout https://svn.FreeBSD.org/doc/head /usr/doc

   O download inicial dos fontes da documentac,ao pode demorar um pouco.
   Deixe executar ate completar.

   Futuras atualizac,oes dos fontes da documentac,ao podem ser obtidas
   executando:

 # svnlite update /usr/doc

   Depois que um snapshot atualizado dos fontes da documentac,ao for obtido e
   disponibilizado em /usr/doc, tudo estara pronto para uma atualizac,ao da
   documentac,ao instalada.

   Uma atualizac,ao completa de todos os idiomas disponiveis pode ser
   realizada digitando:

 # cd /usr/doc
 # make install clean

   Se uma atualizac,ao de apenas um idioma especifico for desejada, o make
   pode ser executado em um subdiretorio especifico de idioma do /usr/doc:

 # cd /usr/doc/en_US.ISO8859-1
 # make install clean

   Uma maneira alternativa de atualizar a documentac,ao e executar este
   comando a partir do /usr/doc ou do subdiretorio especifico do idioma
   desejado:

 # make update

   Os formatos de saida que serao instalados podem ser especificados
   definindo o parametro FORMATS:

 # cd /usr/doc
 # make FORMATS='html html-split' install clean

   Varias opc,oes estao disponiveis para facilitar o processo de atualizac,ao
   de apenas partes da documentac,ao ou a construc,ao de traduc,oes
   especificas. Estas opc,oes podem ser configuradas como opc,oes de todo o
   sistema no /etc/make.conf, ou como opc,oes de linha de comando passadas
   para o make.

   As opc,oes incluem:

   DOC_LANG

           A lista de idiomas e codificac,oes para compilar e instalar, como
           en_US.ISO8859-1 para documentac,ao em ingles.

   FORMATS

           Um formato unico ou uma lista de formatos de saida a serem
           criados. Atualmente os formatos suportados sao, html, html-split,
           txt, ps, e pdf.

   DOCDIR

           Onde instalar a documentac,ao. O padrao e /usr/share/doc.

   Para mais variaveis do make suportadas como opc,oes system-wide no
   FreeBSD, consulte make.conf(5).

  23.3.2. Atualizando a documentac,ao a partir do ports

   Baseado no trabalho de Marc Fonvieille.

   A sec,ao anterior apresentou um metodo para atualizar a documentac,ao do
   FreeBSD a partir do codigo fonte. Esta sec,ao descreve um metodo
   alternativo que usa a Colec,ao de Ports e possibilita:

     * Instalar pacotes pre-compilados da documentac,ao, sem precisar
       compilar nada localmente ou instalar o conjunto de ferramentas de
       documentac,ao.

     * Compilar o codigo fonte da documentac,ao por meio do framework de
       ports, facilitando o check-out e as etapas de compilac,ao.

   Este metodo de atualizac,ao da documentac,ao do FreeBSD e suportado por um
   conjunto de ports e pacotes de documentac,ao que sao atualizados
   mensalmente pela Equipe de Engenharia da Documentac,ao
   <doceng@FreeBSD.org>. Eles estao listados na Colec,ao de Ports do FreeBSD,
   na categoria docs (http://www.freshports.org/docs/).

   A organizac,ao dos ports de documentac,ao e a seguinte:

     * O pacote ou port misc/freebsd-doc-en instala toda a documentac,ao em
       ingles.

     * O meta-pacote ou port do pacote misc/freebsd-doc-all instala toda a
       documentac,ao em todos os idiomas disponiveis.

     * Existe um pacote e um port para cada traduc,ao, como
       misc/freebsd-doc-hu para a documentac,ao hungara.

   Quando pacotes binarios sao usados, a documentac,ao do FreeBSD sera
   instalada em todos os formatos disponiveis para o idioma especificado. Por
   exemplo, o comando a seguir instalara o pacote mais recente da
   documentac,ao em hungaro:

 # pkg install hu-freebsd-doc

  Nota:

   Os pacotes usam um formato que difere do nome do port correspondente:
   lang-freebsd-doc, onde lang e o formato abreviado do codigo de idioma,
   como hu para hungaro, ou zh_cn para chines simplificado.

   Para especificar o formato da documentac,ao, compile o port em vez de
   instalar o pacote. Por exemplo, para compilar e instalar a documentac,ao
   em ingles:

 # cd /usr/ports/misc/freebsd-doc-en
 # make install clean

   O port fornece um menu de configurac,ao no qual o formato para compilar e
   instalar pode ser especificado. Por padrao, o HTML dividido, semelhante ao
   formato usado em http://www.FreeBSD.org e o PDF estao selecionados.

   Alternativamente, varias opc,oes make podem ser especificadas ao compilar
   um port de documentac,ao, incluindo:

   WITH_HTML

           Cria o formato HTML com um unico arquivo HTML por documento. A
           documentac,ao formatada e salva em um arquivo chamado article.html
           ou book.html.

   WITH_PDF

           A documentac,ao formatada e salva em um arquivo chamado article.pd
           ou book.pdf.

   DOCBASE

           Especifica onde instalar a documentac,ao. O padrao e
           /usr/local/share/doc/freebsd.

   Este exemplo usa variaveis para instalar a documentac,ao hungara como um
   arquivo PDF no diretorio especificado:

 # cd /usr/ports/misc/freebsd-doc-hu
 # make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean

   Pacotes ou ports de documentac,ao podem ser atualizados usando as
   instruc,oes em Capitulo 4, Instalando Aplicativos: Pacotes e Ports. Por
   exemplo, o seguinte comando atualiza a documentac,ao hungara instalada
   usando ports-mgmt/portmaster atraves do uso apenas de pacotes:

 # portmaster -PP hu-freebsd-doc

23.4. Acompanhando um ramo de desenvolvimento

   O FreeBSD possui duas ramificac,oes de desenvolvimento: FreeBSD-CURRENT e
   FreeBSD-STABLE.

   Esta sec,ao fornece uma explicac,ao sobre cada ramo e seu publico-alvo,
   bem como manter um sistema atualizado com cada ramo respectivo.

  23.4.1. Usando o FreeBSD-CURRENT

   O FreeBSD-CURRENT e o desenvolvimento "bleeding edge" do FreeBSD e
   espera-se que os usuarios do FreeBSD-CURRENT tenham um alto grau de
   habilidade tecnica. Usuarios menos tecnicos que desejam acompanhar um ramo
   de desenvolvimento devem acompanhar o FreeBSD-STABLE.

   O FreeBSD-CURRENT e o codigo-fonte mais recente do FreeBSD e inclui
   trabalhos em andamento, mudanc,as experimentais e mecanismos de transic,ao
   que podem ou nao estar presentes na proxima versao oficial. Enquanto
   muitos desenvolvedores do FreeBSD compilam o codigo-fonte do
   FreeBSD-CURRENT diariamente, ha curtos periodos de tempo em que o codigo
   fonte pode nao ser compilavel. Esses problemas sao resolvidos o mais
   rapidamente possivel, mas se o FreeBSD-CURRENT traz ou nao uma nova
   funcionalidade pode ser uma questao de quando o codigo-fonte foi
   sincronizado.

   O FreeBSD-CURRENT e disponibilizado para tres grupos de interesse
   principais:

    1. Membros da comunidade do FreeBSD que estao trabalhando ativamente em
       alguma parte da arvore de codigos fontes.

    2. Membros da comunidade FreeBSD que sao testadores ativos. Eles estao
       dispostos a gastar tempo resolvendo problemas, fazendo sugestoes sobre
       mudanc,as e sobre a direc,ao geral do FreeBSD, e enviando correc,oes.

    3. Usuarios que desejam ficar de olho nas coisas, usam o codigo fonte
       atual para fins de referencia ou fazem comentarios ocasionais ou
       contribuic,oes de codigo.

   O FreeBSD-CURRENT nao deve ser considerado um fast-track para obter novos
   recursos antes do proximo release, ja que os recursos de pre-release ainda
   nao foram totalmente testados e provavelmente contem bugs. Nao e uma
   maneira rapida de obter correc,oes de bugs, pois qualquer commit e tao
   provavel de introduzir novos bugs quanto consertar os existentes. O
   FreeBSD-CURRENT nao e de nenhuma maneira "oficialmente suportado".

   Para acompanhar o FreeBSD-CURRENT:

    1. Junte-se as listas freebsd-current e svn-src-head. Isto e essencial
       para ver os comentarios que as pessoas estao fazendo sobre o estado
       atual do sistema e para receber importantes boletins sobre o estado
       atual do FreeBSD-CURRENT.

       A lista svn-src-head registra a entrada de log de commit para cada
       alterac,ao assim que ela e feita, juntamente com qualquer informac,ao
       pertinente sobre possiveis efeitos colaterais.

       Para juntar-se a estas listas, va para
       http://lists.FreeBSD.org/mailman/listinfo, clique na lista para se
       inscrever e siga as instruc,oes. A fim de rastrear mudanc,as em toda a
       arvore de codigo-fonte, nao apenas as mudanc,as no FreeBSD-CURRENT,
       inscreva-se na lista svn-src-all.

    2. Sincronize com o codigo-fonte do FreeBSD-CURRENT. Normalmente, o
       svnlite e usado para obter o codigo -CURRENT da ramificac,ao head de
       um dos sites espelhos do Subversion listados em Sec,ao A.3.6, "Sites
       Espelho do Subversion".

    3. Devido ao tamanho do repositorio, alguns usuarios escolhem sincronizar
       apenas as sec,oes do codigo-fonte que lhes interessam ou para as quais
       estao contribuindo com correc,oes. No entanto, os usuarios que
       planejam compilar o sistema operacional a partir do codigo-fonte devem
       baixar tudo do FreeBSD-CURRENT, nao apenas as partes selecionadas.

       Antes de compilar o FreeBSD-CURRENT , leia o /usr/src/Makefile com
       muito cuidado e siga as instruc,oes em Sec,ao 23.5, "Atualizando o
       FreeBSD a partir do codigo fonte". Leia a lista de discussao do
       FreeBSD-CURRENT e o /usr/src/UPDATING para manter-se atualizado sobre
       outros procedimentos de bootstrapping que algumas vezes se tornam
       necessarios no caminho para a proxima versao.

    4. Ser ativo! Usuarios do FreeBSD-CURRENT sao encorajados a enviar suas
       sugestoes para melhorias ou correc,oes de bugs. Sugestoes acompanhadas
       de codigo sao sempre bem vindas.

  23.4.2. Usando o FreeBSD-STABLE

   O FreeBSD-STABLE e o ramo de desenvolvimento a partir do qual as releases
   principais sao feitas. Mudanc,as entram neste ramo em um ritmo mais lento
   e com a suposic,ao geral de que elas foram testadas primeiro no
   FreeBSD-CURRENT. Ele ainda e um ramo de desenvolvimento e, a qualquer
   momento, as fontes para o FreeBSD-STABLE podem ou nao ser adequadas para
   uso geral. E simplesmente outra trilha de desenvolvimento de engenharia,
   nao um recurso para usuarios finais. Usuarios que nao possuem recursos
   para realizar testes devem, ao inves disso, executar a release mais
   recente do FreeBSD.

   Os interessados em acompanhar ou contribuir para o processo de
   desenvolvimento do FreeBSD, especialmente no que se refere `a proxima
   versao do FreeBSD, devem considerar seguir o FreeBSD-STABLE.

   Embora seja esperado que o ramo FreeBSD-STABLE compile e execute o tempo
   todo, isso nao pode ser garantido. Uma vez que mais pessoas executam o
   FreeBSD-STABLE do que o FreeBSD-CURRENT, e inevitavel que bugs e problemas
   mais raros `as vezes sejam encontrados no FreeBSD-STABLE os quais nao
   foram detectados no FreeBSD-CURRENT. Por esta razao, nao se deve seguir
   cegamente o FreeBSD-STABLE. E particularmente importante nao atualizar
   quaisquer servidores de produc,ao para o FreeBSD-STABLE sem testar
   completamente o codigo em um ambiente de desenvolvimento ou de teste.

   Para acompanhar o FreeBSD-STABLE:

    1. Junte-se `a lista freebsd-stable para se manter informado sobre as
       dependencias de compilac,ao que podem aparecer no FreeBSD-STABLE ou
       qualquer outro problema que requeira atenc,ao especial. Os
       desenvolvedores tambem farao anuncios nesta lista de e-mails quando
       estiverem contemplando alguma correc,ao ou atualizac,ao controversa,
       dando aos usuarios uma chance de responder se tiverem alguma questao a
       ser levantada sobre a alterac,ao proposta.

       Junte-se `a lista svn relevante para o ramo que esta sendo
       acompanhado. Por exemplo, os usuarios que acompanham o ramo 9-STABLE
       devem se juntar a lista svn-src-stable-9. Esta lista registra a
       entrada do log de commit para cada alterac,ao `a medida que ela e
       feita, junto com qualquer informac,ao pertinente sobre os possiveis
       efeitos colaterais.

       Para se juntar a estas listas, va para
       http://lists.FreeBSD.org/mailman/listinfo, clique na lista para se
       inscrever e siga as instruc,oes. Se desejar acompanhar as mudanc,as
       para toda a arvore de codigo-fonte, inscreva-se na svn-src-all .

    2. Para instalar um novo sistema FreeBSD-STABLE, instale a versao mais
       recente do FreeBSD-STABLE a partir de um dos sites espelho do FreeBSD
       ou use um snapshot mensal criado a partir do FreeBSD-STABLE. Consulte
       www.freebsd.org/snapshots para maiores informac,oes sobre snapshots.

       Para compilar ou atualizar um sistema FreeBSD existente para o
       FreeBSD-STABLE, use o svn para obter o codigo-fonte da ramificac,ao
       desejada. Os nomes das ramificac,oes, como stable/9, estao listados em
       www.freebsd.org/releng.

    3. Antes de compilar ou atualizar para o FreeBSD-STABLE , leia o
       /usr/src/Makefile cuidadosamente e siga as instruc,oes em Sec,ao 23.5,
       "Atualizando o FreeBSD a partir do codigo fonte". Leia a lista de
       discussao FreeBSD-STABLE e o /usr/src/UPDATING para manter-se
       atualizado sobre outros procedimentos de bootstrapping que `as vezes
       se tornam necessarios no caminho para o proximo release.

23.5. Atualizando o FreeBSD a partir do codigo fonte

   A atualizac,ao do FreeBSD atraves da compilac,ao a partir do codigo-fonte
   oferece varias vantagens sobre as atualizac,oes binarias. O codigo pode
   ser compilado com opc,oes para aproveitar o hardware especifico. Partes do
   sistema base podem ser compiladas com configurac,oes nao padroes, ou
   deixadas de fora somente onde nao sao necessarias ou desejadas. O processo
   de compilac,ao leva mais tempo para atualizar um sistema do que apenas
   instalar atualizac,oes binarias, mas permite customizac,ao completa para
   produzir uma versao do FreeBSD adaptada as suas necessidades.

  23.5.1. Inicio Rapido

   Esta e uma referencia rapida para as etapas tipicas usadas para atualizar
   o FreeBSD compilando-o a partir do codigo fonte. As sec,oes posteriores
   descrevem o processo com mais detalhes.

     * Atualizar e Compilar

 # svnlite update /usr/src  1
 check /usr/src/UPDATING  2
 # cd /usr/src          3
 # make -j4 buildworld  4
 # make -j4 kernel      5
 # shutdown -r now      6
 # cd /usr/src          7
 # make installworld    8
 # mergemaster -Ui      9
 # shutdown -r now      10

       1  Obtenha a versao mais recente do codigo fonte. Veja Sec,ao 23.5.3,  
          "Atualizando o codigo fonte" para maiores informac,oes sobre como   
          obter e atualizar o codigo fonte.                                   
       2  Verifique o /usr/src/UPDATING para quaisquer etapas manuais         
          necessarias antes ou depois de compilar a partir do codigo fonte.   
       3  Va para o diretorio de origem.                                      
       4  Compile o mundo, tudo exceto o kernel.                              
       5  Compile e instale o kernel. Isso e equivalente a make installkernel 
          installkernel.                                                      
       6  Reinicialize o sistema com o novo kernel.                           
       7  Va para o diretorio de origem.                                      
       8  Instale o mundo.                                                    
       9  Atualize e mescle os arquivos de configurac,ao em /etc/.            
       10 Reinicie o sistema para usar o mundo e o kernel recem-compilados.   

  23.5.2. Preparando-se para uma atualizac,ao a partir do codigo fonte

   Leia o /usr/src/UPDATING. Quaisquer etapas manuais que devem ser
   executadas antes ou depois de uma atualizac,ao sao descritas neste
   arquivo.

  23.5.3. Atualizando o codigo fonte

   O codigo fonte do FreeBSD esta localizado em /usr/src/. O metodo preferido
   para atualizar os fontes e atraves do sistema de controle de versao do
   Subversion. Verifique se o codigo-fonte esta sob controle de versao:

 # svnlite info /usr/src
 Path: /usr/src
 Working Copy Root Path: /usr/src
 ...

   Isto indica que o /usr/src/ esta sob controle de versao e pode ser
   atualizado com o svnlite(1):

 # svnlite update /usr/src

   O processo de atualizac,ao pode levar algum tempo se o diretorio nao tiver
   sido atualizado recentemente. Apos a conclusao, o codigo-fonte estara
   atualizado e o processo de compilac,ao descrito na proxima sec,ao podera
   comec,ar.

  Obtendo o codigo fonte:

   Se a saida disser que '/usr/src' is not a working copy, estao faltando
   arquivos no diretorio ou eles foram instalados com um metodo diferente. Um
   novo checkout da fonte e necessario.

   Tabela 23.1. Versoes do FreeBSD e Caminhos do Repositorio

   +------------------------------------------------------------------------+
   | Saida do uname |   Caminho do    |             Descric,ao              |
   |       -r       |   Repositorio   |                                     |
   |----------------+-----------------+-------------------------------------|
   |                |                 | A versao do release mais apenas     |
   |                |                 | correc,oes criticas de seguranc,a e |
   | X.Y-RELEASE    | base/releng/X.Y | correc,ao de erros. Este ramo e     |
   |                |                 | recomendado para a maioria dos      |
   |                |                 | usuarios.                           |
   |----------------+-----------------+-------------------------------------|
   |                |                 | A versao de Release mais todos os   |
   |                |                 | desenvolvimentos adicionais nesse   |
   |                |                 | ramo. O STABLE refere-se `a         |
   |                |                 | interface binaria de aplicativos    |
   |                |                 | (ABI) nao sendo alterada, portanto, |
   |                |                 | o software compilado para versoes   |
   |                |                 | anteriores ainda e executado. Por   |
   |                |                 | exemplo, o software compilado para  |
   | X.Y-STABLE     | base/stable/X   | rodar no FreeBSD 10.1 ainda rodara  |
   |                |                 | no FreeBSD 10-STABLE compilado      |
   |                |                 | posteriormente.                     |
   |                |                 |                                     |
   |                |                 | Os ramos STABLE ocasionalmente      |
   |                |                 | possuem bugs ou incompatibilidades  |
   |                |                 | que podem afetar os usuarios,       |
   |                |                 | embora sejam normalmente corrigidos |
   |                |                 | rapidamente.                        |
   |----------------+-----------------+-------------------------------------|
   |                |                 | A mais recente versao de            |
   |                |                 | desenvolvimento do FreeBSD. A       |
   | X-CURRENT      | base/head/      | ramificac,ao CURRENT pode ter       |
   |                |                 | grandes erros ou incompatibilidades |
   |                |                 | e e recomendada apenas para         |
   |                |                 | usuarios avanc,ados.                |
   +------------------------------------------------------------------------+

   Determine qual versao do FreeBSD esta sendo usada com uname(1):

 # uname -r
 10.3-RELEASE

   Baseado em Tabela 23.1, "Versoes do FreeBSD e Caminhos do Repositorio", a
   fonte usada para atualizar 10.3-RELEASE tem como caminho de repositorio
   base/releng/10.3. Este caminho e usado ao verificar a fonte:

 # mv /usr/src /usr/src.bak  1
 # svnlite checkout https://svn.freebsd.org/base/releng/10.3 /usr/src  2

   1 Mova o diretorio antigo para fora do caminho. Se nao houver              
     modificac,oes locais nesse diretorio, ele podera ser excluido.           
   2 O caminho da Tabela 23.1, "Versoes do FreeBSD e Caminhos do Repositorio" 
     e adicionado a URL repositorio . O terceiro parametro e o diretorio de   
     destino do codigo-fonte no sistema local.                                

  23.5.4. Compilando a partir do codigo-fonte

   O world, ou todo o sistema operacional, exceto o kernel, e compilado. Isso
   e feito primeiro para fornecer ferramentas atualizadas para construir o
   kernel. Entao o proprio kernel e construido:

 # cd /usr/src
 # make buildworld
 # make buildkernel

   O codigo compilado e escrito em /usr/obj.

   Estes sao os passos basicos. Opc,oes adicionais para controlar a
   compilac,ao sao descritas abaixo.

    23.5.4.1. Executando uma compilac,ao limpa

   Algumas versoes do sistema de compilac,ao do FreeBSD deixam o codigo
   previamente compilado no diretorio de objetos temporarios, /usr/obj. Isso
   pode acelerar as compilac,oes posteriores, evitando recompilar o codigo
   que nao foi alterado. Para forc,ar uma reconstruc,ao limpa de tudo, use
   cleanworld antes de iniciar uma construc,ao:

 # make cleanworld

    23.5.4.2. Definindo o Numero de Jobs

   Aumentar o numero de jobs de compilac,ao em processadores com varios
   nucleos pode melhorar a velocidade de construc,ao. Determine o numero de
   nucleos com sysctl hw.ncpu. Os processadores variam, assim como os
   sistemas de compilac,ao usados com diferentes versoes do FreeBSD,
   portanto, o teste e o unico metodo seguro para determinar como um numero
   diferente de tarefas afeta a velocidade de compilac,ao. Como ponto de
   partida, considere valores entre metade e o dobro do numero de nucleos. O
   numero de jobs e especificado com a opc,ao -j.

   Exemplo 23.1. Aumentando o numero de jobs de compilac,ao

   Compilando o mundo e o kernel com quatro jobs:

 # make -j4 buildworld buildkernel

    23.5.4.3. Compilando Apenas o Kernel

   Um buildworld deve ser completado se o codigo-fonte for alterado. Depois
   disso, um buildkernel para compilar um kernel pode ser executado a
   qualquer momento. Para compilar apenas o kernel:

 # cd /usr/src
 # make buildkernel

    23.5.4.4. Compilando um Kernel Customizado

   O kernel padrao do FreeBSD e baseado em um arquivo de configurac,ao do
   kernel chamado GENERIC. O kernel GENERIC inclui os drivers e opc,oes de
   dispositivos mais comumente necessarios. As vezes, e util ou necessario
   criar um kernel personalizado, adicionando ou removendo drivers de
   dispositivo ou opc,oes para atender a uma necessidade especifica.

   Por exemplo, alguem que desenvolve um pequeno computador embarcado com RAM
   severamente limitada pode remover drivers de dispositivo desnecessarios ou
   opc,oes para tornar o kernel um pouco menor.

   Os arquivos de configurac,ao do Kernel estao localizados em
   /usr/src/sys/arch/conf/, onde arch e a saida do uname - m. Na maioria dos
   computadores, a saida sera amd64, resultando no diretorio de arquivos de
   configurac,ao /usr/src/sys/amd64/conf/.

  Dica:

   O /usr/src pode ser deletado ou recriado, entao e preferivel manter os
   arquivos de configurac,ao do kernel em um diretorio separado, como por
   exemplo em /root. Vincule o arquivo de configurac,ao do kernel ao
   diretorio conf. Se esse diretorio for excluido ou sobrescrito, a
   configurac,ao do kernel pode ser vinculada novamente ao novo.

   Um arquivo de configurac,ao personalizado pode ser criado copiando o
   arquivo de configurac,ao GENERIC. Neste exemplo, o novo kernel
   personalizado e para um servidor de armazenamento, portanto, e denominado
   STORAGESERVER:

 # cp /usr/src/sys/amd64/conf/GENERIC /root/STORAGESERVER
 # cd /usr/src/sys/amd64/conf
 # ln -s /root/STORAGESERVER .

   O /root/STORAGESERVER e entao editado, adicionando ou removendo
   dispositivos ou opc,oes como mostrado em config(5).

   O kernel personalizado e compilado pela configurac,ao KERNCONF no arquivo
   de configurac,ao do kernel na linha de comando:

 # make buildkernel KERNCONF=STORAGESERVER

  23.5.5. Instalando o codigo compilado

   Depois que as etapas buildworld e buildkernel forem concluidas, o novo
   kernel e o restante do sistema base serao instalados:

 # cd /usr/src
 # make installkernel
 # shutdown -r now
 # cd /usr/src
 # make installworld
 # shutdown -r now

   Se um kernel customizado foi compilado, KERNCONF tambem deve ser
   configurado para usar o novo kernel customizado:

 # cd /usr/src
 # make installkernel KERNCONF=STORAGESERVER
 # shutdown -r now
 # cd /usr/src
 # make installworld
 # shutdown -r now

  23.5.6. Concluindo a atualizac,ao

   Algumas tarefas finais completam a atualizac,ao. Quaisquer arquivos de
   configurac,ao que tenham sido modificados serao mesclado com as novas
   versoes, as bibliotecas desatualizadas sao localizadas e removidas e, em
   seguida, o sistema e reiniciado.

    23.5.6.1. Mesclando arquivos de configurac,ao com o mergemaster(8)

   O mergemaster(8) fornece uma maneira facil de mesclar as alterac,oes
   feitas nos arquivos de configurac,ao do sistema com novas versoes desses
   arquivos.

   Com a opc,ao -Ui, o mergemaster(8) atualizara automaticamente os arquivos
   que nao foram modificados pelo usuario e instalara os novos arquivos que
   ainda nao estiverem presentes:

 # mergemaster -Ui

   Se um arquivo precisar ser mesclado manualmente, uma exibic,ao interativa
   permitira que o usuario escolha quais partes dos arquivos serao mantidas.
   Veja mergemaster(8) para maiores informac,oes.

    23.5.6.2. Verificando Arquivos e Bibliotecas Desatualizados

   Alguns arquivos ou diretorios obsoletos podem permanecer apos uma
   atualizac,ao. Esses arquivos podem ser localizados:

 # make check-old

   e excluido:

 # make delete-old

   Algumas bibliotecas obsoletas tambem podem permanecer. Estes podem ser
   detectados com:

 # make check-old-libs

   e deletado com

 # make delete-old-libs

   Os programas que ainda estavam usando estas bibliotecas antigas deixarao
   de funcionar quando a biblioteca for excluida. Estes programas devem ser
   recompilados ou substituidos apos a exclusao das bibliotecas antigas.

  Dica:

   Quando todos os arquivos ou diretorios antigos forem considerados seguros
   para serem excluidos, a ac,ao de pressionar y e Enter para excluir cada
   arquivo podera ser evitada configurando a variavel BATCH_DELETE_OLD_FILES
   no comando. Por exemplo:

 # make BATCH_DELETE_OLD_FILES=yes delete-old-libs

    23.5.6.3. Reiniciando apos a atualizac,ao

   A ultima etapa apos a atualizac,ao e reiniciar o computador para que todas
   as alterac,oes entrem em vigor:

 # shutdown -r now

23.6. Atualizac,ao de varias maquinas

   Contribuido por Mike Meyer.

   Quando varias maquinas precisam rastrear a mesma arvore de codigo-fonte, e
   um desperdicio de espac,o em disco, largura de banda de rede e ciclos de
   CPU se cada sistema tiver que baixar o codigo-fonte e recompilar tudo. A
   soluc,ao e ter uma maquina fazendo a maior parte do trabalho, enquanto o
   resto das maquinas montam esse trabalho via NFS. Esta sec,ao descreve um
   metodo para fazer isso. Para maiores informac,oes sobre o uso de NFS,
   consulte Sec,ao 29.3, "Network File System (NFS)".

   Primeiro, identifique um conjunto de maquinas que executara o mesmo
   conjunto de binarios, conhecido como conjunto de compilac,ao. Cada maquina
   pode ter um kernel customizado, mas executara os mesmos binarios do
   userland. A partir desse conjunto, escolha uma maquina para ser a maquina
   de compilac,ao em que o sistema base e o kernel serao compilados.
   Idealmente, esta devera ser uma maquina rapida que tenha CPU suficiente
   disponivel para executar o make buildworld e o make buildkernel.

   Selecione uma maquina para ser a maquina de teste, que testara as
   atualizac,oes de software antes de serem colocadas em produc,ao. Esta deve
   ser uma maquina que voce possa se dar ao luxo de ficar inativa por um
   longo periodo de tempo. Pode ser a maquina de compilac,ao, mas nao precisa
   ser.

   Todas as maquinas neste conjunto de compilac,ao precisam montar o /usr/obj
   e o /usr/src da maquina de compilac,ao atraves do NFS. Para varios
   conjuntos de compilac,ao, o /usr/src deve ser um sistema de arquivos local
   na maquina de compilac,ao e um sistema montado por NFS nas demais.

   Certifique-se de que o /etc/make.conf e o /etc/src.conf em todas as
   maquinas no conjunto de compilac,ao concordem com a maquina de
   compilac,ao. Isso significa que a maquina de compilac,ao deve compilar
   todas as partes do sistema base que qualquer maquina no conjunto de
   compilac,ao ira instalar. Alem disso, cada maquina de compilac,ao deve ter
   seu nome de kernel definido com KERNCONF em /etc/make.conf, e a maquina de
   compilac,ao deve lista-los todos em seu KERNCONF, listando seu proprio
   kernel primeiro. A maquina de compilac,ao deve ter os arquivos de
   configurac,ao do kernel para cada maquina em seu /usr/src/sys/arch/conf.

   Na maquina de compilac,ao, compile o kernel e o mundo conforme descrito em
   Sec,ao 23.5, "Atualizando o FreeBSD a partir do codigo fonte", mas nao
   instale nada na maquina de compilac,ao. Em vez disso, instale o kernel
   compilado na maquina de teste. Na maquina de teste, monte /usr/src e o
   /usr/obj via NFS. Em seguida, execute shutdown now para ir para o modo de
   usuario unico para instalar o novo kernel e o restante do sistema base e
   execute o mergemaster como de costume. Quando terminar, reinicialize para
   retornar `as operac,oes multiusuario normais.

   Depois de verificar se tudo na maquina de teste esta funcionando
   corretamente, use o mesmo procedimento para instalar o novo software em
   cada uma das outras maquinas no conjunto de compilac,ao.

   A mesma metodologia pode ser usada para a arvore de ports. O primeiro
   passo e compartilhar o /usr/ports via NFS para todas as maquinas no
   conjunto de compilac,ao. Para configurar o /etc/make.conf para
   compartilhar os distfiles, configure o DISTDIR para um diretorio
   compartilhado que possa ser escrito por qualquer usuario root mapeado pela
   montagem NFS. Cada maquina deve definir o WRKDIRPREFIX para um diretorio
   de compilac,ao local, se os ports precisarem ser compilados localmente.
   Como alternativa, se o sistema de compilac,ao tiver que compilar e
   distribuir pacotes para as maquinas no conjunto de compilac,ao, configure
   o PACKAGES no sistema de compilac,ao para um diretorio semelhante ao
   DISTDIR.

Capitulo 24. DTrace

   Escrito por Tom Rhodes.
   Indice

   24.1. Sinopse

   24.2. Diferenc,as de Implementac,ao

   24.3. Ativando o Suporte do DTrace

   24.4. Usando o DTrace

24.1. Sinopse

   O DTrace, tambem conhecido como Dynamic Tracing, foi desenvolvido pela
   Sun(TM) como uma ferramenta para localizar gargalos de desempenho em
   sistemas de produc,ao e pre-produc,ao. Alem de diagnosticar problemas de
   desempenho, o DTrace pode ser usado para ajudar a investigar e depurar
   comportamentos inesperados no kernel do FreeBSD e em programas da
   userland.

   O DTrace e uma ferramenta de criac,ao de perfil notavel, com uma
   impressionante variedade de recursos para diagnosticar problemas do
   sistema. Ele tambem pode ser usado para executar scripts pre-escritos para
   aproveitar seus recursos. Os usuarios podem criar seus proprios
   utilitarios usando a DTrace D Language, permitindo que eles personalizem
   seus perfis com base em necessidades especificas.

   A implementac,ao do FreeBSD fornece suporte completo para o DTrace do
   kernel e suporte experimental para o DTrace da userland. O Userland DTrace
   permite que os usuarios executem o rastreio de limite de func,ao para
   programas de area de trabalho usando o provedor pid e insiram
   investigac,oes estaticas em programas da userland para rastreamento
   posterior. Alguns ports, como databases/postgresql12-server e lang/php74,
   possuem uma opc,ao do DTrace para ativar testes estaticos.

   O guia oficial do DTrace e mantido pelo projeto Illumos no Guia do DTrace.

   Depois de ler este capitulo, voce sabera:

     * O que e o DTrace e quais recursos ele fornece.

     * Diferenc,as entre a implementac,ao do DTrace Solaris(TM) e a fornecida
       pelo FreeBSD.

     * Como ativar e usar o DTrace no FreeBSD.

   Antes de ler este capitulo, voce deve:

     * Entender os fundamentos do UNIX(R) e do FreeBSD (Capitulo 3,
       Fundamentos do FreeBSD).

     * Ter alguma familiaridade com seguranc,a e como ela esta presente no
       FreeBSD (Capitulo 13, Seguranc,a).

24.2. Diferenc,as de Implementac,ao

   Embora o DTrace no FreeBSD seja semelhante ao encontrado no Solaris(TM),
   existem diferenc,as. A principal diferenc,a e que no FreeBSD, o DTrace e
   implementado como um conjunto de modulos do kernel e o DTrace nao pode ser
   usado ate que os modulos sejam carregados. Para carregar todos os modulos
   necessarios:

 # kldload dtraceall

   Comec,ando com o FreeBSD 10.0-RELEASE, os modulos sao carregados
   automaticamente quando o dtrace e executado.

   O FreeBSD usa a opc,ao do kernel DDB_CTF para ativar o suporte para
   carregar dados CTF dos modulos do kernel e do proprio kernel. O CTF e o
   Solaris(TM) Compact C Type Format, que encapsula uma forma reduzida de
   informac,oes de depurac,ao semelhantes ao DWARF e aos veneraveis stabs. Os
   dados do CTF sao adicionados aos binarios pelas ferramentas de compilac,ao
   ctfconvert e ctfmerge. O utilitario ctfconvert analisa as sec,oes de
   depurac,ao do DWARF ELF criadas pelo compilador e o ctfmerge mescla as
   sec,oes do ELF do CTF dos objetos em executaveis ou bibliotecas
   compartilhadas.

   Alguns provedores diferentes existem para o FreeBSD nao para o
   Solaris(TM). O mais notavel e o provedor dtmalloc, que permite rastrear
   malloc() por tipo no kernel do FreeBSD. Alguns dos provedores encontrados
   no Solaris(TM), como cpc e mib, nao estao presentes no FreeBSD. Estes
   podem aparecer em futuras versoes do FreeBSD. Alem disso, alguns dos
   provedores disponiveis em ambos os sistemas operacionais nao sao
   compativeis, no sentido de que suas sondas tem tipos de argumentos
   diferentes. Assim, os scripts D escritos em Solaris(TM) podem ou nao
   funcionar sem modificac,oes no FreeBSD, e vice-versa.

   Devido as diferenc,as de seguranc,a, somente o root pode usar o DTrace no
   FreeBSD. O Solaris(TM) possui algumas verificac,oes de seguranc,a de baixo
   nivel que ainda nao existem no FreeBSD. Como tal, o /dev/dtrace/dtrace e
   estritamente limitado ao root.

   O DTrace se enquadra na licenc,a Common Development and Distribution
   License (CDDL). Para ver esta licenc,a no FreeBSD, consulte
   /usr/src/cddl/contrib/opensolaris/OPENSOLARIS.LICENSE ou acesse on-line em
   http://opensource.org/licenses/CDDL-1.0. Enquanto um kernel do FreeBSD com
   suporte a DTrace e licenciado sob BSD, o CDDL e usado quando os modulos
   sao distribuidos em formato binario ou quando os binarios sao carregados.

24.3. Ativando o Suporte do DTrace

   No FreeBSD 9.2 e 10.0, o suporte do DTrace esta embutido no kernel
   GENERIC. Usuarios de versoes anteriores do FreeBSD ou que preferem
   compilar estaticamente o suporte do DTrace devem adicionar as seguintes
   linhas a um arquivo de configurac,ao de kernel personalizado e recompilar
   o kernel usando as instruc,oes em Capitulo 8, Configurando o kernel do
   FreeBSD:

 options         KDTRACE_HOOKS
 options         DDB_CTF
 makeoptions     DEBUG=-g
 makeoptions     WITH_CTF=1

   Os usuarios da arquitetura AMD64 tambem devem adicionar esta linha:

 options         KDTRACE_FRAME

   Esta opc,ao fornece suporte para FBT. Embora o DTrace funcione sem essa
   opc,ao, havera suporte limitado para o rastreamento de limite de func,ao.

   Uma vez que o sistema FreeBSD foi reinicializado no novo kernel, ou os
   modulos de kernel do DTrace foram carregados usando kldload dtraceall, o
   sistema precisara de suporte para o shell Korn, pois o DTrace Toolkit
   possui varios utilitarios escritos em ksh. Certifique-se de que o pacote
   ou port shells/ksh93 esteja instalado. Tambem e possivel rodar estas
   ferramentas com shells/pdksh ou shells/mksh.

   Por fim, instale o DTrace Toolkit atual, uma colec,ao de scripts prontos
   para coletar informac,oes do sistema. Existem scripts para verificar
   arquivos abertos, memoria, uso de CPU e muito mais. O FreeBSD 10 instala
   alguns desses scripts em /usr/share/dtrace. Em outras versoes do FreeBSD,
   ou para instalar o DTrace Toolkit completo, use o pacote ou port
   sysutils/DTraceToolkit.

  Nota:

   Os scripts encontrados em /usr/share/dtrace foram especificamente portados
   para o FreeBSD. Nem todos os scripts encontrados no DTrace Toolkit
   funcionarao no FreeBSD e alguns scripts podem exigir algum esforc,o para
   que funcionem no FreeBSD.

   O DTrace Toolkit inclui muitos scripts no idioma especial do DTrace. Esta
   linguagem e chamada de linguagem D e e muito semelhante ao C++. Uma
   discussao aprofundada da linguagem esta alem do escopo deste documento.
   Ele e abordado extensivamente no Illumos Dynamic Tracing Guide.

24.4. Usando o DTrace

   Os scripts do DTrace consistem em uma lista de um ou mais testes probes,
   ou pontos de instrumentac,ao, em que cada teste e associado a uma ac,ao.
   Sempre que a condic,ao de uma sonda e atendida, a ac,ao associada e
   executada. Por exemplo, uma ac,ao pode ocorrer quando um arquivo e aberto,
   um processo e iniciado ou uma linha de codigo e executada. A ac,ao pode
   ser registrar algumas informac,oes ou modificar variaveis de contexto. A
   leitura e a escrita de variaveis de contexto permitem que os probes
   compartilhem informac,oes e analisem cooperativa-mente a correlac,ao de
   diferentes eventos.

   Para ver todos os probes, o administrador pode executar o seguinte
   comando:

 # dtrace -l | more

   Cada probe possui um ID, um PROVIDER (dtrace ou fbt), um MODULE e um
   FUNCTION NAME. Consulte dtrace(1) para obter maiores informac,oes sobre
   este comando.

   Os exemplos nesta sec,ao fornecem uma visao geral de como usar dois dos
   scripts totalmente suportados dos scripts do DTrace Toolkit: o hotkernel e
   procsystime.

   O script hotkernel e projetado para identificar qual func,ao esta usando a
   maior parte do tempo do kernel. Ele produzira uma saida semelhante `a
   seguinte:

 # cd /usr/share/dtrace/toolkit
 # ./hotkernel
 Sampling... Hit Ctrl-C to end.

   Conforme instruido, use a combinac,ao de teclas Ctrl+C para interromper o
   processo. Apos o termino, o script exibira uma lista de func,oes do kernel
   e informac,oes de tempo, classificando a saida em ordem crescente de
   tempo:

 kernel`_thread_lock_flags                                   2   0.0%
 0xc1097063                                                  2   0.0%
 kernel`sched_userret                                        2   0.0%
 kernel`kern_select                                          2   0.0%
 kernel`generic_copyin                                       3   0.0%
 kernel`_mtx_assert                                          3   0.0%
 kernel`vm_fault                                             3   0.0%
 kernel`sopoll_generic                                       3   0.0%
 kernel`fixup_filename                                       4   0.0%
 kernel`_isitmyx                                             4   0.0%
 kernel`find_instance                                        4   0.0%
 kernel`_mtx_unlock_flags                                    5   0.0%
 kernel`syscall                                              5   0.0%
 kernel`DELAY                                                5   0.0%
 0xc108a253                                                  6   0.0%
 kernel`witness_lock                                         7   0.0%
 kernel`read_aux_data_no_wait                                7   0.0%
 kernel`Xint0x80_syscall                                     7   0.0%
 kernel`witness_checkorder                                   7   0.0%
 kernel`sse2_pagezero                                        8   0.0%
 kernel`strncmp                                              9   0.0%
 kernel`spinlock_exit                                       10   0.0%
 kernel`_mtx_lock_flags                                     11   0.0%
 kernel`witness_unlock                                      15   0.0%
 kernel`sched_idletd                                       137   0.3%
 0xc10981a5                                              42139  99.3%

   Este script tambem funcionara com modulos do kernel. Para usar este
   recurso, execute o script com -m:

 # ./hotkernel -m
 Sampling... Hit Ctrl-C to end.
 ^C
 MODULE                                                  COUNT   PCNT
 0xc107882e                                                  1   0.0%
 0xc10e6aa4                                                  1   0.0%
 0xc1076983                                                  1   0.0%
 0xc109708a                                                  1   0.0%
 0xc1075a5d                                                  1   0.0%
 0xc1077325                                                  1   0.0%
 0xc108a245                                                  1   0.0%
 0xc107730d                                                  1   0.0%
 0xc1097063                                                  2   0.0%
 0xc108a253                                                 73   0.0%
 kernel                                                    874   0.4%
 0xc10981a5                                             213781  99.6%

   O script procsystime captura e imprime o uso do tempo de chamada do
   sistema para um determinado processo ID (PID) ou nome do processo. No
   exemplo a seguir, uma nova instancia de /bin/csh foi gerada. Entao,
   procsystime foi executado e permaneceu aguardando enquanto alguns comandos
   foram digitados na outra instancia do csh. Estes sao os resultados deste
   teste:

 # ./procsystime -n csh
 Tracing... Hit Ctrl-C to end...
 ^C

 Elapsed Times for processes csh,

          SYSCALL          TIME (ns)
           getpid               6131
        sigreturn               8121
            close              19127
            fcntl              19959
              dup              26955
          setpgid              28070
             stat              31899
        setitimer              40938
            wait4              62717
        sigaction              67372
      sigprocmask             119091
     gettimeofday             183710
            write             263242
           execve             492547
            ioctl             770073
            vfork            3258923
       sigsuspend            6985124
             read         3988049784

   Como mostrado, a chamada de sistema read() usou a maior parte do tempo em
   nanossegundos enquanto a chamada de sistema getpid() usou a menor
   quantidade de tempo.

Capitulo 25. Modo de dispositivo USB/USB OTG

   Indice

   25.1. Sinopse

   25.2. Portas Seriais Virtuais USB

   25.3. Interfaces de rede do modo de dispositivo USB

   25.4. Dispositivo de armazenamento virtual USB

25.1. Sinopse

   Escrito por Edward Tomasz Napierala.

   Este capitulo aborda o uso do Modo de Dispositivo USB e USB On The Go (USB
   OTG) no FreeBSD. Isso inclui consoles seriais virtuais, interfaces de rede
   virtual e drives USB virtuais.

   Quando rodando em hardware que suporta o modo de dispositivo USB ou USB
   OTG, como aquele embutido em muitas placas embarcadas, a stack USB do
   FreeBSD pode ser executada em modo de dispositivo. O modo de dispositivo
   possibilita que o computador apresente-se como diferentes tipos de classes
   de dispositivos USB, incluindo portas seriais, adaptadores de rede e
   armazenamento em massa, ou uma combinac,ao dos mesmos. Um host USB como um
   laptop ou computador desktop pode acessa-los assim como faria com
   dispositivos USB fisicos. O modo de dispositivo e algumas vezes chamado de
   "modo USB gadget".

   Existem duas maneiras basicas pelas quais o hardware pode fornecer a
   funcionalidade do modo de dispositivo: com uma "porta de cliente"
   separada, que suporta apenas o modo de dispositivo, e com uma porta USB
   OTG, que pode fornecer o modo de dispositivo e o modo de host. Para portas
   USB OTG, a stack USB alterna automaticamente entre o lado do host e o lado
   do dispositivo, dependendo do que estiver conectado `a porta. Conectar um
   dispositivo USB como um cartao de memoria `a porta faz com que o FreeBSD
   mude para o modo de host. Conectar um host USB como um computador faz com
   que o FreeBSD mude para o modo de dispositivo. As "portas do cliente" de
   finalidade unica sempre funcionam no modo de dispositivo.

   O que o FreeBSD apresenta para o host USB depende do sysctl
   hw.usb.template. Alguns modelos fornecem um unico dispositivo, como um
   terminal serial; outros fornecem varios, que podem ser todos usados ao
   mesmo tempo. Um exemplo e o template 10, que fornece um dispositivo de
   armazenamento em massa, um console serial e uma interface de rede. Veja o
   usb_template(4) para obter a lista de valores disponiveis.

   Observe que, em alguns casos, dependendo do hardware e do sistema
   operacional do host, para o host notar a alterac,ao da configurac,ao, ele
   deve ser fisicamente desconectado e reconectado ou forc,ado a verificar
   novamente o barramento USB de uma maneira especifica do sistema. Quando o
   FreeBSD e executado no host, o usbconfig(8) reset pode ser usado. Isto
   tambem deve ser feito apos carregar o usb_template.ko se o host USB ja
   estiver conectado ao soquete USB OTG .

   Depois de ler este capitulo, voce sabera:

     * Como configurar a funcionalidade do modo de dispositivo USB no
       FreeBSD.

     * Como configurar a porta serial virtual no FreeBSD.

     * Como se conectar `a porta serial virtual de varios sistemas
       operacionais.

     * Como configurar o FreeBSD para fornecer uma interface de rede virtual
       USB.

     * Como configurar o FreeBSD para fornecer um dispositivo virtual de
       armazenamento USB.

25.2. Portas Seriais Virtuais USB

  25.2.1. Configurando Portas Seriais do Modo de Dispositivo USB

   O suporte para porta serial virtual e fornecido pelos templates numero 3,
   8 e 10. Observe que o template 3 funciona com o Microsoft Windows 10 sem a
   necessidade de drivers especiais e de arquivos INF. Outros sistemas
   operacionais host funcionam com todos os tres modelos. Os modulos do
   kernel usb_template(4) e umodem(4) devem ser carregados.

   Para ativar as portas seriais do modo de dispositivo USB, adicione essas
   linhas ao /etc/ttys:

 ttyU0   "/usr/libexec/getty 3wire"      vt100   onifconsole secure
 ttyU1   "/usr/libexec/getty 3wire"      vt100   onifconsole secure

   Entao adicione estas linhas ao arquivo /etc/devd.conf:

 notify 100 {
         match "system"          "DEVFS";
         match "subsystem"       "CDEV";
         match "type"            "CREATE";
         match "cdev"            "ttyU[0-9]+";
         action "/sbin/init q";
 };

   Recarregue a configurac,ao se o devd(8) ja estiver em execuc,ao:

 # service devd restart

   Certifique-se de que os modulos necessarios estejam carregados e que o
   template correto esteja configurado na inicializac,ao, adicionando estas
   linhas ao /boot/loader.conf, criando-o se ele ainda nao existir:

 umodem_load="YES"
 hw.usb.template=3

   Para carregar o modulo e definir o modelo sem reiniciar, use:

 # kldload umodem
 # sysctl hw.usb.template=3

  25.2.2. Conectando-se `as portas seriais do modo de dispositivo USB a partir
  do FreeBSD

   Para conectar-se a uma placa configurada para fornecer portas seriais de
   um dispositivo USB, conecte o host USB, como um laptop, `as placas USB OTG
   ou porta de cliente USB. Use pstat -t no host para listar as linhas de
   terminal. Perto do final da lista, voce deve ver uma porta serial USB, por
   exemplo, "ttyU0". Para abrir a conexao, use:

 # cu -l /dev/ttyU0

   Depois de pressionar a tecla Enter algumas vezes, voce vera um prompt de
   login.

  25.2.3. Conectando-se `as portas seriais do modo de dispositivo USB a partir
  do macOS

   Para conectar-se a uma placa configurada para fornecer portas seriais de
   modo de dispositivo USB, conecte o host USB, como um laptop, `as placas
   USB OTG ou porta de cliente USB. Para abrir a conexao, use:

 # cu -l /dev/cu.usbmodemFreeBSD1

  25.2.4. Conectando-se `as portas seriais do modo de dispositivo USB a partir
  do Linux

   Para conectar-se a uma placa configurada para fornecer portas seriais de
   modo de dispositivo USB, conecte o host USB, como um laptop, `as placas
   USB OTG ou porta de cliente USB. Para abrir a conexao, use:

 # minicom -D /dev/ttyACM0

  25.2.5. Conectando-se `as portas seriais do modo de dispositivo USB a partir
  do Microsoft Windows 10

   Para conectar-se a uma placa configurada para fornecer portas seriais de
   modo de dispositivo USB, conecte o host USB, como um laptop, `as placas
   USB OTG ou porta de cliente USB. Para abrir uma conexao, voce precisara de
   um programa de terminal serial, como PuTTY. Para verificar o nome da porta
   COM usada pelo Windows, execute o Gerenciador de dispositivos, expanda.
   "Ports (COM & LPT)".Voce vera um nome semelhante a "USB Serial Device
   (COM4)". Execute o programa do terminal serial de sua escolha, por
   exemplo, PuTTY. Na caixa de dialogo PuTTY defina "Connection type" como
   "Serial", digite o COMx obtido no Gerenciador de Dispositivos na caixa de
   dialogo "Serial line" e clique em Abrir.

25.3. Interfaces de rede do modo de dispositivo USB

   O suporte a interfaces de rede virtuais e fornecido pelos templates numero
   1, 8 e 10. Observe que nenhum deles funciona com o Microsoft Windows.
   Outros sistemas operacionais host funcionam com todos os tres modelos. Os
   modulos de kernel usb_template(4) e if_cdce(4) devem ser carregados.

   Certifique-se de que os modulos necessarios estejam carregados e que o
   template correto esteja configurado na inicializac,ao, adicionando estas
   linhas ao /boot/loader.conf, criando-o se ele ainda nao existir:

 if_cdce_load="YES"
 hw.usb.template=1

   Para carregar o modulo e definir o modelo sem reiniciar, use:

 # kldload if_cdce
 # sysctl hw.usb.template=1

25.4. Dispositivo de armazenamento virtual USB

  Nota:

   O driver cfumass(4) e um driver de modo de dispositivo USB disponibilizado
   pela primeira vez no FreeBSD 12.0.

   O target de armazenamento em massa e fornecido pelos templates 0 e 10. Os
   modulos de kernel usb_template(4) e cfumass(4) devem ser carregados. O
   cfumass(4) faz interface com o subsistema CTL, o mesmo usado para os
   targets iSCSI ou Fibre Channel. No lado do host, os inicializadores do
   armazenamento em massa USB so podem acessar um unico LUN, o LUN 0.

  25.4.1. Configurando o target de armazenamento em massa USB usando o script de
  inicializac,ao cfumass

   A maneira mais simples de configurar um target de armazenamento USB
   somente de leitura e usar o script rc cfumass. Para configura-lo dessa
   maneira, copie os arquivos a serem apresentados para a maquina host USB no
   diretorio /var/cfumass e inclua esta linha no /etc/rc.conf :

 cfumass_enable="YES"

   Para fazer valer a configurac,ao sem reiniciar, execute este comando:

 # service cfumass start

   Diferentemente da funcionalidade serial e de rede, o modelo nao deve ser
   definido como 0 ou 10 no /boot/loader.conf. Isso ocorre porque o LUN deve
   ser configurado antes de definir o template. O script de inicializac,ao
   cfumass define o numero do modelo correto automaticamente quando iniciado.

  25.4.2. Configurando o armazenamento em massa USB usando outros meios

   O restante deste capitulo fornece uma descric,ao detalhada da
   configurac,ao do target sem usar o arquivo rc cfumass. Isso e necessario
   se, por exemplo, alguem quiser fornecer um LUN gravavel.

   O armazenamento em massaUSB nao exige que o daemon ctld(8) esteja em
   execuc,ao, embora ele possa ser usado se desejado. Isso e diferente do
   iSCSI. Portanto, existem duas maneiras de configurar o target: o ctladm(8)
   ou o ctld(8). Ambos exigem que o modulo do kernel cfumass.ko seja
   carregado. O modulo pode ser carregado manualmente:

 # kldload cfumass

   Se o cfumass.ko nao foi compilado estaticamente no kernel, o
   /boot/loader.conf pode ser configurado para carregar o modulo na
   inicializac,ao:

 cfumass_load="YES"

   Um LUN pode ser criado sem o daemon ctld(8):

 # ctladm create -b block -o file=/data/target0

   Isto apresenta o conteudo do arquivo de imagem /data/target0 como um LUN
   para o host USB. O arquivo deve existir antes de executar o comando. Para
   configurar o LUN na inicializac,ao do sistema, adicione o comando ao
   /etc/rc.local.

   O ctld(8) tambem pode ser usado para gerenciar LUNs. Crie /etc/ctl.conf,
   adicione uma linha ao /etc/rc.conf para certificar-se ctld(8) e iniciado
   automaticamente na inicializac,ao e, em seguida, inicie o daemon.

   Este e um exemplo de um arquivo de configurac,ao /etc/ctl.conf simple.
   Consulte ctl.conf(5) para obter uma descric,ao mais completa das opc,oes.

 target naa.50015178f369f092 {
         lun 0 {
                 path /data/target0
                 size 4G
         }
 }

   O exemplo cria um unico target com um unico LUN. O naa.50015178f369f092 e
   um identificador de dispositivo composto por 32 digitos hexadecimais
   aleatorios. A linha path define o caminho completo para o arquivo ou zvol
   que suporta o LUN. Esse arquivo deve existir antes do ctld(8) ser
   iniciado. A segunda linha e opcional e especifica o tamanho do LUN.

   Para ter certeza que o daemon ctld(8) foi iniciado na inicializac,ao,
   adicione esta linha ao /etc/rc.conf:

 ctld_enable="YES"

   Para iniciar o ctld(8) agora, execute este comando:

 # service ctld start

   Quando o daemon ctld(8) e iniciado, ele le o /etc/ctl.conf. Se esse
   arquivo for editado depois que o daemon iniciar, recarregue as alterac,oes
   para que elas entrem em vigor imediatamente:

 # service ctld reload

                         Parte IV. Comunicac,ao de rede

   O FreeBSD e um dos sistemas operacionais mais amplamente implantados para
   servidores de rede de alto desempenho. Os capitulos desta parte cobrem:

     * Comunicac,ao Serial

     * PPP e PPP sobre Ethernet

     * Correio Eletronico

     * Executando Servidores de Rede

     * Firewalls

     * Outros topicos avanc,ados de rede

   Esses capitulos sao projetados para serem lidos quando a informac,ao for
   necessaria. Eles nao precisam ser lidos em qualquer ordem especifica, nem
   e necessario ler todos eles antes de usar o FreeBSD em um ambiente de
   rede.

   Indice

   26. Comunicac,oes Seriais

                26.1. Sinopse

                26.2. Terminologia serial e hardware

                26.3. Terminais

                26.4. Servic,o Dial-in

                26.5. Servic,o de Dial-in

                26.6. Configurando o Console Serial

   27. PPP

                27.1. Sinopse

                27.2. Configurando o PPP

                27.3. Soluc,ao de problemas de conexoes PPP

                27.4. Usando o PPP sobre Ethernet (PPPoE)

                27.5. Usando PPP sobre ATM (PPPoA)

   28. Correio Eletronico

                28.1. Sinopse

                28.2. Componentes de Email

                28.3. Arquivos de Configurac,ao do Sendmail

                28.4. Alterando o Mail Transfer Agent

                28.5. Soluc,ao de problemas

                28.6. Topicos Avanc,ados

                28.7. Configurando Apenas Envio

                28.8. Usando Email com uma Conexao Dialup

                28.9. Autenticac,ao SMTP

                28.10. Mail User Agents

                28.11. Usando o fetchmail

                28.12. Usando o procmail

   29. Servidores de Rede

                29.1. Sinopse

                29.2. O super-servidor inetd

                29.3. Network File System (NFS)

                29.4. Sistema de Informac,ao de Rede (NIS)

                29.5. Protocolo leve de acesso de diretorio ( LDAP )

                29.6. Protocolo de configurac,ao dinamica de hosts (DHCP)

                29.7. Sistema de Nomes de Dominio (DNS)

                29.8. Servidor HTTP Apache

                29.9. Protocolo de Transferencia de Arquivos (FTP)

                29.10. Servic,os de arquivos e impressao para clientes
                Microsoft(R) Windows(R) Clients (Samba)

                29.11. Sincronizac,ao de Relogio com NTP

                29.12. Inicializador iSCSI e Configurac,ao Alvo

   30. Firewalls

                30.1. Sinopse

                30.2. Conceitos de Firewall

                30.3. PF

                30.4. IPFW

                30.5. IPFILTER (IPF)

                30.6. Blacklistd

   31. Rede Avanc,ada

                31.1. Sinopse

                31.2. Gateways e Rotas

                31.3. Rede sem fio

                31.4. USB Tethering

                31.5. Bluetooth

                31.6. Bridging

                31.7. Agregac,ao de links e failover

                31.8. Operac,ao Diskless com PXE

                31.9. IPv6

                31.10. Protocolo Comum de Redundancia de Enderec,os (CARP)

                31.11. VLANs

Capitulo 26. Comunicac,oes Seriais

   Indice

   26.1. Sinopse

   26.2. Terminologia serial e hardware

   26.3. Terminais

   26.4. Servic,o Dial-in

   26.5. Servic,o de Dial-in

   26.6. Configurando o Console Serial

26.1. Sinopse

   O UNIX(R) sempre teve suporte para comunicac,ao serial, pois as primeiras
   maquinas UNIX(R) dependiam de linhas seriais para entrada e saida do
   usuario. As coisas mudaram muito desde os dias em que o terminal medio
   consistia de uma impressora serial de 10 caracteres por segundo e um
   teclado. Este capitulo aborda algumas das maneiras pelas quais as
   comunicac,oes seriais podem ser usadas no FreeBSD.

   Depois de ler este capitulo, voce sabera:

     * Como conectar terminais a um sistema FreeBSD.

     * Como usar um modem para discar para hosts remotos.

     * Como permitir que usuarios remotos efetuem login em um sistema FreeBSD
       com um modem.

     * Como inicializar um sistema FreeBSD a partir de uma console serial.

   Antes de ler este capitulo, voce deve:

     * Saiba como configurar e instalar um kernel personalizado.

     * Entenda permissoes e processos do FreeBSD.

     * Tenha acesso ao manual tecnico para o hardware serial a ser usado com
       o FreeBSD.

26.2. Terminologia serial e hardware

   Os termos a seguir sao frequentemente usados em comunicac,oes seriais:

   bps

           Bits por Segundo (bps) e a taxa na qual os dados sao transmitidos.

   DTE

           Equipamento Terminal de Dados (DTE) e um dos dois terminais em uma
           comunicac,ao serial. Um exemplo seria um computador.

   DCE

           Equipamento de Comunicac,oes de Dados (DTE) e o outro terminal em
           uma comunicac,ao serial. Normalmente, e um modem ou terminal
           serial.

   RS-232

           O padrao original que definiu as comunicac,oes seriais de
           hardware. Desde entao, foi renomeado para TIA-232.

   Ao se referir a taxas de dados de comunicac,ao, esta sec,ao nao usa o
   termo baud. Baud refere-se ao numero de transic,oes de estado eletrico
   feitas em um periodo de tempo, enquanto bps e o termo correto a ser usado.

   Para conectar um terminal serial a um sistema FreeBSD, sao necessarias uma
   porta serial no computador e o cabo adequado para conectar ao dispositivo
   serial. Os usuarios que ja estao familiarizados com hardware serial e
   cabeamento podem pular esta sec,ao com seguranc,a.

  26.2.1. Cabos Serial e Portas

   Existem varios tipos diferentes de cabos seriais. Os dois tipos mais
   comuns sao cabo null-modem e cabo padrao RS-232. A documentac,ao do
   hardware deve descrever o tipo de cabo necessario.

   Estes dois tipos de cabos diferem em como os fios sao conectados ao
   conector. Cada fio representa um sinal, com os sinais definidos resumidos
   em Tabela 26.1, "RS-232C Nomes dos Sinais". Um cabo serial padrao passa
   todos os sinais RS-232C diretamente. Por exemplo, o pino "Transmitted
   Data" em uma extremidade do cabo vai para o pino "Transmitted Data" na
   outra extremidade. Este e o tipo de cabo usado para conectar um modem ao
   sistema FreeBSD e tambem e apropriado para alguns terminais.

   Um cabo de modem nulo alterna o pino "Transmitted Data" do conector em uma
   extremidade com o pino "Received Data" na outra extremidade. O conector
   pode ser um DB-25 ou um DB-9.

   Um cabo de modem nulo pode ser construido usando as conexoes de pinos
   resumidas em Tabela 26.2, "Cabo Null-Modem DB-25 para DB-25", Tabela 26.3,
   "Cabo DB-9 para DB-9 Null-Modem" e Tabela 26.4, "Cabo DB-9 para DB-25
   Null-Modem". Enquanto o padrao exige um pino direto 1 para fixar uma linha
   "Protective Ground", ele e frequ:entemente omitido. Alguns terminais
   funcionam usando apenas os pinos 2, 3 e 7, enquanto outros exigem
   configurac,oes diferentes. Em caso de duvida, consulte a documentac,ao do
   hardware.

   Tabela 26.1. RS-232C Nomes dos Sinais

   Siglas                         Nomes                                       
   RD                             Received Data                               
   TD                             Transmitted Data                            
   DTR                            Data Terminal Ready                         
   DSR                            Data Set Ready                              
   DCD                            Data Carrier Detect                         
   SG                             Signal Ground                               
   RTS                            Request to Send                             
   CTS                            Clear to Send                               

   Tabela 26.2. Cabo Null-Modem DB-25 para DB-25

   Sinal         Pin #                              Pin #        Sinal        
   SG            7             conecta-se a         7            SG           
   TD            2             conecta-se a         3            RD           
   RD            3             conecta-se a         2            TD           
   RTS           4             conecta-se a         5            CTS          
   CTS           5             conecta-se a         4            RTS          
   DTR           20            conecta-se a         6            DSR          
   DTR           20            conecta-se a         8            DCD          
   DSR           6             conecta-se a         20           DTR          
   DCD           8             conecta-se a         20           DTR          

   Tabela 26.3. Cabo DB-9 para DB-9 Null-Modem

   Sinal         Pin #                              Pin #        Sinal        
   RD            2             conecta-se a         3            TD           
   TD            3             conecta-se a         2            RD           
   DTR           4             conecta-se a         6            DSR          
   DTR           4             conecta-se a         1            DCD          
   SG            5             conecta-se a         5            SG           
   DSR           6             conecta-se a         4            DTR          
   DCD           1             conecta-se a         4            DTR          
   RTS           7             conecta-se a         8            CTS          
   CTS           8             conecta-se a         7            RTS          

   Tabela 26.4. Cabo DB-9 para DB-25 Null-Modem

   Sinal         Pin #                              Pin #        Sinal        
   RD            2             conecta-se a         2            TD           
   TD            3             conecta-se a         3            RD           
   DTR           4             conecta-se a         6            DSR          
   DTR           4             conecta-se a         8            DCD          
   SG            5             conecta-se a         7            SG           
   DSR           6             conecta-se a         20           DTR          
   DCD           1             conecta-se a         20           DTR          
   RTS           7             conecta-se a         5            CTS          
   CTS           8             conecta-se a         4            RTS          

  Nota:

   Quando um pino em uma extremidade se conecta a um par de pinos na outra
   extremidade, geralmente e implementado com um fio curto entre o par de
   pinos em seu conector e um fio longo no outro pino unico.

   As portas seriais sao os dispositivos atraves dos quais os dados sao
   transferidos entre o computador host do FreeBSD e o terminal. Varios tipos
   de portas seriais existem. Antes de comprar ou construir um cabo,
   verifique se ele ira se encaixar nas portas do terminal e no sistema
   FreeBSD.

   A maioria dos terminais tem portas DB-25. Os computadores pessoais podem
   ter portas DB-25 ou DB-9. Um cartao serial multiportas pode ter portas
   RJ-12 ou RJ-45/. Consulte a documentac,ao que acompanha o hardware para
   especificac,oes sobre o tipo de porta ou verifique visualmente o tipo de
   porta.

   No FreeBSD, cada porta serial e acessada atraves de uma entrada em /dev.
   Existem dois tipos diferentes de entradas:

     * As portas de chamada sao nomeadas /dev/ttyuN onde N e o numero da
       porta, comec,ando do zero. Se um terminal estiver conectado a primeira
       porta serial (COM1), use /dev/ttyu0 para se referir ao terminal. Se o
       terminal estiver na segunda porta serial (COM2), use /dev/ttyu1 e
       assim por diante. Geralmente, a porta de chamada e usada para
       terminais. As portas de chamada requerem que a linha serial declare o
       sinal "Data Carrier Detect" para funcionar corretamente.

     * As portas de chamadas de saida sao nomeadas /dev/cuauN nas versoes 8.X
       e superiores do FreeBSD e /dev/cuadN nas versoes 7.X e inferiores do
       FreeBSD. As portas de chamada de saida geralmente nao sao usadas para
       terminais, mas sao usadas para modems. A porta de evocac,ao pode ser
       usada se o cabo serial ou o terminal nao suportar o sinal "Data
       Carrier Detect".

   O FreeBSD tambem fornece dispositivos de inicializac,ao (/dev/ttyuN.init e
   /dev/cuauN.init ou /dev/cuadN.init) e dispositivos de bloqueio
   (/dev/ttyuN.lock e /dev/cuauN.lock ou /dev/cuadN.lock). Os dispositivos de
   inicializac,ao sao utilizados para inicializar os parametros da porta de
   comunicac,oes de cada vez que uma porta e aberta, tal como o crtscts para
   modems que usam RTS/CTS sinalizac,ao para controle de fluxo. Os
   dispositivos de bloqueio sao usados para bloquear sinalizadores nas portas
   para impedir que usuarios ou programas alterem determinados parametros.
   Consulte termios(4), sio(4), e stty(1) para obter informac,oes sobre
   configurac,oes de terminal, bloqueio e inicializac,ao de dispositivos e
   configurac,ao de opc,oes de terminal, respectivamente.

  26.2.2. Configurac,ao de Porta Serial

   Por padrao, o FreeBSD suporta quatro portas seriais que sao comumente
   conhecidas como COM1, COM2, COM3 e COM4. O FreeBSD tambem suporta placas
   de interfaces seriais multi-port, como o BocaBoard 1008 e 2016, bem como
   placas multi-port mais inteligentes, como as feitas pela Digiboard. No
   entanto, o kernel padrao procura apenas as portas padrao COM.

   Para ver se o sistema reconhece as portas seriais, procure por mensagens
   de inicializac,ao do sistema que comec,am com uart:

 # grep uart /var/run/dmesg.boot

   Se o sistema nao reconhecer todas as portas seriais necessarias, entradas
   adicionais podem ser adicionadas ao /boot/device.hints. Este arquivo ja
   contem entradas hint.uart.0.* para entradas COM1 e hint.uart.1.* para
   COM2. Ao adicionar uma entrada de porta para COM3 use 0x3E8 e para COM4
   use 0x2E8. Enderec,os comuns de IRQ sao 5 para COM3 e 9 para COM4.

   Para determinar o conjunto padrao de configurac,oes de terminal E/S usadas
   pela porta, especifique o nome do dispositivo. Este exemplo determina as
   configurac,oes para a porta de chamada em COM2:

 # stty -a -f /dev/ttyu1

   A inicializac,ao de dispositivos seriais em todo o sistema e controlada
   por /etc/rc.d/serial. Este arquivo afeta as configurac,oes padrao dos
   dispositivos seriais. Para alterar as configurac,oes de um dispositivo,
   use stty. Por padrao, as configurac,oes alteradas estao em vigor ate que o
   dispositivo seja fechado e, quando o dispositivo for reaberto, volte para
   o conjunto padrao. Para alterar permanentemente o conjunto padrao, abra e
   ajuste as configurac,oes do dispositivo de inicializac,ao. Por exemplo,
   para ativar o modo CLOCAL, comunicac,ao de 8 bits e controle de fluxo
   XON/XOFF para ttyu5, digite:

 # stty -f /dev/ttyu5.init clocal cs8 ixon ixoff

   Para impedir que determinadas configurac,oes sejam alteradas por um
   aplicativo, fac,a ajustes no dispositivo de bloqueio. Por exemplo, para
   bloquear a velocidade de ttyu5 para 57600 bps, digite:

 # stty -f /dev/ttyu5.lock 57600

   Agora, qualquer aplicativo que abra ttyu5 e tente alterar a velocidade da
   porta sera bloqueado com 57600 bps.

26.3. Terminais

   Contributed by Sean Kelly.

   Os terminais fornecem uma maneira conveniente e barata de acessar um
   sistema FreeBSD quando nao estao no console do computador ou em uma rede
   conectada. Esta sec,ao descreve como usar terminais com o FreeBSD.

   Os sistemas originais UNIX(R) nao tinham consoles. Em vez disso, os
   usuarios efetuaram login e executaram programas por meio de terminais
   conectados as portas seriais do computador.

   A capacidade de estabelecer uma sessao de login em uma porta serial ainda
   existe em quase todos os sistemas operacionais do tipo UNIX(R) hoje,
   incluindo o FreeBSD. Usando um terminal conectado a uma porta serial nao
   usada, um usuario pode efetuar login e executar qualquer programa de texto
   que possa ser executado normalmente no console ou em uma janela xterm.

   Muitos terminais podem ser conectados a um sistema FreeBSD. Um computador
   sobressalente mais antigo pode ser usado como um terminal conectado a um
   computador mais potente executando o FreeBSD. Isso pode transformar o que
   poderia ser um computador de usuario unico em um poderoso sistema de
   multiplos usuarios.

   O FreeBSD suporta tres tipos de terminais:

   Terminais Burros

           Terminais burro sao um hardware especializado que se conecta a
           computadores atraves de linhas seriais. Eles sao chamados de
           "dumb" porque eles possuem apenas poder computacional suficiente
           para exibir, enviar e receber texto. Nenhum programa pode ser
           executado nesses dispositivos. Em vez disso, os terminais burros
           se conectam a um computador que executa os programas necessarios.

           Existem centenas de tipos de terminais burro feitos por muitos
           fabricantes, e praticamente qualquer tipo funciona com o FreeBSD.
           Alguns terminais high-end podem ate exibir graficos, mas apenas
           determinados pacotes de software podem aproveitar esses recursos
           avanc,ados.

           Terminais burro sao populares em ambientes de trabalho onde os
           trabalhadores nao precisam de acesso a aplicativos graficos.

   Computadores Atuando como Terminais

           Como um terminal burro tem capacidade suficiente para exibir,
           enviar e receber texto, qualquer computador de reserva pode ser um
           terminal burro. Tudo o que e necessario e o cabo adequado e algum
           software de terminal emulation para ser executado no computador.

           Esta configurac,ao pode ser util. Por exemplo, se um usuario esta
           ocupado trabalhando no console do sistema FreeBSD, outro usuario
           pode fazer algum trabalho somente de texto ao mesmo tempo de um
           computador pessoal menos potente ligado como um terminal ao
           sistema FreeBSD.

           Existem pelo menos dois utilitarios no sistema base do FreeBSD que
           podem ser usados para trabalhar atraves de uma conexao serial:
           cu(1) e tip(1).

           Por exemplo, para conectar-se de um sistema cliente que executa o
           FreeBSD para a conexao serial de outro sistema:

 # cu -l /dev/cuauN

           Portas sao numeradas a partir de zero. Isso significa que COM1 e
           /dev/cuau0.

           Programas adicionais estao disponiveis atraves da colec,ao de
           ports, como comms/minicom.

   Terminais X

           Os terminais X sao o tipo de terminal mais sofisticado disponivel.
           Em vez de se conectar a uma porta serial, eles geralmente se
           conectam a uma rede como a Ethernet. Em vez de serem relegados a
           aplicativos somente de texto, eles podem exibir qualquer
           aplicativo Xorg.

           Este capitulo nao cobre a configurac,ao ou uso de terminais X.

  26.3.1. Configurac,ao do Terminal

   Esta sec,ao descreve como configurar um sistema FreeBSD para ativar uma
   sessao de login em um terminal serial. Assume-se que o sistema reconhece a
   porta serial a qual o terminal esta conectado e que o terminal esta
   conectado com o cabo correto.

   No FreeBSD, o init le o /etc/ttys e inicia um processo getty nos terminais
   disponiveis. O processo getty e responsavel por ler um nome de login e
   iniciar o programa login. As portas no sistema FreeBSD que permitem logins
   estao listadas em /etc/ttys. Por exemplo, o primeiro console virtual,
   ttyv0, possui uma entrada nesse arquivo, permitindo logins no console.
   Este arquivo tambem contem entradas para os outros consoles virtuais,
   portas seriais e pseudo-ttys. Para um terminal com fio, a entrada /dev da
   porta serial e listada sem a parte /dev. Por exemplo, /dev/ttyv0 esta
   listado como ttyv0.

   Por padrao o /etc/ttys configura o suporte para as quatro primeiras portas
   seriais, ttyu0 ate ttyu3:

 ttyu0   "/usr/libexec/getty std.9600"   dialup  off secure
 ttyu1   "/usr/libexec/getty std.9600"   dialup  off secure
 ttyu2   "/usr/libexec/getty std.9600"   dialup  off secure
 ttyu3   "/usr/libexec/getty std.9600"   dialup  off secure

   Ao conectar um terminal a uma destas portas, modifique a entrada padrao
   para definir a velocidade e o tipo de terminal necessarios, para ligar o
   dispositivo on e, se necessario, para alterar o secure da porta. Se o
   terminal estiver conectado a outra porta, adicione uma entrada para a
   porta.

   Exemplo 26.1, "Configurando Entradas de Terminal" configura dois terminais
   em /etc/ttys. A primeira entrada configura um Wyse-50 conectado ao COM2. A
   segunda entrada configura um computador antigo executando o software do
   terminal Procomm emulando um terminal VT-100. O computador esta conectado
   `a sexta porta serial em uma placa serial com varias portas.

   Exemplo 26.1. Configurando Entradas de Terminal

 ttyu11  "/usr/libexec/getty std.38400"2  wy503  on4  insecure5
 ttyu5   "/usr/libexec/getty std.19200"  vt100  on insecure

   1 O primeiro campo especifica o nome do dispositivo do terminal serial.    
   2 O segundo campo informa ao getty para inicializar e abrir a linha,       
     definir a velocidade da linha, solicitar um nome de usuario e, em        
     seguida, executar o programa login. O tipo de getty type configura       
     caracteristicas na linha do terminal, como taxa e paridade bps. Os tipos 
     de getty disponiveis estao listados em /etc/gettytab. Em quase todos os  
     casos, os tipos de getty que comec,am com std funcionarao para terminais 
     conectados, ja que essas entradas ignoram a paridade. Ha uma entrada std 
     para cada taxa de bps de 110 a 115200. Consulte gettytab(5) para mais    
     informac,oes.                                                            
                                                                              
     Ao definir o tipo de getty, certifique-se de coincidir com as            
     configurac,oes de comunicac,ao usadas pelo terminal. Para este exemplo,  
     o Wyse-50 nao usa paridade e se conecta a 38400 bps. O computador nao    
     usa paridade e se conecta a 19200 bps.                                   
   3 O terceiro campo e o tipo de terminal. Para portas dial-up, unknown ou   
     dialup e normalmente usado, pois os usuarios podem discar praticamente   
     com qualquer tipo de terminal ou software. Como o tipo de terminal nao   
     muda para terminais com fio, um tipo de terminal real de /etc/termcap    
     pode ser especificado. Para este exemplo, o Wyse-50 usa o tipo de        
     terminal real enquanto o computador executando o Procomm esta            
     configurado para emular um VT-100.                                       
   4 O quarto campo especifica se a porta deve estar ativada. Para ativar     
     logins nessa porta, este campo deve ser definido como on.                
   5 O campo final e usado para especificar se a porta e segura. Marcar uma   
     porta como secure significa que ela e confiavel o suficiente para        
     permitir que root fac,a login a partir dessa porta. As portas inseguras  
     nao permitem logins root. Em uma porta insegura, os usuarios devem       
     efetuar login de contas nao privilegiadas e, em seguida, usar o su ou um 
     mecanismo semelhante para obter privilegios de superusuario, conforme    
     descrito em Sec,ao 3.3.1.3, "A conta de superusuario". Por razoes de     
     seguranc,a, recomenda-se alterar esta configurac,ao para insecure.       

   Depois de fazer qualquer alterac,ao em /etc/ttys, envie um sinal SIGHUP
   (hangup) para o processo init para forc,a-lo a reler seu arquivo de
   configurac,ao:

 # kill -HUP 1

   Como o init e sempre o primeiro processo executado em um sistema, ele
   sempre tem um processo ID de 1.

   Se tudo estiver configurado corretamente, todos os cabos estiverem no
   lugar e os terminais ligados, um processo getty devera estar em execuc,ao
   em cada terminal e as solicitac,oes de login deverao estar disponiveis em
   cada terminal.

  26.3.2. Soluc,ao de Problemas da Conexao

   Mesmo com a mais meticulosa atenc,ao aos detalhes, algo poderia dar errado
   ao configurar um terminal. Aqui esta uma lista de sintomas comuns e
   algumas correc,oes sugeridas.

   Se nenhum prompt de login aparecer, verifique se o terminal esta conectado
   e ligado. Se for um computador pessoal atuando como um terminal, verifique
   se ele esta executando o software de emulac,ao de terminal na porta serial
   correta.

   Certifique-se de que o cabo esteja conectado firmemente ao terminal e ao
   computador do FreeBSD. Certifique-se de que e o tipo certo de cabo.

   Certifique-se de que o terminal e o FreeBSD concordem com as
   configurac,oes de taxa e paridade de bps. Para um terminal de exibic,ao de
   video, verifique se os controles de contraste e brilho estao ativados. Se
   for um terminal de impressao, verifique se o papel e a tinta estao em bom
   estado.

   Use ps para certificar-se de que um processo getty esteja em execuc,ao e
   atendendo ao terminal. Por exemplo, a listagem a seguir mostra que um
   getty esta sendo executado na segunda porta serial, ttyu1, e esta usando a
   entrada std.38400 em /etc/gettytab:

 # ps -axww|grep ttyu
 22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyu1

   Se nenhum processo getty estiver em execuc,ao, certifique-se de que a
   porta esteja ativada em /etc/ttys. Lembre-se de executar kill -HUP 1 apos
   modificar /etc/ttys.

   Se o processo getty estiver em execuc,ao, mas o terminal ainda nao exibir
   um prompt de login ou se exibir um prompt, mas nao aceitar entrada
   digitada, o terminal ou cabo podera nao suportar handshaking de hardware.
   Tente alterar a entrada em /etc/ttys de std.38400 para 3wire.38400 e, em
   seguida, execute kill -HUP 1 depois de modificar o /etc/ttys. A entrada
   3wire e semelhante a std, mas ignora handshaking de hardware. Pode ser
   necessario reduzir a taxa de transmissao ou ativar o controle de fluxo de
   software ao usar 3wire para evitar buffer overflows.

   Se aparecer lixo em vez de um prompt de login, certifique-se de que o
   terminal e o FreeBSD concordem com as configurac,oes de taxa e paridade de
   bps. Verifique os processos getty para certificar-se de que o tipo correto
   getty esteja em uso. Se nao, edite /etc/ttys e execute kill -HUP 1.

   Se os caracteres aparecerem duplicados e a senha aparecer quando digitada,
   alterne o terminal ou o software de emulac,ao de terminal de "half duplex"
   ou "local echo" para "full duplex."

26.4. Servic,o Dial-in

   Contributed by Guy Helmer.
   Additions by Sean Kelly.

   Configurar um sistema FreeBSD para servic,o de discagem e semelhante a
   configurar terminais, exceto que os modens sao usados em vez de
   dispositivos terminais. O FreeBSD suporta modens externos e internos.

   Os modems externos sao mais convenientes, pois geralmente podem ser
   configurados por meio de parametros armazenados em RAM nao volateis e
   geralmente fornecem indicadores luminosos que exibem o estado dos sinais
   RS-232 importantes, indicando se o modem esta funcionando corretamente.

   Normalmente, os modems internos nao possuem RAM nao volatil, portanto, sua
   configurac,ao pode ser limitada `a configurac,ao de switches DIP. Se o
   modem interno tiver luzes indicadoras de sinal, elas serao dificeis de
   visualizar quando a tampa do sistema estiver no lugar.

   Ao usar um modem externo, e necessario um cabo adequado. Um cabo serial
   padrao de RS-232C deve ser suficiente.

   O FreeBSD precisa dos sinais RTS e CTS para controle de fluxo em
   velocidades acima de 2400 bps, o sinal CD para detectar quando uma chamada
   foi atendida ou a linha foi desligada e o sinal DTR para redefinir o modem
   apos a conclusao de uma sessao. Alguns cabos sao conectados sem todos os
   sinais necessarios, portanto, se uma sessao de login nao desaparecer
   quando a linha for desligada, pode haver um problema com o cabo. Consulte
   Sec,ao 26.2.1, "Cabos Serial e Portas" para mais informac,oes sobre esses
   sinais.

   Como outros sistemas operacionais similares ao UNIX(R)-like, o FreeBSD usa
   os sinais de hardware para descobrir quando uma chamada foi atendida ou
   uma linha foi desconectada e para desligar e reinicializar o modem apos
   uma chamada. O FreeBSD evita enviar comandos para o modem ou observar
   relatorios de status do modem.

   O FreeBSD suporta interfaces de comunicac,ao NS8250, NS16450, NS16550 e
   NS16550A baseado em RS-232C (CCITT V.24). Os dispositivos 8250 e 16450
   possuem buffers de caractere unico. O dispositivo 16550 fornece um buffer
   de 16 caracteres, o que permite um melhor desempenho do sistema. Bugs em
   dispositivos simples 16550 impedem o uso do buffer de 16 caracteres,
   portanto, use dispositivos 16550A, se possivel. Como os dispositivos de
   buffer de caractere unico requerem mais trabalho pelo sistema operacional
   do que os dispositivos de buffer de 16 caracteres, as placas de interface
   serial baseadas no 16550A sao preferidas. Se o sistema tiver muitas portas
   seriais ativas ou tiver uma carga pesada, as placas baseadas em 16550A sao
   melhores para comunicac,oes com baixa taxa de erro.

   O restante desta sec,ao demonstra como configurar um modem para receber
   conexoes de entrada, como se comunicar com o modem e oferece algumas dicas
   de soluc,ao de problemas.

  26.4.1. Configurac,ao de Modem

   Como nos terminais, o init gera um processo getty para cada porta serial
   configurada usada para conexoes de dial-in. Quando um usuario disca a
   linha do modem e os modems se conectam, o sinal "Carrier Detect" e
   informado pelo modem. O kernel percebe que a portadora foi detectada e
   instrui o getty a abrir a porta e exibir um prompt login: na velocidade da
   linha inicial especificada. Em uma configurac,ao tipica, se caracteres de
   lixo forem recebidos, geralmente devido `a velocidade de conexao do modem
   ser diferente da velocidade configurada, o getty tenta ajustar as
   velocidades de linha ate receber caracteres razoaveis. Depois que o
   usuario digita seu nome de login, o getty executa o login, que conclui o
   processo de login solicitando a senha do usuario e iniciando o shell do
   usuario.

   Existem duas escolas de pensamento sobre modems dial-up. Um metodo de
   configurac,ao e definir os modems e sistemas de modo que,
   independentemente da velocidade em que um usuario remoto disca, a
   interface de discagem RS-232 seja executada em uma velocidade travada. O
   beneficio dessa configurac,ao e que o usuario remoto sempre ve um prompt
   de login do sistema imediatamente. A desvantagem e que o sistema nao sabe
   qual e a verdadeira taxa de dados do usuario, portanto, programas em tela
   cheia como o Emacs nao ajustam seus metodos de tela para melhorar a
   resposta para conexoes mais lentas.

   O segundo metodo e configurar a interface RS-232 para variar sua
   velocidade com base na velocidade de conexao do usuario remoto. Como o
   getty nao compreende o relatorio de velocidade de conexao de nenhum modem
   em particular, ele fornece uma mensagem login: em uma velocidade inicial e
   observa os caracteres que retornam em resposta. Se o usuario ve lixo, eles
   devem pressionar Enter ate que um prompt reconhecivel seja exibido. Se as
   taxas de dados nao corresponderem, getty vera qualquer coisa que o usuario
   digita como lixo, e tentara a proxima velocidade e informara novamente o
   prompt login:. Esse procedimento normalmente leva apenas um pressionamento
   de tecla ou dois antes que o usuario veja um bom prompt. Essa sequ:encia
   de login nao parece tao limpa quanto o metodo de velocidade travada, mas
   um usuario em uma conexao de baixa velocidade deve receber uma melhor
   resposta interativa de programas em tela cheia.

   Ao travar a taxa de comunicac,ao de dados de um modem a uma velocidade
   especifica, nenhuma alterac,ao em /etc/gettytab deve ser necessaria. No
   entanto, para uma configurac,ao de velocidade compativel, entradas
   adicionais podem ser necessarias para definir as velocidades a serem
   usadas para o modem. Este exemplo configura um modem de 14,4 Kbps com uma
   velocidade de interface superior de 19,2 Kbps usando conexoes de 8 bits
   sem paridade. Ele configura o getty para iniciar a taxa de comunicac,ao
   para uma conexao V.32bis a 19,2 Kbps, passando por 9600 bps, 2400 bps,
   1200 bps, 300 bps e de volta para 19,2 Kbps. O ciclo de taxa de
   comunicac,ao e implementado com o recurso nx= (proxima tabela). Cada linha
   usa uma entrada tc= (continuac,ao de tabela) para selecionar o restante
   das configurac,oes para uma taxa de dados especifica.

 #
 # Additions for a V.32bis Modem
 #
 um|V300|High Speed Modem at 300,8-bit:\
         :nx=V19200:tc=std.300:
 un|V1200|High Speed Modem at 1200,8-bit:\
         :nx=V300:tc=std.1200:
 uo|V2400|High Speed Modem at 2400,8-bit:\
         :nx=V1200:tc=std.2400:
 up|V9600|High Speed Modem at 9600,8-bit:\
         :nx=V2400:tc=std.9600:
 uq|V19200|High Speed Modem at 19200,8-bit:\
         :nx=V9600:tc=std.19200:

   Para um modem de 28,8 Kbps ou para aproveitar a compactac,ao em um modem
   de 14,4 Kbps, use uma taxa de comunicac,ao mais alta, conforme mostrado
   neste exemplo:

 #
 # Additions for a V.32bis or V.34 Modem
 # Starting at 57.6 Kbps
 #
 vm|VH300|Very High Speed Modem at 300,8-bit:\
         :nx=VH57600:tc=std.300:
 vn|VH1200|Very High Speed Modem at 1200,8-bit:\
         :nx=VH300:tc=std.1200:
 vo|VH2400|Very High Speed Modem at 2400,8-bit:\
         :nx=VH1200:tc=std.2400:
 vp|VH9600|Very High Speed Modem at 9600,8-bit:\
         :nx=VH2400:tc=std.9600:
 vq|VH57600|Very High Speed Modem at 57600,8-bit:\
         :nx=VH9600:tc=std.57600:

   Para uma CPU lenta ou um sistema altamente carregado sem portas seriais
   baseadas no 16550A, esta configurac,ao pode produzir erros sio "silo" a
   57,6 Kbps.

   A configurac,ao do /etc/ttys e similar a Exemplo 26.1, "Configurando
   Entradas de Terminal", mas um argumento diferente e passado para o getty e
   dialup e usado para o tipo de terminal. Substitua xxx pelo processo init
   que sera executado no dispositivo:

 ttyu0   "/usr/libexec/getty xxx"   dialup on

   O tipo de terminal dialup pode ser alterado. Por exemplo, definir vt102
   como o tipo de terminal padrao permite que os usuarios usem a emulac,ao
   VT102 em seus sistemas remotos.

   Para uma configurac,ao de velocidade travada, especifique a velocidade com
   um tipo valido listado em /etc/gettytab. Este exemplo e para um modem cuja
   velocidade de porta esta travada em 19,2 Kbps:

 ttyu0   "/usr/libexec/getty std.19200"   dialup on

   Em uma configurac,ao de velocidade correspondente, a entrada precisa
   referenciar a entrada inicial apropriada "auto-baud" em /etc/gettytab.
   Para continuar o exemplo de um modem com velocidade correspondente que
   comec,a em 19,2 Kbps, use esta entrada:

 ttyu0   "/usr/libexec/getty V19200"   dialup on

   Depois de editar o /etc/ttys, espere ate que o modem esteja devidamente
   configurado e conectado antes de sinalizar o init:

 # kill -HUP 1

   Modems de alta velocidade, como os modems V.32, V.32bis e V.34, usam
   hardware (RTS/CTS) para controle de fluxo. Use o stty para definir a flag
   de controle de fluxo de hardware para a porta do modem. Este exemplo
   define a flag crtscts na inicializac,ao dos dispositivos COM2 de dial-in e
   de dial-out:

 # stty -f /dev/ttyu1.init crtscts
 # stty -f /dev/cuau1.init crtscts

  26.4.2. Soluc,ao de problemas

   Esta sec,ao fornece algumas dicas para solucionar problemas de um modem
   dial-up que nao se conecta ha um sistema FreeBSD.

   Conecte o modem ao sistema FreeBSD e inicialize o sistema. Se o modem
   tiver luzes de indicac,ao de status, observe se o indicador DTR do modem
   acende quando o prompt login: e exibido no console do sistema. Se acender,
   isso deve significar que o FreeBSD iniciou um processo getty na porta de
   comunicac,ao apropriada e esta aguardando o modem aceitar uma chamada.

   Se o indicador DTR nao acender, fac,a o login no sistema FreeBSD atraves
   do console e digite ps ax para ver se o FreeBSD esta executando um
   processo getty na porta correta:

   114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu0

   Se a segunda coluna contiver um d0 em vez de um ?? e o modem ainda nao
   aceitou uma chamada, isso significa que o getty completou sua chamada na
   porta de comunicac,oes. Isso pode indicar um problema com o cabeamento ou
   com um modem configurado incorretamente porque o getty nao deve conseguir
   abrir a porta de comunicac,ao ate que o sinal de detecc,ao da portadora
   tenha sido declarado pelo modem.

   Se nenhum processo getty estiver aguardando para abrir a porta, verifique
   se a entrada da porta esta correta no /etc/ttys. Alem disso, verifique o
   /var/log/messages para ver se ha alguma mensagem de log do init ou do
   getty.

   Em seguida, tente discar para o sistema. Certifique-se de usar 8 bits, sem
   paridade e 1 bit de stop no sistema remoto. Se um prompt nao aparecer
   imediatamente ou o prompt mostrar lixo, tente pressionar Enter uma vez por
   segundo durante alguns segundos. Se ainda nao houver nenhum prompt de
   login:, tente enviar um BREAK. Ao usar um modem de alta velocidade, tente
   discar novamente apos travar a velocidade da interface do modem de
   discagem.

   Se ainda nao houver o prompt login:, verifique novamente o /etc/gettytab e
   fac,a um double-check:

     * O nome do recurso inicial especificado na entrada em /etc/ttys
       corresponde ao nome de um recurso em /etc/gettytab.

     * Cada entrada nx= corresponde a outro nome de recurso gettytab.

     * Cada entrada tc= corresponde a outro nome de recurso gettytab.

   Se o modem no sistema FreeBSD nao responder, verifique se o modem esta
   configurado para atender o telefone quando o DTR e ativado. Se o modem
   parece estar configurado corretamente, verifique se a linha DTR e ativada,
   verificando as luzes indicadoras do modem.

   Se ainda assim nao funcionar, tente enviar um e-mail para a lista de
   discussao de perguntas gerais do FreeBSD descrevendo o modem e o problema.

26.5. Servic,o de Dial-in

   A seguir, dicas para fazer com que o host conecte-se atraves do modem a
   outro computador. Isto e apropriado para estabelecer uma sessao de
   terminal com um host remoto.

   Esse tipo de conexao pode ser util para obter um arquivo na Internet, caso
   haja problemas no uso do PPP. Se o PPP nao estiver funcionando, use a
   sessao do terminal para enviar por FTP o arquivo necessario. Em seguida,
   use o zmodem para transferi-lo para a maquina.

  26.5.1. Usando um Modem Stock Hayes

   Um dialer Hayes generico esta incorporado no tip. Use at=hayes em
   /etc/remote.

   O driver Hayes nao e inteligente o suficiente para reconhecer alguns dos
   recursos avanc,ados de mensagens de modems mais recentes como BUSY, NO
   DIALTONE ou CONNECT 115200. Desative essas mensagens ao usar o tip com o
   ATX0&W.

   O tempo limite de discagem para o tip e de 60 segundos. O modem deve usar
   algo menor, ou entao o tip ira achar que existe um problema de
   comunicac,ao. Tente usar ATS7=45&W.

  26.5.2. Usando comandos AT

   Crie uma entrada "direct" em /etc/remote. Por exemplo, se o modem estiver
   conectado `a primeira porta serial, /dev/cuau0, use a seguinte linha:

 cuau0:dv=/dev/cuau0:br#19200:pa=none

   Use a taxa mais alta de bps que o modem suporta no recurso br. Em seguida,
   digite tip cuau0 para conectar-se ao modem.

   Ou use cu como root com o seguinte comando:

 # cu -lline -sspeed

   line e a porta serial, tal como /dev/cuau0, e speed e a velocidade, tal
   como 57600 . Quando terminar de digitar os comandos AT, digite~. para
   sair.

  26.5.3. O Sinal @ Nao Funciona

   O @ na capability do numero de telefone diz ao tip para procurar em
   /etc/phones um numero de telefone. Mas, o sinal. @ tambem e um caractere
   especial em arquivos de capablity como o /etc/remote, entao ele precisa
   ser escapado com uma barra invertida:

 pn=\@

  26.5.4. Discando a Partir da Linha de Comando

   Coloque uma entrada "generica" em /etc/remote. Por exemplo:

 tip115200|Dial any phone number at 115200 bps:\
         :dv=/dev/cuau0:br#115200:at=hayes:pa=none:du:
 tip57600|Dial any phone number at 57600 bps:\
         :dv=/dev/cuau0:br#57600:at=hayes:pa=none:du:

   Isto deve funcionar agora:

 # tip -115200 5551234

   Usuarios que preferem comando cu ao tip, podem usar uma entrada cu
   generica:

 cu115200|Use cu to dial any number at 115200bps:\
         :dv=/dev/cuau1:br#57600:at=hayes:pa=none:du:

   e digite:

 # cu 5551234 -s 115200

  26.5.5. Definindo a Taxa de bps

   Coloque uma entrada para tip1200 ou cu1200, mas va em frente e use
   qualquer taxa bps apropriada com o capability br. O tip acha que um bom
   padrao e de 1200 bps, e e por isso que ele procura por uma entrada
   tip1200. No entanto, 1200 bps nao precisa ser usado.

  26.5.6. Acessando um Conjunto de Hosts por Meio de um Servidor de Terminal

   Em vez de esperar ate conectar-se e digitar CONNECThost a cada vez, use o
   recurso cm do tip. Por exemplo, estas entradas no /etc/remote permitirao
   que voce digite tip pain ou tip muffin para conectar-se aos hosts pain ou
   muffin e tip deep13 para conectar ao servidor de terminal.

 pain|pain.deep13.com|Forrester's machine:\
         :cm=CONNECT pain\n:tc=deep13:
 muffin|muffin.deep13.com|Frank's machine:\
         :cm=CONNECT muffin\n:tc=deep13:
 deep13:Gizmonics Institute terminal server:\
         :dv=/dev/cuau2:br#38400:at=hayes:du:pa=none:pn=5551234:

  26.5.7. Usando Mais de Uma Linha com tip

   Isto geralmente e um problema em que uma universidade tem varias linhas de
   modems e varios milhares de estudantes tentando usa-las.

   Fac,a uma entrada em /etc/remote e use @ para o recurso pn:

 big-university:\
         :pn=\@:tc=dialout
 dialout:\
         :dv=/dev/cuau3:br#9600:at=courier:du:pa=none:

   Em seguida, liste os numeros de telefone em /etc/phones:

 big-university 5551111
 big-university 5551112
 big-university 5551113
 big-university 5551114

   O tip tentara cada numero na ordem listada, depois desistira. Para
   continuar tentando, execute o tip em um loop while.

  26.5.8. Usando o Caractere de Force

   O Ctrl+P e o caracter "force" padrao, usado para dizer ao tip que o
   proximo caractere e um dado literal. O caractere force pode ser definido
   para qualquer outro caractere com o escape ~s, o que significa "definir
   uma variavel."

   Digite ~sforce=single-char seguido por uma nova linha. Onde single-char e
   qualquer caractere unico. Se o single-char for omitido, o caractere force
   sera o caractere nulo, que e acessado digitando-se Ctrl+2 ou Ctrl+Espace.
   Um valor muito bom para single-char e o Shift+Ctrl+6, que e usado apenas
   em alguns servidores de terminal.

   Para alterar o caractere force, especifique o seguinte em ~/.tiprc:

 force=single-char

  26.5.9. Caracteres Maiusculos

   Isso acontece quando o Ctrl+A e pressionado, o qual corresponde ao tip
   "raise character", especialmente concebido para pessoas coma tecla de
   caps-lock quebrada. Use ~s para definir raisechar para algo razoavel. Ele
   pode ser configurado para ser o mesmo que o caractere de force, se nenhum
   recurso for usado.

   Aqui esta um exemplo do ~/.tiprc para os usuarios do Emacs que precisam
   digitar Ctrl+2 e Ctrl+A:

 force=^^
 raisechar=^^

   O ^^ e Shift+Ctrl+6.

  26.5.10. Transferencias de Arquivos com tip

   Ao falar com outro sistema operacional semelhante ao UNIX(R), os arquivos
   podem ser enviados e recebidos usando ~p (put) e ~t (take). Esses comandos
   executam cat e echo no sistema remoto para aceitar e enviar arquivos. A
   sintaxe e:

   ~p local-file [remote-file]

   ~t remote-file [local-file]

   Nao ha verificac,ao de erros, entao outro protocolo, como zmodem,
   provavelmente deveria ser usado.

  26.5.11. Usando o zmodem com o tip?

   Para receber arquivos, inicie o programa de envio no terminal remoto. Em
   seguida, digite ~C rz para comec,ar a recebe-los localmente.

   Para enviar arquivos, inicie o programa de recebimento no terminal remoto.
   Em seguida, digite ~C sz files para envia-los ao sistema remoto.

26.6. Configurando o Console Serial

   Contributed by Kazutaka YOKOTA.
   Based on a document by Bill Paul.

   O FreeBSD tem a capacidade de inicializar um sistema com um terminal burro
   em uma porta serial como um console. Esta configurac,ao e util para
   administradores de sistemas que desejam instalar o FreeBSD em maquinas que
   nao possuem teclado ou monitor conectados, e desenvolvedores que desejam
   depurar o kernel ou drivers de dispositivos.

   Como descrito em Capitulo 12, O processo de inicializac,ao do FreeBSD, o
   FreeBSD emprega um bootstrap de tres estagios. Os dois primeiros estagios
   estao no codigo do bloco de inicializac,ao que e armazenado no inicio da
   slice do FreeBSD no disco de inicializac,ao. O bloco de inicializac,ao, em
   seguida, carrega e executa o carregador de boot como o codigo do terceiro
   estagio.

   Para configurar a inicializac,ao a partir de um console serial, o codigo
   do bloco de inicializac,ao, o codigo do carregador de inicializac,ao e o
   kernel precisam ser configurados.

  26.6.1. Configurac,ao Rapida do Console Serial

   Esta sec,ao fornece uma visao geral rapida da configurac,ao do console
   serial. Este procedimento pode ser usado quando o terminal burro e
   conectado ao COM1.

   Procedimento 26.1. Configurando um Console Serial no COM1
    1. Conecte o cabo serial ao COM1 e ao terminal de controle.

    2. Para configurar mensagens de inicializac,ao para exibic,ao no console
       serial, emita o seguinte comando como o superusuario:

 # sysrc -f /boot/loader.conf console=comconsole

    3. Edite /etc/ttys e mude off para on e dialup para vt100 para a entrada
       ttyu0. Caso contrario, uma senha nao sera necessaria para conectar-se
       atraves do console serial, resultando em uma potencial brecha de
       seguranc,a.

    4. Reinicialize o sistema para ver se as alterac,oes entraram em vigor.

   Se uma configurac,ao diferente for necessaria, consulte a proxima sec,ao
   para obter uma explicac,ao de configurac,ao mais detalhada.

  26.6.2. Configurac,ao do console serial em profundidade

   Esta sec,ao fornece uma explicac,ao mais detalhada das etapas necessarias
   para configurar um console serial no FreeBSD.

   Procedimento 26.2. Configurando um Console Serial
    1. Prepare um cabo serial.

       Use um cabo de null-modem ou um cabo serial padrao e um adaptador de
       null-modem. Veja Sec,ao 26.2.1, "Cabos Serial e Portas" para uma
       discussao sobre cabos seriais.

    2. Desconecte o teclado.

       Muitos sistemas detectam o teclado durante o Power-On Self-Test (POST)
       e geram um erro se o teclado nao for detectado. Algumas maquinas
       recusarao a inicializac,ao ate que o teclado esteja conectado.

       Se o computador reclamar do erro, mas inicializar de qualquer maneira,
       nenhuma outra configurac,ao sera necessaria.

       Se o computador se recusar a inicializar sem um teclado conectado,
       configure o BIOS para que ele ignore este erro. Consulte o manual da
       placa-mae para obter detalhes sobre como fazer isso.

  Dica:

       Tente configurar o teclado para "Not installed" no BIOS. Esta
       configurac,ao diz ao BIOS para nao detectar um teclado ao ligar, entao
       ele nao deve reclamar se o teclado estiver ausente. Se essa opc,ao nao
       estiver presente no BIOS, procure uma opc,ao "Halt on Error".
       Configurando isto para "All but Keyboard" ou para "No Errors" tera o
       mesmo efeito.

       Se o sistema tiver um mouse PS/2(R), desconecte-o tambem. Os mouses
       PS/2(R) compartilham algum hardware com o teclado e, deixar o mouse
       conectado, pode enganar o sistema e faze-lo pensar que o teclado ainda
       esta la.

  Nota:

       Embora a maioria dos sistemas inicialize sem um teclado, alguns nao
       inicializarao sem um adaptador grafico. Alguns sistemas podem ser
       configurados para inicializar sem nenhum adaptador grafico alterando a
       configurac,ao do "graphics adapter" na configurac,ao BIOS para "Not
       installed". Outros sistemas nao suportam esta opc,ao e recusarao a
       inicializac,ao se nao houver hardware de exibic,ao no sistema. Com
       estas maquinas, deixe algum tipo de placa grafica ligada, mesmo que
       seja apenas uma placa mono lixo. Um monitor nao precisa ser conectado.

    3. Conecte um terminal burro, um computador antigo com um programa de
       modem ou a porta serial de outra maquina UNIX(R) na porta serial da
       maquina freebsd.

    4. Adicione as entradas hint.sio.* apropriadas para o /boot/device.hints
       para a porta serial. Algumas placas com varias portas tambem exigem
       opc,oes de configurac,ao do kernel. Consulte sio(4) para obter as
       opc,oes necessarias e os device hints para cada porta serial
       suportada.

    5. Crie o boot.config no diretorio raiz da partic,ao a na unidade de
       inicializac,ao.

       Este arquivo instrui o codigo do bloco de inicializac,ao como
       inicializar o sistema. Para ativar o console serial, uma ou mais das
       seguintes opc,oes sao necessarias. Ao usar varias opc,oes, inclua
       todas elas na mesma linha:

            -h

                    Alterna entre os consoles interno e serial. Use isso para
                    alternar dispositivos do console. Por exemplo, para
                    inicializar a partir do console (video) interno, use -h
                    para direcionar o carregador de boot e o kernel para usar
                    a porta serial como seu dispositivo de console.
                    Alternativamente, para inicializar a partir da porta
                    serial, use -h para dizer ao gerenciador de
                    inicializac,ao e ao kernel para usar a exibic,ao de video
                    como o console.

            -D

                    Alterna entre as configurac,oes de console unica e dupla.
                    Na configurac,ao unica, o console sera o console interno
                    (exibic,ao de video) ou a porta serial, dependendo do
                    estado de -h. Na configurac,ao do console duplo, a
                    exibic,ao de video e a porta serial se tornarao o console
                    ao mesmo tempo, independentemente do estado de -h. No
                    entanto, a configurac,ao do console duplo entrara em
                    vigor somente enquanto o bloco de inicializac,ao estiver
                    em execuc,ao. Depois que o gerenciador de boot obtiver
                    controle, o console especificado por -h se tornara o
                    unico console.

            -P

                    Faz com que o bloco de inicializac,ao avalie o teclado.
                    Se nenhum teclado for encontrado, as opc,oes -D e -h
                    serao automaticamente definidas.

  Nota:

                    Devido a restric,oes de espac,o na versao atual dos
                    blocos de inicializac,ao, -P e capaz de detectar somente
                    teclados estendidos. Teclados com menos de 101 teclas e
                    sem as teclas F11 e F12 podem nao ser detectados.
                    Teclados em alguns laptops podem nao ser encontrados
                    corretamente devido a essa limitac,ao. Se este for o
                    caso, nao use -P.

       Use -P para selecionar o console automaticamente ou -h para ativar o
       console serial. Consulte boot(8) e boot.config(5) para maiores
       detalhes.

       As opc,oes, exceto para -P, sao passadas para o carregador de boot. O
       gerenciador de boot determinara se o video interno ou a porta serial
       deve se tornar o console examinando o estado de -h. Isto significa que
       se -D for especificado mas -h nao estiver especificado no
       /boot.config, a porta serial pode ser usada como console somente
       durante o bloco de inicializac,ao, pois o gerenciador de
       inicializac,ao usara a exibic,ao de video interna como o console.

    6. Inicialize a maquina.

       Quando o FreeBSD inicia, os blocos de inicializac,ao mostram o
       conteudo do /boot.config para o console. Por exemplo:

 /boot.config: -P
 Keyboard: no

       A segunda linha aparece somente se -P aparecer no /boot.config e
       indica a presenc,a ou ausencia do teclado. Estas mensagens vao para o
       console serial ou interno, ou ambos, dependendo da opc,ao em
       /boot.config:

       Opc,oes                         Mensagem vai para                      
       nenhum                          console interno                        
       -h                              console serial                         
       -D                              consoles seriais e internos            
       -Dh                             consoles seriais e internos            
       -P, teclado presente            console interno                        
       -P, teclado ausente             console serial                         

       Apos a mensagem, havera uma pequena pausa antes que os blocos de
       inicializac,ao continuem carregando o carregador de boot e antes que
       qualquer outra mensagem seja impressa no console. Em circunstancias
       normais, nao ha necessidade de interromper os blocos de
       inicializac,ao, mas pode-se faze-lo para garantir que as coisas sejam
       configuradas corretamente.

       Pressione qualquer tecla, exceto Enter, no console para interromper o
       processo de inicializac,ao. Os blocos de inicializac,ao entao
       solicitarao mais ac,oes:

 >> FreeBSD/i386 BOOT
 Default: 0:ad(0,a)/boot/loader
 boot:

       Verifique se a mensagem acima aparece no console serial ou interno, ou
       em/boot.config. Se a mensagem aparecer no console correto, pressione
       Enter para continuar o processo de inicializac,ao.

       Se nao houver nenhum prompt no terminal serial, algo esta errado com
       as configurac,oes. Digite -h e depois Enter ou Return para informar o
       bloco de inicializac,ao (e depois o carregador de inicializac,ao e o
       kernel) para escolher a porta serial para o console. Quando o sistema
       estiver ativo, volte e verifique o que deu errado.

   Durante o terceiro estagio do processo de inicializac,ao, ainda e possivel
   alternar entre o console interno e o console serial definindo as variaveis
   de ambiente apropriadas no carregador de inicializac,ao. Veja loader(8)
   para obter maiores informac,oes.

  Nota:

   Esta linha no /boot/loader.conf ou /boot/loader.conf.local configura o
   carregador de inicializac,ao e o kernel para enviar suas mensagens de
   inicializac,ao para o console serial, independentemente das opc,oes no
   /boot.config:

 console="comconsole"

   Esta linha deve ser a primeira linha do /boot/loader.conf para que as
   mensagens de boot sejam exibidas no console serial o mais cedo possivel.

   Se essa linha nao existir, ou se estiver definida como
   console="vidconsole", o carregador de inicializac,ao e o kernel usarao
   qualquer console indicado por -h no bloco de inicializac,ao. Veja
   loader.conf(5 ) para maiores informac,oes.

   No momento, o carregador de boot nao tem nenhuma opc,ao equivalente a -P
   no bloco de inicializac,ao, e nao ha provisao para selecionar
   automaticamente o console interno e o console serial com base na presenc,a
   do teclado.

  Dica:

   Embora nao seja obrigatorio, e possivel fornecer um prompt login na linha
   serial. Para configurar isto, edite a entrada para a porta serial em
   /etc/ttys usando as instruc,oes em Sec,ao 26.3.1, "Configurac,ao do
   Terminal". Se a velocidade da porta serial tiver sido alterada, altere
   std.9600 para corresponder `a nova configurac,ao.

  26.6.3. Defina uma velocidade de porta serial mais rapida

   Por padrao, as configurac,oes da porta serial sao 9600 baud, 8 bits, sem
   paridade e 1 bit de parada. Para alterar a velocidade do console padrao,
   use uma das seguintes opc,oes:

     * Edite o /etc/make.conf e configure o BOOT_COMCONSOLE_SPEED para a nova
       velocidade do console. Em seguida, recompile e instale os blocos de
       inicializac,ao e o carregador de boot:

 # cd /sys/boot
 # make clean
 # make
 # make install

       Se o console serial estiver configurado de alguma outra maneira que
       nao seja inicializando com -h, ou se o console serial usado pelo
       kernel for diferente daquele usado pelos blocos de inicializac,ao,
       adicione a seguinte opc,ao, com a velocidade desejada, em um arquivo
       de configurac,ao de kernel personalizado e compile um novo kernel:

 options CONSPEED=19200

     * Acrescente a opc,ao de inicializac,ao -S19200 ao /boot.config,
       substituindo 19200 pela velocidade a ser utilizada.

     * Adicione as seguintes opc,oes ao /boot/loader.conf. Substitua 115200
       pela velocidade de uso.

 boot_multicons="YES"
 boot_serial="YES"
 comconsole_speed="115200"
 console="comconsole,vidconsole"

  26.6.4. Entrando no Depurador DDB da Linha Serial

   Para configurar a capacidade de inserir o depurador de kernel no console
   serial, inclua as seguintes opc,oes em um arquivo de configurac,ao de
   kernel personalizado e compile o kernel usando as instruc,oes em
   Capitulo 8, Configurando o kernel do FreeBSD. Observe que, embora isso
   seja util para diagnosticos remotos, tambem e perigoso se um BREAK espurio
   for gerado na porta serial. Consulte ddb(4) e ddb(8) para mais
   informac,oes sobre o depurador do kernel.

 options BREAK_TO_DEBUGGER
 options DDB

Capitulo 27. PPP

   Indice

   27.1. Sinopse

   27.2. Configurando o PPP

   27.3. Soluc,ao de problemas de conexoes PPP

   27.4. Usando o PPP sobre Ethernet (PPPoE)

   27.5. Usando PPP sobre ATM (PPPoA)

27.1. Sinopse

   O FreeBSD suporta o protocolo Point-to-Point (PPP) que pode ser usado para
   estabelecer uma conexao de rede ou Internet usando um modem dial-up. Este
   capitulo descreve como configurar servic,os de comunicac,ao baseados em
   modem no FreeBSD.

   Depois de ler este capitulo, voce sabera:

     * Como configurar, usar e solucionar problemas de uma conexao PPP.

     * Como configurar o PPP sobre Ethernet (PPPoE).

     * Como configurar o PPP sobre ATM (PPPoA).

   Antes de ler este capitulo, voce deve:

     * Estar familiarizado com a terminologia basica de rede.

     * Entender os conceitos basicos e o proposito de uma conexao dial-up e
       PPP.

27.2. Configurando o PPP

   O FreeBSD fornece suporte nativo para gerenciamento conexoes dial-up PPP
   usando ppp(8). O kernel padrao do FreeBSD fornece suporte para o tun, que
   e usado para interagir com um hardware de modem. A configurac,ao e
   executada editando pelo menos um arquivo de configurac,ao, e exemplos
   destes arquivos de configurac,ao sao fornecidos com o sistema. Finalmente,
   o ppp e usado para iniciar e gerenciar conexoes.

   Para usar uma conexao PPP, os seguintes itens sao necessarios:

     * Uma conta dial-up com um provedor de servic,os de Internet (ISP).

     * Um modem dial-up.

     * O numero de discagem para o ISP.

     * O nome de usuario e a senha atribuidos pelo ISP.

     * O enderec,o IP de um ou mais servidores de DNS. Normalmente, o ISP
       fornece estes enderec,os. Caso contrario, o FreeBSD pode ser
       configurado para usar a negociac,ao de DNS.

   Se alguma das informac,oes necessarias estiver faltando, entre em contato
   com o ISP.

   As seguintes informac,oes podem ser fornecidas pelo ISP, mas nao sao
   necessarias:

     * O enderec,o IP do gateway padrao. Se esta informac,ao for
       desconhecida, o ISP fornecera automaticamente o valor correto durante
       a configurac,ao da conexao. Ao configurar o PPP no FreeBSD, este
       enderec,o e chamado de HISADDR.

     * A mascara de sub-rede. Se o ISP nao tiver fornecido um,
       255.255.255.255 sera usado no arquivo de configurac,ao do ppp(8).

     * Se o ISP tiver atribuido um enderec,o IP estatico e um nome de host,
       ele devera ser inserido no arquivo de configurac,ao. Caso contrario,
       essas informac,oes serao fornecidas automaticamente durante a
       configurac,ao da conexao.

   O restante desta sec,ao demonstra como configurar o FreeBSD para cenarios
   de conexao PPP comuns. O arquivo de configurac,ao requerido e o
   /etc/ppp/ppp.conf e arquivos de exemplos adicionais estao disponiveis em
   /usr/share/examples/ppp/.

  Nota:

   Ao longo desta sec,ao, muitos dos exemplos de arquivos exibem numeros de
   linha. Esses numeros de linha foram adicionados para facilitar o
   acompanhamento da discussao e nao devem ser colocados no arquivo real.

   Ao editar um arquivo de configurac,ao, o recuo adequado e importante.
   Linhas que terminam em um : iniciam na primeira coluna (inicio da linha)
   enquanto todas as outras linhas devem ser recuadas como mostrado usando
   espac,os ou tabulac,oes.

  27.2.1. Configurac,ao basica

   Para configurar uma conexao PPP, primeiro edite o /etc/ppp/ppp.conf com as
   informac,oes de discagem do ISP. Este arquivo e descrito da seguinte
   maneira:

 1     default:
 2       set log Phase Chat LCP IPCP CCP tun command
 3       ident user-ppp VERSION
 4       set device /dev/cuau0
 5       set speed 115200
 6       set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \
 7                 \"\" AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT"
 8       set timeout 180
 9       enable dns
 10
 11    provider:
 12      set phone "(123) 456 7890"
 13      set authname foo
 14      set authkey bar
 15      set timeout 300
 16      set ifaddr x.x.x.x/0 y.y.y.y/0 255.255.255.255 0.0.0.0
 17      add default HISADDR

   Linha 1:

           Identifica a entrada default. Os comandos nesta entrada (linhas 2
           a 9) sao executados automaticamente quando o ppp e executado.

   Linha 2:

           Ativa os parametros de log detalhado para testar a conexao. Uma
           vez que a configurac,ao esteja funcionando satisfatoriamente, esta
           linha deve ser reduzida para:

 set log phase tun

   Linha 3:

           Exibe a versao do ppp(8) para o software PPP em execuc,ao no outro
           lado da conexao.

   Linha 4:

           Identifica o dispositivo ao qual o modem esta conectado, onde COM1
           e /dev/cuau0 e COM2 e /dev/cuau1.

   Linha 5:

           Define a velocidade de conexao. Se 115200 nao funcionar em um
           modem mais antigo, tente 38400 em seu lugar.

   Linhas 6 & 7:

           A string de discagem escrita como na sintaxe de envio e espera.
           Consulte chat(8) para obter maiores informac,oes.

           Observe que esse comando continua na proxima linha para facilitar
           a leitura. Qualquer comando no ppp.conf pode fazer isso se o
           ultimo caractere na linha for \.

   Linha 8:

           Define o tempo ocioso limite do link em segundos.

   Linha 9:

           Instrui o peer para confirmar as configurac,oes de DNS. Se a rede
           local estiver executando seu proprio servidor DNS, essa linha deve
           ser comentada, adicionando um # no inicio da linha ou removendo-a.

   Linha 10:

           Uma linha em branco para facilitar a leitura. Linhas em branco sao
           ignoradas pelo ppp(8).

   Linha 11:

           Identifica uma entrada chamada provider. Isto pode ser alterado
           para o nome do ISP, para que load ISP possa ser usado para iniciar
           a conexao.

   Linha 12:

           Use o numero de telefone para o ISP. Varios numeros de telefone
           podem ser especificados usando os dois-pontos (:) ou o caractere
           pipe (|) como um separador. Para rotacionar entre os numeros, use
           dois pontos. Para sempre tentar discar o primeiro numero primeiro
           e usar os outros numeros apenas se o primeiro numero falhar, use o
           caractere pipe. Sempre coloque todo o conjunto de numeros de
           telefone entre aspas (") para evitar falhas de discagem.

   Linhas 13 & 14:

           Use o nome de usuario e senha para o ISP.

   Linha 15:

           Define o tempo ocioso limite padrao em segundos para a conexao.
           Neste exemplo, a conexao sera fechada automaticamente apos 300
           segundos de inatividade. Para evitar um tempo limite, defina esse
           valor como zero.

   Linha 16:

           Define os enderec,os da interface. Os valores usados dependem de
           se um enderec,o IP estatico foi obtido do ISP ou se ele negocia um
           enderec,o IP dinamico durante a conexao.

           Se o ISP tiver alocado um enderec,o IP estatico e um gateway
           padrao, substitua xxxx pelo enderec,o IP estatico e substitua yyyy
           com o enderec,o IP do gateway padrao. Se o ISP tiver fornecido
           apenas um enderec,o IP estatico sem um enderec,o de gateway,
           substitua yyyy por 10.0.0.2/0.

           Se o enderec,o IP mudar sempre que uma conexao for feita, altere
           essa linha para o seguinte valor. Isso diz ao ppp(8)para usar o IP
           Configuration Protocol (IPCP) para negociar um enderec,o IP
           dinamico:

 set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.255 0.0.0.0

   Linha 17:

           Mantenha esta linha como esta, pois ela adiciona uma rota padrao
           ao gateway. O HISADDR sera automaticamente substituido pelo
           enderec,o do gateway especificado na linha 16. E importante que
           esta linha aparec,a depois da linha 16.

   Dependendo se o ppp(8) for iniciado manualmente ou automaticamente, um
   arquivo /etc/ppp/ppp.linkup tambem pode precisar ser criado, contendo as
   seguintes linhas. Este arquivo e requerido ao executar o ppp no modo
   -auto. Este arquivo e usado apos a conexao ter sido estabelecida. Neste
   ponto, o enderec,o IP sera atribuido e agora sera possivel adicionar as
   entradas da tabela de roteamento. Ao criar este arquivo, certifique-se de
   que o provider corresponda ao valor demonstrado na linha 11 do ppp.conf.

 provider:
       add default HISADDR

   Este arquivo tambem e necessario quando o enderec,o do gateway padrao e
   "adivinhado" em uma configurac,ao de enderec,o IP estatico. Neste caso,
   remova a linha 17 do ppp.conf e crie o /etc/ppp/ppp.linkup com as duas
   linhas acima. Outros exemplos para este arquivo podem ser encontrados em
   /usr/share/examples/ppp/.

   Por padrao, o ppp deve ser executado como root. Para alterar esse padrao,
   adicione a conta do usuario que deve executar o ppp ao grupo network em
   /etc/group .

   Em seguida, conceda ao usuario acesso a uma ou mais entradas em
   /etc/ppp/ppp.conf com allow. Por exemplo, para dar a permissao para os
   usuarios fred e mary somente `a entrada provider:, inclua esta linha para
   a sec,ao provider::

 allow users fred mary

   Para fornecer aos usuarios especificados acesso a todas as entradas,
   coloque essa linha na sec,ao default.

  27.2.2. Configurac,ao Avanc,ada

   E possivel configurar o PPP para fornecer enderec,os de servidores DNS e
   NetBIOS sob demanda.

   Para habilitar estas extensoes com o PPP versao 1.x, as seguintes linhas
   podem ser adicionadas `a sec,ao relevante do /etc/ppp/ppp.conf.

 enable msext
 set ns 203.14.100.1 203.14.100.2
 set nbns 203.14.100.5

   E para o PPP versao 2 e acima:

 accept dns
 set dns 203.14.100.1 203.14.100.2
 set nbns 203.14.100.5

   Isso informara aos clientes os enderec,os do servidor de nomes primario e
   secundario e um host do servidor de nomes NetBIOS.

   Na versao 2 e acima, se a linha set dns for omitida, o PPP usara os
   valores encontrados em /etc/resolv.conf.

    27.2.2.1. Autenticac,ao PAP e CHAP

   Alguns ISPs configuram seu sistema para que a parte de autenticac,ao da
   conexao seja feita usando um dos mecanismos de autenticac,ao PAP ou CHAP.
   Se este for o caso, o ISP nao exibira um prompt login: na conexao, mas
   comec,ara a falar PPP imediatamente.

   O PAP e menos seguro que o CHAP, mas a seguranc,a normalmente nao e um
   problema aqui, pois as senhas, embora sejam enviadas como texto simples
   com o PAP, estao sendo transmitidas apenas por uma linha serial. Nao ha
   muito espac,o para crackers "escutarem".

   As seguintes alterac,oes devem ser feitas:

 13      set authname MyUserName
 14      set authkey MyPassword
 15      set login

   Linha 13:

           Esta linha especifica o nome de usuario do PAP/CHAP. Insira o
           valor correto para MyUserName.

   Linha 14:

           Esta linha especifica a senha PAP/CHAP . Insira o valor correto
           para MyPassword. Voce pode querer adicionar uma linha adicional,
           como:

 16      accept PAP

           ou

 16      accept CHAP

           para tornar obvio que essa e a intenc,ao, mas o PAP e o CHAP sao
           aceitos por padrao.

   Linha 15:

           O ISP normalmente nao exigira um login no servidor ao usar o PAP
           ou o CHAP. Portanto, desabilite a string "set login".

    27.2.2.2. Usando a funcionalidade de conversao de enderec,os de rede (NAT)
    do PPP

   O PPP tem a capacidade de usar o NAT interno sem recursos de diverting do
   kernel. Esta funcionalidade pode ser ativada pela seguinte linha no
   /etc/ppp/ppp.conf:

 nat enable yes

   Como alternativa, o NAT pode ser ativado pela opc,ao de linha de comando
   -nat. Ha tambem uma opc,ao no /etc/rc.conf chamada ppp_nat , que e ativada
   por padrao.

   Ao usar este recurso, pode ser util incluir as seguintes opc,oes no
   /etc/ppp/ppp.conf para habilitar o encaminhamento de conexoes de entrada:

 nat port tcp 10.0.0.2:ftp ftp
 nat port tcp 10.0.0.2:http http

   ou para nao confiar em nenhuma conexao de entrada

 nat deny_incoming yes

  27.2.3. Configurac,ao final do sistema

   Embora o ppp agora esteja configurado, algumas edic,oes ainda precisam ser
   feitas no /etc/rc.conf.

   Trabalhando de cima para baixo neste arquivo, certifique-se de que a linha
   hostname= esteja configurada:

 hostname="foo.example.com"

   Se o ISP tiver fornecido um nome de host e um enderec,o IP estatico, use
   este nome como o nome do host.

   Procure pela variavel network_interfaces. Para configurar o sistema para
   discar para o ISP sob demanda, certifique-se de que o dispositivo tun0
   esteja adicionado `a lista, caso contrario, remova-o.

 network_interfaces="lo0 tun0"
 ifconfig_tun0=

  Nota:

   A variavel ifconfig_tun0 deve estar vazia, e um arquivo chamado
   /etc/start_if.tun0 deve ser criado. Este arquivo deve conter a linha:

 ppp -auto mysystem

   Este script e executado no momento da configurac,ao da rede, iniciando o
   daemon do ppp no modo automatico. Se esta maquina funcionar como um
   gateway, considere incluir a opc,ao -alias. Consulte a pagina de manual
   para maiores detalhes.

   Certifique-se de que o programa roteador esta configurado para NO com a
   seguinte linha em /etc/rc.conf:

 router_enable="NO"

   E importante que o daemon routed nao seja iniciado, pois o routed tende a
   excluir as entradas da tabela de roteamento padrao criadas pelo ppp.

   E provavelmente uma boa ideia garantir que a linha sendmail_flags nao
   inclua a opc,ao -q, caso contrario o sendmail tentara fazer uma pesquisa
   de rede de vez em quando, possivelmente fazendo com que sua maquina
   disque. Voce pode tentar:

 sendmail_flags="-bd"

   A desvantagem e que o sendmail e forc,ado a reexaminar a fila de mensagens
   sempre que o link ppp subir. Para automatizar isso, inclua !Bg no
   ppp.linkup:

 1     provider:
 2       delete ALL
 3       add 0 0 HISADDR
 4       !bg sendmail -bd -q30m

   Uma alternativa e configurar um "dfilter" para bloquear o trafego SMTP.
   Consulte os arquivos de exemplo para maiores detalhes.

  27.2.4. Usando o ppp

   Tudo o que resta e reiniciar a maquina. Apos a reinicializac,ao, digite:

 # ppp

   e, em seguida, o dial provider para iniciar a sessao PPP ou para
   configurar o ppp para estabelecer sessoes automaticamente quando houver
   trafego de saida e o start_if .tun0 nao existir, digite:

 # ppp -auto provider

   E possivel falar com o programa ppp enquanto ele esta sendo executado em
   segundo plano, mas somente se uma porta de diagnostico adequada tiver sido
   configurada. Para fazer isso, adicione a seguinte linha `a configurac,ao:

 set server /var/run/ppp-tun%d DiagnosticPassword 0177

   Isso fara com que o PPP escute no soquete de dominio UNIX(R) especificado,
   solicitando aos clientes a senha especificada antes de permitir o acesso.
   O %d no nome e substituido pelo numero do dispositivo tun que esta em uso.

   Uma vez que um socket tenha sido configurado, o programa pppctl(8) pode
   ser usado em scripts que desejam manipular o programa em execuc,ao.

  27.2.5. Configurando servic,os de discagem

   A Sec,ao 26.4, "Servic,o Dial-in" fornece uma boa descric,ao sobre como
   ativar servic,os dial-up usando o getty(8).

   Uma alternativa para o getty e o port comms/mgetty+sendfax), uma versao
   mais inteligente do getty projetada com as linhas dial-up em mente.

   As vantagens de usar o mgetty e que ele fala ativamente com os modems, o
   que significa que se a porta estiver desligada no /etc/ttys entao o modem
   nao ira atender o telefone.

   Versoes posteriores do mgetty (da 0.99beta em diante) tambem suportam a
   detecc,ao automatica de fluxos PPP, permitindo acesso ao servidor de
   clientes sem script.

   Consulte a URL http://mgetty.greenie.net/doc/mgetty_toc.html para maiores
   informac,oes sobre o mgetty.

   Por padrao, o port comms/mgetty+sendfax vem com a opc,ao AUTO_PPP ativada
   permitindo que o mgetty detecte a fase LCP das conexoes PPP e crie
   automaticamente um shell ppp. No entanto, como a sequencia de login/senha
   padrao nao ocorre, e necessario autenticar os usuarios usando o PAP ou o
   CHAP.

   Esta sec,ao assume que o usuario compilou com sucesso e instalou o port
   comms/mgetty+sendfax em seu sistema.

   Assegure-se de que o /usr/local/etc/mgetty+sendfax/login.config tenha o
   seguinte:

 /AutoPPP/ -     - /etc/ppp/ppp-pap-dialup

   Isto diz ao mgetty para executar o ppp-pap-dialup para conexoes PPP
   detectadas.

   Crie um arquivo executavel chamado /etc/ppp/ppp-pap-dialup contendo o
   seguinte:

 #!/bin/sh
 exec /usr/sbin/ppp -direct pap$IDENT

   Para cada linha dial-up ativada em /etc/ttys, crie uma entrada
   correspondente em /etc/ppp/ppp.conf. Isso ira coexistir com as definic,oes
   que criamos acima.

 pap:
   enable pap
   set ifaddr 203.14.100.1 203.14.100.20-203.14.100.40
   enable proxy

   Cada usuario que fizer login com este metodo precisara ter um nome de
   usuario/senha em /etc/ppp/ppp.secret ou, como alternativa, adicione a
   seguinte opc,ao para autenticar os usuarios via PAP a partir de
   /etc/passwd.

 enable passwdauth

   Para atribuir `a alguns usuarios um enderec,o de IP estatico , especifique
   o enderec,o como o terceiro argumento em /etc/ppp/ppp.secret. Consulte o
   /usr/share/examples/ppp/ppp.secret.sample para exemplos.

27.3. Soluc,ao de problemas de conexoes PPP

   Esta sec,ao aborda alguns problemas que podem surgir ao usar PPP em uma
   conexao de modem. Alguns ISPs apresentam o prompt ssword enquanto outros
   apresentam password. Se o script ppp nao for escrito de acordo, a
   tentativa de login falhara. A maneira mais comum de depurar as conexoes
   ppp e conectando manualmente conforme descrito nesta sec,ao.

  27.3.1. Verifique os Device Nodes

   Ao usar um kernel personalizado, certifique-se de incluir a seguinte linha
   no arquivo de configurac,ao do kernel:

 device   uart

   O dispositivo uart ja esta incluido no kernel GENERIC, portanto, nenhuma
   etapa adicional e necessaria neste caso. Basta verificar a saida do dmesg
   para o dispositivo do modem com:

 # dmesg | grep uart

   Isso deve exibir alguma saida pertinente sobre os dispositivos uart. Estas
   sao as portas COM que precisamos. Se o modem funcionar como uma porta
   serial padrao, ele deve estar listado em uart1 ou COM2. Nesse caso, uma
   recompilac,ao do kernel nao e necessaria. Ao fazer a verificac,ao, se o
   modem estiver em uart1, o dispositivo do modem sera /dev/cuau1.

  27.3.2. Conectando Manualmente

   Conectar-se `a Internet controlando manualmente o ppp e rapido, facil e
   uma otima maneira de depurar uma conexao ou simplesmente obter
   informac,oes sobre como o ISP trata as conexoes ppp do cliente. Vamos
   iniciar o PPP na linha de comando. Note que em todos os nossos exemplos
   nos usaremos example como o nome do host da maquina rodando o PPP. Para
   iniciar o ppp:

 # ppp

 ppp ON example> set device /dev/cuau1

   Este segundo comando define o dispositivo do modem como cuau1.

 ppp ON example> set speed 115200

   Isso define a velocidade de conexao para 115.200 kbps.

 ppp ON example> enable dns

   Isto diz ao ppp para configurar o resolver e adicionar as linhas do
   servidor de nomes ao /etc/resolv.conf. Se o ppp nao puder determinar o
   nome do host, ele podera ser configurado manualmente mais tarde.

 ppp ON example> term

   Isso alterna para o modo de "terminal" para controlar manualmente o modem.

 deflink: Entering terminal mode on /dev/cuau1
 type '~h' for help

 at
 OK
 atdt123456789

   Use o comando at para inicializar o modem, entao use o comando atdt e o
   numero o ISP para iniciar o processo de discagem.

 CONNECT

   Confirmac,ao da conexao, se tivermos problemas de conexao, nao
   relacionados ao hardware, aqui e onde tentaremos resolve-los.

 ISP Login:myusername

   Nesse prompt, responda com o nome de usuario fornecido pelo ISP.

 ISP Pass:mypassword

   Nesse prompt, responda com a senha fornecida pelo ISP. Assim como ocorre
   ao se logar no FreeBSD, a senha nao sera exibida quando voce a digitar.

 Shell or PPP:ppp

   Dependendo do ISP, este aviso pode nao aparecer. Em caso afirmativo, ele
   esta perguntando se deve usar um shell no provedor ou iniciar o ppp. Neste
   exemplo, o ppp foi selecionado para estabelecer uma conexao com a
   Internet.

 Ppp ON example>

   Observe que neste exemplo o primeiro p foi capitalizado. Isso mostra que
   nos nos conectamos com sucesso ao ISP.

 PPp ON example>

   Nos nos autenticamos com sucesso com nosso ISP e estamos aguardando que o
   enderec,o IP seja atribuido.

 PPP ON example>

   Fizemos a negociac,ao de um enderec,o IP e concluimos nossa conexao com
   exito.

 PPP ON example>add default HISADDR

   Aqui nos adicionamos nossa rota padrao, precisamos fazer isso antes de
   podermos conversar com o mundo externo, ja que atualmente a unica conexao
   estabelecida e com o peer. Se isso falhar devido a rotas existentes,
   coloque o caractere ! na frente do add. Alternativamente, defina isso
   antes de fazer a conexao real e ele negociara uma nova rota de acordo.

   Se tudo correu bem, agora deveriamos ter uma conexao ativa com a Internet,
   que poderia ser colocada em segundo plano usando CTRL+z Se o PPP retornar
   para ppp, a conexao sera perdida. E bom saber isso porque mostra o status
   da conexao. Os P maiusculos representam uma conexao com o ISP e os p
   minusculos mostram que a conexao foi perdida.

  27.3.3. Depurac,ao

   Se uma conexao nao puder ser estabelecida, desligue o fluxo de hardware
   CTS/RTS usando set ctsrts off. Normalmente este e o problema quando nos
   conectamos ha alguns servidores de terminal com PPP, onde o PPP trava
   quando tenta gravar dados no link de comunicac,ao e aguarda um Clear To
   Send (CTS), sinal que pode nunca vir. Ao usar esta opc,ao, inclua set
   accmap, pois isso pode ser necessario para evitar que o hardware dependa
   de passar certos caracteres de ponta a ponta, na maioria das vezes
   XON/XOFF. Consulte ppp(8) para obter maiores informac,oes sobre essa
   opc,ao e como ela e usada.

   Um modem mais antigo pode precisar de set parity even. A paridade e
   definida como none por padrao, mas e usada para verificac,ao de erros com
   um grande aumento no trafego, em modems mais antigos.

   O PPP pode nao retornar ao modo de comando, que geralmente e um erro de
   negociac,ao em que o ISP esta aguardando a negociac,ao comec,ar. Neste
   ponto, usando ~p forc,ara o ppp a comec,ar a enviar as informac,oes de
   configurac,ao.

   Se um prompt de login nunca aparecer, a autenticac,ao PAP ou CHAP
   provavelmente sera necessaria. Para usar PAP ou CHAP, adicione as
   seguintes opc,oes ao PPP antes de entrar no modo terminal:

 ppp ON example> set authname myusername

   Onde myusername deve ser substituido pelo nome de usuario que foi
   atribuido pelo ISP.

 ppp ON example> set authkey mypassword

   Onde mypassword deve ser substituido pela senha que foi atribuida pelo
   ISP.

   Se uma conexao for estabelecida, mas nao conseguir encontrar nenhum nome
   de dominio, tente utilizar o ping(8) em um enderec,o IP. Se houver 100 por
   cento (100%) de perda de pacotes, e provavel que uma rota padrao nao tenha
   sido atribuida. Verifique novamente se add default HISADDR foi definido
   durante a conexao. Se uma conexao puder ser feita para um enderec,o IP
   remoto, e possivel que um enderec,o de resolvedor nao tenha sido
   adicionado ao /etc/resolv.conf. Este arquivo deve se parecer com:

 domain example.com
 nameserver x.x.x.x
 nameserver y.y.y.y

   Onde x.x.x.x e y.y.y.y deve ser substituido pelo enderec,o IP dos
   servidores DNS do ISP.

   Para configurar syslog(3) para fornecer o registro para a conexao PPP,
   verifique se essa linha existe no /etc/syslog.conf:

 !ppp
 *.*     /var/log/ppp.log

27.4. Usando o PPP sobre Ethernet (PPPoE)

   Esta sec,ao descreve como configurar o PPP sobre Ethernet (PPPoE).

   Aqui esta um exemplo de ppp.conf funcional:

 default:
   set log Phase tun command # you can add more detailed logging if you wish
   set ifaddr 10.0.0.1/0 10.0.0.2/0

 name_of_service_provider:
   set device PPPoE:xl1 # replace xl1 with your Ethernet device
   set authname YOURLOGINNAME
   set authkey YOURPASSWORD
   set dial
   set login
   add default HISADDR

   Como root, execute:

 # ppp -ddial name_of_service_provider

   Adicione o seguinte ao /etc/rc.conf:

 ppp_enable="YES"
 ppp_mode="ddial"
 ppp_nat="YES"   # if you want to enable nat for your local network, otherwise NO
 ppp_profile="name_of_service_provider"

  27.4.1. Usando um nome de perfil PPPoE

   As vezes, sera necessario usar nome de perfil para estabelecer a conexao.
   Nomes de perfil sao usados para distinguir entre diferentes servidores
   PPPoE conectados a uma determinada rede.

   Qualquer informac,ao do nome do perfil necessario deve estar na
   documentac,ao fornecida pelo ISP.

   Como ultimo recurso, pode-se tentar instalar o pacote ou port
   net/rr-pppoe. Lembre-se, no entanto, que isso pode desprogramar o seu
   modem e torna-lo inutil, entao pense duas vezes antes de faze-lo. Basta
   instalar o programa enviado com o modem. Em seguida, acesse o menu System
   do programa. O nome do perfil deve estar listado la. Geralmente e ISP.

   O nome do perfil (service tag) sera usado na entrada de configurac,ao
   PPPoE em ppp.conf como a parte do provedor para o set device. Consulte
   ppp(8) para detalhes completos. Deve ficar assim:

 set device PPPoE:xl1:ISP

   Nao se esquec,a de alterar o xl1 para o dispositivo adequado para a placa
   Ethernet.

   Nao se esquec,a de alterar o ISP para o nome de perfil.

   Para informac,oes adicionais, consulte Banda larga mais barata com o
   FreeBSD em DSL por Renaud Waldura.

  27.4.2. PPPoE com um 3Com(R) HomeConnect(R) ADSL Modem Dual Link

   Este modem nao segue a especificac,ao PPPoE definida em RFC 2516.

   Para tornar o FreeBSD capaz de se comunicar com este dispositivo, um
   sysctl deve ser configurado. Isso pode ser feito automaticamente no
   momento da inicializac,ao, atualizando o /etc/sysctl.conf:

 net.graph.nonstandard_pppoe=1

   ou pode ser feito imediatamente com o comando:

 # sysctl net.graph.nonstandard_pppoe=1

   Infelizmente, como essa e uma configurac,ao valida para todo o sistema,
   nao e possivel falar com um cliente ou servidor PPPoE normal e um 3Com(R)
   HomeConnect(R) Modem ADSL ao mesmo tempo.

27.5. Usando PPP sobre ATM (PPPoA)

   Esta sessao descreve como configurar o PPP sobre ATM (PPPoA). O PPPoA e
   uma escolha popular entre os provedores europeus de DSL.

  27.5.1. Usando o mpd

   O aplicativo mpd pode ser usado para conectar-se a uma variedade de
   servic,os, em particular servic,os PPTP. Ele pode ser instalado usando o
   pacote ou port net/mpd5. Muitos modems ADSL exigem que um tunel PPTP seja
   criado entre o modem e o computador.

   Uma vez instalado, configure o mpd para adequar-se `as configurac,oes do
   provedor. O port coloca um conjunto de arquivos de configurac,ao de
   exemplos os quais sao bem documentados em /usr/local/etc/mpd/. Um guia
   completo para configurar o mpd esta disponivel no formato HTML em
   /usr/ports/share/doc/mpd/. Aqui esta uma configurac,ao de exemplo para
   conectar-se a um servic,o ADSL com o mpd. A configurac,ao esta espalhada
   em dois arquivos, primeiro o mpd.conf:

  Nota:

   Este exemplo de mpd.conf so funciona com o mpd 4.x.

 default:
     load adsl

 adsl:
     new -i ng0 adsl adsl
     set bundle authname username 1
     set bundle password password 2
     set bundle disable multilink

     set link no pap acfcomp protocomp
     set link disable chap
     set link accept chap
     set link keep-alive 30 10

     set ipcp no vjcomp
     set ipcp ranges 0.0.0.0/0 0.0.0.0/0

     set iface route default
     set iface disable on-demand
     set iface enable proxy-arp
     set iface idle 0

     open

   1   O nome de usuario usado para autenticar com seu ISP.  
   2   A senha usada para autenticar com seu ISP.            

   Informac,oes sobre o link, ou links, a estabelecer sao encontradas em
   mpd.links. Um exemplo do mpd.links para acompanhar o exemplo acima e dado
   abaixo:

 adsl:
     set link type pptp
     set pptp mode active
     set pptp enable originate outcall
     set pptp self 10.0.0.1 1
     set pptp peer 10.0.0.138 2

   1 O enderec,o IP do computador FreeBSD executando o mpd.                   
   2 O enderec,o IP do modem ADSL. O padrao do Alcatel SpeedTouch(TM) padrao  
     e 10.0.0.138.                                                            

   E possivel inicializar a conexao facilmente, emitindo o seguinte comando
   como root:

 # mpd -b adsl

   Para ver o status da conexao:

 % ifconfig ng0
 ng0: flags=88d1<UP,POINTOPOINT,RUNNING,NOARP,SIMPLEX,MULTICAST> mtu 1500
      inet 216.136.204.117 --> 204.152.186.171 netmask 0xffffffff

   Usar o mpd e a maneira recomendada de se conectar a um servic,o ADSL com o
   FreeBSD.

  27.5.2. Usando o pptpclient

   Tambem e possivel usar o FreeBSD para conectar-se a outros servic,os PPPoA
   usando o net/pptpclient.

   Para usar o net/pptpclient para conectar-se a um servic,o DSL, instale o
   port ou o pacote e edite o /etc/ppp/ppp.conf. Uma sec,ao de exemplo do
   ppp.conf e dada abaixo. Para maiores informac,oes sobre as opc,oes do
   ppp.conf consulte ppp(8).

 adsl:
  set log phase chat lcp ipcp ccp tun command
  set timeout 0
  enable dns
  set authname username 1
  set authkey password 2
  set ifaddr 0 0
  add default HISADDR

   1   O nome de usuario no provedor de DSL.  
   2   A senha da sua conta.                  

  Atenc,ao:

   Como a senha da conta e adicionada ao ppp.conf em forma de texto simples,
   certifique-se de que ninguem possa ler o conteudo deste arquivo:

 # chown root:wheel /etc/ppp/ppp.conf
 # chmod 600 /etc/ppp/ppp.conf

   Isso abrira um tunel para uma sessao PPP para o roteador DSL. Os modems
   Ethernet DSL tem um enderec,o IP LAN pre-configurado para conexao. No caso
   do Alcatel SpeedTouch(TM) Home, este enderec,o e 10.0.0.138. A
   documentac,ao do roteador deve listar o enderec,o que o dispositivo usa.
   Para abrir o tunel e iniciar uma sessao PPP:

 # pptp address adsl

  Dica:

   Se um E comercial ("&") for adicionado ao final desse comando, o pptp
   retornara ao prompt.

   Um dispositivo de tunel virtual tun sera criado para interac,ao entre os
   processos do pptp e do ppp. Quando o prompt for retornado ou o processo do
   pptp confirmar uma conexao, examine o tunel:

 % ifconfig tun0
 tun0: flags=8051<UP,POINTOPOINT,RUNNING,MULTICAST> mtu 1500
         inet 216.136.204.21 --> 204.152.186.171 netmask 0xffffff00
         Opened by PID 918

   Se a conexao falhar, verifique a configurac,ao do roteador, que geralmente
   e acessivel usando um navegador da web. Alem disso, examine a saida do
   pptp e o conteudo do arquivo de log /var/log/ppp.log para pistas.

Capitulo 28. Correio Eletronico

   Trabalho original por Bill Lloyd.
   Reescrito por Jim Mock.
   Indice

   28.1. Sinopse

   28.2. Componentes de Email

   28.3. Arquivos de Configurac,ao do Sendmail

   28.4. Alterando o Mail Transfer Agent

   28.5. Soluc,ao de problemas

   28.6. Topicos Avanc,ados

   28.7. Configurando Apenas Envio

   28.8. Usando Email com uma Conexao Dialup

   28.9. Autenticac,ao SMTP

   28.10. Mail User Agents

   28.11. Usando o fetchmail

   28.12. Usando o procmail

28.1. Sinopse

   O "Electronic Mail", mais conhecido como email, e uma das formas de
   comunicac,ao mais utilizadas atualmente. Este capitulo fornece uma
   introduc,ao basica `a execuc,ao de um servidor de email no FreeBSD, bem
   como uma introduc,ao ao envio e recebimento de email usando o FreeBSD.
   Para uma cobertura mais completa deste assunto, consulte os livros
   listados em Apendice B, Bibliografia.

   Depois de ler este capitulo, voce sabera:

     * Quais softwares estao envolvidos no envio e recebimento de mensagens
       de email.

     * Onde os arquivos basicos de configurac,ao do Sendmail estao
       localizados no FreeBSD.

     * A diferenc,a entre caixas de correio remotas e locais.

     * Como bloquear spammers de utilizar ilegalmente um servidor de email
       como relay.

     * Como instalar e configurar um Mail Transfer Agent, substituindo o
       Sendmail.

     * Como solucionar problemas comuns de servidor de email.

     * Como configurar o sistema para apenas enviar email.

     * Como usar email com uma conexao discada.

     * Como configurar a autenticac,ao SMTP para seguranc,a adicional.

     * Como instalar e usar um Mail User Agent, como o mutt, para enviar e
       receber email.

     * Como baixar emails de um servidor remoto utilizando POP ou IMAP.

     * Como aplicar automaticamente filtros e regras ao email recebido.

   Antes de ler este capitulo, voce deve:

     * Configurar corretamente uma conexao de rede (Capitulo 31, Rede
       Avanc,ada).

     * Configure corretamente as informac,oes de DNS para um host de email
       (Capitulo 29, Servidores de Rede).

     * Saber como instalar software adicional de terceiros (Capitulo 4,
       Instalando Aplicativos: Pacotes e Ports).

28.2. Componentes de Email

   Ha cinco partes principais envolvidas em uma troca de email: o Mail User
   Agent (MUA), o Mail Transfer Agent (MTA), um host de email, uma caixa de
   correio remota ou local e DNS. Esta sec,ao fornece uma visao geral desses
   componentes.

   Mail User Agent (MUA)

           O Mail User Agent (MUA) e um aplicativo que e usado para redigir,
           enviar e receber emails. Este aplicativo pode ser um programa de
           linha de comando, como o utilitario mail interno ou um aplicativo
           de terceiros da Colec,ao de Ports, como mutt, alpine ou elm.
           Dezenas de programas graficos tambem estao disponiveis na Colec,ao
           de Ports, incluindo o Claws Mail, Evolution e Thunderbird. Algumas
           organizac,oes fornecem um programa web de email que pode ser
           acessado por meio de um navegador. Mais informac,oes sobre como
           instalar e usar um MUA no FreeBSD podem ser encontradas em
           Sec,ao 28.10, "Mail User Agents".

   Mail Transfer Agent (MTA)

           O Mail Transfer Agent (MTA) e responsavel por receber emails de
           entrada e entregar emails de saida. O FreeBSD vem com o Sendmail
           como o MTA padrao, mas tambem suporta varios outros daemons de
           servidor de email, incluindo Exim, Postfix e qmail. A
           configurac,ao do Sendmail e descrita em Sec,ao 28.3, "Arquivos de
           Configurac,ao do Sendmail". Se outro MTA estiver instalado usando
           a Colec,ao de Ports, consulte sua mensagem de pos-instalac,ao para
           detalhes de configurac,ao especificos do FreeBSD e o site do
           aplicativo para obter instruc,oes de configurac,ao mais completas.

   Servidor de Email e Caixas de Correio

           O servidor de email e um servidor responsavel por entregar e
           receber emails para um host ou uma rede. O servidor de email
           coleta todas as mensagens enviadas para o dominio e as armazena no
           mbox padrao ou no formato alternativo Maildir, dependendo da
           configurac,ao. Uma vez que o email foi armazenado, ele pode ser
           lido localmente usando um MUA ou acessado e coletado remotamente
           usando protocolos como POP ou IMAP. Se o email for lido
           localmente, nao e necessario instalar um servidor POP ou IMAP.

           Para acessar as caixas de email remotamente, e necessario um
           servidor POP ou IMAP, pois esses protocolos permitem que os
           usuarios se conectem a suas caixas de correio de locais remotos. O
           IMAP oferece varias vantagens sobre o POP. Isso inclui a
           capacidade de armazenar uma copia de mensagens em um servidor
           remoto apos o download e atualizac,oes simultaneas. O IMAP pode
           ser util em links de baixa velocidade, pois permite aos usuarios
           buscar a estrutura das mensagens sem baixa-las. Ele tambem pode
           executar tarefas como pesquisas no servidor para minimizar a
           transferencia de dados entre clientes e servidores.

           Varios servidores POP e IMAP estao disponiveis na Colec,ao de
           Ports. Estes incluem o mail/qpopper, mail/imap-uw,
           mail/courier-imap e mail/dovecot2 .

  Atenc,ao:

           Deve-se notar que o POP e o IMAP transmitem informac,oes,
           incluindo nome de usuario e senha, em texto nao criptografado.
           Para garantir a seguranc,a na transmissao de informac,oes entre
           esses protocolos, considere a utilizac,ao de tuneis seguros com
           ssh(1) (Sec,ao 13.8.1.2, "Tunelamento SSH ") ou utilize SSL
           (Sec,ao 13.6, "OpenSSL").

   Sistema de Nomes de Dominio (DNS)

           O Sistema de Nomes de Dominio (DNS) e seu daemon named desempenham
           um grande papel na entrega de email. Para enviar emails de um site
           para outro, o MTA procurara o site remoto por DNS para determinar
           qual host recebera os emails para o destino. Esse processo tambem
           ocorre quando o email e enviado de um host remoto para o MTA.

           Alem de mapear nomes de hosts para enderec,os de IP, o DNS e
           responsavel por armazenar informac,oes especificas da entrega de
           emails, conhecidas como Mail eXchanger MX. O registro MX
           especifica quais hosts receberao mensagens de um dominio em
           particular.

           Para visualizar os registros MX de um dominio, especifique o tipo
           de registro. Consulte host(1), para mais detalhes sobre este
           comando:

 % host -t mx FreeBSD.org
 FreeBSD.org mail is handled by 10 mx1.FreeBSD.org

           Consulte Sec,ao 29.7, "Sistema de Nomes de Dominio (DNS)" para
           mais informac,oes sobre DNS e sua configurac,ao.

28.3. Arquivos de Configurac,ao do Sendmail

   Contributed by Christopher Shumway.

   Sendmail e o MTA padrao instalado com o FreeBSD. Ele aceita emails de MUAs
   e os entrega ao host de email apropriado, conforme definido por sua
   configurac,ao. O Sendmail tambem pode aceitar conexoes de rede e enviar
   mensagens para caixas de correio locais ou para outro programa.

   Os arquivos de configurac,ao do Sendmail estao localizados em /etc/mail.
   Esta sec,ao descreve esses arquivos em mais detalhes.

   /etc/mail/access

           Este arquivo de acesso define quais hosts ou enderec,os de IP tem
           acesso ao servidor de email local e que tipo de acesso eles
           possuem. Os hosts listados como OK, que e a opc,ao padrao, tem
           permissao para enviar emails para esse host, desde que o destino
           final do email seja a maquina local. Os hosts listados como REJECT
           sao rejeitados para todas as conexoes de email. Os hosts listados
           como RELAY tem permissao para enviar emails para qualquer destino
           usando este servidor de email. Os hosts listados como ERROR terao
           seus emails retornados com o erro de email especificado. Se um
           host estiver listado como SKIP, o Sendmail interrompera a pesquisa
           atual por esta entrada sem aceitar ou rejeitar o email. Os hosts
           listados como QUARANTINE terao suas mensagens retidas e receberao
           o texto especificado como o motivo da retenc,ao.

           Exemplos de uso destas opc,oes para enderec,os IPv4 e IPv6 podem
           ser encontrados na configurac,ao de exemplo do FreeBSD,
           /etc/mail/access.sample:

 # $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
 #
 # Mail relay access control list.  Default is to reject mail unless the
 # destination is local, or listed in /etc/mail/local-host-names
 #
 ## Examples (commented out for safety)
 #From:cyberspammer.com          ERROR:"550 We don't accept mail from spammers"
 #From:okay.cyberspammer.com     OK
 #Connect:sendmail.org           RELAY
 #To:sendmail.org                RELAY
 #Connect:128.32                 RELAY
 #Connect:128.32.2               SKIP
 #Connect:IPv6:1:2:3:4:5:6:7     RELAY
 #Connect:suspicious.example.com QUARANTINE:Mail from suspicious host
 #Connect:[127.0.0.3]            OK
 #Connect:[IPv6:1:2:3:4:5:6:7:8] OK

           Para configurar o arquivo de acesso, use o formato mostrado no
           exemplo para adicionar entradas em /etc/mail/access, mas nao
           coloque um simbolo de comentario (#) na frente das entradas. Crie
           uma entrada para cada host ou rede cujo acesso deve ser
           configurado. Os remetentes de email que correspondem ao lado
           esquerdo da tabela sao afetados pela ac,ao no lado direito da
           tabela.

           Sempre que este arquivo for atualizado, atualize seu banco de
           dados e reinicie o Sendmail:

 # makemap hash /etc/mail/access < /etc/mail/access
 # service sendmail restart

   /etc/mail/aliases

           Este arquivo aliases contem uma lista de caixas de correio
           virtuais que sao expandidas para usuarios, arquivos, programas ou
           outros aliases. Aqui estao algumas entradas para ilustrar o
           formato do arquivo:

 root: localuser
 ftp-bugs: joe,eric,paul
 bit.bucket:  /dev/null
 procmail: "|/usr/local/bin/procmail"

           O nome da caixa de correio no lado esquerdo dos dois pontos e
           expandido para o(s) alvo(s) `a direita. A primeira entrada expande
           a caixa de correio root para a caixa de correio localuser, que e
           entao pesquisada no /etc/mail/aliases. Se nenhuma correspondencia
           for encontrada, a mensagem sera entregue para localuser. A segunda
           entrada mostra uma lista de email. Um email para ftp-bugs e
           expandido para as tres caixas de correio locais joe, eric e paul.
           Uma caixa de correio remota pode ser especificada como
           user@example.com. A terceira entrada mostra como escrever
           mensagens em um arquivo, neste caso, /dev/null. A ultima entrada
           demonstra como enviar email para um programa,
           /usr/local/bin/procmail, atraves de um pipe UNIX(R). Consulte
           aliases(5) para obter mais informac,oes sobre o formato desse
           arquivo.

           Sempre que este arquivo for atualizado, execute newaliases para
           atualizar e inicializar o banco de dados de aliases.

   /etc/mail/sendmail.cf

           Este e o arquivo de configurac,ao principal do Sendmail. Ele
           controla o comportamento geral do Sendmail, incluindo tudo desde a
           traduc,ao de enderec,os de email ate a impressao de mensagens de
           rejeic,ao para servidores de email remotos. Assim, este arquivo de
           configurac,ao e bastante complexo. Felizmente, esse arquivo
           raramente precisa ser alterado para servidores de email padrao.

           O arquivo de configurac,ao master do Sendmail pode ser criado a
           partir de macros m4(1) que definem os recursos e o comportamento
           do Sendmail. Consulte /usr/src/contrib/sendmail/cf/README para
           mais detalhes.

           Sempre que alterac,oes nesse arquivo sao feitas, o Sendmail
           precisa ser reiniciado para que as alterac,oes entrem em vigor.

   /etc/mail/virtusertable

           Esse arquivo mapeia enderec,os de email de dominios virtuais para
           caixas de correio usuarios reais. Essas caixas de correio podem
           ser locais, remotas, aliases definidas em /etc/mail/aliases ou
           arquivos. Isso permite que varios dominios virtuais sejam
           hospedados em uma maquina.

           O FreeBSD fornece um exemplo de arquivo de configurac,ao em
           /etc/mail/virtusertable.sample para demonstrar ainda mais seu
           formato. O exemplo a seguir demonstra como criar entradas
           personalizadas usando esse formato:

 root@example.com                root
 postmaster@example.com          postmaster@noc.example.net
 @example.com                    joe

           Este arquivo e processado pela primeira entrada que for
           correspondida. Quando um enderec,o de email corresponde ao
           enderec,o `a esquerda, ele e mapeado para a caixa de correio local
           listada `a direita. O formato da primeira entrada neste exemplo
           mapeia um enderec,o de email especifico para uma caixa de correio
           local, enquanto o formato da segunda entrada mapeia um enderec,o
           de email especifico para uma caixa de correio remota. Por fim,
           qualquer enderec,o de email de example.com que nao correspondeu a
           nenhuma das entradas anteriores correspondera ao ultimo mapeamento
           e sera enviado para a caixa de correio local joe. Ao criar
           entradas personalizadas, use este formato e adicione-as ao
           /etc/mail/virtusertable. Sempre que este arquivo for editado,
           atualize seu banco de dados e reinicie o Sendmail:

 # makemap hash /etc/mail/virtusertable < /etc/mail/virtusertable
 # service sendmail restart

   /etc/mail/relay-domains

           Em uma instalac,ao padrao do FreeBSD, o Sendmail e configurado
           para enviar apenas mensagens provenientes do host em que esta
           sendo executado. Por exemplo, se um servidor POP estiver
           disponivel, os usuarios poderao verificar os emails de locais
           remotos, mas nao poderao enviar emails de dominios externos.
           Normalmente, apos alguns momentos da tentativa, um email sera
           enviado de MAILER-DAEMON com uma mensagem 5.7 Relaying Denied.

           A soluc,ao mais simples e adicionar o FQDN do ISP ao
           /etc/mail/relay-domains. Se varios enderec,os forem necessarios,
           adicione-os um por linha:

 your.isp.example.com
 other.isp.example.net
 users-isp.example.org
 www.example.org

           Depois de criar ou editar este arquivo, reinicie o Sendmail com
           service sendmail restart.

           Agora, qualquer mensagem enviada pelo sistema por qualquer dominio
           dessa lista, desde que o usuario tenha uma conta no sistema, sera
           aceita. Isso permite que os usuarios enviem emails de dominios
           remotos do sistema sem precisar liberar acesso externo ao sistema,
           evitando SPAM da Internet.

28.4. Alterando o Mail Transfer Agent

   Written by Andrew Boothman.
   Information taken from emails written by Gregory Neil Shapiro.

   O FreeBSD vem com o Sendmail ja instalado como MTA, que e responsavel
   pelos emails enviados e recebidos. No entanto, o administrador do sistema
   pode alterar o MTA do sistema. Uma ampla lista de alternativas de MTAs
   esta disponivel na categoria mail da Colec,ao de Ports do FreeBSD.

   Uma vez que um novo MTA esteja instalado, configure e teste o novo
   software antes de substituir o Sendmail. Consulte a documentac,ao do novo
   MTA para obter informac,oes sobre como configurar o software.

   Uma vez que o novo MTA estiver funcionando, use as instruc,oes nesta
   sec,ao para desativar o Sendmail e configurar o FreeBSD para usar o MTA
   substituto.

  28.4.1. Desativar o Sendmail

  Atenc,ao:

   Se o servic,o de email de saida do Sendmail estiver desabilitado, e
   importante que ele seja substituido por um sistema de entrega de email
   alternativo. Caso contrario, as func,oes do sistema, como periodic(8), nao
   poderao entregar seus resultados por email. Muitas partes do sistema
   esperam um MTA funcional. Se os aplicativos continuarem a usar os binarios
   do Sendmail para tentar enviar emails depois que eles forem desativados, o
   email podera entrar em uma fila inativa do Sendmail e nunca sera entregue.

   Para desabilitar completamente o Sendmail, adicione ou edite as seguintes
   linhas no /etc/rc.conf:

 sendmail_enable="NO"
 sendmail_submit_enable="NO"
 sendmail_outbound_enable="NO"
 sendmail_msp_queue_enable="NO"

   Para desabilitar somente o servic,o de email de entrada do Sendmail, use
   apenas esta entrada no /etc/rc.conf:

 sendmail_enable="NO"

   Mais informac,oes sobre as opc,oes de inicializac,ao do Sendmail estao
   disponiveis em rc.sendmail(8).

  28.4.2. Substitua o MTA Padrao

   Quando um novo MTA e instalado usando a Colec,ao de Ports, seu script de
   inicializac,ao tambem e instalado e as instruc,oes de inicializac,ao sao
   mencionadas em sua mensagem de pacote. Antes de iniciar o novo MTA, pare
   os processos do Sendmail em execuc,ao. Este exemplo interrompe todos esses
   servic,os e em seguida, inicia o servic,o Postfix:

 # service sendmail stop
 # service postfix start

   Para configurar a substituic,ao MTA na inicializac,ao do sistema, adicione
   sua linha de configurac,ao ao /etc/rc.conf. Esta entrada habilita o MTA
   Postfix:

 postfix_enable="YES"

   Algumas configurac,oes adicionais sao necessarias, pois o Sendmail e tao
   onipresente que alguns softwares assumem que ele ja esta instalado e
   configurado. Verifique o /etc/periodic.conf e certifique-se de que esses
   valores estejam configurados como NO. Se este arquivo nao existir, crie-o
   com estas entradas:

 daily_clean_hoststat_enable="NO"
 daily_status_mail_rejects_enable="NO"
 daily_status_include_submit_mailq="NO"
 daily_submit_queuerun="NO"

   Alguns MTAs alternativos fornecem suas proprias implementac,oes
   compativeis de linha de comando do Sendmail para facilitar o uso delas
   como substitutos para o Sendmail. No entanto, alguns MUAs podem tentar
   executar binarios padrao do Sendmail em vez dos binarios do novo MTA. O
   FreeBSD usa o /etc/mail/mailer.conf para mapear os binarios esperados do
   Sendmail para o local dos novos binarios. Mais informac,oes sobre esse
   mapeamento podem ser encontradas em mailwrapper(8).

   O /etc/mail/mailer.conf padrao se parece com isto:

 # $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
 #
 # Execute the "real" sendmail program, named /usr/libexec/sendmail/sendmail
 #
 sendmail        /usr/libexec/sendmail/sendmail
 send-mail       /usr/libexec/sendmail/sendmail
 mailq           /usr/libexec/sendmail/sendmail
 newaliases      /usr/libexec/sendmail/sendmail
 hoststat        /usr/libexec/sendmail/sendmail
 purgestat       /usr/libexec/sendmail/sendmail

   Quando qualquer um dos comandos listados `a esquerda e executado, o
   sistema na verdade executa o comando associado mostrado `a direita. Esse
   sistema facilita a alterac,ao de quais binarios sao executados quando
   esses binarios padroes sao chamados.

   Alguns MTAs, quando instalados usando a Colec,ao de Ports, solicitarao a
   atualizac,ao deste arquivo para os novos binarios. Por exemplo, o Postfix
   atualizara o arquivo da seguinte forma:

 #
 # Execute the Postfix sendmail program, named /usr/local/sbin/sendmail
 #
 sendmail        /usr/local/sbin/sendmail
 send-mail       /usr/local/sbin/sendmail
 mailq           /usr/local/sbin/sendmail
 newaliases      /usr/local/sbin/sendmail

   Se a instalac,ao do MTA nao atualizar automaticamente o
   /etc/mail/mailer.conf, edite esse arquivo em um editor de texto para que
   ele aponte para os novos binarios. Este exemplo aponta para os binarios
   instalados pelo mail/ssmtp:

 sendmail        /usr/local/sbin/ssmtp
 send-mail       /usr/local/sbin/ssmtp
 mailq           /usr/local/sbin/ssmtp
 newaliases      /usr/local/sbin/ssmtp
 hoststat        /usr/bin/true
 purgestat       /usr/bin/true

   Depois que tudo estiver configurado, e recomendavel reinicializar o
   sistema. A reinicializac,ao oferece a oportunidade de garantir que o
   sistema esteja configurado corretamente para iniciar o novo MTA
   automaticamente no boot.

28.5. Soluc,ao de problemas

   28.5.1. Por que preciso usar o FQDN para hosts no meu site?

   28.5.2. Como posso executar um servidor de email em um host PPP dial-up?

28.5.1. Por que preciso usar o FQDN para hosts no meu site?                        
        O host pode, na verdade, estar em um dominio diferente. Por exemplo, para  
        um host em foo.bar.edu se conectar a um host chamado mumble no dominio     
        bar.edu, fac,a a referencia pelo Nome de Dominio Totalmente Qualificado    
        (Fully-Qualified Domain Name) FQDN, mumble.bar.edu, em vez de apenas       
        mumble.                                                                    
                                                                                   
        Isso ocorre porque a versao do BIND que vem com o FreeBSD nao fornece mais 
        abreviac,oes padrao para nao-FQDNs que nao sejam o dominio local. Um host  
        nao qualificado como mumble deve ser encontrado como mumble.foo.bar.edu,   
        ou ele sera procurado no dominio raiz.                                     
                                                                                   
        Nas versoes mais antigas do BIND, a pesquisa continuava em mumble.bar.edu  
        e mumble.edu. A RFC 1535 detalha por que isso e considerado uma ma pratica 
        ou ate mesmo uma falha de seguranc,a.                                      
                                                                                   
        Como uma boa soluc,ao, coloque a linha:                                    
                                                                                   
        search foo.bar.edu bar.edu                                                 
                                                                                   
        em vez do anterior:                                                        
                                                                                   
        domain foo.bar.edu                                                         
                                                                                   
        no /etc/resolv.conf. No entanto, certifique-se de que a ordem de pesquisa  
        nao ultrapasse o limite "entre administrac,ao local e publica", como a RFC 
        1535 a chama.                                                              
28.5.2. Como posso executar um servidor de email em um host PPP dial-up?           
        Conecte-se a um gateway de email FreeBSD na LAN. A conexao PPP nao e       
        dedicada.                                                                  
                                                                                   
        Uma maneira de fazer isso e obter um servidor de Internet em tempo         
        integral para fornecer servic,os MX secundarios para o dominio. Neste      
        exemplo, o dominio e example.com e o ISP configurou example.net para       
        fornecer o servic,o de MX secundario para o dominio:                       
                                                                                   
        example.com.          MX        10      example.com.                       
                              MX        20      example.net.                       
                                                                                   
        Apenas um host deve ser especificado como o destinatario final. Para       
        Sendmail, adicione Cw example.com em /etc/mail/sendmail.cf em example.com. 
                                                                                   
        Quando o MTA de envio tentar entregar o email, ele tentara conectar ao     
        sistema, example.com, atraves do link PPP. Isso expirara se o destino      
        estiver offline. O MTA ira entrega-lo automaticamente ao site MX           
        secundario no Provedor de Servic,os de Internet (ISP), example.net. O site 
        secundario de MX tentara conectar-se periodicamente ao host primario MX,   
        example.com.                                                               
                                                                                   
        Use algo assim como um script de login:                                    
                                                                                   
        #!/bin/sh                                                                  
        # Put me in /usr/local/bin/pppmyisp                                        
        ( sleep 60 ; /usr/sbin/sendmail -q ) &                                     
        /usr/sbin/ppp -direct pppmyisp                                             
                                                                                   
        Ao criar um script de login separado para usuarios, use sendmail           
        -qRexample.com no script acima. Isso forc,ara todos os emails na fila para 
        que example.com sejam processados imediatamente.                           
                                                                                   
        Um refinamento adicional da situac,ao pode ser visto neste exemplo na      
        lista de discussao Lista de discussao de provedor de servic,os de Internet 
        do FreeBSD:                                                                
                                                                                   
        > we provide the secondary MX for a customer. The customer connects to     
        > our services several times a day automatically to get the mails to       
        > his primary MX (We do not call his site when a mail for his domains      
        > arrived). Our sendmail sends the mailqueue every 30 minutes. At the      
        > moment he has to stay 30 minutes online to be sure that all mail is      
        > gone to the primary MX.                                                  
        >                                                                          
        > Is there a command that would initiate sendmail to send all the mails    
        > now? The user has not root-privileges on our machine of course.          
                                                                                   
        In the "privacy flags" section of sendmail.cf, there is a                  
        definition Opgoaway,restrictqrun                                           
                                                                                   
        Remove restrictqrun to allow non-root users to start the queue processing. 
        You might also like to rearrange the MXs. We are the 1st MX for our        
        customers like this, and we have defined:                                  
                                                                                   
        # If we are the best MX for a host, try directly instead of generating     
        # local config error.                                                      
        OwTrue                                                                     
                                                                                   
        That way a remote site will deliver straight to you, without trying        
        the customer connection.  You then send to your customer.  Only works for  
        "hosts", so you need to get your customer to name their mail               
        machine "customer.com" as well as                                          
        "hostname.customer.com" in the DNS.  Just put an A record in               
        the DNS for "customer.com".                                                

28.6. Topicos Avanc,ados

   Esta sec,ao aborda topicos mais envolvidos, como configurac,ao de email e
   configurac,ao de email para um dominio inteiro.

  28.6.1. Configurac,ao basica

   Fora da caixa, pode-se enviar email para hosts externos desde que
   /etc/resolv.conf esteja configurado ou a rede tenha acesso a um servidor
   DNS. Para ter um email entregue ao MTA em um host FreeBSD, siga um destes
   procedimentos:

     * Execute um servidor DNS para o dominio.

     * Tenha o email entregue diretamente para o FQDN para a maquina.

   Para que o email seja entregue diretamente a um host, ele deve ter um
   enderec,o IP estatico permanente, nao um enderec,o IP dinamico. Se o
   sistema estiver protegido por um firewall, ele devera ser configurado para
   permitir o trafego SMTP. Para receber mensagens diretamente em um host, um
   desses dois deve ser configurado:

     * Certifique-se de que o registro MX de menor numerac,ao no DNS aponte
       para o enderec,o IP estatico do host.

     * Certifique-se de que nao exista nenhuma entrada MX no DNS para o host.

   Qualquer um dos itens acima permitira que o correio seja recebido
   diretamente no host.

   Tente isto:

 # hostname
 example.FreeBSD.org
 # host example.FreeBSD.org
 example.FreeBSD.org has address 204.216.27.XX

   Neste exemplo, as mensagens enviadas diretamente para
   <yourlogin@exemplo.FreeBSD.org> devem funcionar sem problemas, supondo que
   o Sendmail esteja sendo executado corretamente em example.FreeBSD.org.

   Para este exemplo:

 # host example.FreeBSD.org
 example.FreeBSD.org has address 204.216.27.XX
 example.FreeBSD.org mail is handled (pri=10) by nevdull.FreeBSD.org

   Todas as mensagens enviadas para exemple.FreeBSD.org serao coletadas no
   hub sob o mesmo nome de usuario, em vez de serem enviadas diretamente para
   o seu host.

   As informac,oes acima sao tratadas pelo servidor DNS. O registro DNS que
   possui as informac,oes de roteamento de email e a entrada MX. Se nao
   existir nenhum registro MX, os emails serao entregues diretamente ao host
   por meio de seu enderec,o IP.

   A entrada MX de freefall.FreeBSD.org uma vez foi assim:

 freefall                MX      30      mail.crl.net
 freefall                MX      40      agora.rdrop.com
 freefall                MX      10      freefall.FreeBSD.org
 freefall                MX      20      who.cdrom.com

   freefall teve muitas entradas MX. O menor numero MX e o host que recebe
   email diretamente, se disponivel. Se nao for acessivel por algum motivo, o
   proximo host de numero mais baixo aceitara as mensagens temporariamente e
   as transmitira quando um host de numero inferior for disponibilizado.

   Sites alternativos de MX devem ter conexoes de Internet separadas para
   serem mais uteis. Seu ISP pode fornecer este servic,o.

  28.6.2. Email para um Dominio

   Ao configurar um MTA para uma rede, qualquer mensagem enviada para hosts
   em seu dominio deve ser desviada para o MTA para que os usuarios possam
   receber seus emails no servidor de email principal.

   Para tornar a vida mais facil, uma conta de usuario com o mesmo username
   deve existir tanto no MTA como no sistema com o MUA. Use adduser(8) para
   criar as contas de usuario.

   O MTA deve ser o servidor de mensagens designado para cada estac,ao de
   trabalho na rede. Isso e feito na configurac,ao DNS com um registro MX:

 example.FreeBSD.org     A       204.216.27.XX           ; Workstation
                         MX      10 nevdull.FreeBSD.org  ; Mailhost

   Isso redirecionara o email para a estac,ao de trabalho para o MTA, nao
   importa onde o registro A aponta. O email e enviado para o host MX.

   Isso deve ser configurado em um servidor DNS. Se a rede nao executar seu
   proprio servidor DNS, fale com o ISP ou provedor DNS.

   A seguir, um exemplo de hospedagem de email virtual. Considere um cliente
   com o dominio customer1.org, onde todas as mensagens para customer1.org
   devem ser enviadas para mail.myhost.com. A entrada DNS deve ficar assim:

 customer1.org           MX      10      mail.myhost.com

   Um registro A> nao e necessario em customer1.org para que seja enviado
   emails para esse dominio. No entanto, um ping em customer1.org nao
   funcionara, a menos que exista um registro A para ele.

   Diga ao MTA quais dominios e/ou nomes de host que ele deve aceitar emails.
   Qualquer um dos itens a seguir funcionara para o Sendmail:

     * Adicione os hosts ao /etc/mail/local-host-names ao usar FEATURE
       (use_cw_file).

     * Adicione uma linha Cwyour.host.com em /etc/sendmail.cf.

28.7. Configurando Apenas Envio

   Contributed by Bill Moran.

   Ha muitos casos em que muitas instancias podem querer enviar email atraves
   de um relay. Alguns exemplos sao:

     * O computador e uma maquina desktop que precisa usar programas como
       mail(1), usando o relay de email do ISP.

     * O computador e um servidor que nao manipula emails localmente, mas
       precisa passar todos os emails para um relay para processamento.

   Embora qualquer MTA seja capaz de preencher esse nicho especifico, pode
   ser dificil configurar adequadamente um MTA com todos os recursos apenas
   para lidar com o descarregamento de email. Programas como Sendmail e
   Postfix sao um exagero para esse uso.

   Alem disso, um acordo tipico de servic,o de acesso `a Internet pode
   proibir a execuc,ao de um "servidor de email".

   A maneira mais facil de atender a essas necessidades e instalar o port
   mail/ssmtp:

 # cd /usr/ports/mail/ssmtp
 # make install replace clean

   Uma vez instalado, o mail/ssmtp pode ser configurado em
   /usr/local/etc/ssmtp/ssmtp.conf:

 root=yourrealemail@example.com
 mailhub=mail.example.com
 rewriteDomain=example.com
 hostname=_HOSTNAME_

   Use o enderec,o de email real para root. Insira a retransmissao de
   mensagens de saida do ISP no lugar de mail.example.com. Alguns ISPs chamam
   isso de "servidor de email de saida" ou "servidor SMTP".

   Certifique-se de desativar o Sendmail, incluindo o servic,o de envio de
   mensagens. Veja Sec,ao 28.4.1, "Desativar o Sendmail" para detalhes.

   mail/ssmtp tem algumas outras opc,oes disponiveis. Consulte os exemplos em
   /usr/local/etc/ssmtp ou na pagina de manual do ssmtp para obter mais
   informac,oes.

   A configurac,ao do ssmtp dessa maneira permite que qualquer software no
   computador que precise enviar mensagens funcione corretamente, sem violar
   a politica de uso dos ISPs ou permitindo que o computador seja sequestrado
   para envio de spam.

28.8. Usando Email com uma Conexao Dialup

   Ao usar um enderec,o IP estatico, nao e necessario ajustar a configurac,ao
   padrao. Configure o nome do host para o nome da Internet designado e o
   Sendmail fara o resto.

   Ao usar um enderec,o IP atribuido dinamicamente e uma conexao PPP de
   discagem `a Internet, geralmente ha uma caixa de correio no servidor de
   email do ISP. Neste exemplo, o dominio do ISP e example.net, o nome de
   usuario e user, o nome do host e bsd.home, e o ISP permitiu
   relay.example.net como um relay de email.

   Para baixar emails da caixa de correio do ISP, instale um agente pela
   colec,ao de ports. O mail/fetchmail e uma boa escolha, pois suporta muitos
   protocolos diferentes. Normalmente, o ISP fornecera POP. Ao usar o usuario
   PPP, o email pode ser baixado automaticamente quando uma conexao com a
   Internet e estabelecida com a seguinte entrada em /etc/ppp/ppp.linkup:

 MYADDR:
 !bg su user -c fetchmail

   Ao usar o Sendmail para entregar emails em contas nao locais, configure o
   Sendmail para processar a fila de mensagens assim que a conexao com a
   Internet for estabelecida. Para fazer isso, adicione esta linha apos a
   entrada fetchmail acima em /etc/ppp/ppp.linkup:

   !bg su user -c "sendmail -q"

   Neste exemplo, ha uma conta para userembsd.home. No diretorio home de user
   em bsd.home, crie um .fetchmailrc que contenha esta linha :

 poll example.net protocol pop3 fetchall pass MySecret

   Este arquivo nao deve ter permissao de leitura para ninguem, exceto pelo
   user, pois contem a senha MySecret.

   Para enviar emails com o cabec,alho correto from:, configure o Sendmail
   para usar <user@example.net> em vez de <user@bsd.home> e para enviar todos
   os emails atraves de relay.example.net, permitindo uma transmissao de
   email mais rapida.

   O seguinte .mc deve ser suficiente:

 VERSIONID(`bsd.home.mc version 1.0')
 OSTYPE(bsd4.4)dnl
 FEATURE(nouucp)dnl
 MAILER(local)dnl
 MAILER(smtp)dnl
 Cwlocalhost
 Cwbsd.home
 MASQUERADE_AS(`example.net')dnl
 FEATURE(allmasquerade)dnl
 FEATURE(masquerade_envelope)dnl
 FEATURE(nocanonify)dnl
 FEATURE(nodns)dnl
 define(`SMART_HOST', `relay.example.net')
 Dmbsd.home
 define(`confDOMAIN_NAME',`bsd.home')dnl
 define(`confDELIVERY_MODE',`deferred')dnl

   Consulte a sec,ao anterior para obter detalhes sobre como converter esse
   arquivo no formato sendmail.cf. Nao esquec,a de reiniciar o Sendmail apos
   atualizar o sendmail.cf.

28.9. Autenticac,ao SMTP

   Written by James Gorham.

   Configurar a autenticac,ao SMTP no MTA oferece varios beneficios. A
   autenticac,ao SMTP adiciona uma camada de seguranc,a ao Sendmail e fornece
   aos usuarios moveis que alternam os hosts a capacidade de usar o mesmo MTA
   sem a necessidade de reconfigurar as configurac,oes de seus clientes de
   email a cada vez.

    1. Instale o security/cyrus-sasl2 da Colec,ao de Ports. Este port suporta
       varias opc,oes de tempo de compilac,ao. Para o metodo de autenticac,ao
       SMTP demonstrado neste exemplo, certifique-se de que LOGIN nao esteja
       desabilitado.

    2. Depois de instalar o security/cyrus-sasl2, edite o
       /usr/local/lib/sasl2/Sendmail.conf, ou crie-o se ele nao existir, e
       adicione a seguinte linha :

 pwcheck_method: saslauthd

    3. Em seguida, instale o security/cyrus-sasl2-saslauthd e adicione a
       seguinte linha ao /etc/rc.conf:

 saslauthd_enable="YES"

       Finalmente, inicie o daemon saslauthd:

 # service saslauthd start

       Este daemon serve como um intermediario para o Sendmail autenticar no
       banco de dados do FreeBSD o passwd(5). Isso evita o trabalho de criar
       um novo conjunto de nomes de usuario e senhas para cada usuario que
       precise usar a autenticac,ao SMTP e mantem a senha de login e email
       igual.

    4. Em seguida, edite o /etc/make.conf e adicione as seguintes linhas:

 SENDMAIL_CFLAGS=-I/usr/local/include/sasl -DSASL
 SENDMAIL_LDFLAGS=-L/usr/local/lib
 SENDMAIL_LDADD=-lsasl2

       Essas linhas fornecem ao Sendmail as opc,oes de configurac,ao
       apropriadas para vincular ao cyrus-sasl2 em tempo de compilac,ao.
       Certifique-se de que o cyrus-sasl2 tenha sido instalado antes de
       recompilar o Sendmail.

    5. Recompile o Sendmail executando os seguintes comandos:

 # cd /usr/src/lib/libsmutil
 # make cleandir && make obj && make
 # cd /usr/src/lib/libsm
 # make cleandir && make obj && make
 # cd /usr/src/usr.sbin/sendmail
 # make cleandir && make obj && make && make install

       Esta compilac,ao nao deve ter nenhum problema se o /usr/src nao foi
       alterado extensivamente e as bibliotecas compartilhadas necessarias
       estiverem disponiveis.

    6. Depois que o Sendmail tenha sido compilado e reinstalado, edite o
       /etc/mail/freebsd.mc ou o arquivo local .mc. Muitos administradores
       optam por usar a saida de hostname(1) como o nome de .mc para
       exclusividade. Adicione estas linhas:

 dnl set SASL options
 TRUST_AUTH_MECH(`GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN')dnl
 define(`confAUTH_MECHANISMS', `GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN')dnl

       Essas opc,oes configuram os diferentes metodos disponiveis para que o
       Sendmail autentique usuarios. Para usar um metodo diferente de
       pwcheck, consulte a documentac,ao do Sendmail.

    7. Finalmente, execute make(1) enquanto estiver em /etc/mail. Isso
       executara o novo .mc e criara um .cf chamado freebsd.cf ou o nome
       usado para o arquivo local .mc. Em seguida, execute make install
       restart, que copiara o arquivo para o sendmail.cf, e reinicie
       corretamente o Sendmail. Para mais informac,oes sobre este processo,
       consulte /etc/mail/Makefile.

   Para testar a configurac,ao, use um MUA para enviar uma mensagem de teste.
   Para investigac,oes posteriores, defina o LogLevel do Sendmail como 13 e
   verifique o /var/log/maillog para quaisquer erros.

   Para mais informac,oes, consulte autenticac,ao SMTP.

28.10. Mail User Agents

   Contributed by Marc Silver.

   Um MUA e um aplicativo usado para enviar e receber emails. A medida que o
   email "evolui" e se torna mais complexo, os MUAs estao se tornando cada
   vez mais poderosos e fornecem aos usuarios maior funcionalidade e
   flexibilidade. A categoria mail da Colec,ao de Ports do FreeBSD contem
   numerosos MUAs. Eles incluem clientes de email graficos como Evolution ou
   Balsa e clientes baseados em console, como mutt ou alpine.

  28.10.1. mail

   mail(1) e o MUA padrao instalado com o FreeBSD. E um MUA baseado em
   console que oferece a funcionalidade basica necessaria para enviar e
   receber email em texto. Ele fornece suporte limitado a anexos e so pode
   acessar caixas de correio locais.

   Embora o mail nao suporte nativamente a interac,ao com os servidores POP
   ou IMAP, essas caixas de correio podem ser baixadas para um arquivo mbox
   local usando um aplicativo como fetchmail.

   Para enviar e receber email, execute mail:

 % mail

   O conteudo da caixa de correio do usuario em /var/mail e lido
   automaticamente pelo mail. Se a caixa de correio estiver vazia, o
   utilitario saira com uma mensagem indicando que nenhum email foi
   encontrado. Se o email existir, a interface do aplicativo sera iniciada e
   uma lista de mensagens sera exibida. As mensagens sao numeradas
   automaticamente, como pode ser visto no exemplo a seguir:

 Mail version 8.1 6/6/93.  Type ? for help.
 "/var/mail/marcs": 3 messages 3 new
 >N  1 root@localhost        Mon Mar  8 14:05  14/510   "test"
  N  2 root@localhost        Mon Mar  8 14:05  14/509   "user account"
  N  3 root@localhost        Mon Mar  8 14:05  14/509   "sample"

   Agora as mensagens podem ser lidas digitando t seguido pelo numero da
   mensagem. Este exemplo le o primeiro email:

 & t 1
 Message 1:
 From root@localhost  Mon Mar  8 14:05:52 2004
 X-Original-To: marcs@localhost
 Delivered-To: marcs@localhost
 To: marcs@localhost
 Subject: test
 Date: Mon,  8 Mar 2004 14:05:52 +0200 (SAST)
 From: root@localhost (Charlie Root)

 This is a test message, please reply if you receive it.

   Como visto neste exemplo, a mensagem sera exibida com cabec,alhos
   completos. Para exibir novamente a lista de mensagens, pressione h.

   Se o email exigir uma resposta, pressione as teclas R ou r no mail. R
   instrui o mail a responder apenas ao remetente do email, enquanto r
   responde a todos os outros destinatarios da mensagem. Esses comandos podem
   ser sufixados com o numero do email. Depois de digitar a resposta, o final
   da mensagem deve ser marcado por um unico . em sua propria linha. Um
   exemplo pode ser visto abaixo:

 & R 1
 To: root@localhost
 Subject: Re: test

 Thank you, I did get your email.
 .
 EOT

   Para enviar um novo email, pressione m, seguido pelo enderec,o de email do
   destinatario. Varios destinatarios podem ser especificados separando cada
   enderec,o com o delimitador ,. O assunto da mensagem pode entao ser
   inserido, seguido pelo conteudo da mensagem. O final da mensagem deve ser
   especificado colocando um unico . em sua propria linha.

 & mail root@localhost
 Subject: I mastered mail

 Now I can send and receive email using mail ... :)
 .
 EOT

   Enquanto estiver usando o mail, pressione ? para exibir a ajuda a qualquer
   momento. Consulte mail(1) para obter mais detalhes sobre como usar o mail.

  Nota:

   O mail(1) nao foi projetado para manipular anexos e, portanto, lida mal
   com eles. Novos MUAs lidam com anexos de uma maneira mais inteligente.
   Usuarios que preferem usar mail podem preferir o port converters/mpack.

  28.10.2. mutt

   O mutt e um poderoso MUA, com muitos recursos, incluindo:

     * A capacidade de enviar mensagens.

     * Suporte PGP para assinatura digital e criptografia de email.

     * Suporte MIME.

     * Suporte Maildir.

     * Altamente personalizavel.

   Consulte http://www.mutt.org para mais informac,oes sobre o mutt.

   O mutt pode ser instalado usando o port mail/mutt. Apos o port ter sido
   instalado, o mutt pode ser iniciado com o seguinte comando:

 % mutt

   O mutt ira automaticamente ler o conteudo da caixa de correio do usuario
   em /var/mail. Se nenhum email for encontrado, o mutt aguardara os comandos
   do usuario. O exemplo abaixo mostra o mutt exibindo uma lista de
   mensagens:

   Para ler um email, selecione-o usando as teclas de cursor e pressione
   Enter. Um exemplo de email exibido pelo mutt pode ser visto abaixo:

   Semelhante ao mail(1), o mutt pode ser usado para responder apenas ao
   remetente da mensagem, bem como para todos os destinatarios. Para
   responder apenas ao remetente do email, pressione r. Para enviar uma
   resposta de grupo ao remetente original e a todos os destinatarios da
   mensagem, pressione g.

  Nota:

   Por padrao, o mutt usa o editor vi(1) para criar e responder emails. Cada
   usuario pode personalizar isso criando ou editando o .muttrc em seu
   diretorio home e configurando a variavel editor ou definindo a variavel de
   ambiente EDITOR. Consulte http://www.mutt.org/ para obter mais
   informac,oes sobre como configurar o mutt.

   Para escrever uma nova mensagem de email, pressione m. Depois que um
   assunto valido foi dado, mutt iniciara o vi(1) para que o email possa ser
   escrito. Quando o conteudo do email estiver completo, salve e saia do vi.
   O mutt sera retomado, exibindo uma tela de resumo do email que sera
   enviado. Para enviar o email, pressione y. Um exemplo da tela de resumo
   pode ser visto abaixo:

   O mutt contem manuais extensos que podem ser acessados pela maioria dos
   menus pressionando ?. A linha superior tambem exibe os atalhos de teclado,
   quando apropriado.

  28.10.3. alpine

   O alpine e destinado a um usuario iniciante, mas tambem inclui alguns
   recursos avanc,ados.

  Atenc,ao:

   O alpine teve varias vulnerabilidades remotas descobertas no passado, que
   permitiam que atacantes remotos executassem codigo arbitrario como
   usuarios no sistema local, pela ac,ao de enviar um email especialmente
   preparado. Enquanto problemas conhecidos foram corrigidos, o codigo alpine
   foi escrito em um estilo inseguro e o FreeBSD Security Officer acredita
   que provavelmente ha outras vulnerabilidades nao descobertas. Os usuarios
   instalam o alpine por sua conta e risco.

   A versao atual do alpine pode ser instalada usando o port mail/alpine.
   Apos a instalac,ao do port, o alpine pode ser iniciado executando o
   seguinte comando:

 % alpine

   A primeira vez que o alpine e executado, ele exibe uma pagina de saudac,ao
   com uma breve introduc,ao, bem como uma solicitac,ao da equipe de
   desenvolvimento do alpine para enviar uma mensagem de email anonima para
   que eles saibam quantos usuarios estao usando o seu cliente. Para enviar
   esta mensagem anonima, pressione Enter. Como alternativa, pressione E para
   sair da saudac,ao sem enviar uma mensagem anonima. Um exemplo da pagina de
   saudac,ao e mostrado abaixo:

   O menu principal e entao apresentado, o qual pode ser navegado usando as
   teclas de cursor. Esse menu principal fornece atalhos para a composic,ao
   de novos emails, navegac,ao em diretorios de email e administrac,ao de
   entradas do catalogo de enderec,os. Abaixo do menu principal, sao
   mostrados os atalhos de teclado relevantes para executar func,oes
   especificas da tarefa em questao.

   O diretorio padrao aberto pelo alpine e o inbox. Para visualizar o indice
   da mensagem, pressione I ou selecione a opc,ao MESSAGE INDEX mostrada
   abaixo:

   O indice de mensagens mostra mensagens no diretorio atual e pode ser
   navegado usando as teclas de cursor. As mensagens destacadas podem ser
   lidas pressionando Enter.

   Na captura de tela abaixo, uma mensagem de exemplo e exibida pelo alpine.
   Atalhos de teclado contextuais sao exibidos na parte inferior da tela. Um
   exemplo de um atalho e r, que diz ao MUA para responder `a mensagem atual
   sendo exibida.

   A resposta de um email pelo alpine e feita usando o editor pico, que e
   instalado por padrao com o alpine. O pico facilita a navegac,ao na
   mensagem e e mais facil de ser usado por usuarios iniciantes do que o
   vi(1) ou mail(1). Quando a resposta estiver completa, a mensagem pode ser
   enviada pressionando Ctrl+X. O alpine solicitara confirmac,ao antes de
   enviar a mensagem.

   O alpine pode ser personalizado usando a opc,ao SETUP no menu principal.
   Consulte http://www.washington.edu/alpine/ para mais informac,oes.

28.11. Usando o fetchmail

   Contributed by Marc Silver.

   O fetchmail e um cliente IMAP e POP completo. Ele permite que os usuarios
   baixem automaticamente emails de servidores IMAP e POP remotos e os salvem
   em caixas de correio locais, onde podem ser acessados mais facilmente. O
   fetchmail pode ser instalado usando o port mail/fetchmail e oferece varios
   recursos, incluindo:

     * Suporte para os protocolos POP3, o APOP, o KPOP, o IMAP, o ETRN e o
       ODMR.

     * Capacidade de encaminhar emails usando SMTP, que permite que a
       filtragem, o encaminhamento e aliases funcionem normalmente.

     * Pode ser executado no modo daemon para verificar periodicamente novas
       mensagens.

     * Pode buscar varias caixas de correio e encaminha-las, com base na
       configurac,ao, para diferentes usuarios locais.

   Esta sec,ao explica alguns dos recursos basicos do fetchmail. Este
   utilitario requer uma configurac,ao .fetchmailrc no diretorio pessoal do
   usuario para que seja executado corretamente. Este arquivo inclui
   informac,oes do servidor, bem como credenciais de login. Devido `a
   natureza sensivel do conteudo deste arquivo, e aconselhavel torna-lo
   legivel apenas pelo usuario, com o seguinte comando:

 % chmod 600 .fetchmailrc

   O seguinte .fetchmailrc serve como um exemplo para fazer o download de uma
   unica caixa de correio de usuario usando POP. Ele diz ao fetchmail para se
   conectar ao example.com usando um nome de usuario joesoap e uma senha de
   XXX. Este exemplo pressupoe que o usuario joesoap exista no sistema local.

 poll example.com protocol pop3 username "joesoap" password "XXX"

   O proximo exemplo conecta-se a varios servidores POP e IMAP e redireciona
   para diferentes nomes de usuarios locais quando aplicavel:

 poll example.com proto pop3:
 user "joesoap", with password "XXX", is "jsoap" here;
 user "andrea", with password "XXXX";
 poll example2.net proto imap:
 user "john", with password "XXXXX", is "myth" here;

   fetchmail pode ser executado no modo daemon executando-o com -d, seguido
   pelo intervalo (em segundos) que o fetchmail deve pesquisar servidores
   listados em .fetchmailrc. O exemplo a seguir configura o fetchmail para
   pesquisar a cada 600 segundos:

 % fetchmail -d 600

   Mais informac,oes sobre o fetchmail podem ser encontradas em
   http://www.fetchmail.info/.

28.12. Usando o procmail

   Contributed by Marc Silver.

   O procmail e um poderoso aplicativo usado para filtrar mensagens
   recebidas. Ele permite que os usuarios definam "regras" que podem ser
   correspondidas aos emails recebidos para executar func,oes especificas ou
   para redirecionar o email para caixas de correio alternativas ou
   enderec,os de email. O procmail pode ser instalado usando o port
   mail/procmail. Uma vez instalado, ele pode ser diretamente integrado na
   maioria dos MTAs. Consulte a documentac,ao do MTA para mais informac,oes.
   Alternativamente, procmail pode ser integrado adicionando a seguinte linha
   a um .forward no diretorio pessoal do usuario:

 "|exec /usr/local/bin/procmail || exit 75"

   A sec,ao a seguir exibe algumas regras basicas do procmail, alem de breves
   descric,oes do que elas fazem. As regras devem ser inseridas em um
   .procmailrc, que deve residir no diretorio pessoal do usuario.

   A maioria dessas regras pode ser encontrada em procmailex(5).

   Para encaminhar todos os emails de <user@example.com> para um enderec,o
   externo de <goodmail@example2.com>:

 :0
 * ^From.*user@example.com
 ! goodmail@example2.com

   Para encaminhar todos os emails com menos de 1000 bytes para um enderec,o
   externo de <goodmail@example2.com>:

 :0
 * < 1000
 ! goodmail@example2.com

   Para enviar todas as mensagens enviadas para <alternate@example.com> para
   uma caixa de correio chamada alternate:

 :0
 * ^TOalternate@example.com
 alternate

   Para enviar todas as mensagens com um assunto de "Spam" para /dev/null:

 :0
 ^Subject:.*Spam
 /dev/null

   Uma receita util que analisa listas de discussao do FreeBSD.org e coloca
   cada lista em sua propria caixa de correio:

 :0
 * ^Sender:.owner-freebsd-\/[^@]+@FreeBSD.ORG
 {
         LISTNAME=${MATCH}
         :0
         * LISTNAME??^\/[^@]+
         FreeBSD-${MATCH}
 }

Capitulo 29. Servidores de Rede

   Indice

   29.1. Sinopse

   29.2. O super-servidor inetd

   29.3. Network File System (NFS)

   29.4. Sistema de Informac,ao de Rede (NIS)

   29.5. Protocolo leve de acesso de diretorio ( LDAP )

   29.6. Protocolo de configurac,ao dinamica de hosts (DHCP)

   29.7. Sistema de Nomes de Dominio (DNS)

   29.8. Servidor HTTP Apache

   29.9. Protocolo de Transferencia de Arquivos (FTP)

   29.10. Servic,os de arquivos e impressao para clientes Microsoft(R)
   Windows(R) Clients (Samba)

   29.11. Sincronizac,ao de Relogio com NTP

   29.12. Inicializador iSCSI e Configurac,ao Alvo

29.1. Sinopse

   Este capitulo aborda alguns dos servic,os de rede usados com mais
   frequencia em sistemas UNIX(R). Isso inclui instalar, configurar, testar e
   manter muitos tipos diferentes de servic,os de rede. Exemplos de arquivos
   de configurac,ao estao incluidos neste capitulo para referencia.

   No final deste capitulo, os leitores saberao:

     * Como gerenciar o daemon inetd.

     * Como configurar o Network File System (NFS).

     * Como configurar o Network Information Server (NIS) para centralizar e
       compartilhar contas de usuarios.

     * Como configurar o FreeBSD para funcionar como um servidor ou cliente
       LDAP

     * Como configurar configurac,oes de rede automaticas usando o DHCP.

     * Como configurar um Domain Name Server (DNS).

     * Como configurar o servidor Apache HTTP.

     * Como Configurar um Servidor de File Transfer Protocol (FTP).

     * Como configurar um servidor de arquivo e de impressao para clientes
       Windows(R) usando o Samba.

     * Como sincronizar a hora e a data e configurar um servidor de horario
       usando o Network Time Protocol (NTP).

     * Como configurar o iSCSI.

   Este capitulo pressupoe um conhecimento basico de:

     * scripts /etc/rc.

     * Terminologia de rede.

     * Instalac,ao de software adicional de terceiros (Capitulo 4, Instalando
       Aplicativos: Pacotes e Ports).

29.2. O super-servidor inetd

   O daemon inetd(8) e algumas vezes chamado de Super-Servidor porque
   gerencia conexoes para muitos servic,os. Em vez de iniciar varios
   aplicativos, apenas o servic,o inetd precisa ser iniciado. Quando uma
   conexao e recebida para um servic,o gerenciado pelo inetd, ele determina
   para qual programa a conexao esta destinada, gera um processo para esse
   programa e delega ao programa um socket. O uso de inetd para servic,os que
   nao sao muito usados pode reduzir a carga do sistema, quando comparado `a
   execuc,ao de cada daemon individualmente no modo independente.

   Primeiramente, inetd e usado para gerar outros daemons, mas varios
   protocolos triviais sao tratados internamente, como chargen, auth, time,
   echo, discard e daytime.

   Esta sec,ao aborda os conceitos basicos da configurac,ao do inetd.

  29.2.1. Arquivo de Configurac,ao

   A configurac,ao do inetd e feita editando o /etc/inetd.conf. Cada linha
   deste arquivo de configurac,ao representa um aplicativo que pode ser
   iniciado pelo inetd. Por padrao, cada linha comec,a com um comentario (#),
   o que significa que inetd nao esta atendendo a nenhum aplicativo. Para
   configurar o inetd para escutar as conexoes de um aplicativo, remova o #
   no inicio da linha desse aplicativo.

   Depois de salvar suas edic,oes, configure o inetd para iniciar na
   inicializac,ao do sistema editando o arquivo /etc/rc.conf:

 inetd_enable="YES"

   Para iniciar o inetd agora, para que ele ouc,a o servic,o que voce
   configurou, digite:

 # service inetd start

   Uma vez iniciado o inetd, ele precisa ser notificado sempre que uma
   modificac,ao for feita no arquivo /etc/inetd.conf:

   Exemplo 29.1. Recarregando o Arquivo de Configurac,ao do inetd

 # service inetd reload

   Normalmente, a entrada padrao de um aplicativo nao precisa ser editada
   alem da remoc,ao do #. Em algumas situac,oes, pode ser apropriado editar a
   entrada padrao.

   Como exemplo, esta e a entrada padrao para ftpd(8) sobre o IPv4:

 ftp     stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -l

   As sete colunas em uma entrada sao as seguintes:

 service-name
 socket-type
 protocol
 {wait|nowait}[/max-child[/max-connections-per-ip-per-minute[/max-child-per-ip]]]
 user[:group][/login-class]
 server-program
 server-program-arguments

   Onde:

   service-name

           O nome do servic,o do daemon para iniciar. Deve corresponder a um
           servic,o listado no arquivo /etc/services. Isso determina qual
           porta inetd atende para conexoes de entrada para esse servic,o. Ao
           usar um servic,o personalizado, ele deve primeiro ser adicionado
           ao arquivo /etc/services.

   socket-type

           Ou stream, dgram, raw, ou seqpacket. Use stream para conexoes TCP
           e dgram para servic,os UDP.

   protocol

           Use um dos seguintes nomes de protocolo:

                   Protocol Name                     Explicac,ao              
           tcp ou tcp4                   TCP IPv4                             
           udp ou udp4                   UDP IPv4                             
           tcp6                          TCP IPv6                             
           udp6                          UDP IPv6                             
           tcp46                         Ambos TCP IPv4 e IPv6                
           udp46                         Ambos UDP IPv4 e IPv6                

   {wait|nowait}[/max-child[/max-connections-per-ip-per-minute[/max-child-per-ip]]]

           Neste campo, wait ou nowait deve ser especificado. max-child,
           max-connections-per-ip-por-minute e max-child-per-ip sao
           opcionais.

           wait|nowait indica se o servic,o pode ou nao manipular seu proprio
           socket. Os tipos de socket dgram devem usar wait enquanto os
           daemons stream, que geralmente sao multi-threaded, devem usar
           nowait. wait geralmente passa varios sockets para um unico daemon,
           enquanto nowait gera um daemon filho para cada novo socket.

           O numero maximo de daemons inetd que podem aparecer e definido por
           max-child. Por exemplo, para limitar dez instancias do daemon,
           coloque um /10 apos o nowait. Especificar /0 permite um numero
           ilimitado de filhos.

           max-connections-per-ip-per-minute limita o numero de conexoes de
           qualquer enderec,o especifico de IP por minuto. Quando o limite
           for atingido, outras conexoes desse enderec,o IP serao descartadas
           ate o final do minuto. Por exemplo, um valor de /10 limitaria
           qualquer enderec,o IP especifico a dez tentativas de conexao por
           minuto. max-child-per-ip limita o numero de processos-filhos que
           podem ser iniciados em nome de um unico enderec,o IP a qualquer
           momento. Essas opc,oes podem limitar o consumo excessivo de
           recursos e ajudar a impedir ataques de negac,ao de servic,o (DoS
           (Denial Of Service)).

           Um exemplo pode ser visto nas configurac,oes padrao para
           fingerd(8):

 finger stream  tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -k -s

   usuario

           O nome de usuario que o daemon sera executado como. Daemons
           geralmente sao executados como root, daemon, ou nobody.

   programa servidor

           O caminho completo para o daemon. Se o daemon for um servic,o
           fornecido pelo inetd internamente, use internal.

   argumentos do programa servidor

           Usado para especificar qualquer argumento de comando a ser
           transmitido ao daemon na chamada. Se o daemon for um servic,o
           interno, use internal.

  29.2.2. Opc,oes de linha de comando

   Como a maioria dos daemons de servidor, o inetd tem varias opc,oes que
   podem ser usadas para modificar seu comportamento. Por padrao, inetd e
   iniciado com -wW -C 60. Essas opc,oes ativam TCP wrappers para todos os
   servic,os, incluindo servic,os internos, e impedem que qualquer enderec,o
   de IP solicite qualquer servic,o mais de 60 vezes por minuto.

   Para alterar as opc,oes padrao que sao passadas para inetd, adicione uma
   entrada para inetd_flags no arquivo /etc/rc.conf. Se o inetd ja estiver em
   execuc,ao, reinicie-o com service inetd restart.

   As opc,oes disponiveis de limitac,ao de taxa sao:

   -c maximo

           Especifique o numero maximo padrao de chamadas simultaneas de cada
           servic,o, em que o padrao e ilimitado. Pode ser sobrescrito com
           base no servic,o usando max-child em /etc/inetd.conf.

   -C taxa

           Especifique o numero maximo padrao de vezes por minuto que um
           servic,o pode ser chamado a partir de um unico enderec,o de IP.
           Pode ser substituido com base no servic,o usando
           max-connections-per-ip-por-minute em /etc/inetd.conf.

   -R taxa

           Especifique o numero maximo de vezes que um servic,o pode ser
           chamado em um minuto, em que o padrao e 256. Uma taxa de 0 permite
           um numero ilimitado.

   -s maximo

           Especifique o numero maximo de vezes que um servic,o pode ser
           chamado a partir de um unico enderec,o IP a qualquer momento, em
           que o padrao e ilimitado. Pode ser sobrescrito com base no
           servic,o usando max-child-per-ip no arquivo /etc/inetd.conf.

   Opc,oes adicionais estao disponiveis. Consulte inetd(8) para a lista
   completa de opc,oes.

  29.2.3. Considerac,oes de seguranc,a

   Muitos dos daemons que podem ser gerenciados pelo inetd nao sao
   conscientes da seguranc,a. Alguns daemons, como fingerd, podem fornecer
   informac,oes que podem ser uteis para um invasor. Ative apenas os
   servic,os necessarios e monitore o sistema para tentativas excessivas de
   conexao. max-connections-per-ip-por-minute, max-child e max-child-per-ip
   podem ser usados para limitar tais ataques.

   Por padrao, TCP wrappers estao ativados. Consulte hosts_access(5) para
   obter mais informac,oes sobre como colocar restric,oes TCP em varios
   daemons chamados pelo inetd.

29.3. Network File System (NFS)

   Reorganizado e aprimorado por Tom Rhodes.
   Escrito por Bill Swingle.

   O FreeBSD suporta o Network File System (NFS), que permite que um servidor
   compartilhe diretorios e arquivos com clientes atraves de uma rede. Com o
   NFS, os usuarios e programas podem acessar arquivos em sistemas remotos
   como se estivessem armazenados localmente.

   NFS tem muitos usos praticos. Alguns dos usos mais comuns incluem:

     * Os dados que seriam duplicados em cada cliente podem ser mantidos em
       um unico local e acessados por clientes na rede.

     * Varios clientes podem precisar de acesso ao diretorio
       /usr/ports/distfiles. Compartilhar esse diretorio permite acesso
       rapido aos arquivos fonte sem precisar baixa-los para cada cliente.

     * Em grandes redes, geralmente e mais conveniente configurar um servidor
       central NFS no qual todos os diretorios home dos usuarios sao
       armazenados. Os usuarios podem logar em um cliente em qualquer lugar
       da rede e ter acesso aos seus diretorios home.

     * A administrac,ao de exports do NFS e simplificada. Por exemplo, ha
       apenas um sistema de arquivos no qual as politicas de seguranc,a ou de
       backup devem ser definidas.

     * Dispositivos removiveis de armazenamento de midia podem ser usados por
       outras maquinas na rede. Isso reduz o numero de dispositivos em toda a
       rede e fornece um local centralizado para gerenciar sua seguranc,a.
       Geralmente, e mais conveniente instalar software em varias maquinas a
       partir de uma midia de instalac,ao centralizada.

   O NFS consiste em um servidor e um ou mais clientes. O cliente acessa
   remotamente os dados armazenados na maquina do servidor. Para que isso
   funcione corretamente, alguns processos precisam ser configurados e
   executados.

   Esses daemons devem estar em execuc,ao no servidor:

   Daemon                              Descric,ao                             
   nfsd    O daemon NFS que atende a solicitac,oes de clientes NFS.           
   mountd  O daemon de montagem do NFS que realiza solicitac,oes recebidas do 
           nfsd.                                                              
   rpcbind Este daemon permite que clientes NF descubram qual porta o         
           servidor NFS esta usando.                                          

   A execuc,ao de nfsiod(8) no cliente pode melhorar o desempenho, mas nao e
   necessaria.

  29.3.1. Configurando o Servidor

   Os sistemas de arquivos que o servidor NFS ira compartilhar sao
   especificados no arquivo /etc/exports. Cada linha neste arquivo especifica
   um sistema de arquivos a ser exportado, quais clientes tem acesso a esse
   sistema de arquivos e quaisquer opc,oes de acesso. Ao adicionar entradas a
   este arquivo, cada sistema de arquivos exportado, suas propriedades e
   hosts permitidos devem ocorrer em uma unica linha. Se nenhum cliente
   estiver listado na entrada, qualquer cliente na rede podera montar esse
   sistema de arquivos.

   As seguintes entradas no arquivo /etc/exports demonstram como exportar
   sistemas de arquivos. Os exemplos podem ser modificados para corresponder
   aos sistemas de arquivos e nomes de clientes na rede do leitor. Existem
   muitas opc,oes que podem ser usadas neste arquivo, mas apenas algumas
   serao mencionadas aqui. Veja exports(5) para a lista completa de opc,oes.

   Este exemplo mostra como exportar /cdrom para tres hosts chamados alpha,
   bravo e charlie:

 /cdrom -ro alpha bravo charlie

   A flag -ro torna o sistema de arquivos somente leitura, impedindo que os
   clientes fac,am alterac,oes no sistema de arquivos exportado. Este exemplo
   assume que os nomes de host estao no DNS ou no arquivo /etc/hosts.
   Consulte hosts(5) se a rede nao tiver um servidor de DNS.

   O proximo exemplo exporta /home para tres clientes pelo enderec,o IP. Isso
   pode ser util para redes sem DNS ou /etc/hosts. A flag -alldirs permite
   que os subdiretorios sejam pontos de montagem. Em outras palavras, ele nao
   montara automaticamente os subdiretorios, mas permitira que o cliente
   monte os diretorios necessarios conforme necessario.

 /usr/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4

   Este proximo exemplo exporta /a para que dois clientes de dominios
   diferentes possam acessar esse sistema de arquivos. -maproot=root permite
   que o usuario root no sistema remoto grave os dados no sistema de arquivos
   exportado como root. Se -maproot=root nao for especificado, o usuario root
   do cliente sera mapeado para a conta nobody do servidor e estara sujeito
   `as limitac,oes de acesso definidas para nobody.

 /a  -maproot=root  host.example.com box.example.org

   Um cliente so pode ser especificado uma vez por sistema de arquivos. Por
   exemplo, se /usr for um unico sistema de arquivos, essas entradas serao
   invalidas, ja que ambas as entradas especificam o mesmo host:

 # Invalid when /usr is one file system
 /usr/src   client
 /usr/ports client

   O formato correto para essa situac,ao e usar uma entrada:

 /usr/src /usr/ports  client

   A seguir, um exemplo de uma lista de exportac,ao valida, em que /usr e
   /exports sao sistemas de arquivos locais:

 # Export src and ports to client01 and client02, but only
 # client01 has root privileges on it
 /usr/src /usr/ports -maproot=root    client01
 /usr/src /usr/ports               client02
 # The client machines have root and can mount anywhere
 # on /exports. Anyone in the world can mount /exports/obj read-only
 /exports -alldirs -maproot=root      client01 client02
 /exports/obj -ro

   Para habilitar os processos requeridos pelo servidor NFS no momento da
   inicializac,ao, adicione estas opc,oes ao arquivo /etc/rc.conf:

 rpcbind_enable="YES"
 nfs_server_enable="YES"
 mountd_flags="-r"

   O servidor pode ser iniciado agora executando este comando:

 # service nfsd start

   Sempre que o servidor NFS for iniciado, o mountd tambem e iniciado
   automaticamente. No entanto, mountd le apenas /etc/exports quando e
   iniciado. Para fazer as edic,oes subsequentes de /etc/exports entrarem em
   vigor imediatamente, force mountd para ler novamente:

 # service mountd reload

  29.3.2. Configurando o Cliente

   Para ativar clientes NFS, defina essa opc,ao no arquivo /etc/rc.conf de
   cada cliente:

 nfs_client_enable="YES"

   Em seguida, execute este comando em cada cliente NFS:

 # service nfsclient start

   O cliente agora tem tudo de que precisa para montar um sistema de arquivos
   remoto. Nestes exemplos, o nome do servidor e server e o nome do cliente e
   client. Para montar /home no server para o ponto de montagem /mnt no
   client:

 # mount server:/home /mnt

   Os arquivos e diretorios em /home agora estarao disponiveis no client, no
   diretorio /mnt.

   Para montar um sistema de arquivos remoto toda vez que o cliente for
   inicializado, adicione-o ao arquivo /etc/fstab:

 server:/home    /mnt    nfs     rw      0       0

   Consulte fstab(5) para obter uma descric,ao de todas as opc,oes
   disponiveis.

  29.3.3. Bloqueando

   Alguns aplicativos exigem o bloqueio de arquivos para funcionar
   corretamente. Para ativar o bloqueio, adicione estas linhas ao arquivo
   /etc/rc.conf no cliente e no servidor:

 rpc_lockd_enable="YES"
 rpc_statd_enable="YES"

   Entao inicie as aplicac,oes:

 # service lockd start
 # service statd start

   Se o bloqueio nao for necessario no servidor, o cliente NFS pode ser
   configurado para bloquear localmente incluindo -L ao executar o mount.
   Consulte mount_nfs(8) para mais detalhes.

  29.3.4. Automatizando Montagens com autofs(5)

  Nota:

   O recurso de montagem automatica autofs(5) e suportado a partir do FreeBSD
   10.1-RELEASE. Para usar a funcionalidade automounter em versoes mais
   antigas do FreeBSD, use amd(8). Este capitulo descreve apenas o montador
   automatico autofs(5).

   O recurso autofs(5) e um nome comum para varios componentes que, juntos,
   permitem a montagem automatica de sistemas de arquivos locais e remotos
   sempre que um arquivo ou diretorio dentro desse sistema de arquivos e
   acessado. Ele consiste no componente do kernel, autofs(5) e varios
   aplicativos no espac,o do usuario: automount(8), automountd(8) e
   autounmountd(8). Ele serve como uma alternativa para amd(8) de versoes
   anteriores do FreeBSD. Amd ainda e fornecido para fins de compatibilidade
   com versoes anteriores, ja que os dois usam formato de mapeamento
   diferentes; o usado pelo autofs e o mesmo que com outros automontadores do
   SVR4, como os do Solaris, MacOS X e Linux.

   O sistema de arquivos virtual autofs(5) e montado em pontos de montagem
   especificados por automount(8), geralmente chamado durante a
   inicializac,ao.

   Sempre que um processo tentar acessar o arquivo dentro do ponto de
   montagem autofs(), o kernel notificara o daemon automountd(8) e ira pausar
   o processo de disparo. O daemon automountd(8) processara as solicitac,oes
   do kernel localizando o mapeamento apropriado e ira montar o sistema de
   arquivos de acordo com ele, entao sinaliza ao kernel para liberar o
   processo bloqueado . O daemon autounmountd(8) desmonta automaticamente os
   sistemas de arquivos montados automaticamente apos algum tempo, a menos
   que eles ainda estejam sendo usados.

   O arquivo de configurac,ao principal do autofs e o /etc/auto_master.
   Atribui mapeamentos individuais a montagens de nivel superior. Para uma
   explicac,ao do auto_master e da sintaxe do mapeamento, consulte
   auto_master(5).

   Existe um mapeamento especial montado automaticamente em /net. Quando um
   arquivo e acessado dentro desse diretorio, o autofs(5) procura a montagem
   remota correspondente e monta-a automaticamente. Por exemplo, uma
   tentativa de acessar um arquivo dentro de /net/foobar/usr informaria
   automountd(8) para montar a exportac,ao /usr do host foobar.

   Exemplo 29.2. Montando uma Exportac,ao com autofs(5)

   Neste exemplo, showmount -e mostra os sistemas de arquivos exportados que
   podem ser montados a partir do servidor NFS, foobar:

 % showmount -e foobar
 Exports list on foobar:
 /usr                               10.10.10.0
 /a                                 10.10.10.0
 % cd /net/foobar/usr

   A saida de showmount mostra /usr como uma exportac,ao. Ao alterar os
   diretorios para /host/foobar/usr, o automountd(8) intercepta o pedido e
   tenta resolver o nome do host foobar. Se for bem-sucedido, automountd(8)
   montara automaticamente a exportac,ao de origem.

   Para habilitar autofs(5) no momento da inicializac,ao, adicione esta linha
   ao arquivo /etc/rc.conf:

 autofs_enable="YES"

   Em seguida, autofs(5) pode ser iniciado executando:

 # service automount start
 # service automountd start
 # service autounmountd start

   O formato de mapeamento de autofs(5) e o mesmo que em outros sistemas
   operacionais. Informac,oes sobre este formato de outras fontes podem ser
   uteis, como o documento do Mac OS X.

   Consulte as paginas de manuais automount(8), automountd(8),
   autounmountd(8) e auto_master(5) para maiores informac,oes.

29.4. Sistema de Informac,ao de Rede (NIS)

   O Network Information System (NIS) foi projetado para centralizar a
   administrac,ao de sistemas UNIX(R) como Solaris(TM), HP-UX, AIX(R), Linux,
   NetBSD, OpenBSD e FreeBSD. O NIS era originalmente conhecido como Yellow
   Pages, mas o nome foi alterado devido a problemas de marca registrada.
   Esta e a razao pela qual os comandos do NIS comec,am com yp.

   O NIS e um sistema cliente/servidor baseado em Remote Procedure Call (RPC)
   que permite que um grupo de maquinas dentro de um dominio NIS compartilhe
   um conjunto de arquivos de configurac,ao. Isso permite que um
   administrador do sistema configure sistemas clientes NIS com apenas dados
   minimos de configurac,ao e adicione, remova ou modifique dados de
   configurac,ao de um unico local.

   O FreeBSD usa a versao 2 do protocolo NIS.

  29.4.1. Termos do NIS e Processos

   A Tabela 28.1 resume os termos e processos importantes usados pelo NIS:

   Tabela 29.1. Terminologia do NIS

          Termo                              Descric,ao                       
                       Os servidores e clientes do NIS compartilham um nome   
   nome de dominio NIS de dominio NIS. Normalmente, esse nome nao tem nada a  
                       ver com DNS.                                           
   rpcbind(8)          Este servic,o habilita o RPC e deve estar rodando para 
                       rodar um servidor NIS ou atuar como um cliente NIS.    
                       Este servic,o liga um cliente NIS ao seu servidor NIS. 
                       Ele levara o nome de dominio NIS e usara RPC para se   
   ypbind(8)           conectar ao servidor. E o nucleo da comunicac,ao       
                       cliente/servidor em um ambiente NIS. Se este servic,o  
                       nao estiver sendo executado em uma maquina cliente,    
                       ele nao podera acessar o servidor NIS.                 
                       Este e o processo para o servidor NIS. Se este         
                       servic,o parar de funcionar, o servidor nao podera     
                       mais responder aos pedidos do NIS, portanto, esperamos 
   ypserv(8)           que exista um servidor slave para assumir o controle.  
                       Alguns clientes nao-FreeBSD nao tentarao se reconectar 
                       usando um servidor slave e o processo ypbind pode      
                       precisar ser reiniciado nesses clientes.               
                       Este processo so e executado em servidores principais  
                       de NIS. Este daemon permite que clientes NIS alterem   
   rpc.yppasswdd(8)    suas senhas do NIS. Se este daemon nao estiver         
                       rodando, os usuarios terao que acessar o servidor      
                       principal do NIS e alterar suas senhas la.             

  29.4.2. Tipos de Maquinas

   Existem tres tipos de hosts em um ambiente NIS:

     * Servidor NIS master

       Esse servidor atua como um repositorio central para as informac,oes de
       configurac,ao do host e mantem a copia autoritativa dos arquivos
       usados por todos os clientes do NIS. O passwd, o group e outros
       arquivos usados pelos clientes do NIS sao armazenados no servidor
       master. Embora seja possivel que uma maquina seja um servidor NIS
       master para mais de um dominio NIS, esse tipo de configurac,ao nao
       sera abordado neste capitulo, pois pressupoe ambiente NIS de pequena
       escala.

     * Servidores NIS slave

       Os servidores slaves do NIS mantem copias dos arquivos de dados do
       master do NIS para fornecer redundancia. Os servidores slaves tambem
       ajudam a balancear a carga do servidor master, pois os clientes do NIS
       sempre se conectam ao servidor do NIS que responde primeiro.

     * Clientes NIS

       Os clientes do NIS autenticam-se contra o servidor NIS durante o
       logon.

   Informac,oes em muitos arquivos podem ser compartilhadas usando o NIS . Os
   arquivos master.passwd, group e hosts sao comumente compartilhados via
   NIS. Sempre que um processo em um cliente precisa de informac,oes que
   normalmente seriam encontradas nesses arquivos localmente, ele faz uma
   consulta ao servidor NIS ao qual esta vinculado.

  29.4.3. Considerac,oes de Planejamento

   Esta sec,ao descreve um ambiente NIS de exemplo que consiste em 15
   maquinas FreeBSD sem ponto de administrac,ao centralizado. Cada maquina
   tem seu proprio /etc/passwd e /etc/master.passwd. Esses arquivos sao
   mantidos em sincronia entre si somente por meio de intervenc,ao manual.
   Atualmente, quando um usuario e adicionado ao laboratorio, o processo deve
   ser repetido em todas as 15 maquinas.

   A configurac,ao do laboratorio sera a seguinte:

    Nome da maquina     Enderec,o IP              Role da maquina             
   ellington          10.0.0.2         NIS master                             
   coltrane           10.0.0.3         NIS slave                              
   basie              10.0.0.4         Estac,ao de Trabalho da Facultativa    
   bird               10.0.0.5         Maquina Cliente                        
   cli[1-11]          10.0.0.[6-17]    Outras Maquinas Clientes               

   Se esta e a primeira vez que um esquema de NIS esta sendo desenvolvido,
   ele deve ser cuidadosamente planejado atraves do tempo. Independentemente
   do tamanho da rede, varias decisoes precisam ser tomadas como parte do
   processo de planejamento.

    29.4.3.1. Escolhendo um Nome de Dominio NIS

   Quando um cliente transmite suas solicitac,oes de informac,oes, ele inclui
   o nome do dominio NIS do qual faz parte. E assim que varios servidores em
   uma rede podem informar qual servidor deve responder a qual solicitac,ao.
   Pense no nome de dominio NIS como o nome de um grupo de hosts.

   Algumas organizac,oes optam por usar o nome de dominio da Internet para o
   nome de dominio NIS. Isso nao e recomendado, pois pode causar confusao ao
   tentar depurar problemas de rede. O nome de dominio NIS deve ser unico
   dentro da rede e e util se ele descrever o grupo de maquinas que
   representa. Por exemplo, o departamento de Arte da Acme Inc. pode estar no
   dominio NIS "acme-art". Este exemplo usara o nome de dominio test-domain.

   No entanto, alguns sistemas operacionais nao-FreeBSD exigem que o nome de
   dominio NIS seja o mesmo que o nome de dominio da Internet. Se uma ou mais
   maquinas na rede tiverem essa restric,ao, o nome de dominio da Internet
   deve ser usado como o nome de dominio NIS.

    29.4.3.2. Requisitos Fisicos do Servidor

   Ha varias coisas que voce deve ter em mente ao escolher uma maquina para
   usar como um servidor NIS. Como os clientes do NIS dependem da
   disponibilidade do servidor, escolha uma maquina que nao seja
   reinicializada com frequ:encia. O servidor do NIS deve idealmente ser uma
   maquina autonoma cujo unico proposito seja ser um servidor NIS. Se a rede
   nao for muito usada, e aceitavel colocar o servidor NIS em uma maquina que
   executa outros servic,os. No entanto, se o servidor NIS ficar
   indisponivel, isso afetara negativamente todos os clientes NIS.

  29.4.4. Configurando o Servidor NIS Master

   As copias canonicas de todos os arquivos NIS sao armazenadas no servidor
   master. Os bancos de dados usados para armazenar as informac,oes sao
   chamados de mapas de NIS. No FreeBSD, estes mapas sao armazenados em
   /var/yp/[nome_do_dominio] onde [nome_do_dominio] e o nome do dominio NIS.
   Como varios dominios sao suportados, e possivel ter varios diretorios, um
   para cada dominio. Cada dominio tera seu proprio conjunto independente de
   mapas.

   Os servidores master e slave do NIS lidam com todas as requisic,oes NIS
   atraves do ypserv(8). Esse daemon e responsavel por receber solicitac,oes
   de entrada de clientes NIS, traduzindo o dominio e o nome do mapa
   solicitados para um caminho para o arquivo de banco de dados
   correspondente e transmitindo dados do banco de dados de volta ao cliente.

   Configurar um servidor NIS master pode ser relativamente simples,
   dependendo das necessidades ambientais. Como o FreeBSD oferece suporte a
   NIS embutido, ele so precisa ser ativado adicionando as seguintes linhas
   ao arquivo /etc/rc.conf:

 nisdomainname="test-domain"     1
 nis_server_enable="YES"         2
 nis_yppasswdd_enable="YES"      3

   1 Esta linha define o nome de dominio NIS para test-domain.                
   2 Isto automatiza o inicio dos processos do servidor NIS quando o sistema  
     e inicializado.                                                          
   3 Isso habilita o daemon rpc.yppasswdd(8) para que os usuarios possam      
     alterar sua senha NIS de uma maquina cliente.                            

   E preciso ter cuidado em um dominio com varios servidores, no qual as
   maquinas do servidor tambem sao clientes NIS. Geralmente, e uma boa ideia
   forc,ar os servidores a fazerem bind em si mesmos, em vez de permitir que
   eles transmitam solicitac,oes de bind e, possivelmente, fiquem vinculados
   um ao outro. Modos de falha estranhos podem ocorrer se um servidor cair e
   outros dependerem dele. Eventualmente, todos os clientes terao tempo
   limite e tentarao fazer bind em outros servidores, mas o atraso envolvido
   podera ser consideravel e o modo de falha ainda estara presente, uma vez
   que os servidores podem ligar-se entre si novamente.

   Um servidor que tambem e um cliente pode ser forc,ado fazer bind em um
   servidor em particular adicionando estas linhas adicionais ao arquivo
   /etc/rc.conf:

 nis_client_enable="YES" # run client stuff as well
 nis_client_flags="-S NIS domain,server"

   Depois de salvar as edic,oes, digite /etc/netstart para reiniciar a rede e
   aplicar os valores definidos no arquivo /etc/rc.conf. Antes de inicializar
   os mapas de NIS, inicie ypserv(8):

 # service ypserv start

    29.4.4.1. Inicializando os mapas do NIS

   Os mapeamentos NIS sao gerados a partir dos arquivos de configurac,ao no
   diretorio /etc no NIS master, com uma excec,ao: /etc/master.passwd. Isso
   evita a propagac,ao de senhas para todos os servidores no dominio NIS.
   Portanto, antes de inicializar os mapas do NIS, configure os arquivos de
   senha primarios:

 # cp /etc/master.passwd /var/yp/master.passwd
 # cd /var/yp
 # vi master.passwd

   E aconselhavel remover todas as entradas de contas do sistema, bem como
   quaisquer contas de usuario que nao precisem ser propagadas para os
   clientes do NIS, como o root e quaisquer outras contas administrativas.

  Nota:

   Assegure-se de que o arquivo /var/yp/master.passwd nao seja de grupo nem
   de mundo legivel, definindo suas permissoes para 600.

   Depois de concluir esta tarefa, inicialize os mapas do NIS. O FreeBSD
   inclui o script ypinit(8) para fazer isso. Ao gerar mapas para o servidor
   master, inclua -m e especifique o nome de dominio NIS:

 ellington# ypinit -m test-domain
 Server Type: MASTER Domain: test-domain
 Creating an YP server will require that you answer a few questions.
 Questions will all be asked at the beginning of the procedure.
 Do you want this procedure to quit on non-fatal errors? [y/n: n] n
 Ok, please remember to go back and redo manually whatever fails.
 If not, something might not work.
 At this point, we have to construct a list of this domains YP servers.
 rod.darktech.org is already known as master server.
 Please continue to add any slave servers, one per line. When you are
 done with the list, type a <control D>.
 master server   :  ellington
 next host to add:  coltrane
 next host to add:  ^D
 The current list of NIS servers looks like this:
 ellington
 coltrane
 Is this correct?  [y/n: y] y

 [..output from map generation..]

 NIS Map update completed.
 ellington has been setup as an YP master server without any errors.

   Isto ira criar /var/yp/Makefile a partir de /var/yp/Makefile.dist. Por
   padrao, este arquivo assume que o ambiente tem um unico servidor NIS com
   apenas clientes FreeBSD. Como test-domain tem um servidor slave, edite
   esta linha no arquivo /var/yp/Makefile para que comece com um comentario (
   # ) :

 NOPUSH = "True"

    29.4.4.2. Adicionando novos usuarios

   Toda vez que um novo usuario e criado, a conta de usuario deve ser
   adicionada ao servidor mestre NIS e aos mapeamentos do NIS reconstruidos.
   Ate que isso ocorra, o novo usuario nao podera efetuar login em nenhum
   lugar, exceto no NIS master. Por exemplo, para adicionar o novo usuario
   jsmith ao dominio test-domain, execute estes comandos no servidor master:

 # pw useradd jsmith
 # cd /var/yp
 # make test-domain

   O usuario tambem pode ser adicionado usando adduser jsmith em vez de pw
   useradd smith.

  29.4.5. Configurando um Servidor NIS Slave

   Para configurar um servidor NIS slave, fac,a o logon no servidor slave e
   edite o arquivo /etc/rc.conf assim como para o servidor master. Nao gere
   nenhum mapa de NIS, pois estes ja existem no servidor master. Ao executar
   ypinit no servidor slave, use -s (para slave) ao inves de -m (para
   master). Esta opc,ao requer o nome do NIS master, alem do nome do dominio,
   como visto neste exemplo:

 coltrane# ypinit -s ellington test-domain

 Server Type: SLAVE Domain: test-domain Master: ellington

 Creating an YP server will require that you answer a few questions.
 Questions will all be asked at the beginning of the procedure.

 Do you want this procedure to quit on non-fatal errors? [y/n: n]  n

 Ok, please remember to go back and redo manually whatever fails.
 If not, something might not work.
 There will be no further questions. The remainder of the procedure
 should take a few minutes, to copy the databases from ellington.
 Transferring netgroup...
 ypxfr: Exiting: Map successfully transferred
 Transferring netgroup.byuser...
 ypxfr: Exiting: Map successfully transferred
 Transferring netgroup.byhost...
 ypxfr: Exiting: Map successfully transferred
 Transferring master.passwd.byuid...
 ypxfr: Exiting: Map successfully transferred
 Transferring passwd.byuid...
 ypxfr: Exiting: Map successfully transferred
 Transferring passwd.byname...
 ypxfr: Exiting: Map successfully transferred
 Transferring group.bygid...
 ypxfr: Exiting: Map successfully transferred
 Transferring group.byname...
 ypxfr: Exiting: Map successfully transferred
 Transferring services.byname...
 ypxfr: Exiting: Map successfully transferred
 Transferring rpc.bynumber...
 ypxfr: Exiting: Map successfully transferred
 Transferring rpc.byname...
 ypxfr: Exiting: Map successfully transferred
 Transferring protocols.byname...
 ypxfr: Exiting: Map successfully transferred
 Transferring master.passwd.byname...
 ypxfr: Exiting: Map successfully transferred
 Transferring networks.byname...
 ypxfr: Exiting: Map successfully transferred
 Transferring networks.byaddr...
 ypxfr: Exiting: Map successfully transferred
 Transferring netid.byname...
 ypxfr: Exiting: Map successfully transferred
 Transferring hosts.byaddr...
 ypxfr: Exiting: Map successfully transferred
 Transferring protocols.bynumber...
 ypxfr: Exiting: Map successfully transferred
 Transferring ypservers...
 ypxfr: Exiting: Map successfully transferred
 Transferring hosts.byname...
 ypxfr: Exiting: Map successfully transferred

 coltrane has been setup as an YP slave server without any errors.
 Remember to update map ypservers on ellington.

   Isto ira gerar um diretorio no servidor slave chamado /var/yp/test-domain
   que contem copias dos mapas do servidor principal do NIS. Adicionar estas
   entradas ao arquivo /etc/crontab em cada servidor slave forc,ara os slaves
   a sincronizar seus mapas com os mapas no servidor master:

 20      *       *       *       *       root   /usr/libexec/ypxfr passwd.byname
 21      *       *       *       *       root   /usr/libexec/ypxfr passwd.byuid

   Essas entradas nao sao obrigatorias porque o servidor master tenta enviar
   automaticamente quaisquer alterac,oes no mapa para seus escravos. No
   entanto, como os clientes podem depender do servidor escravo para fornecer
   informac,oes corretas de senha, recomenda-se forc,ar atualizac,oes
   frequentes de mapas de senha. Isso e especialmente importante em redes
   ocupadas nas quais as atualizac,oes de mapas nem sempre sao concluidas.

   Para finalizar a configurac,ao, execute /etc/netstart no servidor slave
   para iniciar os servic,os do NIS.

  29.4.6. Configurando um cliente NIS

   Um cliente NIS e vinculado a um servidor NIS usando ypbind(8). Esse daemon
   transmite solicitac,oes de RPC na rede local. Essas solicitac,oes
   especificam o nome do dominio configurado no cliente. Se um servidor NIS
   no mesmo dominio receber uma das transmissoes, ele respondera a ypbind,
   que registrara o enderec,o do servidor. Se houver varios servidores
   disponiveis, o cliente usara o enderec,o do primeiro servidor para
   responder e direcionara todas as suas solicitac,oes de NIS para esse
   servidor. O cliente ira automaticamente pingar o servidor regularmente
   para garantir que ainda esteja disponivel. Se ele nao receber uma resposta
   dentro de um periodo de tempo razoavel, o ypbind marcara o dominio como
   nao acoplado e comec,ara a transmitir novamente na esperanc,a de localizar
   outro servidor.

   Para configurar uma maquina FreeBSD para ser um cliente NIS:

    1. Edite o /etc/rc.conf e adicione as seguintes linhas para definir o
       nome de dominio NIS e inicie ypbind(8) durante a inicializac,ao da
       rede:

 nisdomainname="test-domain"
 nis_client_enable="YES"

    2. Para importar todas as possiveis entradas de senha do servidor NIS,
       use vipw para remover todas as contas de usuario, exceto uma do
       arquivo /etc/master.passwd. Ao remover as contas, lembre-se de que
       pelo menos uma conta local deve permanecer e essa conta deve ser
       membro do grupo wheel. Se houver um problema com o NIS, essa conta
       local podera ser usada para efetuar login remotamente, tornar-se o
       superusuario e corrigir o problema. Antes de salvar as edic,oes,
       adicione a seguinte linha ao final do arquivo:

 +:::::::::

       Esta linha configura o cliente para fornecer qualquer pessoa com uma
       conta valida na senha do servidor do NIS mapeia uma conta no cliente.
       Existem varias maneiras de configurar o cliente NIS modificando essa
       linha. Um metodo e descrito em Sec,ao 29.4.8, "Usando Netgroups". Para
       uma leitura mais detalhada, consulte o livro Managing NFS and NIS,
       publicado pela O'Reilly Media.

    3. Para importar todas as entradas de grupo possiveis do servidor NIS,
       adicione esta linha ao /etc/group:

 +:*::

   Para iniciar imediatamente o cliente NIS, execute os seguintes comandos
   como superusuario:

 # /etc/netstart
 # service ypbind start

   Depois de concluir estas etapas, a execuc,ao do ypcat passwd no cliente
   deve mostrar o mapa passwd do servidor.

  29.4.7. Seguranc,a NIS

   Como o RPC e um servic,o baseado em broadcast, qualquer sistema executando
   o ypbind dentro do mesmo dominio pode recuperar o conteudo dos mapas do
   NIS. Para evitar transac,oes nao autorizadas, ypserv(8) suporta um recurso
   chamado "securenets" que pode ser usado para restringir o acesso a um dado
   conjunto de hosts. Por padrao, essas informac,oes sao armazenadas no
   arquivo /var/yp/securenets, a menos que ypserv(8) seja iniciado com -p e
   um caminho alternativo. Este arquivo contem entradas que consistem em uma
   especificac,ao de rede e uma mascara de rede separadas por espac,o em
   branco. Linhas iniciando com # sao consideradas comentarios. Um exemplo de
   securenets pode ser assim:

 # allow connections from local host -- mandatory
 127.0.0.1     255.255.255.255
 # allow connections from any host
 # on the 192.168.128.0 network
 192.168.128.0 255.255.255.0
 # allow connections from any host
 # between 10.0.0.0 to 10.0.15.255
 # this includes the machines in the testlab
 10.0.0.0      255.255.240.0

   Se ypserv(8) receber uma solicitac,ao de um enderec,o que corresponda a
   uma dessas regras, ela processara a solicitac,ao normalmente. Se o
   enderec,o nao corresponder a uma regra, a solicitac,ao sera ignorada e uma
   mensagem de aviso sera registrada. Se o securenets nao existir, o ypserv
   permitira conexoes de qualquer host.

   Sec,ao 13.4, "TCP Wrapper" e um mecanismo alternativo para fornecer
   controle de acesso em vez de securenets. Embora o mecanismo de controle de
   acesso acrescente alguma seguranc,a, ambos sao vulneraveis a ataques como
   "IP spoofing". Todo o trafego relacionado a NIS deve ser bloqueado no
   firewall.

   Servidores que usam securenets podem nao servir clientes legitimos de NIS
   com implementac,oes arcaicas de TCP/IP. Algumas dessas implementac,oes
   definem todos os bits do host como zero ao fazer transmissoes ou nao
   observam a mascara de sub-rede ao calcular o enderec,o de transmissao.
   Embora alguns desses problemas possam ser corrigidos alterando a
   configurac,ao do cliente, outros problemas podem forc,ar a desativac,ao
   desses sistemas clientes ou o abandono do securenets.

   O uso de TCP Wrapper aumenta a latencia do servidor NIS. O atraso
   adicional pode ser longo o suficiente para causar timeouts em programas
   clientes, especialmente em redes ocupadas com servidores NIS lentos. Se um
   ou mais clientes sofrerem de latencia, converta esses clientes em
   servidores de NIS slaves e force-os a se ligarem a eles mesmos.

    29.4.7.1. Barrando alguns usuarios

   Neste exemplo, o sistema basie e uma estac,ao de trabalho da dentro do
   dominio NIS facultativo. O mapa passwd no servidor NIS master contem
   contas para professores e alunos. Esta sec,ao demonstra como permitir o
   login do corpo docente neste sistema e, ao mesmo tempo, recusar logins de
   alunos.

   Para previnir usuarios especificos de logar em um sistema, desde que eles
   estejam presentes no banco de dados do NIS, use vipw para adicionar
   -username com o numero correto de virgulas em direc,ao ao fim do arquivo
   /etc/master.passwd no cliente, onde username e o nome de usuario a impedir
   de logar. A linha com o usuario bloqueado deve estar antes da linha + que
   permite usuarios do NIS. Neste exemplo, bill esta impedido de logar no
   basie:

 basie# cat /etc/master.passwd
 root:[password]:0:0::0:0:The super-user:/root:/bin/csh
 toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
 daemon:*:1:1::0:0:Owner of many system processes:/root:/usr/sbin/nologin
 operator:*:2:5::0:0:System &:/:/usr/sbin/nologin
 bin:*:3:7::0:0:Binaries Commands and Source,,,:/:/usr/sbin/nologin
 tty:*:4:65533::0:0:Tty Sandbox:/:/usr/sbin/nologin
 kmem:*:5:65533::0:0:KMem Sandbox:/:/usr/sbin/nologin
 games:*:7:13::0:0:Games pseudo-user:/usr/games:/usr/sbin/nologin
 news:*:8:8::0:0:News Subsystem:/:/usr/sbin/nologin
 man:*:9:9::0:0:Mister Man Pages:/usr/share/man:/usr/sbin/nologin
 bind:*:53:53::0:0:Bind Sandbox:/:/usr/sbin/nologin
 uucp:*:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
 xten:*:67:67::0:0:X-10 daemon:/usr/local/xten:/usr/sbin/nologin
 pop:*:68:6::0:0:Post Office Owner:/nonexistent:/usr/sbin/nologin
 nobody:*:65534:65534::0:0:Unprivileged user:/nonexistent:/usr/sbin/nologin
 -bill:::::::::
 +:::::::::

 basie#

  29.4.8. Usando Netgroups

   A exclusao de usuarios especificados do logon em sistemas individuais
   torna-se imprestavel em redes maiores e perde rapidamente o principal
   beneficio do NIS: administrac,ao centralizada.

   Os netgroups foram desenvolvidos para lidar com redes grandes e complexas
   com centenas de usuarios e maquinas. Seu uso e comparavel aos grupos
   UNIX(R), onde a principal diferenc,a e a falta de um ID numerico e a
   capacidade de definir um netgroup incluindo contas de usuario e outros
   netgroups.

   Para expandir o exemplo usado neste capitulo, o dominio NIS sera estendido
   para adicionar os usuarios e sistemas mostrados nas Tabelas 28.2 e 28.3:

   Tabela 29.2. Usuarios Adicionais

          Nome(s) de usuario                       Descric,ao                 
   alpha, beta                      Funcionarios do departamento de TI        
   charlie, delta                   Aprendizes do departamento de TI          
   echo, foxtrott, golf, ...        funcionarios                              
   able, baker, ...                 estagiarios                               

   Tabela 29.3. Sistemas Adicionais

        Nome(s) de maquina                        Descric,ao                  
   war, death, famine, pollution Somente funcionarios de TI podem fazer logon 
                                 nesses servidores.                           
   pride, greed, envy, wrath,    Todos os membros do departamento de TI podem 
   lust, sloth                   fazer login nesses servidores.               
   one, two, three, four, ...    Estac,oes de trabalho comuns usadas pelos    
                                 funcionarios.                                
   trashcan                      Uma maquina muito antiga sem dados criticos. 
                                 Ate os estagiarios podem usar este sistema.  

   Ao usar netgroups para configurar esse cenario, cada usuario e atribuido a
   um ou mais netgroups e os logins sao permitidos ou proibidos para todos os
   membros do netgroup. Ao adicionar uma nova maquina, as restric,oes de
   login devem ser definidas para todos os netgroups. Quando um novo usuario
   e adicionado, a conta deve ser adicionada a um ou mais netgroups. Se a
   configurac,ao do NIS for planejada com cuidado, somente um arquivo de
   configurac,ao central precisara ser modificado para conceder ou negar
   acesso a maquinas.

   O primeiro passo e a inicializac,ao do mapa do NIS netgroup. No FreeBSD,
   este mapa nao e criado por padrao. No servidor NIS master, use um editor
   para criar um mapa chamado /var/yp/netgroup.

   Este exemplo cria quatro grupos de rede para representar funcionarios de
   TI, aprendizes de TI, funcionarios e estagiarios:

 IT_EMP  (,alpha,test-domain)    (,beta,test-domain)
 IT_APP  (,charlie,test-domain)  (,delta,test-domain)
 USERS   (,echo,test-domain)     (,foxtrott,test-domain) \
         (,golf,test-domain)
 INTERNS (,able,test-domain)     (,baker,test-domain)

   Cada entrada configura um netgroup. A primeira coluna em uma entrada e o
   nome do netgroup. Cada conjunto de colchetes representa um grupo de um ou
   mais usuarios ou o nome de outro grupo de rede. Ao especificar um usuario,
   os tres campos delimitados por virgula dentro de cada grupo representam:

    1. O nome do(s) host(s) onde os outros campos que representam o usuario
       sao validos. Se um nome de host nao for especificado, a entrada sera
       valida em todos os hosts.

    2. O nome da conta que pertence a este netgroup.

    3. O dominio NIS da conta. As contas podem ser importadas de outros
       dominios do NIS para um netgroup.

   Se um grupo contiver varios usuarios, separe cada usuario com espac,o em
   branco. Alem disso, cada campo pode conter curingas. Veja netgroup(5) para
   detalhes.

   Nomes de grupos maiores que 8 caracteres nao devem ser usados. Os nomes
   diferenciam maiusculas de minusculas e usar letras maiusculas para nomes
   de grupos de rede e uma maneira facil de distinguir entre nomes de
   usuarios, maquinas e grupos de rede.

   Alguns clientes nao-FreeBSD NIS nao podem lidar com netgroups contendo
   mais de 15 entradas. Esse limite pode ser contornado criando varios grupos
   de sub-redes com 15 usuarios ou menos e um grupo de rede real consistindo
   dos grupos de sub-redes, como visto neste exemplo:

 BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
 BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
 BIGGRP3  (,joe31,domain)  (,joe32,domain)
 BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3

   Repita este processo se mais de 225 (15 vezes 15) usuarios existirem
   dentro de um unico netgroup.

   Para ativar e distribuir o novo mapa do NIS:

 ellington# cd /var/yp
 ellington# make

   Isso gerara os tres mapas NIS, netgroup, netgroup.byhost e
   netgroup.byuser. Use a opc,ao de chave de mapa ypcat(1) para verificar se
   os novos mapas de NIS estao disponiveis:

 ellington% ypcat -k netgroup
 ellington% ypcat -k netgroup.byhost
 ellington% ypcat -k netgroup.byuser

   A saida do primeiro comando deve lembrar o conteudo de /var/yp/netgroup. O
   segundo comando so produz saida se os netgroups especificos do host foram
   criados. O terceiro comando e usado para obter a lista de netgroups de um
   usuario.

   Para configurar um cliente, use vipw(8) para especificar o nome do
   netgroup. Por exemplo, no servidor chamado war, substitua esta linha:

 +:::::::::

   com

 +@IT_EMP:::::::::

   Isso especifica que apenas os usuarios definidos no netgroup IT_EMP serao
   importados para o banco de dados de senhas deste sistema e somente esses
   usuarios terao permissao para efetuar login nesse sistema.

   Essa configurac,ao tambem se aplica `a func,ao ~ do shell e a todas as
   rotinas que convertem entre nomes de usuario e IDs de usuario numerico. Em
   outras palavras, cd ~user nao funcionara, ls -l mostrara o ID numerico em
   vez do nome de usuario e find . -user joe -print falhara com a mensagem No
   such user. Para corrigir isso, importe todas as entradas do usuario sem
   permitir que elas efetuem login nos servidores. Isto pode ser conseguido
   adicionando uma linha extra:

 +:::::::::/usr/sbin/nologin

   Esta linha configura o cliente para importar todas as entradas, mas para
   substituir o shell nessas entradas com /usr/sbin/nologin.

   Certifique-se que a linha extra e colocada apos +@IT_EMP:::::::::. Caso
   contrario, todas as contas de usuario importadas do NIS terao
   /usr/sbin/nologin como seu shell de login e ninguem podera efetuar o login
   no sistema.

   Para configurar os servidores menos importantes, substitua o antigo
   +::::::::: nos servidores com estas linhas:

 +@IT_EMP:::::::::
 +@IT_APP:::::::::
 +:::::::::/usr/sbin/nologin

   As linhas correspondentes para as estac,oes de trabalho seriam:

 +@IT_EMP:::::::::
 +@USERS:::::::::
 +:::::::::/usr/sbin/nologin

   O NIS suporta a criac,ao de grupos de rede de outros grupos de rede, o que
   pode ser util se a politica relacionada ao acesso do usuario for alterada.
   Uma possibilidade e a criac,ao de netgroups baseados em func,oes. Por
   exemplo, pode-se criar um netgroup chamado BIGSRV para definir as
   restric,oes de login para os servidores importantes, outro grupo de rede
   chamado SMALLSRV para os servidores menos importantes e um terceiro
   netgroup chamado USERBOX para as estac,oes de trabalho. Cada um desses
   netgroups contem os netgroups com permissao para efetuar login nessas
   maquinas. As novas entradas para o mapa do NIS netgroup seriam assim:

 BIGSRV    IT_EMP  IT_APP
 SMALLSRV  IT_EMP  IT_APP  ITINTERN
 USERBOX   IT_EMP  ITINTERN USERS

   Esse metodo de definir restric,oes de login funciona razoavelmente bem
   quando e possivel definir grupos de maquinas com restric,oes identicas.
   Infelizmente, esta e a excec,ao e nao a regra. Na maioria das vezes, e
   necessaria a capacidade de definir restric,oes de login por maquina.

   As definic,oes de netgroup especificas da maquina sao outra possibilidade
   para lidar com as mudanc,as na politica. Neste cenario, o
   /etc/master.passwd de cada sistema contem duas linhas que comec,am com
   "+". A primeira linha adiciona um netgroup com as contas permitidas para
   entrar nesta maquina e a segunda linha adiciona todas as outras contas com
   /usr/sbin/nologin como shell. Recomenda-se usar a versao "ALL-CAPS" do
   nome do host como o nome do netgroup:

 +@BOXNAME:::::::::
 +:::::::::/usr/sbin/nologin

   Quando esta tarefa estiver completa em todas as maquinas, nao havera mais
   a necessidade de modificar as versoes locais de /etc/master.passwd
   novamente. Todas as alterac,oes posteriores podem ser manipuladas,
   modificando o mapa do NIS. Aqui esta um exemplo de um possivel mapa
   netgroup para este cenario:

 # Define groups of users first
 IT_EMP    (,alpha,test-domain)    (,beta,test-domain)
 IT_APP    (,charlie,test-domain)  (,delta,test-domain)
 DEPT1     (,echo,test-domain)     (,foxtrott,test-domain)
 DEPT2     (,golf,test-domain)     (,hotel,test-domain)
 DEPT3     (,india,test-domain)    (,juliet,test-domain)
 ITINTERN  (,kilo,test-domain)     (,lima,test-domain)
 D_INTERNS (,able,test-domain)     (,baker,test-domain)
 #
 # Now, define some groups based on roles
 USERS     DEPT1   DEPT2     DEPT3
 BIGSRV    IT_EMP  IT_APP
 SMALLSRV  IT_EMP  IT_APP    ITINTERN
 USERBOX   IT_EMP  ITINTERN  USERS
 #
 # And a groups for a special tasks
 # Allow echo and golf to access our anti-virus-machine
 SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
 #
 # machine-based netgroups
 # Our main servers
 WAR       BIGSRV
 FAMINE    BIGSRV
 # User india needs access to this server
 POLLUTION  BIGSRV  (,india,test-domain)
 #
 # This one is really important and needs more access restrictions
 DEATH     IT_EMP
 #
 # The anti-virus-machine mentioned above
 ONE       SECURITY
 #
 # Restrict a machine to a single user
 TWO       (,hotel,test-domain)
 # [...more groups to follow]

   Pode nao ser sempre aconselhavel usar netgroups baseados em maquina. Ao
   implantar algumas duzias ou centenas de sistemas, grupos de rede baseados
   em func,oes em vez de grupos de rede baseados em maquina podem ser usados
   para manter o tamanho do mapa do NIS dentro de limites razoaveis.

  29.4.9. Formatos de Senha

   O NIS requer que todos os hosts em um dominio NIS usem o mesmo formato
   para criptografar senhas. Se os usuarios tiverem problemas para autenticar
   em um cliente NIS, pode ser devido a um formato de senha diferente. Em uma
   rede heterogenea, o formato deve ser suportado por todos os sistemas
   operacionais, onde DES e o padrao comum mais baixo.

   Para verificar qual formato um servidor ou cliente esta usando, veja esta
   sec,ao do /etc/login.conf:

 default:\
         :passwd_format=des:\
         :copyright=/etc/COPYRIGHT:\
         [Further entries elided]

   Neste exemplo, o sistema esta usando o formato DES. Outros valores
   possiveis sao blf para Blowfish e md5 para senhas criptografadas com MD5.

   Se o formato em um host precisar ser editado para corresponder ao que esta
   sendo usado no dominio NIS, o banco de dados de recursos de login deve ser
   reconstruido apos salvar a alterac,ao:

 # cap_mkdb /etc/login.conf

  Nota:

   O formato das senhas das contas de usuarios existentes nao sera atualizado
   ate que cada usuario mude sua senha apos o banco de dados de recursos de
   login ser reconstruido.

29.5. Protocolo leve de acesso de diretorio ( LDAP )

   Originalmente contribuido por Tom Rhodes.
   Atualizado por Rocky Hotas.

   O protocolo LDAP (LDAP) e um protocolo da camada de aplicac,ao usado para
   acessar, modificar e autenticar objetos usando um servic,o de informac,oes
   de diretorio distribuido. Pense nisso como um telefone ou livro de
   registro que armazena varios niveis de informac,oes hierarquicas e
   homogeneas. Ele e usado nas redes do Active Directory e do OpenLDAP e
   permite que os usuarios acessem varios niveis de informac,oes internas
   utilizando uma unica conta. Por exemplo, a autenticac,ao de email, a
   obtenc,ao de informac,oes de contato dos funcionarios e a autenticac,ao
   interna de sites podem usar uma unica conta de usuario na base de
   registros do servidor LDAP.

   Esta sec,ao fornece um guia de inicio rapido para configurar um servidor
   LDAP em um sistema FreeBSD. Ele pressupoe que o administrador ja tenha um
   plano de design que inclua o tipo de informac,ao a ser armazenada, para
   que essas informac,oes sejam usadas, quais usuarios devem ter acesso a
   essas informac,oes e como proteger essas informac,oes contra acesso nao
   autorizado.

  29.5.1. Terminologia e Estrutura do LDAP

   O LDAP usa varios termos que devem ser entendidos antes de iniciar a
   configurac,ao. Todas as entradas de diretorio consistem em um grupo de
   attributes. Cada um desses conjuntos de atributos contem um identificador
   exclusivo conhecido como Distinguished Name (DN) que e normalmente criado
   a partir de varios outros atributos, como Common ou Relative Distinguished
   Name (RDN). Semelhante a como os diretorios tem caminhos absolutos e
   relativos, considere um DN como um caminho absoluto e o RDN como o caminho
   relativo.

   Um exemplo de entrada LDAP e semelhante ao seguinte. Este exemplo procura
   a entrada para a conta de usuario especificada (uid), unidade
   organizacional (ou) e organizac,ao (o):

 % ldapsearch -xb "uid=trhodes,ou=users,o=example.com"
 # extended LDIF
 #
 # LDAPv3
 # base <uid=trhodes,ou=users,o=example.com> with scope subtree
 # filter: (objectclass=*)
 # requesting: ALL
 #

 # trhodes, users, example.com
 dn: uid=trhodes,ou=users,o=example.com
 mail: trhodes@example.com
 cn: Tom Rhodes
 uid: trhodes
 telephoneNumber: (123) 456-7890

 # search result
 search: 2
 result: 0 Success

 # numResponses: 2
 # numEntries: 1

   Esta entrada de exemplo mostra os valores para os atributos dn, mail, cn,
   uid e telephoneNumber. O atributo do cn e o RDN.

   Maiores informac,oes sobre o LDAP e sua terminologia podem ser encontradas
   em http://www.openldap.org/doc/admin24/intro.html.

  29.5.2. Configurando um servidor LDAP

   O FreeBSD nao prove um servidor LDAP embutido. Comece a configurac,ao
   instalando o pacote ou port net/openldap-server:

 # pkg install openldap-server

   Aqui esta um largo conjunto de opc,oes habilitadas no pacote. Reveja-os
   rodando o comando pkg info openldap-server. Se nao for suficiente (por
   exemplo se o suporte a SQL for necessario), por favor considere recompilar
   o port usando o framework apropriado.

   A instalac,ao cria o diretorio /var/db/openldap-data para conter os dados.
   O diretorio para armazenar os certificados deve ser criado:

 # mkdir /usr/local/etc/openldap/private

   A proxima fase e configurar a autoridade de certificac,ao. Os seguintes
   comandos devem ser executados em /usr/local/etc/openldap/private. Isso e
   importante, pois as permissoes de arquivo precisam ser restritivas e os
   usuarios nao devem ter acesso a esses arquivos. Informac,oes mais
   detalhadas sobre certificados e seus parametros podem ser encontradas em
   Sec,ao 13.6, "OpenSSL". Para criar a Autoridade de Certificac,ao, comece
   com este comando e siga os prompts:

 # openssl req -days 365 -nodes -new -x509 -keyout ca.key -out ../ca.crt

   As entradas para os prompts podem ser genericas exceto para o Common Name.
   Esta entrada deve ser diferente do nome do host do sistema. Se este sera
   um certificado auto-assinado, prefixe o nome do host com CA para a
   Autoridade de Certificac,ao.

   A proxima tarefa e criar uma solicitac,ao de assinatura de certificado e
   uma chave privada. Insira este comando e siga os prompts:

 # openssl req -days 365 -nodes -new -keyout server.key -out server.csr

   Durante o processo de gerac,ao de certificados, certifique-se de
   configurar corretamente o atributo Common Name. A Solicitac,ao de
   Assinatura de Certificado deve ser assinada com a Autoridade de
   Certificac,ao para ser usada como um certificado valido:

 # openssl x509 -req -days 365 -in server.csr -out ../server.crt -CA ../ca.crt -CAkey ca.key -CAcreateserial

   A parte final do processo de gerac,ao de certificados e gerar e assinar os
   certificados do cliente:

 # openssl req -days 365 -nodes -new -keyout client.key -out client.csr
 # openssl x509 -req -days 3650 -in client.csr -out ../client.crt -CA ../ca.crt -CAkey ca.key

   Lembre-se de usar o mesmo atributo Common Name quando solicitado. Quando
   terminar, assegure-se de que um total de oito (8) novos arquivos tenham
   sido gerado atraves dos comandos procedentes.

   O daemon que executa o servidor OpenLDAP e o slapd. Sua configurac,ao e
   executada atraves do slapd.ldif: o antigo slapd.conf foi descontinuado
   pelo OpenLDAP.

   Exemplos de configurac,ao para o slapd.ldif estao disponiveis e tambem
   podem ser encontrados em /usr/local/etc/openldap/slapd.ldif.sample. As
   opc,oes estao documentadas em slapd-config(5). Cada sec,ao do slapd.ldif,
   como todos os outros conjuntos de atributos LDAP, e identificada
   exclusivamente por meio de um DN. Certifique-se de que nenhuma linha em
   branco seja deixada entre a instruc,ao dn: e o final desejado da sec,ao.
   No exemplo a seguir, o TLS sera usado para implementar um canal seguro. A
   primeira sec,ao representa a configurac,ao global:

 #
 # See slapd-config(5) for details on configuration options.
 # This file should NOT be world readable.
 #
 dn: cn=config
 objectClass: olcGlobal
 cn: config
 #
 #
 # Define global ACLs to disable default read access.
 #
 olcArgsFile: /var/run/openldap/slapd.args
 olcPidFile: /var/run/openldap/slapd.pid
 olcTLSCertificateFile: /usr/local/etc/openldap/server.crt
 olcTLSCertificateKeyFile: /usr/local/etc/openldap/private/server.key
 olcTLSCACertificateFile: /usr/local/etc/openldap/ca.crt
 #olcTLSCipherSuite: HIGH
 olcTLSProtocolMin: 3.1
 olcTLSVerifyClient: never

   A Autoridade de Certificac,ao, o certificado do servidor e os arquivos de
   chave privada do servidor devem ser especificados aqui. Recomenda-se que
   os clientes escolham a opc,ao de criptografia de seguranc,a e omitam
   olcTLSCipherSuite (incompativel com clientes TLS diferentes de openssl). A
   opc,ao olcTLSProtocolMin permite que o servidor exija um nivel minimo de
   seguranc,a: e recomendado. Enquanto a verificac,ao e obrigatoria para o
   servidor, nao e para o cliente: olcTLSVerifyClient: never.

   A segunda sec,ao e sobre os modulos de backend e pode ser configurada da
   seguinte maneira:

 #
 # Load dynamic backend modules:
 #
 dn: cn=module,cn=config
 objectClass: olcModuleList
 cn: module
 olcModulepath:  /usr/local/libexec/openldap
 olcModuleload:  back_mdb.la
 #olcModuleload: back_bdb.la
 #olcModuleload: back_hdb.la
 #olcModuleload: back_ldap.la
 #olcModuleload: back_passwd.la
 #olcModuleload: back_shell.la

   A terceira sec,ao e dedicada a carregar os esquemas ldif necessarios para
   serem usados pelos bancos de dados: eles sao essenciais.

 dn: cn=schema,cn=config
 objectClass: olcSchemaConfig
 cn: schema

 include: file:///usr/local/etc/openldap/schema/core.ldif
 include: file:///usr/local/etc/openldap/schema/cosine.ldif
 include: file:///usr/local/etc/openldap/schema/inetorgperson.ldif
 include: file:///usr/local/etc/openldap/schema/nis.ldif

   Em seguida, a sec,ao de configurac,ao do frontend:

 # Frontend settings
 #
 dn: olcDatabase={-1}frontend,cn=config
 objectClass: olcDatabaseConfig
 objectClass: olcFrontendConfig
 olcDatabase: {-1}frontend
 olcAccess: to * by * read
 #
 # Sample global access control policy:
 #       Root DSE: allow anyone to read it
 #       Subschema (sub)entry DSE: allow anyone to read it
 #       Other DSEs:
 #               Allow self write access
 #               Allow authenticated users read access
 #               Allow anonymous users to authenticate
 #
 #olcAccess: to dn.base="" by * read
 #olcAccess: to dn.base="cn=Subschema" by * read
 #olcAccess: to *
 #       by self write
 #       by users read
 #       by anonymous auth
 #
 # if no access controls are present, the default policy
 # allows anyone and everyone to read anything but restricts
 # updates to rootdn.  (e.g., "access to * by * read")
 #
 # rootdn can always read and write EVERYTHING!
 #
 olcPasswordHash: {SSHA}
 # {SSHA} is already the default for olcPasswordHash

   Outra sec,ao e dedicada ao backend de configurac,ao, a unica maneira de
   acessar posteriormente a configurac,ao do servidor OpenLDAP e como um
   superusuario global.

 dn: olcDatabase={0}config,cn=config
 objectClass: olcDatabaseConfig
 olcDatabase: {0}config
 olcAccess: to * by * none
 olcRootPW: {SSHA}iae+lrQZILpiUdf16Z9KmDmSwT77Dj4U

   O nome de usuario administrador padrao e cn=config. Digite slappasswd em
   um shell, escolha a senha e use sua hash olcRootPW. Se essa opc,ao nao for
   especificada agora, antes do arquivo slapd.ldif ser importado, ninguem
   podera modificar a sec,ao de configurac,ao global.

   A ultima sec,ao e sobre o back-end do banco de dados:

 #######################################################################
 # LMDB database definitions
 #######################################################################
 #
 dn: olcDatabase=mdb,cn=config
 objectClass: olcDatabaseConfig
 objectClass: olcMdbConfig
 olcDatabase: mdb
 olcDbMaxSize: 1073741824
 olcSuffix: dc=domain,dc=example
 olcRootDN: cn=mdbadmin,dc=domain,dc=example
 # Cleartext passwords, especially for the rootdn, should
 # be avoided.  See slappasswd(8) and slapd-config(5) for details.
 # Use of strong authentication encouraged.
 olcRootPW: {SSHA}X2wHvIWDk6G76CQyCMS1vDCvtICWgn0+
 # The database directory MUST exist prior to running slapd AND
 # should only be accessible by the slapd and slap tools.
 # Mode 700 recommended.
 olcDbDirectory: /var/db/openldap-data
 # Indices to maintain
 olcDbIndex: objectClass eq

   Esse banco de dados hospeda os conteudos atuais do diretorio LDAP. Outros
   tipos diferentes de mdb estao disponiveis. Esse e super-usuario, nao
   confundir com um global, e configurado aqui: um usuario (possivelmente
   customizado) em olcRootDN e a hash da senha em olcRootPW; slappasswd pode
   ser usado como antes.

   Esse repositorio contem quatro exemplos do arquivo slapd.ldif. Para
   converter um arquivo slapd.conf existente dentro de slapd.ldif, referencie
   a essa pagina (por favor, note que isso pode introduzir algumas opc,oes
   inuteis).

   Quando a configurac,ao estiver concluida, o slapd.ldif deve ser colocado
   em um diretorio vazio. Recomenda-se cria-lo como:

 # mkdir /usr/local/etc/openldap/slapd.d/

   Importe o banco de dados de configurac,ao:

 # /usr/local/sbin/slapadd -n0 -F /usr/local/etc/openldap/slapd.d/ -l /usr/local/etc/openldap/slapd.ldif

   Inicie o daemon slapd:

 # /usr/local/libexec/slapd -F /usr/local/etc/openldap/slapd.d/

   A opc,ao -d pode ser usada para depurac,ao, conforme especificado em
   slapd(8). Para verificar se o servidor esta em execuc,ao e funcionando:

 # ldapsearch -x -b '' -s base '(objectclass=*)' namingContexts
 # extended LDIF
 #
 # LDAPv3
 # base <> with scope baseObject
 # filter: (objectclass=*)
 # requesting: namingContexts
 #

 #
 dn:
 namingContexts: dc=domain,dc=example

 # search result
 search: 2
 result: 0 Success

 # numResponses: 2
 # numEntries: 1

   O servidor ainda deve ser confiavel. Se isso nunca foi feito antes, siga
   estas instruc,oes. Instale o pacote ou o port OpenSSL:

 # pkg install openssl

   No diretorio onde o ca.crt esta armazenado (neste exemplo,
   /usr/local/etc/openldap), execute:

 # c_rehash .

   Tanto a CA quanto o certificado do servidor agora sao reconhecidos
   corretamente em suas respectivas func,oes. Para verificar isso, execute
   este comando no diretorio server.crt:

 # openssl verify -verbose -CApath . server.crt

   Se o slapd estiver em execuc,ao, reinicie-o. Como declarado em
   /usr/local/etc/rc.d/slapd, para executar corretamente o slapd na
   inicializac,ao, as seguintes linhas devem ser adicionadas ao /etc/rc.conf:

 lapd_enable="YES"
 slapd_flags='-h "ldapi://%2fvar%2frun%2fopenldap%2fldapi/
 ldap://0.0.0.0/"'
 slapd_sockets="/var/run/openldap/ldapi"
 slapd_cn_config="YES"

   O slapd nao fornece depurac,ao na inicializac,ao. Verifique o
   /var/log/debug.log, o dmesg -a e o /var/log/messages para este proposito.

   O exemplo a seguir adiciona o grupo team e o usuario john ao banco de
   dados LDAP de domain.example, que ainda esta vazio. Primeiro, crie o
   arquivo domain.ldif:

 # cat domain.ldif
 dn: dc=domain,dc=example
 objectClass: dcObject
 objectClass: organization
 o: domain.example
 dc: domain

 dn: ou=groups,dc=domain,dc=example
 objectClass: top
 objectClass: organizationalunit
 ou: groups

 dn: ou=users,dc=domain,dc=example
 objectClass: top
 objectClass: organizationalunit
 ou: users

 dn: cn=team,ou=groups,dc=domain,dc=example
 objectClass: top
 objectClass: posixGroup
 cn: team
 gidNumber: 10001

 dn: uid=john,ou=users,dc=domain,dc=example
 objectClass: top
 objectClass: account
 objectClass: posixAccount
 objectClass: shadowAccount
 cn: John McUser
 uid: john
 uidNumber: 10001
 gidNumber: 10001
 homeDirectory: /home/john/
 loginShell: /usr/bin/bash
 userPassword: secret

   Veja a documentac,ao do OpenLDAP para mais detalhes. Use slappasswd para
   substituir a senha secret em texto puro com um hash no userPassword. O
   caminho especificado como loginShell deve existir em todos sistemas onde
   john pode se logar. Finalmente, use o administrador mdb para modificar o
   banco de dados:

 # ldapadd -W -D "cn=mdbadmin,dc=domain,dc=example" -f domain.ldif

   Modificac,oes para a sec,ao configurac,oes globais podem ser feitas apenas
   pelo super-usuario global. Por exemplo, assume que a opc,ao
   olcTLSCipherSuite: HIGH:MEDIUM:SSLv3 foi inicialmente especificada e deve
   agora ser deletada. Primeiro, crie um arquivo que contenha o seguinte:

 # cat global_mod
 dn: cn=config
 changetype: modify
 delete: olcTLSCipherSuite

   Em seguida, aplique as modificac,oes:

 # ldapmodify -f global_mod -x -D "cn=config" -W

   Quando solicitado, fornec,a a senha escolhida na sec,ao configurac,ao
   backend. O nome de usuario nao e necessario: aqui, cn=config representa o
   DN da sec,ao do banco de dados a ser modificada. Como alternativa, use
   ldapmodify para excluir uma unica linha do banco de dados, ldapdelete para
   excluir uma entrada inteira.

   Se algo der errado ou se o superusuario global nao puder acessar o backend
   de configurac,ao, e possivel excluir e reescrever toda a configurac,ao:

 # rm -rf /usr/local/etc/openldap/slapd.d/

   O slapd.ldif pode entao ser editado e importado novamente. Por favor, siga
   este procedimento somente quando nenhuma outra soluc,ao estiver
   disponivel.

   Esta e a configurac,ao do servidor apenas. A mesma maquina tambem pode
   hospedar um cliente LDAP, com sua propria configurac,ao separada.

29.6. Protocolo de configurac,ao dinamica de hosts (DHCP)

   O protocolo de configurac,ao dinamica de hosts (DHCP) permite que um
   sistema se conecte a uma rede para receber as informac,oes de
   enderec,amento necessarias para a comunicac,ao nessa rede. O FreeBSD
   inclui a versao do dhclient do OpenBSD que e usada pelo cliente para obter
   as informac,oes de enderec,amento. O FreeBSD nao instala um servidor DHCP,
   mas varios servidores estao disponiveis na colec,ao de Ports do FreeBSD. O
   protocolo DHCP e totalmente descrito em RFC 2131. Recursos informativos
   tambem estao disponiveis em isc.org/downloads/dhcp/.

   Esta sec,ao descreve como usar o cliente DHCP integrado. Em seguida,
   descreve como instalar e configurar um servidor DHCP.

  Nota:

   No FreeBSD, o dispositivo bpf(4) e necessario tanto pelo servidor DHCP
   como pelo DHCP > cliente. Este dispositivo esta incluido no kernel GENERIC
   que e instalado com o FreeBSD. Usuarios que preferem criar um kernel
   personalizado precisam manter este dispositivo se o DHCP for usado.

   Deve-se notar que o bpf tambem permite que usuarios privilegiados executem
   sniffers de pacotes de rede naquele sistema.

  29.6.1. Configurando um cliente DHCP

   O suporte ao cliente DHCP esta incluido no instalador do FreeBSD,
   facilitando a configurac,ao de um sistema recem-instalado para receber
   automaticamente as informac,oes de enderec,amento de rede de um servidor
   DHCP existente. Consulte Sec,ao 2.8, "Pos-instalac,ao" para exemplos de
   configurac,ao de rede.

   Quando o dhclient e executado na maquina cliente, ele inicia as
   solicitac,oes de transmissao das informac,oes de configurac,ao. Por
   padrao, esses pedidos usam a porta UDP 68. O servidor responde na porta
   UDP 67 , fornecendo ao cliente um enderec,o IP e outras informac,oes de
   rede relevantes como uma mascara de sub-rede, gateway padrao e enderec,os
   de servidor DNS. Esta informac,ao esta na forma de uma "concessao" de DHCP
   e e valida por um tempo configuravel. Isso permite que enderec,os IP
   obsoletos para clientes que nao estejam mais conectados `a rede sejam
   reutilizados automaticamente. Clientes DHCP podem obter uma grande
   quantidade de informac,oes do servidor. Uma lista exaustiva pode ser
   encontrada em dhcp-options(5).

   Por padrao, quando um sistema FreeBSD inicializa, seu cliente DHCP e
   executado em segundo plano, ou asynchronously. Outros scripts de
   inicializac,ao continuam sendo executados enquanto o processo DHCP e
   concluido, o que acelera a inicializac,ao do sistema.

   O DHCP em segundo plano funciona bem quando o servidor DHCP responde
   rapidamente `as solicitac,oes do cliente. No entanto, o DHCP pode levar
   muito tempo para ser concluido em alguns sistemas. Se os servic,os de rede
   tentarem executar antes que o DHCP tenha atribuido as informac,oes de
   enderec,amento de rede, eles falharao. O uso do DHCP no modo synchronous
   impede esse problema, pois ele pausa a inicializac,ao ate que a
   configurac,ao DHCP seja concluida.

   Esta linha no /etc/rc.conf e usada para configurar o modo background ou
   assincrono:

 ifconfig_fxp0="DHCP"

   Esta linha pode ja existir se o sistema foi configurado para usar o DHCP
   durante a instalac,ao. Substitua o fxp0 mostrado nesses exemplos pelo nome
   da interface a ser configurada dinamicamente, conforme descrito em
   Sec,ao 11.5, "Configurando Placas de Interface de Rede".

   Para configurar o sistema para usar o modo sincrono e pausar durante a
   inicializac,ao enquanto o DHCP e concluido, use "SYNCDHCP":

 ifconfig_fxp0="SYNCDHCP"

   Opc,oes adicionais do cliente estao disponiveis. Procure por dhclient in
   rc.conf(5) para detalhes.

   O cliente DHCP usa os seguintes arquivos:

     * /etc/dhclient.conf

       O arquivo de configurac,ao usado pelo dhclient. Normalmente, esse
       arquivo contem apenas comentarios, pois os padroes sao adequados para
       a maioria dos clientes. Este arquivo de configurac,ao e descrito em
       dhclient.conf(5).

     * /sbin/dhclient

       Maiores informac,oes sobre o comando em si podem ser encontradas em
       dhclient(8).

     * /sbin/dhclient-script

       O script de configurac,ao do cliente DHCP especifico do FreeBSD. Ele e
       descrito em dhclient-script(8), mas nao deve precisar de nenhuma
       modificac,ao do usuario para funcionar corretamente.

     * /var/db/dhclient.leases.interface

       O cliente DHCP mantem um banco de dados de concessoes validas neste
       arquivo, que e escrito como um log e e descrito em dhclient.leases(5).

  29.6.2. Instalando e configurando um servidor DHCP

   Esta sec,ao demonstra como configurar um sistema FreeBSD para atuar como
   um servidor DHCP usando a implementac,ao do servidor DHCP do Internet
   Systems Consortium (ISC). Esta implementac,ao e a sua documentac,ao podem
   ser instaladas usando o pacote ou port net/isc-dhcp43-server.

   A instalac,ao do net/isc-dhcp43-server instala um arquivo de configurac,ao
   de exemplo. Copie o /usr/local/etc/dhcpd.conf.example para
   /usr/local/etc/dhcpd.conf e fac,a as alterac,oes neste novo arquivo.

   O arquivo de configurac,ao e composto de declarac,oes para sub-redes e
   hosts que definem as informac,oes que sao fornecidas aos clientes DHCP.
   Por exemplo, essas linhas configuram o seguinte:

 option domain-name "example.org";1
 option domain-name-servers ns1.example.org;2
 option subnet-mask 255.255.255.0;3

 default-lease-time 600;4
 max-lease-time 72400;5
 ddns-update-style none;6

 subnet 10.254.239.0 netmask 255.255.255.224 {
   range 10.254.239.10 10.254.239.20;7
   option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org;8
 }

 host fantasia {
   hardware ethernet 08:00:07:26:c0:a5;9
   fixed-address fantasia.fugue.com;10
 }

   1  Esta opc,ao especifica o dominio de pesquisa padrao que sera fornecido  
      aos clientes. Consulte resolv.conf(5) para obter maiores informac,oes.  
   2  Esta opc,ao especifica uma lista separada por virgula de servidores DNS 
      que o cliente deve usar. Eles podem ser listados por seus nomes de      
      dominio totalmente qualificados (FQDN), como visto no exemplo, ou por   
      seus enderec,os de IP.                                                  
   3  A mascara de sub-rede que sera fornecida aos clientes.                  
   4  O tempo de expirac,ao da concessao padrao em segundos. Um cliente pode  
      ser configurado para substituir esse valor.                             
   5  O periodo maximo permitido de tempo, em segundos, para uma concessao.   
      Se um cliente solicitar uma concessao mais longa, uma concessao ainda   
      sera emitida, mas sera valida apenas para o tempo especificado em       
      max-lease-time.                                                         
   6  O padrao none desabilita as atualizac,oes de DNS dinamicas. Alterar     
      isso para interim configura o servidor DHCP para atualizar um servidor  
      DNS sempre que for concedido um contrato para que o servidor de DNS     
      saiba quais enderec,os de IP estao associados a quais computadores na   
      rede. Nao altere a configurac,ao padrao, a menos que o servidor de DNS  
      tenha sido configurado para suportar DNS dinamico.                      
   7  Esta linha cria um conjunto de enderec,os IP disponiveis que sao        
      reservados para alocac,ao a clientes DHCP. O intervalo de enderec,os    
      deve ser valido para a rede ou sub-rede especificada na linha anterior. 
   8  Declara o gateway padrao que e valido para a rede ou sub-rede           
      especificada antes do colchete de abertura {.                           
   9  Especifica o enderec,o de hardware MAC de um cliente para que o         
      servidor DHCP possa reconhecer o cliente quando ele fizer uma           
      solicitac,ao.                                                           
   10 Especifica que este host deve sempre receber o mesmo enderec,o IP. A    
      utilizac,ao do nome do host esta correta, pois o servidor DHCP          
      resolvera o nome do host antes de retornar as informac,oes de           
      concessao.                                                              

   Este arquivo de configurac,ao suporta muito mais opc,oes. Consulte o
   dhcpd.conf(5), instalado com o servidor, para obter detalhes e exemplos.

   Uma vez que a configurac,ao do dhcpd.conf estiver completa, habilite o
   servidor DHCP em /etc/rc.conf:

 dhcpd_enable="YES"
 dhcpd_ifaces="dc0"

   Substitua o dc0 pela interface (ou interfaces, separadas por espac,o em
   branco) que o servidor DHCP devera escutar por solicitac,oes de clientes
   DHCP.

   Inicie o servidor executando o seguinte comando:

 # service isc-dhcpd start

   Quaisquer mudanc,as futuras na configurac,ao do servidor exigirao que o
   servic,o dhcpd seja interrompido e, em seguida, iniciado usando
   service(8).

   O servidor DHCP usa os seguintes arquivos. Observe que as paginas de
   manual sao instaladas com o software do servidor.

     * /usr/local/sbin/dhcpd

       Maiores informac,oes sobre o servidor dhcpd podem ser encontradas em
       dhcpd(8).

     * /usr/local/etc/dhcpd.conf

       O arquivo de configurac,ao do servidor precisa conter todas as
       informac,oes que devem ser fornecidas aos clientes, juntamente com
       informac,oes sobre a operac,ao do servidor. Este arquivo de
       configurac,ao e descrito no dhcpd.conf(5).

     * /var/db/dhcpd.leases

       O servidor DHCP mantem um banco de dados das concessoes que ele emitiu
       neste arquivo, que e gravado como um log. Consulte dhcpd.leases(5), o
       qual fornece uma descric,ao um pouco mais longa.

     * /usr/local/sbin/dhcrelay

       Esse daemon e usado em ambientes avanc,ados, onde um servidor DHCP
       encaminha uma solicitac,ao de um cliente para outro servidor DHCP em
       uma rede separada. Se esta funcionalidade for necessaria, instale o
       pacote ou port net/isc-dhcp43-relay. A instalac,ao inclui o
       dhcrelay(8), que fornece maiores detalhes.

29.7. Sistema de Nomes de Dominio (DNS)

   O Sistema de Nomes de Dominio (DNS) e o protocolo atraves do qual os nomes
   de dominio sao mapeados para enderec,os de IP e vice-versa. O DNS e
   coordenado pela Internet atraves de um sistema complexo de raiz de
   autoridade, Top Level Domain (TLD) e outros servidores de nomes de menor
   escala, que hospedam e armazenam em cache dominios individuais. Nao e
   necessario executar um servidor de nomes para executar pesquisas de DNS em
   um sistema.

   A tabela a seguir descreve alguns dos termos associados ao DNS:

   Tabela 29.4. Terminologia DNS

           Termo                              Definic,ao                      
   Encaminhamento de DNS Mapeamento de nomes de hosts para enderec,os de IP.  
   Origem                Refere-se ao dominio coberto em um arquivo de zona   
                         especifico.                                          
                         Um processo do sistema atraves do qual uma maquina   
   Resolver              consulta um servidor de nomes para informac,oes de   
                         zona.                                                
   DNS Reverso           Mapeamento de enderec,os IP para hostnames.          
                         O inicio da hierarquia da zona da Internet. Todas as 
   Root zone             zonas se enquadram na zona de raiz, semelhante a     
                         como todos os arquivos em um sistema de arquivos se  
                         enquadram no diretorio raiz.                         
   Zona                  Um dominio individual, subdominio ou parte do DNS    
                         administrado pela mesma autoridade.                  

   Exemplos de zonas:

     * . e como a zona root e geralmente referida na documentac,ao.

     * org. e um dominio de nivel superior (TLD) sob a zona raiz.

     * example.org. e uma zona sob o TLD org..

     * 1.168.192.in-addr.arpa e uma zona que faz referencia a todos os
       enderec,os IP que se enquadram no espac,o de enderec,amento IP
       192.168.1.* .

   Como se pode ver, a parte mais especifica de um nome de host aparece `a
   esquerda. Por exemplo, example.org. e mais especifico que org., como org.
   e mais especifico que a zona raiz . O layout de cada parte de um nome de
   host e muito parecido com um sistema de arquivos: o diretorio /dev esta
   dentro da raiz e assim por diante.

  29.7.1. Razoes para executar um servidor de nomes

   Os servidores de nomes geralmente vem em duas formas: servidores de nomes
   autoritativos e servidores de nomes de armazenamento em cache (tambem
   conhecidos como servidores de resoluc,ao).

   Um servidor de nomes autoritativo e necessario quando:

     * Alguem quer servir ao mundo informac,oes de DNS, respondendo
       autoritariamente a consultas.

     * Um dominio, como example.org, esta registrado e os enderec,os IP
       precisam ser atribuidos a nomes de host sob ele.

     * Um bloco de enderec,os IP requer entradas reversas de DNS (IP para
       hostname).

     * Um servidor de nomes de backup ou secundario, chamado de escravo,
       respondera `as consultas.

   Um servidor de nomes em cache e necessario quando:

     * Um servidor DNS local pode armazenar em cache e responder mais
       rapidamente do que consultar um servidor de nomes externo.

   Quando alguem pergunta por www.FreeBSD.org, o resolvedor geralmente
   consulta o servidor de nomes do ISP e recupera a resposta. Com um servidor
   local, de cache DNS, a consulta so precisa ser feita uma vez para o mundo
   externo pelo servidor de Cache DNS. Consultas adicionais nao precisarao
   sair da rede local, pois as informac,oes estao armazenadas em um cache
   local.

  29.7.2. Configurac,ao do servidor de DNS

   O Unbound e fornecido no sistema basico do FreeBSD. Por padrao, ele
   fornecera a resoluc,ao de DNS apenas para a maquina local. Embora o pacote
   basico do sistema possa ser configurado para fornecer servic,os de
   resoluc,ao alem da maquina local, e recomendavel que esses requisitos
   sejam resolvidos instalando o Unbound da colec,ao de ports do FreeBSD.

   Para ativar o Unbound, adicione o seguinte ao /etc/rc.conf:

 local_unbound_enable="YES"

   Quaisquer servidores de nomes existentes em /etc/resolv.conf serao
   configurados como forwarders na nova configurac,ao do Unbound.

  Nota:

   Se algum dos servidores de nomes listados nao suportar o DNSSEC, a
   resoluc,ao local DNS falhara. Certifique-se de testar cada servidor de
   nomes e remover qualquer um que falhe no teste. O seguinte comando
   mostrara a arvore de confianc,a ou uma falha para um servidor de nomes em
   execuc,ao em 192.168.1.1:

 % drill -S FreeBSD.org @192.168.1.1

   Quando cada servidor de nomes for confirmado para suportar DNSSEC, inicie
   o Unbound:

 # service local_unbound onestart

   Isso cuidara da atualizac,ao do arquivo /etc/resolv.conf para que as
   consultas para dominios seguros DNSSEC funcionem agora. Por exemplo,
   execute o seguinte DNSSEC para validar a arvore confiavel do FreeBSD.org :

 % drill -S FreeBSD.org
 ;; Number of trusted keys: 1
 ;; Chasing: freebsd.org. A

 DNSSEC Trust tree:
 freebsd.org. (A)
 |---freebsd.org. (DNSKEY keytag: 36786 alg: 8 flags: 256)
     |---freebsd.org. (DNSKEY keytag: 32659 alg: 8 flags: 257)
     |---freebsd.org. (DS keytag: 32659 digest type: 2)
         |---org. (DNSKEY keytag: 49587 alg: 7 flags: 256)
             |---org. (DNSKEY keytag: 9795 alg: 7 flags: 257)
             |---org. (DNSKEY keytag: 21366 alg: 7 flags: 257)
             |---org. (DS keytag: 21366 digest type: 1)
             |   |---. (DNSKEY keytag: 40926 alg: 8 flags: 256)
             |       |---. (DNSKEY keytag: 19036 alg: 8 flags: 257)
             |---org. (DS keytag: 21366 digest type: 2)
                 |---. (DNSKEY keytag: 40926 alg: 8 flags: 256)
                     |---. (DNSKEY keytag: 19036 alg: 8 flags: 257)
 ;; Chase successful

29.8. Servidor HTTP Apache

   Contribuido por Murray Stokely.

   O open source Apache HTTP Server e o servidor Web mais utilizado. O
   FreeBSD nao instala este servidor web por padrao, mas ele pode ser
   instalado a partir do pacote ou Port www/apache24.

   Esta sec,ao resume como configurar e iniciar a versao 2.x do Servidor HTTP
   Apache no FreeBSD. Para informac,oes mais detalhadas sobre o Apache2.X e
   suas diretivas de configurac,ao, consulte httpd.apache.org.

  29.8.1. Configurando e Iniciando o Apache

   No FreeBSD, o arquivo de configurac,ao principal do Apache HTTP Server e
   instalado como /usr/local/etc/apache2x/httpd.conf, onde x representa o
   numero da versao. Este arquivo ASCII de texto inicia as linhas de
   comentario com um #. As diretivas modificadas com mais frequ:encia sao:

   ServerRoot "/usr/local"

           Especifica a hierarquia de diretorio padrao para a instalac,ao do
           Apache. Os binarios sao armazenados nos subdiretorios bin e sbin
           da raiz do servidor e os arquivos de configurac,ao sao armazenados
           no subdiretorio etc/apache2x.

   ServerAdmin you@example.com

           Altere isso para seu enderec,o de e-mail para receber problemas
           com o servidor. Esse enderec,o tambem aparece em algumas paginas
           geradas pelo servidor, como documentos de erro.

   ServerName www.example.com:80

           Permite que um administrador defina um nome de host que e enviado
           de volta aos clientes pelo servidor. Por exemplo, www pode ser
           usado em vez do nome do host real. Se o sistema nao tiver um nome
           registrado no DNS, insira seu enderec,o IP. Se o servidor ira
           escutar em um relatorio alternativo, altere a porta 80 para o
           numero de porta alternativa.

   DocumentRoot "/usr/local/www/apache2x/data"

           O diretorio no qual os documentos serao exibidos. Por padrao,
           todas as solicitac,oes sao obtidas desse diretorio, mas os links e
           aliases simbolicos podem ser usados para apontar para outros
           locais.

   E sempre uma boa ideia fazer uma copia de backup do arquivo de
   configurac,ao do Apache padrao antes de fazer alterac,oes. Quando a
   configurac,ao do Apache estiver concluida, salve o arquivo e verifique a
   configurac,ao usando o apachectl. A execuc,ao do apachectl configtest deve
   retornar Syntax OK.

   Para iniciar o Apache na inicializac,ao do sistema, adicione a seguinte
   linha ao /etc/rc.conf:

 apache24_enable="YES"

   Se o Apache deve ser iniciado com opc,oes nao-padrao, a seguinte linha
   pode ser adicionada ao /etc/rc.conf para especificar os flags necessarios:

 apache24_flags=""

   Se o apachectl nao relatar erros de configurac,ao, inicie o httpd agora:

 # service apache24 start

   O servic,o httpd pode ser testado inserindo http://localhost em um
   navegador da Web, substituindo localhost pelo nome de dominio totalmente
   qualificado da maquina que esta executando o httpd. A pagina padrao da Web
   exibida e /usr/local/www/apache24/data/index.html.

   A configurac,ao do Apache pode ser testada quanto a erros depois de fazer
   alterac,oes subsequentes de configurac,ao enquanto o httpd esta em
   execuc,ao usando o seguinte comando:

 # service apache24 configtest

  Nota:

   E importante notar que o configtest nao e um padrao rc(8) e nao se espera
   que funcione para todos os scripts de inicializac,ao.

  29.8.2. Hospedagem Virtual

   A hospedagem virtual permite que varios sites sejam executados em um
   servidor Apache. Os hosts virtuais podem ser baseados em IP ou baseados em
   nome. A hospedagem virtual baseada em IP usa um enderec,o IP diferente
   para cada site. A hospedagem virtual baseada em nome usa os cabec,alhos
   HTTP/1.1 do cliente para descobrir o nome do host, o que permite que os
   sites compartilhem o mesmo enderec,o de IP.

   Para configurar o Apache para usar hospedagem virtual baseada em nome,
   adicione um bloco VirtualHost para cada site. Por exemplo, para o servidor
   Web denominado www.domain.tld com um dominio virtual de
   www.someotherdomain.tld, adicione as seguintes entradas ao arquivo
   httpd.conf:

 <VirtualHost *>
     ServerName www.domain.tld
     DocumentRoot /www/domain.tld
 </VirtualHost>

 <VirtualHost *>
     ServerName www.someotherdomain.tld
     DocumentRoot /www/someotherdomain.tld
 </VirtualHost>

   Para cada host virtual, substitua os valores de ServerName e DocumentRoot
   pelos valores a serem usados.

   Para obter mais informac,oes sobre como configurar hosts virtuais,
   consulte a documentac,ao oficial do Apache em:
   http://httpd.apache.org/docs/vhosts/.

  29.8.3. Modulos Apache

   O Apache usa modulos para aumentar a funcionalidade fornecida pelo
   servidor basico. Consulte o http://httpd.apache.org/docs/current/mod/ para
   uma lista completa e detalhes de configurac,ao para os modulos
   disponiveis.

   No FreeBSD, alguns modulos podem ser compilados com o port www/apache24.
   Digite make config dentro do diretorio /usr/ports/www/apache24 para ver
   quais modulos estao disponiveis e quais estao ativados por padrao. Se o
   modulo nao e compilado com o port, a Colec,ao de Ports do FreeBSD fornece
   uma maneira facil de instalar varios modulos. Esta sec,ao descreve tres
   dos modulos mais usados.

    29.8.3.1. mod_ssl

   O modulo mod_ssl usa a biblioteca OpenSSL para fornecer criptografia
   robusta via SSL (SSLv3) e protocolos de Seguranc,a da Camada de Transporte
   (TLSv1). Este modulo fornece todo o necessario para solicitar um
   certificado assinado de uma autoridade de assinatura de certificado
   confiavel para executar um servidor web seguro no FreeBSD.

   No FreeBSD, o modulo mod_ssl e habilitado por padrao tanto no pacote
   quanto no port. As diretivas de configurac,ao disponiveis sao explicadas
   em http://httpd.apache.org/docs/current/mod/mod_ssl.html.

    29.8.3.2. mod_perl

   O modulo mod_perl torna possivel escrever modulos Apache em Perl. Alem
   disso, o interprete persistente embutido no servidor evita a sobrecarga de
   iniciar um interprete externo e a penalidade do tempo de inicializac,ao do
   Perl.

   O mod_perl pode ser instalado usando o pacote ou port www/mod_perl2. A
   documentac,ao para usar este modulo pode ser encontrada em
   http://perl.apache.org/docs/2.0/index .html.

    29.8.3.3. mod_php

   Escrito porTom Rhodes.

   PHP: Pre-processador de hipertexto ( PHP ) e uma linguagem de script de
   proposito geral que e especialmente adequada para desenvolvimento web.
   Capaz de ser incorporada em HTML, sua sintaxe se baseia em C, Java(TM) e
   Perl com a intenc,ao de permitir desenvolvedores web para escrever
   rapidamente paginas da web geradas dinamicamente.

   Para obter suporte para PHP5 para o servidor da web Apache, instale o
   pacote ou port www/mod_php56. Isso instalara e configurara os modulos
   necessarios para suportar aplicativos dinamicos PHP. A instalac,ao
   adicionara automaticamente esta linha ao arquivo
   /usr/local/etc/apache24/httpd.conf:

 LoadModule php5_module        libexec/apache24/libphp5.so

   Em seguida, execute uma reinicializac,ao normal para carregar o modulo
   PHP:

 # apachectl graceful

   O suporte a PHP fornecido pelo www/mod_php56 e limitado. Suporte adicional
   pode ser instalado usando o port lang/php56-extensions que fornece uma
   interface baseada em menus para as extensoes PHP disponiveis.

   Como alternativa, extensoes individuais podem ser instaladas usando a
   porta apropriada. Por exemplo, para adicionar suporte PHP para o servidor
   de banco de dados MySQL, instale o databases/php56-mysql.

   Depois de instalar uma extensao, o servidor Apache deve ser recarregado
   para selecionar as novas alterac,oes de configurac,ao:

 # apachectl graceful

  29.8.4. Websites Dinamicos

   Alem do mod_perl e do mod_php, outras linguagens estao disponiveis para a
   criac,ao de conteudo dinamico da web. Estes incluem o Django e o Ruby on
   Rails.

    29.8.4.1. Django

   O Django e um framework de licenc,a BSD projetado para permitir que
   desenvolvedores escrevam aplicac,oes web elegantes e de alto desempenho
   rapidamente. Ele fornece um mapeador relacional de objeto para que os
   tipos de dados sejam desenvolvidos como objetos Python. Uma API rica e
   dinamica de acesso ao banco de dados e fornecida para os objetos sem que o
   desenvolvedor tenha que escrever SQL. Ele tambem fornece um sistema de
   template extensivel para que a logica do aplicativo seja separada da
   apresentac,ao HTML.

   Django depende de mod_python, e um mecanismo de banco de dados SQL. No
   FreeBSD, o port www/py-django instala automaticamente o mod_python e
   suporta os banco de dados PostgreSQL, MySQL, ou SQLite, com o padrao sendo
   o SQLite. Para trocar o mecanismo de banco de dados, digite make config
   dentro do diretorio /usr/ports/www/py-django, entao instale o port.

   Uma vez instalado o Django, a aplicac,ao precisara de um diretorio de
   projeto junto com a configurac,ao Apache para usar o interpretador Python
   incorporado. Este interprete e usado para chamar o aplicativo para URLs
   especificas no site.

   Para configurar o Apache para que passe a fazer solicitac,oes para
   determinadas URLs para a aplicac,ao Web, adicione o seguinte ao
   httpd.conf, especificando o caminho completo para o diretorio do projeto:

 <Location "/">
     SetHandler python-program
     PythonPath "['/dir/to/the/django/packages/'] + sys.path"
     PythonHandler django.core.handlers.modpython
     SetEnv DJANGO_SETTINGS_MODULE mysite.settings
     PythonAutoReload On
     PythonDebug On
 </Location>

   Consulte https://docs.djangoproject.com para maiores informac,oes sobre
   como usar o Django.

    29.8.4.2. Ruby on Rails

   O Ruby on Rails e outro framework de software livre da Web que fornece uma
   stack de desenvolvimento completa. Ele e otimizado para tornar os
   desenvolvedores da Web mais produtivos e capazes de criar rapidamente
   aplicativos poderosos. No FreeBSD, ele pode ser instalado usando o pacote
   ou port www/rubygem-rails.

   Consulte http://guides.rubyonrails.org para maiores informac,oes sobre
   como usar o Ruby on Rails .

29.9. Protocolo de Transferencia de Arquivos (FTP)

   O Protocolo de Transferencia de Arquivos (FTP) fornece aos usuarios uma
   maneira simples de transferir arquivos para um servidor FTP. O FreeBSD
   inclui o software do servidor FTP, ftpd, no sistema base.

   O FreeBSD fornece varios arquivos de configurac,ao para controlar o acesso
   ao servidor FTP. Esta sec,ao resume esses arquivos. Consulte ftpd(8) para
   obter mais detalhes sobre o servidor FTP incorporado.

  29.9.1. Configurac,ao

   A etapa de configurac,ao mais importante e decidir quais contas terao
   permissao para acessar o servidor FTP. Um sistema FreeBSD possui varias
   contas do sistema que nao devem ter acesso ao FTP. A lista de usuarios que
   nao permitem acesso FTP pode ser encontrada em /etc/ftpusers. Por padrao,
   inclui contas do sistema. Usuarios adicionais que nao devem ter acesso a
   FTP podem ser adicionados.

   Em alguns casos, pode ser desejavel restringir o acesso de alguns usuarios
   sem impedi-los completamente de usar o FTP. Isso pode ser feito criando
   /etc/ftpchroot como descrito em ftpchroot(5). Este arquivo lista usuarios
   e grupos sujeitos a restric,oes de acesso a FTP.

   Para permitir acesso anonimo ao servidor FTP, crie um usuario chamado ftp
   no sistema FreeBSD. Os usuarios poderao entao fazer logon no servidor FTP
   com um nome de usuario ftp ou anonymous . Quando for solicitada a senha,
   qualquer entrada sera aceita, mas por convenc,ao, um enderec,o de e-mail
   devera ser usado como a senha. O servidor FTP chamara chroot(2) quando um
   usuario anonimo efetuar login para restringir o acesso somente ao
   diretorio home do usuario ftp.

   Existem dois arquivos de texto que podem ser criados para especificar
   mensagens de boas-vindas a serem exibidas para clientes FTP. O conteudo de
   /etc/ftpwelcome sera exibido aos usuarios antes que eles atinjam o prompt
   de login. Apos um login bem sucedido, o conteudo de /etc/ftpmotd sera
   exibido. Observe que o caminho para esse arquivo e relativo ao ambiente de
   login, portanto, o conteudo de ~ftp/etc/ftpmotd seria exibido para
   usuarios anonimos.

   Uma vez configurado o servidor FTP, defina a variavel apropriada em
   /etc/rc.conf para iniciar o servic,o durante a inicializac,ao:

 ftpd_enable="YES"

   Para iniciar o servic,o agora:

 # service ftpd start

   Teste a conexao com o servidor FTP digitando:

 % ftp localhost

   O daemon ftpd usa o syslog(3) para registrar mensagens. Por padrao, o
   daemon de log do sistema gravara mensagens relacionadas a FTP em
   /var/log/xferlog. A localizac,ao do log do FTP pode ser modificada
   alterando a seguinte linha no /etc/syslog.conf:

 ftp.info      /var/log/xferlog

  Nota:

   Esteja ciente dos possiveis problemas envolvidos na execuc,ao de um
   servidor FTP anonimo. Em particular, pense duas vezes antes de permitir
   que usuarios anonimos fac,am upload de arquivos. Pode acontecer que o site
   FTP se torne um forum para o comercio de software comercial nao licenciado
   ou pior. Se uploads anonimos de FTP forem necessarios, verifique as
   permissoes para que esses arquivos nao possam ser lidos por outros
   usuarios anonimos ate que sejam revisados por um administrador.

29.10. Servic,os de arquivos e impressao para clientes Microsoft(R) Windows(R)
Clients (Samba)

   Samba e um popular pacote de software de codigo aberto que fornece
   servic,os de arquivo e impressao usando o protocolo SMB/CIFS. Este
   protocolo esta incorporado nos sistemas Microsoft(R) Windows(R). Ele pode
   ser adicionado a sistemas nao Microsoft(R) Windows(R) instalando as
   bibliotecas-cliente Samba. O protocolo permite que os clientes acessem
   dados e impressoras compartilhadas. Esses compartilhamentos podem ser
   mapeados como uma unidade de disco local e as impressoras compartilhadas
   podem ser usadas como se fossem impressoras locais.

   No FreeBSD, as bibliotecas cliente do Samba podem ser instaladas usando o
   port ou pacote net/samba410. O cliente fornece a capacidade de um sistema
   FreeBSD acessar compartilhamentos de SMB/CIFS em uma rede Microsoft(R)
   Windows(R).

   Um sistema FreeBSD tambem pode ser configurado para atuar como um servidor
   Samba instalando o port ou pacote net/samba410. Isso permite que o
   administrador crie compartilhamentos de SMB/CIFS no sistema FreeBSD que
   podem ser acessados por clientes executando Microsoft(R) Windows(R) ou as
   bibliotecas do cliente Samba.

  29.10.1. Configurac,ao do Servidor

   O Samba e configurado em /usr/local/etc/smb4.conf. Este arquivo deve ser
   criado antes que o Samba possa ser usado.

   Um simples smb4.conf para compartilhar diretorios e impressoras com
   clientes Windows(R) em um grupo de trabalho e mostrado aqui. Para
   configurac,oes mais complexas envolvendo LDAP ou Active Directory, e mais
   facil usar o samba-tool(8) para criar o smb4.conf.

 [global]
 workgroup = WORKGROUP
 server string = Samba Server Version %v
 netbios name = ExampleMachine
 wins support = Yes
 security = user
 passdb backend = tdbsam

 # Example: share /usr/src accessible only to 'developer' user
 [src]
 path = /usr/src
 valid users = developer
 writable  = yes
 browsable = yes
 read only = no
 guest ok = no
 public = no
 create mask = 0666
 directory mask = 0755

    29.10.1.1. Configurac,oes Globais

   As configurac,oes que descrevem a rede sao adicionadas em
   /usr/local/etc/smb4.conf:

   workgroup

           O nome do grupo de trabalho a ser servido.

   netbios name

           O nome NetBIOS pelo qual um servidor Samba e conhecido. Por
           padrao, e o mesmo que o primeiro componente do nome do DNS do
           host.

   server string

           A string que sera exibida na saida de net view e algumas outras
           ferramentas de rede que buscam exibir texto descritivo sobre o
           servidor.

   wins support

           Se o Samba funcionara como um servidor WINS. Nao habilite o
           suporte para WINS em mais de um servidor na rede.

    29.10.1.2. Configurac,oes de Seguranc,a

   As configurac,oes mais importantes em /usr/local/etc/smb4.conf sao o
   modelo de seguranc,a e o formato de senha de backend. Essas diretivas
   controlam as opc,oes:

   security

           As configurac,oes mais comuns sao security=share e security=user.
           Se os clientes usarem nomes de usuarios que sejam os mesmos nomes
           de usuarios na maquina do FreeBSD, a seguranc,a no nivel do
           usuario deve ser usada. Essa e a politica de seguranc,a padrao e
           exige que os clientes fac,am logon pela primeira vez antes de
           poderem acessar recursos compartilhados.

           Na seguranc,a em nivel de compartilhamento, os clientes nao
           precisam efetuar logon no servidor com um nome de usuario e senha
           validos antes de tentar se conectar a um recurso compartilhado.
           Este era o modelo de seguranc,a padrao para versoes mais antigas
           do Samba.

   passdb backend

           O Samba possui varios modelos de autenticac,ao de backend
           diferentes. Os clientes podem ser autenticados com LDAP, NIS+, um
           banco de dados SQL ou um arquivo de senha modificado. O metodo de
           autenticac,ao recomendado, tdbsam, e ideal para redes simples e e
           abordado aqui. Para redes maiores ou mais complexas, o ldapsam e
           recomendado. smbpasswd foi o padrao anterior e agora esta
           obsoleto.

    29.10.1.3. Usuarios do Samba

   As contas de usuario do FreeBSD devem ser mapeadas para o banco de dados
   SambaSAMAccount para que os clientes Windows(R) acessem o
   compartilhamento. Mapear contas de usuarios existentes do FreeBSD usando
   pdbedit(8):

 # pdbedit -a username

   Esta sec,ao mencionou apenas as configurac,oes mais usadas. Consulte a
   Wiki Oficial do Samba para obter informac,oes adicionais sobre as opc,oes
   de configurac,ao disponiveis.

  29.10.2. Iniciando o Samba

   Para habilitar o Samba no momento da inicializac,ao, adicione a seguinte
   linha ao /etc/rc.conf:

 samba_server_enable="YES"

   Para iniciar o Samba agora:

 # service samba_server start
 Performing sanity check on Samba configuration: OK
 Starting nmbd.
 Starting smbd.

   O Samba consiste em tres daemons separados. Os daemons nmbd e smbd sao
   iniciados por samba_enable. Se resoluc,ao de nomes winbind tambem e
   necessaria, defina:

 winbindd_enable="YES"

   O Samba pode ser interrompido a qualquer momento digitando:

 # service samba_server stop

   O Samba e um conjunto de software complexo com funcionalidade que permite
   ampla integrac,ao com as redes Microsoft(R) Windows(R). Para mais
   informac,oes sobre a funcionalidade alem da configurac,ao basica descrita
   aqui, consulte https://www.samba.org.

29.11. Sincronizac,ao de Relogio com NTP

   Com o tempo, o relogio de um computador esta propenso a se desviar. Isso e
   problematico, pois muitos servic,os de rede exigem que os computadores em
   uma rede compartilhem o mesmo tempo exato. Tempo preciso tambem e
   necessario para garantir que os registros de data e hora dos arquivos
   permanec,am consistentes. O protocolo de horario da rede (NTP) e uma
   maneira de fornecer precisao de relogio em uma rede.

   O FreeBSD inclui o ntpd(8) o qual pode ser configurado para consultar
   outros servidores NTP para sincronizar o relogio nessa maquina ou para
   fornecer servic,os de horario para outros computadores na rede.

   Esta sec,ao descreve como configurar o ntpd no FreeBSD. Mais documentac,ao
   pode ser encontrada em /usr/share/doc/ntp/ no formato HTML.

  29.11.1. Configurac,ao de NTP

   No FreeBSD, o ntpd nativo pode ser usado para sincronizar o relogio do
   sistema. O Ntpd e configurado usando variaveis no rc.conf(5) e no
   /etc/ntp.conf, conforme detalhado nas sec,oes a seguir.

   O Ntpd se comunica com seus network peers usando pacotes UDP. Quaisquer
   firewalls entre sua maquina e seus NTP peers devem ser configurados para
   permitir a entrada e saida de pacotes UDP na porta 123.

    29.11.1.1. O arquivo /etc/ntp.conf

   O Ntpd faz a leitura do /etc/ntp.conf para determinar quais servidores NTP
   que ele deve consultar. E recomendavel escolher varios servidores NTP,
   caso um dos servidores se torne inacessivel ou seu relogio torne-se nao
   confiavel. Como o ntpd recebe respostas, ele favorece servidores
   confiaveis em vez dos menos confiaveis. Os servidores consultados podem
   ser locais na rede, fornecidos por um ISP ou selecionados a partir de uma
   lista online de servidores NTP publicamente acessiveis. Ao escolher um
   servidor NTP publico, selecione um servidor geograficamente proximo e
   revise sua politica de uso. A palavra-chave pool de configurac,ao
   seleciona um ou mais servidores de um pool de servidores. Esta disponivel
   uma lista online de pools NTP publicamente acessiveis, organizada por area
   geografica. Alem disso, o FreeBSD fornece um pool patrocinado pelo
   projeto, 0.freebsd.pool.ntp.org.

   Exemplo 29.3. Exemplo de /etc/ntp.conf

   Este e um exemplo simples de um arquivo ntp.conf. Ele pode ser usado com
   seguranc,a como esta; ele contem as opc,oes restrict recomendadas para
   operac,ao em uma conexao de rede publica.

 # Disallow ntpq control/query access.  Allow peers to be added only
 # based on pool and server statements in this file.
 restrict default limited kod nomodify notrap noquery nopeer
 restrict source  limited kod nomodify notrap noquery

 # Allow unrestricted access from localhost for queries and control.
 restrict 127.0.0.1
 restrict ::1

 # Add a specific server.
 server ntplocal.example.com iburst

 # Add FreeBSD pool servers until 3-6 good servers are available.
 tos minclock 3 maxclock 6
 pool 0.freebsd.pool.ntp.org iburst

 # Use a local leap-seconds file.
 leapfile "/var/db/ntpd.leap-seconds.list"

   O formato deste arquivo e descrito em ntp.conf(5). As descric,oes abaixo
   fornecem uma visao geral rapida apenas das palavras-chave usadas no
   arquivo de exemplo acima.

   Por padrao, um servidor NTP pode ser acessado de qualquer host da rede. A
   palavra-chave restrict controla quais sistemas podem acessar o servidor.
   Multiplas entradas restrict sao suportadas, cada uma refinando as
   restric,oes fornecidas nas instruc,oes anteriores. Os valores mostrados no
   exemplo concedem ao sistema local o acesso completo `a consulta e
   controle, enquanto permitem aos sistemas remotos apenas a capacidade de
   consultar o horario. Para obter mais detalhes, consulte a subsec,ao Access
   Control Support de ntp.conf(5).

   A palavra-chave server especifica um unico servidor para consulta. O
   arquivo pode conter varias palavras-chave server, com um servidor listado
   em cada linha. A palavra-chave pool especifica um pool de servidores. O
   Ntpd adicionara um ou mais servidores desse pool, conforme necessario,
   para atingir o numero de peers especificado usando o valor tos minclock. A
   palavra-chave iburst direciona o ntpd para executar um burst de oito
   trocas rapidas de pacotes com um servidor quando o contato e estabelecido
   pela primeira vez, para ajudar a sincronizar rapidamente a hora do
   sistema.

   A palavra-chave leapfile especifica o local de um arquivo que contem
   informac,oes sobre segundos bissextos. O arquivo e atualizado
   automaticamente pelo periodic(8). O local do arquivo especificado por esta
   palavra-chave deve corresponder ao local definido na variavel
   ntp_db_leapfile em /etc/rc.conf.

    29.11.1.2. Entradas NTP no /etc/rc.conf

   Defina ntpd_enable=YES para iniciar o ntpd no momento do boot do sistema.
   Depois que o ntpd_enable=YES for adicionado ao /etc/rc.conf, o ntpd podera
   ser iniciado imediatamente sem reiniciar o sistema, digitando:

 # service ntpd start

   Somente ntpd_enable deve ser configurado para usar o ntpd. As variaveis
   rc.conf listadas abaixo tambem podem ser definidas conforme necessario.

   Defina ntpd_sync_on_start=YES para permitir que o ntpd adiante o relogio,
   uma vez na inicializac,ao. Normalmente, o ntpd registra uma mensagem de
   erro e se finaliza se o relogio estiver dessincronizado por mais de 1000
   segundos. Essa opc,ao e especialmente util em sistemas sem um relogio em
   tempo real com bateria.

   Defina ntpd_oomprotect=YES para proteger o servic,o ntpd de ser finalizado
   pelo sistema quando ele tentar se recuperar de uma condic,ao de Falta de
   Nemoria (OOM).

   Defina ntpd_config= para o local de um arquivo ntp.conf alternativo.

   Defina ntpd_flags= para conter outras flags ntpd conforme necessario, mas
   evite usar as flags gerenciadas internamente pelo /etc/rc.d/ntpd:

     * -p (local do arquivo pid)

     * -c (configure ntpd_config= como alternativa)

    29.11.1.3. O Ntpd e o usuario nao privilegiado ntpd

   O Ntpd no FreeBSD pode ser iniciado e executado como um usuario nao
   privilegiado. Para isso, e necessario o modulo de politica mac_ntpd(4). O
   script de inicializac,ao /etc/rc.d/ntpd examina primeiro a configurac,ao
   do NTP. Se possivel, ele carrega o modulo mac_ntpd e inicia o ntpd como um
   usuario nao vinculado ntpd (user id 123). Para evitar problemas com o
   acesso a arquivos e diretorios, o script de inicializac,ao nao iniciara
   automaticamente o ntpd como ntpd quando a configurac,ao contiver quaisquer
   opc,oes relacionadas a arquivos.

   A presenc,a de qualquer um dos itens a seguir em ntpd_flags requer
   configurac,ao manual, conforme descrito abaixo, para ser executada como o
   usuario ntpd user:

     * -f or --driftfile

     * -i or --jaildir

     * -k or --keyfile

     * -l or --logfile

     * -s or --statsdir

   A presenc,a de qualquer uma das seguintes palavras-chave no ntp.conf
   requer configurac,ao manual, conforme descrito abaixo, para ser executado
   como usuario ntpd:

     * crypto

     * driftfile

     * key

     * logdir

     * statsdir

   Para configurar manualmente o ntpd para ser executado como usuario ntpd,
   voce deve:

     * Certifique-se de que o usuario ntpd tenha acesso a todos os arquivos e
       diretorios especificados na configurac,ao.

     * Se certifique para que o modulo mac_ntpd seja carregado ou compilado
       no kernel. Consulte mac_ntpd(4) para obter detalhes.

     * Defina ntpd_user="ntpd" no /etc/rc.conf

  29.11.2. Usando NTP com uma Conexao PPP

   O ntpd nao precisa de uma conexao permanente com a Internet para funcionar
   corretamente. No entanto, se uma conexao PPP estiver configurada para
   discar sob demanda, o trafego de NTP devera ser impedido de disparar uma
   discagem ou manter a conexao ativa. Isso pode ser configurado com as
   diretivas filter em /etc/ppp/ppp.conf. Por exemplo:

 set filter dial 0 deny udp src eq 123
 # Prevent NTP traffic from initiating dial out
 set filter dial 1 permit 0 0
 set filter alive 0 deny udp src eq 123
 # Prevent incoming NTP traffic from keeping the connection open
 set filter alive 1 deny udp dst eq 123
 # Prevent outgoing NTP traffic from keeping the connection open
 set filter alive 2 permit 0/0 0/0

   Para mais detalhes, consulte a sec,ao PACKET FILTERING em ppp(8) e os
   exemplos em /usr/share/examples/ppp/.

  Nota:

   Alguns provedores de acesso `a Internet bloqueiam portas de numeros
   baixos, impedindo o funcionamento do NTP, pois as respostas nunca chegam
   `a maquina.

29.12. Inicializador iSCSI e Configurac,ao Alvo

   iSCSI e uma maneira de compartilhar o armazenamento em uma rede. Ao
   contrario do NFS, que funciona no nivel do sistema de arquivos, o iSCSI
   funciona no nivel do dispositivo de bloco.

   Na terminologia iSCSI, o sistema que compartilha o armazenamento e
   conhecido como alvo. O armazenamento pode ser um disco fisico ou uma area
   representando varios discos ou uma parte de um disco fisico. Por exemplo,
   se os discos estiverem formatados com ZFS, um zvol podera ser criado para
   ser usado como armazenamento iSCSI.

   Os clientes que acessam o armazenamento do iSCSI sao chamados de
   iniciadores. Para os iniciadores, o armazenamento disponivel por meio do
   iSCSI aparece como um disco bruto, nao formatado, conhecido como LUN. Nos
   de dispositivo para o disco aparecem em /dev/ e o dispositivo deve ser
   formatado e montado separadamente.

   O FreeBSD fornece um alvo e iniciador nativo, baseado em kernel iSCSI.
   Esta sec,ao descreve como configurar um sistema FreeBSD como um alvo ou um
   iniciador.

  29.12.1. Configurando um Alvo iSCSI

   Para configurar um alvo iSCSI, crie o arquivo de configurac,ao
   /etc/ctl.conf, adicione uma linha ao arquivo /etc/rc.conf para
   certificar-se de que o daemon ctld(8) seja iniciado automaticamente na
   inicializac,ao e, em seguida, inicie-o.

   A seguir, um exemplo de um arquivo de configurac,ao simples /etc/ctl.conf.
   Consulte ctl.conf(5) para obter uma descric,ao mais completa das opc,oes
   disponiveis deste arquivo.

 portal-group pg0 {
         discovery-auth-group no-authentication
         listen 0.0.0.0
         listen [::]
 }

 target iqn.2012-06.com.example:target0 {
         auth-group no-authentication
         portal-group pg0

         lun 0 {
                 path /data/target0-0
                 size 4G
         }
 }

   A primeira entrada define o grupo de portais pg0. Grupos de portal definem
   quais enderec,os de rede o daemon ctld(8) ira escutar. A entrada
   discovery-auth-group no-authentication indica que qualquer iniciador tem
   permissao para executar descoberta de alvo iSCSI sem autenticac,ao. As
   linhas tres e quatro configuram ctld(8) para escutar em todos os
   enderec,os IPv4 (listen 0.0.0.0) e IPv6 (listen [::]) na porta padrao
   3260.

   Nao e necessario definir um grupo de portais, pois ha um grupo de portais
   interno chamado default. Nesse caso, a diferenc,a entre default e pg0 e
   que com default, a descoberta de alvo e sempre negada, enquanto com pg0, e
   sempre permitido.

   A segunda entrada define um unico alvo. O alvo tem dois significados
   possiveis: uma maquina que atende iSCSI ou um grupo nomeado de LUNs. Este
   exemplo usa o ultimo significado, onde iqn.2012-06.com.example:target0 e o
   nome do alvo. Este nome de alvo e adequado para fins de teste. Para uso
   real, altere com.example para o nome de dominio real, invertido. O 2012-06
   representa o ano e o mes de aquisic,ao do controle desse nome de dominio,
   e target0 pode ser qualquer valor. Qualquer numero de alvos pode ser
   definido neste arquivo de configurac,ao.

   A linha auth-group no-authentication permite que todos os iniciadores se
   conectem ao alvo especificado e portal-group pg0 torna o alvo acessivel
   atraves do grupo do portal pg0.

   A proxima sec,ao define o LUN. Para o iniciador, cada LUN sera visivel
   como um dispositivo de disco separado. Multiplos LUNs podem ser definidos
   para cada destino. Cada LUN e identificado por um numero, onde LUN 0 e
   obrigatorio. A linha path/data/target0-0 define o caminho completo para um
   arquivo ou zvol que suporta o LUN. Esse caminho deve existir antes de
   iniciar ctld(8). A segunda linha e opcional e especifica o tamanho do LUN.

   Em seguida, para ter certeza que o daemon ctld(8) foi iniciado no boot,
   adicione esta linha ao arquivo /etc/rc.conf:

 ctld_enable="YES"

   Para iniciar o ctld(8) agora, execute este comando:

 # service ctld start

   Quando o daemon ctld(8) e iniciado, ele le o arquivo /etc/ctl.conf. Se
   este arquivo for editado depois que o daemon iniciar, use este comando
   para que as mudanc,as entrem em vigor imediatamente:

 # service ctld reload

    29.12.1.1. Autenticac,ao

   O exemplo anterior e inerentemente inseguro, pois nao usa autenticac,ao,
   concedendo a qualquer um acesso total a todos os alvos. Para exigir um
   nome de usuario e senha para acessar os alvos, modifique a configurac,ao
   da seguinte maneira:

 auth-group ag0 {
         chap username1 secretsecret
         chap username2 anothersecret
 }

 portal-group pg0 {
         discovery-auth-group no-authentication
         listen 0.0.0.0
         listen [::]
 }

 target iqn.2012-06.com.example:target0 {
         auth-group ag0
         portal-group pg0
         lun 0 {
                 path /data/target0-0
                 size 4G
         }
 }

   A sec,ao auth-group define os pares de nome de usuario e senha. Um
   inicializador tentando se conectar a iqn.2012-06.com.example:target0 deve
   primeiro especificar um nome de usuario e senha definidos. No entanto, a
   descoberta do alvo ainda e permitida sem autenticac,ao. Para exigir
   autenticac,ao de descoberta de alvo, defina discovery-auth-group como um
   nome auth-group definido em vez de no-authentication.

   E comum definir um unico alvo exportado para cada inicializador. Como um
   atalho para a sintaxe acima, o nome de usuario e a senha podem ser
   especificados diretamente na entrada do alvo:

 target iqn.2012-06.com.example:target0 {
         portal-group pg0
         chap username1 secretsecret

         lun 0 {
                 path /data/target0-0
                 size 4G
         }
 }

  29.12.2. Configurando um Inicializador iSCSI

  Nota:

   O inicializador iSCSI descrito nesta sec,ao e suportado a partir do
   FreeBSD 10.0-RELEASE. Para usar o inicializador iSCSI disponivel em
   versoes mais antigas, consulte iscontrol(8).

   O inicializador iSCSI requer que o daemon iscsid(8) esteja em execuc,ao.
   Este daemon nao usa um arquivo de configurac,ao. Para inicia-lo
   automaticamente na inicializac,ao, adicione esta linha ao arquivo
   /etc/rc.conf:

 iscsid_enable="YES"

   Para iniciar iscsid(8) agora, execute este comando:

 # service iscsid start

   Conectar-se a um alvo pode ser feito com ou sem um arquivo /etc/iscsi.conf
   de configurac,ao. Esta sec,ao demonstra os dois tipos de conexoes.

    29.12.2.1. Conectando-se a um Alvo sem um Arquivo de Configurac,ao

   Para conectar um inicializador a um unico alvo, especifique o enderec,o IP
   do portal e o nome do alvo:

 # iscsictl -A -p 10.10.10.10 -t iqn.2012-06.com.example:target0

   Para verificar se a conexao foi bem sucedida, execute iscsictl sem nenhum
   argumento. A saida deve ser semelhante a esta:

 Target name                                     Target portal   State
 iqn.2012-06.com.example:target0                 10.10.10.10     Connected: da0

   Neste exemplo, a sessao iSCSI foi estabelecida com sucesso, com /dev/da0
   representando o LUN anexado. Se o destino iqn.2012-06.com.example:target0
   exportar mais de um LUN, varios nos de dispositivos serao mostrados nessa
   sec,ao da saida:

 Connected: da0 da1 da2.

   Quaisquer erros serao relatados na saida, assim como os logs do sistema.
   Por exemplo, esta mensagem normalmente significa que o daemon iscsid(8)
   nao esta em execuc,ao:

 Target name                                     Target portal   State
 iqn.2012-06.com.example:target0                 10.10.10.10     Waiting for iscsid(8)

   A mensagem a seguir sugere um problema de rede, como uma porta ou
   enderec,o IP incorreto:

 Target name                                     Target portal   State
 iqn.2012-06.com.example:target0                 10.10.10.11     Connection refused

   Esta mensagem significa que o nome do alvo especificado esta errado:

 Target name                                     Target portal   State
 iqn.2012-06.com.example:target0                 10.10.10.10     Not found

   Esta mensagem significa que o alvo requer autenticac,ao:

 Target name                                     Target portal   State
 iqn.2012-06.com.example:target0                 10.10.10.10     Authentication failed

   Para especificar um nome de usuario e uma senha de CHAP, use esta sintaxe:

 # iscsictl -A -p 10.10.10.10 -t iqn.2012-06.com.example:target0 -u user -s secretsecret

    29.12.2.2. Conectando-se a um Alvo com um Arquivo de Configurac,ao

   Para se conectar usando um arquivo de configurac,ao, crie o
   /etc/iscsi.conf com o seguinte conteudo:

 t0 {
         TargetAddress   = 10.10.10.10
         TargetName      = iqn.2012-06.com.example:target0
         AuthMethod      = CHAP
         chapIName       = user
         chapSecret      = secretsecret
 }

   O t0 especifica um nickname para a sec,ao do arquivo de configurac,ao. Ele
   sera usado pelo iniciador para especificar qual configurac,ao usar. As
   outras linhas especificam os parametros a serem usados durante a conexao.
   O TargetAddress e TargetName sao obrigatorios, enquanto as outras opc,oes
   sao opcionais. Neste exemplo, o nome de usuario e a senha do CHAP sao
   mostrados.

   Para se conectar ao alvo definido, especifique o apelido:

 # iscsictl -An t0

   Como alternativa, para conectar-se a todos os alvos definidos no arquivo
   de configurac,ao, use:

 # iscsictl -Aa

   Para fazer com que o inicializador se conecte automaticamente a todos os
   alvos no arquivo /etc/iscsi.conf, adicione o seguinte ao arquivo
   /etc/rc.conf:

 iscsictl_enable="YES"
 iscsictl_flags="-Aa"

Capitulo 30. Firewalls

   Contribuido por Joseph J. Barbish.
   Convertido para SGML e atualizado por Brad Davis.
   Indice

   30.1. Sinopse

   30.2. Conceitos de Firewall

   30.3. PF

   30.4. IPFW

   30.5. IPFILTER (IPF)

   30.6. Blacklistd

30.1. Sinopse

   Os firewalls permitem filtrar o trafego de entrada e saida que flui
   atraves de um sistema. Um firewall pode usar um ou mais conjuntos de
   "regras" para inspecionar os pacotes de rede `a medida que eles entram ou
   saem das conexoes de rede e assim permitir ou bloquear o trafego. As
   regras de um firewall podem inspecionar uma ou mais caracteristicas dos
   pacotes, como o tipo de protocolo, o enderec,o do host de origem ou de
   destino e a porta de origem ou de destino.

   Os firewalls podem melhorar a seguranc,a de um host ou de uma rede. Eles
   podem ser usados para fazer um ou mais dos seguintes procedimentos:

     * Proteger e isolar as aplicac,oes, servic,os e maquinas de uma rede
       interna contra trafego indesejado da Internet publica.

     * Limitar ou desabilitar o acesso de hosts da rede interna para
       servic,os da Internet publica.

     * Suportar a traduc,ao de enderec,os de rede (NAT), que possibilita que
       uma rede interna use enderec,os IP privados e compartilhe uma unica
       conexao com a Internet publica usando um unico enderec,o IP ou um pool
       compartilhado de enderec,os publicos atribuidos automaticamente.

   O FreeBSD possui tres firewalls embutidos no sistema base: PF, IPFW e
   IPFILTER, tambem conhecido como IPF. O FreeBSD tambem fornece dois traffic
   shapers para controlar o uso da largura de banda: altq(4) e dummynet(4). O
   ALTQ tem sido tradicionalmente vinculado ao PF e o dummynet ao IPFW. Cada
   firewall usa regras para controlar o acesso de pacotes provenientes e com
   destino a um sistema FreeBSD, embora eles fac,am isso de maneiras
   diferentes e cada um com uma sintaxe de regra diferente.

   O FreeBSD fornece varios firewalls para atender aos diferentes requisitos
   e preferencias para uma ampla variedade de usuarios. Cada usuario deve
   avaliar qual firewall atende melhor `as suas necessidades.

   Depois de ler este capitulo, voce sabera:

     * Como definir regras de filtragem de pacotes.

     * As diferenc,as entre os firewalls embutidos no FreeBSD.

     * Como usar e configurar o firewall PF.

     * Como usar e configurar o firewall IPFW.

     * Como usar e configurar o firewall IPFILTER.

   Antes de ler este capitulo, voce deve:

     * Entender os conceitos basicos do FreeBSD e de Internet.

  Nota:

   Como todos os firewalls sao baseados em inspecionar os valores dos campos
   de controle de pacotes selecionados, o criador do conjunto de regras do
   firewall deve ter uma compreensao de como funciona o TCP/IP, quais sao os
   diferentes valores nos campos de controle de pacotes e como esses valores
   sao usados em uma conversa de sessao normal. Para uma boa introduc,ao,
   consulte Daryl's TCP/IP Primer.

30.2. Conceitos de Firewall

   Um conjunto de regras contem um grupo de regras que liberam ou bloqueiam
   pacotes com base nos valores contidos no pacote. A troca bidirecional de
   pacotes entre hosts compreende uma conversa de sessao. O conjunto de
   regras do firewall processa os pacotes que chegam da Internet publica, bem
   como os pacotes produzidos pelo sistema como uma resposta aos que
   chegaram. Cada servic,o TCP/IP e pre-definido pelo seu protocolo e porta
   de escuta. Os pacotes destinados a um servic,o especifico sao originados
   do enderec,o de origem usando uma porta nao privilegiada e tem como
   destino a porta do servic,o especifica no enderec,o de destino. Todos os
   parametros acima podem ser usados como criterios de selec,ao para criar
   regras que irao liberar ou bloquear servic,os.

   Para procurar numeros de porta desconhecidos, consulte o arquivo
   /etc/services. Alternativamente, visite
   http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers e fac,a uma
   pesquisa de numero de porta para encontrar a finalidade de um determinado
   numero de porta.

   Confira este link para ver os numeros de porta usados por Trojans.

   O FTP possui dois modos: modo ativo e modo passivo. A diferenc,a esta em
   como o canal de dados e adquirido. O modo passivo e mais seguro, pois o
   canal de dados e adquirido pelo solicitante de sessao ftp. Para obter uma
   boa explicac,ao sobre o FTP e seus diferentes modos, consulte
   http://www.slacksite.com/other/ftp.html.

   Um conjunto de regras de firewall pode ser "exclusivo" ou "inclusivo". Um
   firewall exclusivo libera todo o trafego, exceto o trafego correspondente
   ao conjunto de regras. Um firewall inclusivo faz o inverso, liberando o
   trafego que corresponde as regras e bloqueia todo o resto.

   Um firewall inclusivo oferece melhor controle do trafego de saida,
   tornando-o uma melhor escolha para sistemas que oferecem servic,os `a
   Internet publica. Tambem controla o tipo de trafego originado da Internet
   publica que pode obter acesso a uma rede privada. Todo o trafego que nao
   corresponde `as regras e bloqueado e registrado. Os firewalls inclusivos
   sao geralmente mais seguros do que os firewalls exclusivos, pois reduzem
   significativamente o risco de permitir trafego indesejado.

  Nota:

   Salvo indicac,ao contraria, todos os conjuntos de regras de configurac,ao
   e exemplo neste capitulo criam conjuntos de regras de firewall inclusivos.

   A seguranc,a pode ser reforc,ada usando um "firewall stateful". Esse tipo
   de firewall registra e acompanha as conexoes abertas e libera apenas o
   trafego que corresponde a uma conexao existente ou libera e abre uma nova
   conexao.

   A filtragem stateful trata o trafego como uma troca bidirecional de
   pacotes compondo uma sessao. Quando um estado e especificado em uma regra
   de correspondencia, o firewall gera dinamicamente regras internas para
   cada pacote antecipado sendo trocado durante a sessao. Ele possui recursos
   de correspondencia suficientes para determinar se um pacote e valido para
   uma sessao. Quaisquer pacotes que nao se encaixem corretamente no modelo
   de sessao serao automaticamente rejeitados.

   Quando a sessao e concluida, ela e removida da tabela de estados
   dinamicos.

   A filtragem stateful permite dar foco no bloqueio/liberac,ao de novas
   sessoes. Se a nova sessao for passada, todos os seus pacotes subsequentes
   serao permitidos automaticamente e todos os pacotes de um impostor serao
   automaticamente rejeitados. Se uma nova sessao for bloqueada, nenhum dos
   seus pacotes subsequentes serao permitidos. A filtragem stateful fornece
   habilidades de correspondencia avanc,adas capazes de se defender contra o
   flood de diferentes metodos de ataque empregados pelos invasores.

   NAT significa Traduc,ao de Enderec,os de Rede. A func,ao NAT permite que a
   LAN privada por tras do firewall compartilhe um unico enderec,o IP
   atribuido pelo ISP, mesmo que esse enderec,o seja atribuido dinamicamente.
   O NAT permite que cada computador na LAN tenha acesso `a Internet, sem ter
   que pagar ao ISP por varias contas de Internet ou enderec,os IP.

   O NAT traduzira automaticamente o enderec,o IP da LAN privada de cada
   sistema na LAN para o unico enderec,o IP publico, `a medida que os pacotes
   saem do firewall vinculado `a Internet publica. Tambem executa a conversao
   inversa para devolver os pacotes.

   De acordo com a RFC 1918, os seguintes intervalos de enderec,os IP sao
   reservados para redes privadas que nunca serao roteadas diretamente para a
   Internet publica e, portanto, estao disponiveis para uso com o NAT:

     * 10.0.0.0/8.

     * 172.16.0.0/12.

     * 192.168.0.0/16.

  Atenc,ao:

   Ao trabalhar com regras de firewall, seja muito cuidadoso. Algumas
   configurac,oes podem bloquear o administrador do servidor. Para estar
   seguro, considere executar a configurac,ao inicial do firewall a partir do
   console local, em vez de faze-lo remotamente por ssh.

30.3. PF

   Revisado e atualizado por John Ferrell.

   Desde o FreeBSD 5.3, uma versao portada do firewall PF do OpenBSD foi
   incluida como uma parte integrada do sistema base. O PF e um firewall
   completo, cheio de recursos que possui suporte opcional para ALTQ
   (Alternate Queuing), que fornece Qualidade de Servic,o (QoS).

   O Projeto OpenBSD mantem a referencia definitiva para PF no FAQ do PF.
   Peter Hansteen mantem um tutorial completo do PF em
   http://home.nuug.no/~peter/pf/.

  Atenc,ao:

   Ao ler o FAQ do PF, tenha em mente que a versao do PF do FreeBSD divergiu
   substancialmente da versao inicial do OpenBSD ao longo dos anos. Nem todos
   os recursos funcionam da mesma maneira no FreeBSD como no OpenBSD e
   vice-versa.

   A lista de emails do packet filter do FreeBSD e um bom lugar para
   perguntar questoes relacionadas a configurac,ao e execuc,ao do firewall
   PF. Verifique os arquivos da lista de email antes de perguntar alguma
   questao, pois ela ja pode ter sido respondida.

   Esta sec,ao do Handbook foca no PF no que se refere ao FreeBSD. Ele
   demonstra como ativar o PF e ALTQ. Em seguida, ele fornece varios exemplos
   para criar conjuntos de regras em um sistema FreeBSD.

  30.3.1. Ativando o PF

   Para usar o PF, seu modulo do kernel deve ser carregado primeiro. Esta
   sec,ao descreve as entradas que podem ser adicionadas ao /etc/rc.conf para
   habilitar o PF.

   Comece adicionando a seguinte linha pf_enable=yes ao arquivo /etc/rc.conf:

 # sysrc pf_enable=yes

   Opc,oes adicionais, descritas em pfctl(8), podem ser passadas para o PF
   quando ele e iniciado. Adicione esta entrada ao arquivo /etc/rc.conf e
   especifique quaisquer flags necessarias entre duas aspas (""):

 pf_flags=""                     # additional flags for pfctl startup

   O PF nao sera iniciado se nao puder localizar o arquivo de configurac,ao
   do conjunto de regras. Por padrao, o FreeBSD nao vem com um conjunto de
   regras e nao ha um /etc/pf.conf. Exemplos de regras podem ser encontrados
   em /usr/share/examples/pf/. Se um conjunto de regras personalizado foi
   salvo em algum outro lugar, adicione uma linha ao arquivo /etc/rc.conf que
   especifica o caminho completo para o arquivo:

 pf_rules="/path/to/pf.conf"

   O suporte de log para o PF e fornecido pelo pflog(4). Para ativar o
   suporte aos logs, adicione esta linha ao /etc/rc.conf:

 # sysrc pflog_enable=yes

   As seguintes linhas tambem podem ser adicionadas para alterar a
   localizac,ao padrao do arquivo de log ou para especificar quaisquer flags
   adicionais na inicializac,ao do pflog(4):

 pflog_logfile="/var/log/pflog"  # where pflogd should store the logfile
 pflog_flags=""                  # additional flags for pflogd startup

   Finalmente, se houver uma LAN atras do firewall e os pacotes precisarem
   ser encaminhados para os computadores na LAN, ou se NAT for necessario,
   adicione a seguinte opc,ao:

 gateway_enable="YES"            # Enable as LAN gateway

   Depois de salvar as edic,oes necessarias, o PF pode ser iniciado com o
   suporte de log, digitando:

 # service pf start
 # service pflog start

   Por padrao, o PF le suas regras de configurac,ao do arquivo /etc/pf.conf e
   modifica, descarta ou libera pacotes de acordo com as regras ou
   definic,oes especificadas neste arquivo. A instalac,ao do FreeBSD inclui
   varios arquivos de exemplo localizados em /usr/share/examples/pf/.
   Consulte o FAQ do PF para obter uma cobertura completa dos conjuntos de
   regras do PF.

   Para controlar o PF, use o pfctl. Tabela 30.1, "Opc,oes Uteis do pfctl"
   resume algumas opc,oes uteis para este comando. Consulte pfctl(8) para
   obter uma descric,ao de todas as opc,oes disponiveis:

   Tabela 30.1. Opc,oes Uteis do pfctl

             Comando                              Proposito                   
   pfctl -e                     Ativa o PF.                                   
   pfctl -d                     Desabilita o PF.                              
   pfctl -F all -f /etc/pf.conf Limpa todas as regras de NAT, filtro, estado  
                                e tabela e recarrega o /etc/pf.conf.          
   pfctl -s [ rules | nat |     Informa as regras de filtragem, de NAT ou a   
   states ]                     tabela de estados.                            
                                Verifica se tem erros no arquivo              
   pfctl -vnf /etc/pf.conf      /etc/pf.conf, mas nao carrega o conjunto de   
                                regras.                                       

  Dica:

   security/sudo e util para executar comandos como pfctl que exigem
   privilegios elevados. Ele pode ser instalado a partir da Colec,ao de
   Ports.

   Para ficar de olho no trafego que passa pelo firewall PF, considere
   instalar o pacote ou port sysutils/pftop. Uma vez instalado, o pftop pode
   ser executado para exibir um snapshot do estado atual do trafego em um
   formato semelhante ao top(1).

  30.3.2. Conjuntos de Regras do PF

   Contribuido por Peter N. M. Hansteen.

   Esta sec,ao demonstra como criar um conjunto de regras personalizado. Ele
   comec,a com o mais simples dos conjuntos de regras e baseia-se em seus
   conceitos usando varios exemplos para demonstrar o uso real dos diversos
   recursos do PF.

   O conjunto de regras mais simples possivel e para uma unica maquina que
   nao executa nenhum servic,o e que precisa de acesso a uma rede, que pode
   ser a Internet. Para criar este conjunto de regras minimo, edite o arquivo
   /etc/pf.conf para que fique assim:

 block in all
 pass out all keep state

   A primeira regra nega todo o trafego de entrada por padrao. A segunda
   regra permite que as conexoes originadas por este sistema sejam liberadas,
   mantendo as informac,oes de estado nessas conexoes. Essas informac,oes de
   estado permitem que o trafego de retorno para essas conexoes seja liberado
   e so deve ser usado em maquinas confiaveis. O conjunto de regras pode ser
   carregado com:

 # pfctl -e ; pfctl -f /etc/pf.conf

   Alem de manter estados, o PF fornece listas e macros que podem ser
   definidas para uso ao criar regras. As macros podem incluir listas e
   precisam ser definidas antes de serem usadas. Como exemplo, insira essas
   linhas no topo do conjunto de regras:

 tcp_services = "{ ssh, smtp, domain, www, pop3, auth, pop3s }"
 udp_services = "{ domain }"

   O PF entende os nomes das portas, assim como os numeros das portas, desde
   que os nomes estejam listados em /etc/services. Este exemplo cria duas
   macros. A primeira e uma lista de sete nomes de portas TCP e a segunda e
   um nome de porta UDP. Uma vez definidas, as macros podem ser usadas em
   regras. Neste exemplo, todo o trafego e bloqueado, exceto pelas conexoes
   originadas por este sistema para os sete servic,os TCP especificados e
   para o servic,o UDP especificado:

 tcp_services = "{ ssh, smtp, domain, www, pop3, auth, pop3s }"
 udp_services = "{ domain }"
 block all
 pass out proto tcp to any port $tcp_services keep state
 pass proto udp to any port $udp_services keep state

   Embora o UDP seja considerado um protocolo sem estado, o PF e capaz de
   rastrear algumas informac,oes de estado. Por exemplo, quando uma
   solicitac,ao UDP e liberada perguntando a um servidor de nomes sobre um
   nome de dominio, o PF ira procurar pela resposta para libera-la.

   Sempre que uma edic,ao e feita em um conjunto de regras, as novas regras
   devem ser carregadas para que possam ser usadas:

 # pfctl -f /etc/pf.conf

   Se nao houver erros de sintaxe, o pfctl nao exibira nenhuma mensagem
   durante o carregamento da regra. As regras tambem podem ser testadas antes
   de tentar carrega-las:

 # pfctl -nf /etc/pf.conf

   A inclusao de -n faz com que as regras sejam interpretadas apenas, mas nao
   carregadas. Isso fornece uma oportunidade para corrigir quaisquer erros.
   Em todos os momentos, o ultimo conjunto de regras valido carregado sera
   imposto ate que o PF seja desativado ou um novo conjunto de regras seja
   carregado.

  Dica:

   Adicionando -v ao comando pfctl no carregamento ou checagem de conjuntos
   de regras, sera exibido as regras exatamente da maneira como elas serao
   carregadas. Isso e extremamente util ao depurar regras.

    30.3.2.1. Um Gateway Simples com NAT

   Esta sec,ao demonstra como configurar um sistema FreeBSD executando PF
   para atuar como um gateway para pelo menos uma outra maquina. O gateway
   precisa de pelo menos duas interfaces de rede, cada uma conectada a uma
   rede separada. Neste exemplo, xl1 esta conectada `a Internet e a xl0 esta
   conectada `a rede interna.

   Primeiro, ative o gateway para permitir que a maquina encaminhe o trafego
   de rede que recebe em uma interface para outra interface. Esta
   configurac,ao do sysctl encaminhara pacotes IPv4:

 # sysctl net.inet.ip.forwarding=1

   Para encaminhar trafego IPv6, use:

 # sysctl net.inet6.ip6.forwarding=1

   Para ativar essas configurac,oes na inicializac,ao do sistema, use o
   sysrc(8) para adiciona-las ao /etc/rc.conf:

 # sysrc gateway_enable=yes
 # sysrc ipv6_gateway_enable=yes

   Verifique com o ifconfig se ambas as interfaces estao ativadas e em
   execuc,ao.

   Em seguida, crie as regras PF para permitir que o gateway transmita
   trafego. Embora a regra a seguir permita que o trafego com informac,oes de
   estado passe da Internet para os hosts na rede, a palavra-chave to nao
   garante a passagem da origem ate o destino:

 pass in on xl1 from xl1:network to xl0:network port $ports keep state

   Essa regra so permite que o trafego passe para o gateway na interface
   interna. Para deixar os pacotes irem mais longe, e necessaria uma regra de
   correspondencia:

 pass out on xl0 from xl1:network to xl0:network port $ports keep state

   Embora essas duas regras funcionem, regras especificadas dessa forma
   raramente sao necessarias. Para um administrador de rede ocupado, um
   conjunto de regras legivel e um conjunto de regras mais seguro. O restante
   desta sec,ao demonstra como manter as regras o mais simples possivel para
   facilitar a leitura. Por exemplo, essas duas regras podem ser substituidas
   por uma regra:

 pass from xl1:network to any port $ports keep state

   A notac,ao interface:network pode ser substituida por uma macro para
   tornar o conjunto de regras ainda mais legivel. Por exemplo, uma macro
   $localnet pode ser definida como a rede diretamente conectada `a interface
   interna ($xl1:network). Alternativamente, a definic,ao de $localnet
   poderia ser alterada para uma notac,ao IP address/netmask para denotar uma
   rede, como 192.168.100.1/24 para uma sub-rede de enderec,os privados.

   Se necessario, $localnet pode ser definido como uma lista de redes.
   Quaisquer que sejam as necessidades especificas, uma definic,ao sensata de
   $localnet poderia ser usada em uma regra tipica de liberac,ao da seguinte
   maneira:

 pass from $localnet to any port $ports keep state

   O conjunto de regras de exemplo a seguir libera todo o trafego originado
   por maquinas na rede interna. Primeiro define duas macros para representar
   as interfaces externas e internas 3COM do gateway.

  Nota:

   Para usuarios dial-up, a interface externa sera tun0. Para uma conexao
   ADSL, especificamente aquelas que usam PPP over Ethernet (PPPoE), a
   interface externa correta e tun0, nao a interface fisica Ethernet.

 ext_if = "xl0"  # macro for external interface - use tun0 for PPPoE
 int_if = "xl1"  # macro for internal interface
 localnet = $int_if:network
 # ext_if IP address could be dynamic, hence ($ext_if)
 nat on $ext_if from $localnet to any -> ($ext_if)
 block all
 pass from { lo0, $localnet } to any keep state

   Este conjunto de regras introduz a regra nat que e usada para tratar a
   traduc,ao de enderec,os de rede dos enderec,os nao roteaveis dentro da
   rede interna para o enderec,o IP atribuido `a interface externa. Os
   parenteses em torno da ultima parte da regra nat ($ext_if) sao incluidos
   quando o enderec,o IP da interface externa e atribuido dinamicamente. Ele
   garante que o trafego de rede seja executado sem interrupc,oes graves,
   mesmo se o enderec,o IP externo for alterado.

   Observe que esse conjunto de regras provavelmente permite que mais trafego
   seja transmitido para fora da rede do que o necessario. Uma configurac,ao
   razoavel poderia criar essa macro:

 client_out = "{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \
     https, cvspserver, 2628, 5999, 8000, 8080 }"

   para usar na regra principal de liberac,ao:

 pass inet proto tcp from $localnet to any port $client_out \
     flags S/SA keep state

   Algumas outras regras de aprovac,ao podem ser necessarias. Esta permite
   ativar o SSH na interface externa:

 pass in inet proto tcp to $ext_if port ssh

   Esta definic,ao de macro e regra permite DNS e NTP para clientes internos:

 udp_services = "{ domain, ntp }"
 pass quick inet proto { tcp, udp } to any port $udp_services keep state

   Observe a palavra-chave quick nesta regra. Como o conjunto de regras
   consiste em varias regras, e importante entender as relac,oes entre as
   regras em um conjunto de regras. As regras sao avaliadas de cima para
   baixo, na sequencia em que sao escritas. Para cada pacote ou conexao
   avaliado pelo PF, a ultima regra correspondente no conjunto de regras e
   aquela que e aplicada. No entanto, quando um pacote corresponde a uma
   regra que contem a palavra-chave quick, o processamento da regra e
   interrompido e o pacote e tratado de acordo com essa regra. Isso e muito
   util quando e necessaria uma excec,ao `as regras gerais.

    30.3.2.2. Criando um Proxy FTP

   Configurar regras funcionais de FTP pode ser problematico devido `a
   natureza do protocolo FTP. O FTP pre-data os firewalls por varias decadas
   e e inseguro em seu design. Os pontos mais comuns contra o uso do FTP
   incluem:

     * As senhas sao transferidas em texto puro.

     * O protocolo exige o uso de pelo menos duas conexoes TCP (controle e
       dados) em portas separadas.

     * Quando uma sessao e estabelecida, os dados sao transmitidos usando
       portas selecionadas aleatoriamente.

   Todos esses pontos apresentam desafios de seguranc,a, mesmo antes de
   considerar possiveis pontos fracos de seguranc,a no software cliente ou
   servidor. Ha alternativas mais seguras para a transferencia de arquivos,
   como sftp(1) ou scp(1), que apresentam autenticac,ao e transferencia de
   dados atraves de conexoes criptografadas.

   Para as situac,oes em que o FTP e necessario, o PF fornece o
   redirecionamento do trafego FTP para um pequeno programa proxy chamado
   ftp-proxy(8), que esta incluido no sistema base do FreeBSD. O papel do
   proxy e inserir dinamicamente e excluir regras no conjunto de regras,
   usando um conjunto de ancoras, para lidar corretamente com o trafego de
   FTP.

   Para habilitar o proxy FTP, adicione esta linha ao /etc/rc.conf:

 ftpproxy_enable="YES"

   Em seguida, inicie o proxy executando service ftp-proxy start.

   Para uma configurac,ao basica, tres elementos precisam ser adicionados ao
   arquivo /etc/pf.conf. Primeiro, as ancoras que o proxy usara para inserir
   as regras que ele gera para as sessoes de FTP:

 nat-anchor "ftp-proxy/*"
 rdr-anchor "ftp-proxy/*"

   Em segundo, e necessaria uma regra de liberac,ao para permitir o trafego
   de FTP para o proxy.

   Terceiro, as regras de redirecionamento e NAT precisam ser definidas antes
   das regras de filtragem. Insira esta regra rdr imediatamente apos a regra
   nat:

 rdr pass on $int_if proto tcp from any to any port ftp -> 127.0.0.1 port 8021

   Finalmente, permita que o trafego redirecionado passe:

 pass out proto tcp from $proxy to any port ftp

   onde $proxy se expande para o enderec,o ao qual o daemon proxy esta
   vinculado.

   Salve o arquivo /etc/pf.conf, carregue as novas regras e verifique a
   partir de um cliente se as conexoes FTP estao funcionando:

 # pfctl -f /etc/pf.conf

   Este exemplo cobre uma configurac,ao basica em que os clientes na rede
   local precisam entrar em contato com servidores FTP em outro lugar. Essa
   configurac,ao basica deve funcionar bem com a maioria das combinac,oes de
   clientes e servidores FTP. Como mostrado em ftp-proxy(8), o comportamento
   do proxy pode ser alterado de varias maneiras adicionando opc,oes na linha
   ftpproxy_flags=. Alguns clientes ou servidores podem ter peculiaridades
   especificas que devem ser compensadas na configurac,ao ou pode ser
   necessario integrar o proxy de maneiras especificas, como atribuir trafego
   FTP a uma fila especifica.

   Para formas de executar um servidor FTP protegido por PF e ftp-proxy(8),
   configure um ftp-proxy separado em modo reverso, usando -R, em uma porta
   separada com sua propria regra de redirecionamento de passagem.

    30.3.2.3. Gerenciando ICMP

   Muitas das ferramentas usadas para depurar ou solucionar problemas de uma
   rede TCP/IP dependem do Internet Control Message Protocol (ICMP), o qual
   foi projetado especificamente para depurac,ao.

   O protocolo ICMP envia e recebe mensagens de controle entre hosts e
   gateways, principalmente para fornecer feedback a um remetente sobre
   quaisquer condic,oes incomuns ou dificeis na rota para o host de destino.
   Os roteadores usam ICMP para negociar tamanhos de pacote e outros
   parametros de transmissao em um processo geralmente chamado de descoberta
   de path MTU.

   Do ponto de vista do firewall, algumas mensagens de controle ICMP sao
   vulneraveis a vetores de ataque conhecidos. Alem disso, deixar todo o
   trafego de diagnostico passar incondicionalmente torna a depurac,ao mais
   facil, mas tambem torna mais facil para os outros extrairem informac,oes
   sobre a rede. Por esses motivos, a regra a seguir pode nao ser a ideal:

 pass inet proto icmp from any to any

   Uma soluc,ao e permitir todo o trafego de ICMP originado na rede local e
   bloquear as chamadas provenientes de fora da rede:

 pass inet proto icmp from $localnet to any keep state
 pass inet proto icmp from any to $ext_if keep state

   Opc,oes adicionais estao disponiveis, o que demonstra algumas das
   flexibilidades do PF. Por exemplo, em vez de liberar todas as mensagens
   ICMP, pode-se especificar as mensagens usadas pelo ping(8) e
   traceroute(8). Comece definindo uma macro para esse tipo de mensagem:

 icmp_types = "echoreq"

   e uma regra que usa a macro:

 pass inet proto icmp all icmp-type $icmp_types keep state

   Se outros tipos de pacotes ICMP forem necessarios, expanda icmp_types para
   uma lista desses tipos de pacotes. Digite more
   /usr/src/sbin/pfctl/pfctl_parser.c para ver a lista de tipos de mensagem
   ICMP suportados pelo PF. Consulte
   http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml para
   uma explicac,ao de cada tipo de mensagem.

   Como o Unix traceroute usa UDP por padrao, outra regra e necessaria para
   permitir o comando traceroute do Unix:

 # allow out the default range for traceroute(8):
 pass out on $ext_if inet proto udp from any to any port 33433 >< 33626 keep state

   Como o TRACERT.EXE em sistemas Microsoft Windows usa ICMP echo request
   messages, somente a primeira regra e necessaria para permitir
   rastreamentos de rede desses sistemas. O Unix traceroute tambem pode ser
   instruido a usar outros protocolos e usara ICMP echo request messages se
   -I for usado. Verifique a pagina de manual traceroute(8) para detalhes.

      30.3.2.3.1. Descoberta de Path MTU

   Os protocolos de Internet sao projetados para serem independentes do
   dispositivo, e uma consequencia da independencia do dispositivo e que o
   tamanho ideal do pacote para uma determinada conexao nem sempre pode ser
   previsto com seguranc,a. A principal restric,ao no tamanho do pacote e a
   Maximum Transmission Unit (MTU), que define o limite superior do tamanho
   do pacote para uma interface. Digite ifconfig para exibir os MTUs para as
   interfaces de rede do sistema.

   O TCP/IP usa um processo conhecido como descoberta de path MTU para
   determinar o tamanho correto do pacote para uma conexao. Este processo
   envia pacotes de tamanhos variados com o conjunto de flag "Nao
   fragmentar", esperando um pacote de retorno ICMP de "tipo 3, codigo 4"
   quando o limite for alcanc,ado. O tipo 3 significa "destino inacessivel",
   e o codigo 4 e uma abreviac,ao para "fragmentac,ao necessaria, mas a flag
   para nao fragmentar esta definida". Para permitir que a descoberta de path
   MTU suporte conexoes com outros MTUs, adicione o tipo destination
   unreachable `a macro icmp_types:

 icmp_types = "{ echoreq, unreach }"

   Como a regra de liberac,ao ja usa essa macro, ela nao precisa ser
   modificada para suportar o novo tipo de ICMP:

 pass inet proto icmp all icmp-type $icmp_types keep state

   O PF permite filtrar todas as variac,oes dos tipos e codigos de ICMP. A
   lista de tipos e codigos possiveis esta documentada em icmp(4) and
   icmp6(4).

    30.3.2.4. Usando Tabelas

   Alguns tipos de dados sao relevantes para filtragem e redirecionamento em
   um determinado momento, mas sua definic,ao e muito longa para ser incluida
   no arquivo do conjunto de regras. O PF suporta o uso de tabelas, que sao
   listas definidas que podem ser manipuladas sem a necessidade de recarregar
   todo o conjunto de regras e que podem fornecer pesquisas rapidas. Nomes de
   tabelas sao sempre colocados dentro de < >, assim:

 table <clients> { 192.168.2.0/24, !192.168.2.5 }

   Neste exemplo, a rede 192.168.2.0/24 faz parte da tabela, exceto pelo
   enderec,o 192.168.2.5, que e excluido pelo operador !. Tambem e possivel
   carregar tabelas de arquivos onde cada entrada esta em uma linha separada.
   como neste exemplo /etc/clients:

 192.168.2.0/24
 !192.168.2.5

   Para se referir ao arquivo, defina a tabela da seguinte forma:

 table <clients> persist file "/etc/clients"

   Depois que a tabela e definida, ela pode ser referenciada por uma regra:

 pass inet proto tcp from <clients> to any port $client_out flags S/SA keep state

   O conteudo de uma tabela pode ser manipulado ao vivo, usando pfctl. Este
   exemplo adiciona outra rede a tabela:

 # pfctl -t clients -T add 192.168.1.0/16

   Observe que quaisquer alterac,oes feitas dessa maneira terao efeito
   imediato, tornando-as ideais para testes, mas nao sobreviverao a uma falha
   de energia ou reinicializac,ao. Para tornar as alterac,oes permanentes,
   modifique a definic,ao da tabela no conjunto de regras ou edite o arquivo
   a que a tabela se refere. E possivel manter a copia em disco da tabela
   usando uma tarefa cron(8) que copia o conteudo da tabela para o disco em
   intervalos de tempo, usando um comando como pfctl -t clients -T show
   >/etc/clients. Alternativamente, o /etc/clients pode ser atualizado com o
   conteudo da tabela na memoria:

 # pfctl -t clients -T replace -f /etc/clients

    30.3.2.5. Usando Tabelas de Sobrecarga para Proteger o SSH

   Aqueles que executam o SSH em uma interface externa provavelmente ja viram
   algo assim nos logs de autenticac,ao:

 Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2
 Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2
 Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye
 Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31
 Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin
 Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2

   Isso indica um ataque de forc,a bruta em que alguem ou algum programa esta
   tentando descobrir o nome de usuario e senha que os permitira entrar no
   sistema.

   Se o acesso externo ao SSH for necessario para usuarios legitimos, a
   alterac,ao da porta padrao usada pelo SSH pode oferecer alguma protec,ao.
   No entanto, o PF fornece uma soluc,ao mais elegante. As regras de
   liberac,ao podem conter limites sobre o que os hosts de conexao podem
   fazer e os violadores podem ser banidos para uma tabela de enderec,os aos
   quais e negado algum ou todo o acesso. E ate possivel descartar todas as
   conexoes existentes de maquinas que excedem os limites.

   Para configurar isso, crie esta tabela na sec,ao de tabelas do conjunto de
   regras:

 table <bruteforce> persist

   Entao, em algum lugar no inicio do conjunto de regras, adicione regras
   para bloquear o acesso bruto, permitindo acesso legitimo:

 block quick from <bruteforce>
 pass inet proto tcp from any to $localnet port $tcp_services \
     flags S/SA keep state \
     (max-src-conn 100, max-src-conn-rate 15/5, \
     overload <bruteforce> flush global)

   A parte entre parenteses define os limites e os valores devem ser
   alterados para atender aos requisitos locais. Isso pode ser lido da
   \seguinte forma:

   max-src-conn e o numero de conexoes simultaneas permitidas de um host.

   max-src-conn-rate e a taxa de novas conexoes permitidas de qualquer host
   unico (15) por numero de segundos (5).

   overload <bruteforce> significa que qualquer host que excede esses limites
   obtem seu enderec,o adicionado `a tabela bruteforce. O conjunto de regras
   bloqueia todo o trafego de enderec,os na tabela bruteforce.

   Finalmente, flush global diz que quando um host atinge o limite, todo
   (global) das conexoes desse host sera finalizado (flush).

  Nota:

   Estas regras nao irao bloquear bruteforcers lentos, como descrito em
   http://home.nuug.no/~peter/hailmary2013/.

   Este conjunto de regras de exemplo e projetado principalmente como uma
   ilustrac,ao. Por exemplo, se um numero grande de conexoes em geral e
   desejado, mas o desejo e ser mais restritivo quando se trata de ssh,
   complemente a regra acima com algo como o abaixo, no inicio do conjunto de
   regras:

 pass quick proto { tcp, udp } from any to any port ssh \
     flags S/SA keep state \
     (max-src-conn 15, max-src-conn-rate 5/3, \
     overload <bruteforce> flush global)

  Pode Nao ser Necessario Bloquear Todos os Overloaders:

   E importante notar que o mecanismo de sobrecarga e uma tecnica geral que
   nao se aplica exclusivamente ao SSH, e nem sempre e ideal bloquear
   totalmente todo o trafego dos infratores.

   Por exemplo, uma regra de sobrecarga pode ser usada para proteger um
   servic,o de email ou um servic,o Web e a tabela de sobrecarga pode ser
   usada em uma regra para atribuir infratores a uma fila com uma alocac,ao
   de largura de banda minima ou redirecionar para uma pagina Web especifica.

   Com o tempo, as tabelas serao preenchidas por regras de sobrecarga e seu
   tamanho crescera incrementalmente, ocupando mais memoria. As vezes, um
   enderec,o de IP que e bloqueado e atribuido dinamicamente, que ja foi
   atribuido a um host que tem um motivo legitimo para se comunicar com hosts
   na rede local.

   Para situac,oes como essas, o pfctl fornece a capacidade de expirar as
   entradas da tabela. Por exemplo, este comando removera entradas de tabela
   <bruteforce> que nao foram referenciadas por 86400 segundos:

 # pfctl -t bruteforce -T expire 86400

   Funcionalidade semelhante e fornecida por security/expiretable, que remove
   entradas de tabela que nao foram acessadas por um periodo de tempo
   especificado.

   Uma vez instalado, o expiretable pode ser executado para remover entradas
   de tabela <bruteforce> mais antigas que uma tempo especifico. Este exemplo
   remove todas as entradas com mais de 24 horas:

 /usr/local/sbin/expiretable -v -d -t 24h bruteforce

    30.3.2.6. Protegendo Contra SPAM

   Nao deve ser confundido com o daemon spamd que vem junto com spamassassin,
   mail/spamd pode ser configurado com o PF para fornecer uma defesa externa
   contra SPAM. Esse spamd conecta-se `a configurac,ao do PF usando um
   conjunto de redirecionamentos.

   Os spammers tendem a enviar um grande numero de mensagens, e o SPAM e
   enviado principalmente de algumas redes amigaveis de spammers e um grande
   numero de maquinas sequestradas, sendo que ambas sao reportadas a
   blacklists bem rapido.

   Quando uma conexao SMTP de um enderec,o que esta em uma blacklist e
   recebido, o spamd apresenta seu banner e imediatamente muda para um modo
   em que ele responde o tragefo SMTP um byte de cada vez. Esta tecnica, que
   pretende desperdic,ar tanto tempo quanto possivel do spammer, e chamada de
   tarpitting. A implementac,ao especifica que usa respostas de um byte SMTP
   e muitas vezes referenciada como stuttering.

   Este exemplo demonstra o procedimento basico para configurar o spamd com
   blacklists atualizadas automaticamente. Consulte as paginas de manual que
   sao instaladas com o mail/spamd para mais informac,oes.

   Procedimento 30.1. Configurando o spamd
    1. Instale o pacote ou port mail/spamd. Para usar os recursos de greylist
       do spamd, fdescfs(5) deve ser montado em /dev/fd. Adicione a seguinte
       linha ao arquivo /etc/fstab:

  fdescfs /dev/fd fdescfs rw 0 0

       Em seguida, monte o sistema de arquivos:

 # mount fdescfs

    2. Em seguida, edite o conjunto de regras do PF para incluir:

 table <spamd> persist
 table <spamd-white> persist
 rdr pass on $ext_if inet proto tcp from <spamd> to \
     { $ext_if, $localnet } port smtp -> 127.0.0.1 port 8025
 rdr pass on $ext_if inet proto tcp from !<spamd-white> to \
     { $ext_if, $localnet } port smtp -> 127.0.0.1 port 8025

       As duas tabelas <spamd> e <spamd-white> sao essenciais. O trafego SMTP
       de um enderec,o listado em <spamd> mas nao em <spamd-white> e
       redirecionado para o daemon spamd ouvindo a porta 8025.

    3. O proximo passo e configurar o spamd no arquivo
       /usr/local/etc/spamd.conf e adicionar alguns parametros no arquivo
       rc.conf.

       A instalac,ao do mail/spamd inclui um arquivo de configurac,ao de
       exemplo (/usr/local/etc/spamd.conf.sample) e uma pagina de manual para
       o spamd.conf. Refira-se a estes para opc,oes adicionais de
       configurac,ao alem daquelas mostradas neste exemplo.

       Uma das primeiras linhas no arquivo de configurac,ao que nao comec,a
       com um sinal de comentario # contem o bloco que define a lista all,
       que especifica as listas a serem usadas:

 all:\
     :traplist:whitelist:

       Esta entrada adiciona as blacklists desejadas, separadas por dois
       pontos (:). Para usar uma whitelist para subtrair enderec,os de uma
       blacklist, adicione o nome da whitelist imediatamente apos o nome
       dessa blacklist. Por exemplo: :blacklist:whitelist:.

       Isto e seguido pela definic,ao da blacklist especificada:

 traplist:\
     :black:\
     :msg="SPAM. Your address %A has sent spam within the last 24 hours":\
     :method=http:\
     :file=www.openbsd.org/spamd/traplist.gz

       onde a primeira linha e o nome da blacklist e a segunda linha
       especifica o tipo da lista. O campo msg contem a mensagem a ser
       exibida aos remetentes da blacklist durante a comunicac,ao SMTP. O
       campo method especifica como o spamd-setup busca os dados da lista; os
       metodos suportados sao http, ftp, de um arquivo em um sistema de
       arquivos montado e via exec de um programa externo. Finalmente, o
       campo file especifica o nome do arquivo que o spamd espera receber.

       A definic,ao da whitelist especificada e semelhante, mas omite o campo
       msg porque uma mensagem nao e necessaria:

 whitelist:\
     :white:\
     :method=file:\
     :file=/var/mail/whitelist.txt

  Escolha Fontes de Dados com Cuidado:

       Usar todas as blacklists do arquivo de exemplo spamd.conf ira colocar
       na blacklist grandes blocos da Internet. Os administradores precisam
       editar o arquivo para criar uma configurac,ao ideal que use fontes de
       dados aplicaveis e, quando necessario, use listas personalizadas.

       Em seguida, adicione esta entrada ao arquivo /etc/rc.conf. Flags
       adicionais sao descritas na pagina de manual especificada pelo
       comentario:

 spamd_flags="-v" # use "" and see spamd-setup(8) for flags

       Quando terminar, recarregue o conjunto de regras, inicio o spamd
       digitando service obspamd start, e complete a configurac,ao usando
       spamd-setup. Finalemente, crie uma tarefa cron(8) que chame
       spamd-setup para atualizar as tabelas razoaveis.

   Em um gateway tipico na frente de um servidor de email, os hosts logo
   comec,am a ficar presos dentro de segundos ou alguns minutos.

   PF tambem suporta greylist, que rejeita temporariamente mensagens de hosts
   desconhecidos com codigos 45n. Conexoes de hosts que estao na greylist e
   que tentam novamente dentro de um tempo razoavel de tempo sao liberados. O
   trafego de remetentes que estao configurados para se comportarem dentro
   dos limites estabelecidos pela RFC 1123 e pela RFC 2821 e imediatamente
   permitido.

   Mais informac,oes sobre tecnicas de greylist podem ser encontradas no site
   greylisting.org. A coisa mais surpreendente sobre greylist, alem de sua
   simplicidade, e que ainda funciona. Os spammers e os criadores de malware
   tem sido muito lentos para se adaptar, a fim de contornar essa tecnica.

   O procedimento basico para configurar o greylist e o seguinte:

   Procedimento 30.2. Configurando Greylist
    1. Certifique-se de que fdescfs(5) esteja montado conforme descrito na
       Etapa 1 do Procedimento anterior.

    2. Para executar spamd no modo greylist, adicione esta linha ao
       /etc/rc.conf:

 spamd_grey="YES"  # use spamd greylisting if YES

       Consulte a pagina de manual do spamd para obter descric,oes de
       parametros relacionados adicionais.

    3. Para concluir a configurac,ao da greylist:

 # service obspamd restart
 # service obspamlogd start

   Nos bastidores, a ferramenta de banco de dados spamdb e o atualizador de
   whitelist spamlogd executam func,oes essenciais para o recurso de
   greylist. O spamdb e a interface principal do administrador para gerenciar
   as greylists, blacklists e whitelists por meio do conteudo do banco de
   dados /var/db/spamdb.

    30.3.2.7. Higiene de Rede

   Esta sec,ao descreve como o block-policy, scrub, e antispoof pode ser
   usado para fazer o conjunto de regras se comportar corretamente.

   O block-policy e uma opc,ao que pode ser definida na parte de opc,oes do
   conjunto de regras, que precede as regras de redirecionamento e filtragem.
   Essa opc,ao determina qual feedback, se houver, que o PF envia para hosts
   que sao bloqueados por uma regra. A opc,ao tem dois valores possiveis:
   drop descarta pacotes bloqueados sem feedback, e return retorna um codigo
   de status como Connection refused.

   Se nao definido, a politica padrao e drop. Para alterar o block-policy,
   especifique o valor desejado:

 set block-policy return

   No PF, scrub e uma palavra-chave que permite a normalizac,ao do pacote de
   rede. Esse processo remonta pacotes fragmentados e descarta pacotes TCP
   que possuem combinac,oes de sinalizadores invalidos. Ativar scrub fornece
   uma medida de protec,ao contra certos tipos de ataques com base no
   manuseio incorreto de fragmentos de pacotes. Varias opc,oes estao
   disponiveis, mas a forma mais simples e adequada para a maioria das
   configurac,oes:

 scrub in all

   Alguns servic,os, como o NFS, exigem opc,oes especificas de manipulac,ao
   de fragmentos. Consulte https://home.nuug.no/~peter/pf/en/scrub.html para
   mais informac,oes.

   Este exemplo remonta fragmentos, limpa o bit "nao fragmentar" e define o
   tamanho maximo do segmento para 1440 bytes:

 scrub in all fragment reassemble no-df max-mss 1440

   O mecanismo antispoof protege contra a atividade de enderec,os IP falsos
   ou forjados, principalmente bloqueando pacotes que aparecem em interfaces
   e em direc,oes que logicamente nao sao possiveis.

   Essas regras eliminam trafego falsificado do resto do mundo, bem como
   qualquer pacote falsificado originado na rede local:

 antispoof for $ext_if
 antispoof for $int_if

    30.3.2.8. Manipulando Enderec,os Nao-Roteados

   Mesmo com um gateway configurado adequadamente para lidar com a traduc,ao
   de enderec,os de rede, pode ser necessario compensar as configurac,oes
   incorretas de outras pessoas. Uma configurac,ao incorreta comum e permitir
   o trafego com enderec,os nao roteaveis para a Internet. Como o trafego de
   enderec,os nao roteados pode desempenhar um papel em varias tecnicas de
   ataque de DoS, considere bloquear explicitamente o trafego de enderec,os
   nao roteaveis de entrar na rede por meio da interface externa.

   Neste exemplo, uma macro contendo enderec,os nao roteaveis e definida e
   usada em regras de bloqueio. O trafego de origem e destino para esses
   enderec,os e silenciosamente descartado na interface externa do gateway.

 martians = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \
               10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \
               0.0.0.0/8, 240.0.0.0/4 }"

 block drop in quick on $ext_if from $martians to any
 block drop out quick on $ext_if from any to $martians

  30.3.3. Ativando o ALTQ

   No FreeBSD, o ALTQ pode ser usado com PF para fornecer Qualidade de
   Servic,o (QOS). Depois que o ALTQ e ativado, as filas podem ser definidas
   no conjunto de regras que determina a prioridade de processamento dos
   pacotes de saida.

   Antes de ativar o ALTQ, consulte altq(4) para determinar se os drivers das
   placas de rede instaladas no sistema suportam isto.

   ALTQ nao esta disponivel como um modulo de kernel carregavel. Se as
   interfaces do sistema suportarem ALTQ, crie um kernel personalizado usando
   as instruc,oes em Capitulo 8, Configurando o kernel do FreeBSD. As
   seguintes opc,oes do kernel estao disponiveis. O primeira e necessaria
   para ativar o ALTQ. Pelo menos uma das outras opc,oes e necessaria para
   especificar o algoritmo do scheduler de enfileiramento:

 options         ALTQ
 options         ALTQ_CBQ        # Class Based Queuing (CBQ)
 options         ALTQ_RED        # Random Early Detection (RED)
 options         ALTQ_RIO        # RED In/Out
 options         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)
 options         ALTQ_PRIQ       # Priority Queuing (PRIQ)

   Os seguintes algoritmos de agendamento estao disponiveis:

   CBQ

           Class Based Queuing (CBQ) e usado para dividir a largura de banda
           de uma conexao em diferentes classes ou filas para priorizar o
           trafego com base nas regras de filtragem.

   RED

           Random Early Detection (RED) e usado para evitar o
           congestionamento da rede, medindo o comprimento da fila e
           comparando-a com os limites minimo e maximo da fila. Quando a fila
           esta acima do maximo, todos os novos pacotes sao descartados
           aleatoriamente.

   RIO

           No modo Random Early Detection In and Out (RIO), RED mantem varios
           comprimentos medios de fila e varios valores limite, um para cada
           nivel QOS.

   HFSC

           Hierarchical Fair Service Curve Packet Scheduler (HFSC) e descrito
           em http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html.

   PRIQ

           Priority Queuing (PRIQ) sempre passa primeiro o trafego que esta
           em uma fila mais alta.

   Maiores informac,oes sobre os algoritmos de agendamento e os conjuntos de
   regras de exemplo estao disponiveis no arquivo web do OpenBSD.

30.4. IPFW

   O IPFW e um firewall stateful para o FreeBSD, que suporta tanto o IPv4
   como o IPv6. Ele e composto de varios componentes: o processador de regras
   de filtro de firewall do kernel e seu recurso integrado de contabilidade
   de pacotes, o recurso de registro em log, NAT, o dummynet(4) traffic
   shaper, um recurso de forward, um recurso de bridge e uma habilidade
   ipstealth.

   O FreeBSD fornece um conjunto de regras de exemplo em /etc/rc.firewall que
   define varios tipos de firewall para cenarios comuns para ajudar usuarios
   iniciantes a gerar um conjunto de regras apropriado. O IPFW fornece uma
   poderosa sintaxe que os usuarios avanc,ados podem usar para criar
   conjuntos de regras personalizados que atendam aos requisitos de
   seguranc,a de um determinado ambiente.

   Esta sec,ao descreve como ativar o IPFW, fornece uma visao geral de sua
   sintaxe de regra e demonstra varios conjuntos de regras para cenarios
   comuns de configurac,ao.

  30.4.1. Ativando o IPFW

   O IPFW esta incluido na instalac,ao base do FreeBSD como um modulo
   carregavel do kernel, o que significa que um kernel customizado nao e
   necessario para ativar o IPFW.

   Para aqueles usuarios que desejam compilar estaticamente o suporte ao IPFW
   em um kernel personalizado, veja Sec,ao 30.4.6, "Opc,oes do Kerne para o
   IPFW".

   Para configurar o sistema para ativar o IPFW no momento da inicializac,ao,
   adicione firewall_enable="YES" ao /etc/rc.conf:

 # sysrc firewall_enable="YES"

   Para usar um dos tipos de firewall padrao fornecidos pelo FreeBSD,
   adicione outra linha que especifique o tipo:

 # sysrc firewall_type="open"

   Os tipos disponiveis sao:

     * open: passa todo o trafego.

     * client: protege apenas esta maquina.

     * simple: protege toda a rede.

     * closed: desativa completamente o trafego IP, exceto na interface de
       loopback.

     * workstation: protege apenas esta maquina usando regras stateful.

     * UNKNOWN: desativa o carregamento de regras de firewall.

     * filename: caminho completo do arquivo que contem o conjunto de regras
       do firewall.

   Se firewall_type estiver definido como client ou simple, modifique as
   regras padrao encontradas em /etc/rc.firewall para se adequar a
   configurac,ao do sistema.

   Observe que o tipo filename e usado para carregar um conjunto de regras
   customizado.

   Uma maneira alternativa de carregar um conjunto de regras personalizado e
   definir a variavel firewall_script para o caminho absoluto de um script
   executavel que inclui comandos IPFW. Os exemplos usados nesta sec,ao
   assumem que o firewall_script esta definido como /etc/ipfw.rules:

 # sysrc firewall_script="/etc/ipfw.rules"

   Para habilitar o registro em log por meio do syslogd(8), inclua esta
   linha:

 # sysrc firewall_logging="YES"

  Atenc,ao:

   Somente regras de firewall com opc,ao de log vao ser registradas. As
   regras padrao nao contem essa opc,ao e deve ser adicionada manualmente.
   Por isso e avisado que o conjunto de regras padrao e editado para logar.
   Em adic,ao a isso, rotacionamento de log e desejado se os logs estiverem
   em um arquivo separado.

   Nao existe uma variavel em /etc/rc.conf para definir os limites de log.
   Para limitar o numero de vezes que uma regra e registrada por tentativa de
   conexao, especifique o numero usando esta linha no /etc/sysctl.conf:

 # echo "net.inet.ip.fw.verbose_limit=5" >> /etc/sysctl.conf

   Para habilitar o registro atraves de uma interface dedicada chamada ipfw0,
   adicione esta linha ao /etc/rc.conf em vez disso:

 # sysrc firewall_logif="YES"

   Em seguida, use o tcpdump para ver o que esta sendo registrado:

 # tcpdump -t -n -i ipfw0

  Dica:

   Nao ha sobrecarga devido ao log, a menos que o tcpdump esteja anexado.

   Depois de salvar as edic,oes necessarias, inicie o firewall. Para ativar
   os limites de log agora, defina tambem o valor sysctl especificado acima:

 # service ipfw start
 # sysctl net.inet.ip.fw.verbose_limit=5

  30.4.2. Sintaxe de Regras IPFW

   Quando um pacote entra no firewall IPFW, ele e comparado com a primeira
   regra no conjunto de regras e avanc,a uma regra por vez, movendo-se de
   cima para baixo em sequencia. Quando o pacote corresponde aos parametros
   de selec,ao de uma regra, a ac,ao da regra e executada e a pesquisa do
   conjunto de regras termina para esse pacote. Isto e conhecido como
   "primeira combinac,ao vence". Se o pacote nao corresponder a nenhuma das
   regras, ele sera pego pela regra padrao obrigatoria IPFW de numero 65535,
   que bloqueia todos os pacotes e os descarta silenciosamente. No entanto,
   se o pacote corresponder a uma regra que contenha as palavras-chave count,
   skipto ou tee, a pesquisa continuara. Consulte ipfw(8) para obter detalhes
   sobre como essas palavras-chave afetam o processamento de regras.

   Ao criar uma regra IPFW, as palavras-chave devem ser escritas na seguinte
   ordem. Algumas palavras-chave sao obrigatorias, enquanto outras sao
   opcionais. As palavras mostradas em maiusculas representam uma variavel e
   as palavras mostradas em minusculas devem preceder a variavel que a segue.
   O simbolo # e usado para marcar o inicio de um comentario e pode aparecer
   no final de uma regra ou em sua propria linha. Linhas em branco sao
   ignoradas.

   CMD RULE_NUMBER set SET_NUMBER ACTION log LOG_AMOUNT PROTO from SRC
   SRC_PORT to DST DST_PORT OPTIONS

   Esta sec,ao fornece uma visao geral dessas palavras-chave e suas opc,oes.
   Nao e uma lista exaustiva de todas as opc,oes possiveis. Consulte ipfw(8)
   para obter uma descric,ao completa da sintaxe de regra que pode ser usada
   ao criar regras IPFW.

   CMD

           Toda regra deve comec,ar com ipfw add.

   RULE_NUMBER

           Cada regra e associada a um numero de 1 ate 65534. O numero e
           usado para indicar a ordem do processamento da regra. Varias
           regras podem ter o mesmo numero e, nesse caso, elas sao aplicadas
           de acordo com a ordem em que foram adicionadas.

   SET_NUMBER

           Cada regra e associada a um numero definido de 0 ate 31. Os
           conjuntos podem ser desativados ou ativados individualmente,
           possibilitando adicionar ou excluir rapidamente um conjunto de
           regras. Se um SET_NUMBER nao for especificado, a regra sera
           adicionada no conjunto 0.

   ACTION

           Uma regra pode ser associada a uma das ac,oes a seguir. A ac,ao
           especificada sera executada quando o pacote corresponder ao
           criterio de selec,ao da regra.

           allow | accept | pass | permit: essas palavras-chave sao
           equivalentes e permitem pacotes que correspondem `a regra.

           check-state: verifica o pacote em relac,ao `a tabela de estados
           dinamicos. Se uma correspondencia for encontrada, execute a ac,ao
           associada `a regra que gerou essa regra dinamica, caso contrario,
           va para a proxima regra. Uma regra check-state nao possui criterio
           de selec,ao. Se nenhuma regra check-state estiver presente no
           conjunto de regras, a tabela de regras dinamicas sera verificada
           na primeira regra keep-state ou limit.

           count: atualiza os contadores de todos os pacotes que correspondem
           `a regra. A pesquisa continua com a proxima regra.

           deny | drop: qualquer das duas palavras descarta silenciosamente
           os pacotes que correspondem a essa regra.

           Ac,oes adicionais estao disponiveis. Consulte ipfw(8) para
           detalhes.

   LOG_AMOUNT

           Quando um pacote corresponde a uma regra com a palavra-chave log,
           uma mensagem sera registrada no syslogd(8) com nome SECURITY. O
           registro somente ocorre se o numero de pacotes registrados para
           essa regra especifica nao exceder um LOG_AMOUNT especificado. Se
           nenhum LOG_AMOUNT for especificado, o limite sera retirado do
           valor de net.inet.ip.fw.verbose_limit. Um valor de zero remove o
           limite de registro. Quando o limite for atingido, o registro em
           log podera ser reativado, limpando o contador de registro ou o
           contador de pacotes para essa regra, usando ipfw resetlog.

  Nota:

           O registro e feito depois que todas as outras condic,oes de
           correspondencia de pacote foram atendidas e antes de executar a
           ac,ao final no pacote. O administrador decide quais regras
           habilitar o log.

   PROTO

           Este valor opcional pode ser usado para especificar qualquer nome
           ou numero de protocolo encontrado no arquivo /etc/protocols.

   SRC

           A palavra-chave from deve ser seguida pelo enderec,o de origem ou
           por uma palavra-chave que represente o enderec,o de origem. Um
           enderec,o pode ser representado por any, me (qualquer enderec,o
           configurado em uma interface neste sistema), me6, (qualquer
           enderec,o IPv6 configurado em uma interface neste sistema), ou
           table seguido pelo numero de uma tabela de consulta que contem uma
           lista de enderec,os. Ao especificar um enderec,o IP, ele pode ser
           seguido opcionalmente pela mascara ou pela mascara de sub-rede do
           CIDR. Por exemplo, 1.2.3.4/25 ou 1.2.3.4:255.255.255.128.

   SRC_PORT

           Uma porta de origem opcional pode ser especificada usando o numero
           da porta ou um nome de /etc/services.

   DST

           A palavra-chave to deve ser seguida pelo enderec,o de destino ou
           por uma palavra-chave que represente o enderec,o de destino. As
           mesmas palavras-chave e enderec,os descritos na sec,ao SRC podem
           ser usados para descrever o destino.

   DST_PORT

           Uma porta de destino opcional pode ser especificada usando o
           numero da porta ou um nome de /etc/services.

   OPTIONS

           Varias palavras-chave podem seguir a origem e o destino. Como o
           nome sugere, OPTIONS sao opcionais. As opc,oes comumente usadas
           incluem in ou out, que especificam a direc,ao do fluxo de pacotes,
           icmptypes seguido pelo tipo de mensagem ICMP e keep-state.

           Quando uma regra keep-state e correspondida, o firewall criara uma
           regra dinamica que corresponda ao trafego bidirecional entre os
           enderec,os e portas de origem e destino usando o mesmo protocolo.

           O recurso de regras dinamicas e vulneravel ao esgotamento de
           recursos de um ataque SYN-flood, o que abriria um grande numero de
           regras dinamicas. Para combater esse tipo de ataque com IPFW, use
           limit. Esta opc,ao limita o numero de sessoes simultaneas
           verificando as regras dinamicas abertas, contando o numero de
           vezes que esta regra e a combinac,ao de enderec,os IP ocorreram.
           Se essa contagem for maior que o valor especificado por limit, o
           pacote sera descartado.

           Dezenas de OPTIONS estao disponiveis. Consulte ipfw(8) para obter
           uma descric,ao de cada opc,ao disponivel.

  30.4.3. Exemplo de Conjunto de Regras

   Esta sec,ao demonstra como criar um exemplo de script de conjunto de
   regras de firewall stateful chamado /etc/ipfw.rules. Neste exemplo, todas
   as regras de conexao usam in ou out para esclarecer a direc,ao. Eles
   tambem usam via nome-da-interface para especificar a interface que o
   pacote esta percorrendo.

  Nota:

   Ao criar ou testar um conjunto de regras de firewall, considere esta
   configurac,ao temporaria:

 net.inet.ip.fw.default_to_accept="1"

   Isso define a politica padrao do ipfw(8) para ser mais permissiva do que o
   padrao deny ip from any to any, tornando um pouco mais dificil ficar
   bloqueado fora do sistema logo apos a reinicializac,ao.

   O script de firewall comec,a indicando que e um script Bourne shell e
   limpa quaisquer regras existentes. Em seguida, ele cria a variavel cmd
   para que ipfw add nao precise ser digitado no inicio de cada regra. Ele
   tambem define a variavel pif que representa o nome da interface que esta
   conectada `a Internet.

 #!/bin/sh
 # Flush out the list before we begin.
 ipfw -q -f flush

 # Set rules command prefix
 cmd="ipfw -q add"
 pif="dc0"     # interface name of NIC attached to Internet

   As duas primeiras regras permitem todo o trafego na interface interna e na
   interface de loopback:

 # Change xl0 to LAN NIC interface name
 $cmd 00005 allow all from any to any via xl0

 # No restrictions on Loopback Interface
 $cmd 00010 allow all from any to any via lo0

   A proxima regra permite que o pacote passe se corresponder a uma entrada
   existente na tabela de regras dinamicas:

 $cmd 00101 check-state

   O proximo conjunto de regras define quais conexoes stateful os sistemas
   internos podem criar para hosts na Internet:

 # Allow access to public DNS
 # Replace x.x.x.x with the IP address of a public DNS server
 # and repeat for each DNS server in /etc/resolv.conf
 $cmd 00110 allow tcp from any to x.x.x.x 53 out via $pif setup keep-state
 $cmd 00111 allow udp from any to x.x.x.x 53 out via $pif keep-state

 # Allow access to ISP's DHCP server for cable/DSL configurations.
 # Use the first rule and check log for IP address.
 # Then, uncomment the second rule, input the IP address, and delete the first rule
 $cmd 00120 allow log udp from any to any 67 out via $pif keep-state
 #$cmd 00120 allow udp from any to x.x.x.x 67 out via $pif keep-state

 # Allow outbound HTTP and HTTPS connections
 $cmd 00200 allow tcp from any to any 80 out via $pif setup keep-state
 $cmd 00220 allow tcp from any to any 443 out via $pif setup keep-state

 # Allow outbound email connections
 $cmd 00230 allow tcp from any to any 25 out via $pif setup keep-state
 $cmd 00231 allow tcp from any to any 110 out via $pif setup keep-state

 # Allow outbound ping
 $cmd 00250 allow icmp from any to any out via $pif keep-state

 # Allow outbound NTP
 $cmd 00260 allow udp from any to any 123 out via $pif keep-state

 # Allow outbound SSH
 $cmd 00280 allow tcp from any to any 22 out via $pif setup keep-state

 # deny and log all other outbound connections
 $cmd 00299 deny log all from any to any out via $pif

   O proximo conjunto de regras controla conexoes de hosts da Internet para a
   rede interna. Ele comec,a negando pacotes tipicamente associados a ataques
   e, em seguida, permite explicitamente tipos especificos de conexoes. Todos
   os servic,os autorizados originados da Internet usam limit para evitar
   ataques de flood.

 # Deny all inbound traffic from non-routable reserved address spaces
 $cmd 00300 deny all from 192.168.0.0/16 to any in via $pif     #RFC 1918 private IP
 $cmd 00301 deny all from 172.16.0.0/12 to any in via $pif      #RFC 1918 private IP
 $cmd 00302 deny all from 10.0.0.0/8 to any in via $pif         #RFC 1918 private IP
 $cmd 00303 deny all from 127.0.0.0/8 to any in via $pif        #loopback
 $cmd 00304 deny all from 0.0.0.0/8 to any in via $pif          #loopback
 $cmd 00305 deny all from 169.254.0.0/16 to any in via $pif     #DHCP auto-config
 $cmd 00306 deny all from 192.0.2.0/24 to any in via $pif       #reserved for docs
 $cmd 00307 deny all from 204.152.64.0/23 to any in via $pif    #Sun cluster interconnect
 $cmd 00308 deny all from 224.0.0.0/3 to any in via $pif        #Class D & E multicast

 # Deny public pings
 $cmd 00310 deny icmp from any to any in via $pif

 # Deny ident
 $cmd 00315 deny tcp from any to any 113 in via $pif

 # Deny all Netbios services.
 $cmd 00320 deny tcp from any to any 137 in via $pif
 $cmd 00321 deny tcp from any to any 138 in via $pif
 $cmd 00322 deny tcp from any to any 139 in via $pif
 $cmd 00323 deny tcp from any to any 81 in via $pif

 # Deny fragments
 $cmd 00330 deny all from any to any frag in via $pif

 # Deny ACK packets that did not match the dynamic rule table
 $cmd 00332 deny tcp from any to any established in via $pif

 # Allow traffic from ISP's DHCP server.
 # Replace x.x.x.x with the same IP address used in rule 00120.
 #$cmd 00360 allow udp from any to x.x.x.x 67 in via $pif keep-state

 # Allow HTTP connections to internal web server
 $cmd 00400 allow tcp from any to me 80 in via $pif setup limit src-addr 2

 # Allow inbound SSH connections
 $cmd 00410 allow tcp from any to me 22 in via $pif setup limit src-addr 2

 # Reject and log all other incoming connections
 $cmd 00499 deny log all from any to any in via $pif

   A ultima regra registra todos os pacotes que nao correspondem a nenhuma
   das regras do conjunto de regras:

 # Everything else is denied and logged
 $cmd 00999 deny log all from any to any

  30.4.4. NAT no Kernel

   Contribuido porChern Lee.
   Revisado e atualizado por Dries Michiels.

   O firewall IPFW do FreeBSD possui duas implementac,oes de NAT: a
   implementac,ao do sistema base natd(8) e a implementac,ao de NAT interno
   do IPFW. Ambos trabalham em conjunto com o IPFW para fornecer traduc,ao de
   enderec,o de rede. Isso pode ser usado para fornecer uma soluc,ao de
   compartilhamento de conexao com a Internet, para que varios computadores
   internos possam se conectar `a Internet usando um unico enderec,o IP
   publico.

   Para isso, a maquina FreeBSD conectada na internet deve atuar como um
   gateway. Esse sistema deve ter duas NICs, onde uma e conectada a internet
   e a outra conectada a LAN interna. Cada maquina conectada com a LAN deve
   estar associada a um enderec,o IP no espac,o de rede privado, como
   definido pela RFC 1918.

   Algumas configurac,ao adicionais sao necessarias para ativar a
   funcionalidade in-kernel NAT do IPFW. Para ativar o suporte ao in-kernel
   NAT no momento da inicializac,ao do sistema, o seguinte deve ser definido
   em /etc/rc.conf:

 gateway_enable="YES"
 firewall_enable="YES"
 firewall_nat_enable="YES"

  Nota:

   Quando firewall_nat_enable estiver definido, mas firewall_enable nao
   estiver, ele nao tera efeito e nao fara nada. Isso ocorre porque a
   implementac,ao do in-kernel NAT e compativel apenas com o IPFW.

   Quando o conjunto de regras contem regras stateful, o posicionamento da
   regra NAT e critico e a ac,ao skipto e usada. A ac,ao skipto requer um
   numero de regra para que ele saiba para qual regra saltar. O exemplo
   abaixo se baseia no conjunto de regras do firewall mostrado na sec,ao
   anterior. Ele adiciona algumas entradas adicionais e modifica algumas
   regras existentes para configurar o firewall com in-kernel NAT. Ele
   comec,a adicionando algumas variaveis adicionais que representam o numero
   da regra para pular para, a opc,ao keep-state e uma lista de portas TCP
   que serao usadas para reduzir o numero de regras.

 #!/bin/sh
 ipfw -q -f flush
 cmd="ipfw -q add"
 skip="skipto 1000"
 pif=dc0
 ks="keep-state"
 good_tcpo="22,25,37,53,80,443,110"

   Com o in-kernel NAT e necessario desativar o descarregamento da
   segmentac,ao TCP (TSO) devido `a arquitetura do libalias(3), uma
   biblioteca implementada como um modulo do kernel para fornecer o in-kernel
   NAT do IPFW. O TSO pode ser desativado em uma interface de rede usando
   ifconfig(8) ou em todo o sistema usando sysctl(8). Para desativar o TSO em
   todo o sistema, deve-se definir o seguinte em /etc/sysctl.conf:

 net.inet.tcp.tso="0"

   Uma instancia NAT tambem sera configurada. E possivel ter varias
   instancias de NAT, cada uma com sua propria configurac,ao. Para este
   exemplo, apenas uma instancia NAT e necessaria; Instancia NAT numero 1. A
   configurac,ao pode receber algumas opc,oes, como: if, que indica a
   interface publica, same_ports, que cuida para que as portas mapeadas e o
   numeros das portas locais sejam mapeados da mesma maneira, unreg_only
   resultara em apenas espac,os de enderec,o nao registrados (privados) a
   serem processados pela instancia NAT e reset, que ajudara a manter uma
   instancia NAT em funcionamento, mesmo quando o enderec,o de IP publico da
   maquina IPFW for alterado. Para todas as opc,oes possiveis que podem ser
   passadas para uma unica configurac,ao de instancia NAT, consulte ipfw(8).
   Ao configurar um firewall NAT stateful, e necessario permitir que pacotes
   traduzidos sejam reinjetados no firewall para processamento subsequente.
   Isso pode ser obtido desativando o comportamento one_pass no inicio do
   script do firewall.

 ipfw disable one_pass
 ipfw -q nat 1 config if $pif same_ports unreg_only reset

   A regra NAT de entrada e inserida apos as duas regras que permitem todo o
   trafego nas interfaces interna e de loopback e apos a regra de remontagem,
   mas antes da regra check-state . E importante que o numero da regra
   selecionada para esta regra NAT, neste exemplo 100, seja maior que as tres
   primeiras regras e menor que a regra check-state. Alem disso, devido ao
   comportamento do in-kernel NAT, e recomendavel colocar uma regra de
   remontagem pouco antes da primeira regra NAT e depois das regras que
   permitem trafego nas interfaces. Normalmente, a fragmentac,ao IP nao deve
   ocorrer, mas ao lidar com o trafego de tunelamento com IPSEC/ESP/GRE, isso
   pode ocorrer e a recomposic,ao de fragmentos e necessaria antes de
   entregar o pacote completo para o mecanismo de in-kernel NAT.

  Nota:

   A regra de remontagem nao era necessaria com o natd(8) do sistema base
   porque o recurso interno de divert no IPFW ja cuida disso, remontando os
   pacotes antes da entrega no socket, tambem informado em ipfw(8).

   A instancia NAT e o numero da regra usados neste exemplo nao coincidem com
   a instancia NAT e o numero da regra padrao criados por rc.firewall.
   rc.firewall e um script que configura as regras de firewall padrao
   presentes no FreeBSD.

 $cmd 005 allow all from any to any via xl0  # exclude LAN traffic
 $cmd 010 allow all from any to any via lo0  # exclude loopback traffic
 $cmd 099 reass all from any to any in       # reassamble inbound packets
 $cmd 100 nat 1 ip from any to any in via $pif # NAT any inbound packets
 # Allow the packet through if it has an existing entry in the dynamic rules table
 $cmd 101 check-state

   As regras de saida sao modificadas para substituir a ac,ao allow com a
   variavel $skip, indicando que o processamento da regra continuara na regra
   1000. As sete regras tcp foram substituidas pela regra 125 porque a
   variavel $good_tcpo contem as sete portas de saida permitidas.

  Nota:

   Lembre-se de que o desempenho do IPFW e amplamente determinado pelo numero
   de regras presentes no conjunto de regras.

 # Authorized outbound packets
 $cmd 120 $skip udp from any to x.x.x.x 53 out via $pif $ks
 $cmd 121 $skip udp from any to x.x.x.x 67 out via $pif $ks
 $cmd 125 $skip tcp from any to any $good_tcpo out via $pif setup $ks
 $cmd 130 $skip icmp from any to any out via $pif $ks

   As regras de entrada permanecem as mesmas, exceto a ultima regra que
   remove via $pif com intenc,ao de casar com ambas regras de entrada e
   saida. A regra de NAT deve seguir essa ultima regra de saida, deve ter um
   numero maior que a ultima regra, e o numero da regra deve referenciar a
   ac,ao skipto. Nesse conjunto de regras, o numero de regra 1000 lida com a
   passagem de todos os pacotes para nossa instancia configurada para
   processamento NAT. A proxima regra permite que qualquer pacote submetido
   ao processamento NAT seja liberado.

 $cmd 999 deny log all from any to any
 $cmd 1000 nat 1 ip from any to any out via $pif # skipto location for outbound stateful rules
 $cmd 1001 allow ip from any to any

   Neste exemplo, as regras 100, 101, 125, 1000 e 1001 controlam a traduc,ao
   de enderec,os dos pacotes de saida e de entrada para que as entradas na
   tabela de estado dinamico sempre registrem o enderec,o de IP privado da
   LAN .

   Considere um navegador Web interno que inicialize uma nova sessao HTTP
   pela porta 80. Quando o primeiro pacote de saida entra no firewall, ele
   nao corresponde `a regra 100 porque ele esta saindo e nao entrando. Ele
   pula a regra 101 porque este e o primeiro pacote e ainda nao foi inserido
   na tabela de estados dinamicos. O pacote finalmente corresponde `a regra
   125 pois e uma conexao de saida em uma porta permitida e tem um enderec,o
   IP de origem da LAN interna. Ao combinar essa regra, duas ac,oes ocorrem.
   Primeiro, a ac,ao keep-state adiciona uma entrada `a tabela de estados
   dinamicos e a ac,ao especificada, skipto rule 1000, e executada. Em
   seguida, o pacote passa pelo NAT e e enviado para a Internet. Este pacote
   faz o seu caminho para o servidor web de destino, onde um pacote de
   resposta e gerado e enviado de volta. Este novo pacote entra no topo do
   conjunto de regras. Ele corresponde `a regra 100 e tem seu enderec,o de
   destino IP mapeado de volta para o enderec,o interno original. Em seguida,
   ele e processado pela regra check-state, e encontrado na tabela como uma
   sessao existente e e liberado para a LAN.

   No lado da entrada, o conjunto de regras deve negar pacotes invalidos e
   permitir apenas servic,os autorizados. Um pacote que corresponde a uma
   regra de entrada e postado na tabela de estados dinamicos e o pacote e
   liberado para a LAN. O pacote gerado como resposta e reconhecido pela
   regra check-state como pertencente a uma sessao existente. Em seguida, ele
   e enviado para a regra 1000 para passar pelo NAT antes de ser liberado
   para a interface de saida.

  Nota:

   A transic,ao do natd(8) do sistema base para o in-kernel NAT pode parecer
   facil no inicio, mas ha algumas particularidades. Ao usar o kernel
   GENERIC, o IPFW carregara o modulo libalias.ko do kernel, quando o
   firewall_nat_enable estiver ativado no rc.conf. O modulo do kernel
   libalias.ko fornece apenas a funcionalidade basica de NAT, enquanto a
   implementac,ao do natd(8) do sistema base possui todas as funcionalidades
   de NAT disponivel na userland sem nenhuma configurac,ao extra. Toda
   funcionalidade refere-se aos seguintes modulos do kernel que podem ser
   carregados adicionalmente quando necessario, alem do modulo do kernel
   padrao libalias.ko: alias_cuseeme.ko, alias_ftp.ko, alias_bbt.ko,
   skinny.ko, irc.ko, alias_pptp.ko and alias_smedia.ko usando a diretiva
   kld_list em rc.conf. Se um kernel personalizado for usado, a
   funcionalidade completa do sistema base podera ser compilada no kernel,
   usando a opc,ao options LIBALIAS.

    30.4.4.1. Redirecionamento de Portas

   A desvantagem com NAT em geral e que os clientes da LAN nao estao
   acessiveis na Internet. Os clientes na LAN podem fazer conexoes de saida
   para o mundo, mas nao podem receber conexoes diretas. Isso e um problema
   ao tentar executar servic,os de Internet em uma das maquinas clientes da
   LAN. Uma forma simples de contornar isso e redirecionar as portas
   selecionadas da Internet na maquina NAT para um cliente da LAN.

   Por exemplo, um servidor IRC e executado no cliente A e um servidor Web e
   executado no cliente B. Para que isso funcione corretamente, as conexoes
   recebidas nas portas 6667 (IRC) e 80 (HTTP) devem ser redirecionadas para
   as respectivas maquinas.

   Com o in-kernel NAT, toda a configurac,ao e feita na configurac,ao da
   instancia NAT. Para obter uma lista completa de opc,oes que uma instancia
   in-kernel NAT pode usar, consulte ipfw(8). A sintaxe IPFW segue a sintaxe
   do natd. A sintaxe para redirect_port e a seguinte:

 redirect_port proto targetIP:targetPORT[-targetPORT]
   [aliasIP:]aliasPORT[-aliasPORT]
   [remoteIP[:remotePORT[-remotePORT]]]

   Para configurar o exemplo de instalac,ao acima, os argumentos devem ser:

 redirect_port tcp 192.168.0.2:6667 6667
 redirect_port tcp 192.168.0.3:80 80

   Depois de adicionar esses argumentos `a configurac,ao da instancia 1 de
   NAT no conjunto de regras acima, as portas TCP serao encaminhadas para as
   maquinas clientes da LAN que rodam os servic,os IRC e HTTP.

 ipfw -q nat 1 config if $pif same_ports unreg_only reset \
   redirect_port tcp 192.168.0.2:6667 6667 \
   redirect_port tcp 192.168.0.3:80 80

   Intervalos de portas podem ser indicados com redirect_port. Por exemplo,
   tcp 192.168.0.2:2000-3000 2000-3000 redirecionaria todas as conexoes
   recebidas entre as portas 2000 e 3000 para as portas 2000 a 3000 no
   cliente A.

    30.4.4.2. Redirecionamento de Enderec,os

   Redirecionamento de enderec,os e util se mais de um enderec,o IP estiver
   disponivel. Cada cliente da LAN pode receber seu proprio enderec,o IP
   externo pelo ipfw(8), que reescrevera os pacotes de saida dos clientes da
   LAN com o enderec,o IP externo apropriado e redirecionara todo o trafego
   recebido naquele enderec,o IP especifico de volta para o cliente da LAN
   especifico. Isso tambem e conhecido como NAT estatico. Por exemplo, se o
   enderec,o IP 128.1.1.1, 128.1.1.2, e 128.1.1.3 estiverem disponiveis,
   128.1.1.1 pode ser usado pelo ipfw(8) como o enderec,o IP de saida
   externa, enquanto 128.1.1.2 e 128.1.1.3 sao encaminhados de volta para os
   clientes da LAN A e B.

   A sintaxe redirect_address e a seguinte, onde localIP e o enderec,o IP
   interno do cliente da LAN e publicIP e o enderec,o IP externo que
   corresponde ao cliente da LAN .

 redirect_address localIP publicIP

   No exemplo, os argumentos seriam:

 redirect_address 192.168.0.2 128.1.1.2
 redirect_address 192.168.0.3 128.1.1.3

   Como o redirect_port, esses argumentos sao inseridos na configurac,ao da
   instancia NAT. Com o redirecionamento de enderec,o, nao ha necessidade de
   redirecionamento de porta, pois todos os dados recebidos em um determinado
   enderec,o IP sao redirecionados.

   Os enderec,os IP externos na maquina ipfw(8) devem estar ativos e com
   alias na interface externa. Consulte rc.conf(5) para mais informac,oes.

    30.4.4.3. NAT do espac,o do usuario

   Vamos comec,ar com uma declarac,ao: a implementac,ao de NAT do sistema
   base: natd(8), tem mais sobrecarga do que no in-kernel NAT. Para que o
   natd(8) traduza pacotes, os pacotes precisam ser copiados do kernel para o
   espac,o do usuario e vice-versa, o que gera uma sobrecarga extra que nao
   esta presente com o in-kernel NAT.

   Para ativar o daemon de NAT do sistema base , natd(8), no momento da
   inicializac,ao do sistema, e necessario a seguinte configurac,ao minima em
   /etc/rc.conf. Onde natd_interface e definido com o nome da interface NIC
   conectada `a Internet. O script rc(8) do natd(8) verifica automaticamente
   se um enderec,o IP dinamico e usado e configura-se para lidar com isso.

 gateway_enable="YES"
 natd_enable="YES"
 natd_interface="rl0"

   Em geral, o conjunto de regras acima, conforme explicado para o in-kernel
   NAT, tambem pode ser usado junto com natd(8). As excec,oes sao a
   configurac,ao da instancia in-kernel NAT (ipfw -q nat 1 config ...) que
   nao e necessaria junto com a regra de remontagem 99 porque sua
   funcionalidade e incluida na ac,ao divert. As regras numero 100 e 1000
   terao que mudar ligeiramente, como mostrado abaixo.

 $cmd 100 divert natd ip from any to any in via $pif
 $cmd 1000 divert natd ip from any to any out via $pif

   Para configurar o redirecionamento de porta ou enderec,o, e usada uma
   sintaxe semelhante `a do in-kernel NAT. Embora agora, em vez de
   especificar a configurac,ao em nosso script de conjunto de regras, como no
   in-kernel NAT, a configurac,ao do natd(8) e melhor realizada em um arquivo
   de configurac,ao. Para fazer isso, uma flag extra deve ser passado atraves
   do /etc/rc.conf, que especifica o caminho do arquivo de configurac,ao.

 natd_flags="-f /etc/natd.conf"

  Nota:

   O arquivo especificado deve conter uma lista de opc,oes de configurac,ao,
   uma por linha. Para obter mais informac,oes sobre esse arquivo de
   configurac,ao e possiveis variaveis, consulte natd(8). Abaixo estao dois
   exemplos de valores, um por linha:

 redirect_port tcp 192.168.0.2:6667 6667
 redirect_address 192.168.0.3 128.1.1.3

  30.4.5. O Comando IPFW

   O ipfw pode ser usado para adicionar ou excluir regras unicas e manuais ao
   firewall ativo enquanto ele estiver em execuc,ao. O problema com o uso
   desse metodo e que todas as alterac,oes sao perdidas quando o sistema e
   reinicializado. Recomenda-se, em vez disso, gravar todas as regras em um
   arquivo e usar esse arquivo para carregar as regras no momento da
   inicializac,ao e substituir as regras de firewall em execuc,ao no momento
   em que o arquivo for alterado.

   O ipfw e uma maneira util para se exibir as regras de firewall em
   execuc,ao na tela do console. O recurso de contabilidade IPFW cria
   dinamicamente um contador para cada regra que case com cada pacote que
   corresponde `a regra. Durante o processo de teste de uma regra, listar a
   regra com seu contador e uma maneira de determinar se a regra esta
   funcionando conforme o esperado.

   Para listar todas as regras em execuc,ao em sequencia:

 # ipfw list

   Para listar todas as regras em execuc,ao com um registro de data e hora de
   quando a ultima vez em que a regra foi utilizada:

 # ipfw -t list

   O proximo exemplo lista as informac,oes contabeis e a contagem de pacotes
   das regras correspondentes, junto com as proprias regras. A primeira
   coluna e o numero da regra, seguido pelo numero de pacotes e bytes
   correspondidos, seguidos pela propria regra.

 # ipfw -a list

   Para listar regras dinamicas alem das regras estaticas:

 # ipfw -d list

   Para mostrar tambem as regras dinamicas expiradas:

 # ipfw -d -e list

   Para zerar os contadores:

 # ipfw zero

   Para zerar os contadores apenas para a regra com o numero NUM:

 # ipfw zero NUM

    30.4.5.1. Mensagens de Log do Firewall

   Mesmo com o recurso de gerac,ao de log ativado, o IPFW nao ira gerar
   nenhum log de regras por conta propria. O administrador do firewall decide
   quais regras no conjunto de regras serao logadas e adiciona a
   palavra-chave log a essas regras. Normalmente, apenas as regras de
   bloqueio sao logadas. E costume duplicar a regra "ipfw default deny
   everything" com a palavra-chave log incluida como a ultima regra no
   conjunto de regras. Dessa forma, e possivel ver todos os pacotes que nao
   correspondem a nenhuma das regras do conjunto de regras.

   O log e uma espada de dois gumes. Se nao houver cuidado, uma abundancia de
   dados de log ou um ataque DoS pode encher o disco com arquivos de log. As
   mensagens de log nao sao gravadas apenas no syslogd, mas tambem sao
   exibidas na tela do console do root e logo se tornam irritantes.

   A opc,ao do kernel IPFIREWALL_VERBOSE_LIMIT=5 limita o numero de mensagens
   consecutivas enviadas para o syslogd(8), referente `a correspondencia de
   pacotes de uma regra dada. Quando esta opc,ao esta ativada no kernel, o
   numero de mensagens consecutivas relativas a uma regra especifica e
   limitado ao numero especificado. Nao ha nada a ganhar com 200 mensagens de
   log identicas. Com essa opc,ao definida como cinco, cinco mensagens
   consecutivas referentes a uma regra especifica seriam registradas no
   syslogd e as mensagens consecutivas identicas restantes seriam contadas e
   postadas no syslogd com uma frase assim:

 last message repeated 45 times

   Todas os pacotes logados sao escritos por padrao no arquivo
   /var/log/security, que e definido no /etc/syslog.conf.

    30.4.5.2. Criando um Script de Regras

   Os usuarios mais experientes do IPFW criam um arquivo contendo as regras e
   as codificam de maneira compativel com sua execuc,ao como um script. A
   principal vantagem de fazer isso e que as regras de firewall podem ser
   atualizadas em massa sem a necessidade de reinicializar o sistema para
   ativa-las. Este metodo e conveniente para testar novas regras, pois o
   procedimento pode ser executado quantas vezes forem necessarias. Sendo um
   script, a substituic,ao simbolica pode ser usada para valores usados
   frequentemente para serem substituidos em varias regras.

   Este script de exemplo tem a sintaxe compativel com shells sh(1), csh(1),
   e tcsh(1). Campos de substituic,ao simbolicos sao prefixados com um sinal
   de dolar ($). Campos simbolicos nao possuem o prefixo $. O valor para
   preencher o campo simbolico deve ser colocado entre aspas duplas ("").

   Inicie o arquivo de regras assim:

 ############### start of example ipfw rules script #############
 #
 ipfw -q -f flush       # Delete all rules
 # Set defaults
 oif="tun0"             # out interface
 odns="192.0.2.11"      # ISP's DNS server IP address
 cmd="ipfw -q add "     # build rule prefix
 ks="keep-state"        # just too lazy to key this each time
 $cmd 00500 check-state
 $cmd 00502 deny all from any to any frag
 $cmd 00501 deny tcp from any to any established
 $cmd 00600 allow tcp from any to any 80 out via $oif setup $ks
 $cmd 00610 allow tcp from any to $odns 53 out via $oif setup $ks
 $cmd 00611 allow udp from any to $odns 53 out via $oif $ks
 ################### End of example ipfw rules script ############

   As regras nao sao importantes, pois o foco deste exemplo e como os campos
   de substituic,ao simbolica sao preenchidos.

   Se o exemplo acima estiver no arquivo /etc/ipfw.rules, as regras podem ser
   recarregadas pelo seguinte comando:

 # sh /etc/ipfw.rules

   /etc/ipfw.rules pode estar localizado em qualquer lugar e o arquivo pode
   ter qualquer nome.

   A mesma coisa pode ser realizada executando esses comandos manualmente:

 # ipfw -q -f flush
 # ipfw -q add check-state
 # ipfw -q add deny all from any to any frag
 # ipfw -q add deny tcp from any to any established
 # ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state
 # ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state
 # ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state

  30.4.6. Opc,oes do Kerne para o IPFW

   Para compilar estaticamente o suporte ao IPFW em um kernel personalizado,
   consulte as instruc,oes em Capitulo 8, Configurando o kernel do FreeBSD.
   As seguintes opc,oes estao disponiveis para o arquivo de configurac,ao do
   kernel personalizado:

 options    IPFIREWALL                   # enables IPFW
 options    IPFIREWALL_VERBOSE           # enables logging for rules with log keyword to syslogd(8)
 options    IPFIREWALL_VERBOSE_LIMIT=5   # limits number of logged packets per-entry
 options    IPFIREWALL_DEFAULT_TO_ACCEPT # sets default policy to pass what is not explicitly denied
 options    IPFIREWALL_NAT               # enables basic in-kernel NAT support
 options    LIBALIAS                     # enables full in-kernel NAT support
 options    IPFIREWALL_NAT64             # enables in-kernel NAT64 support
 options    IPFIREWALL_NPTV6             # enables in-kernel IPv6 NPT support
 options    IPFIREWALL_PMOD              # enables protocols modification module support
 options    IPDIVERT                     # enables NAT through natd(8)

  Nota:

   O IPFW pode ser carregado como um modulo do kernel: as opc,oes acima sao
   compiladas por padrao como modulos ou podem ser configuradas em tempo de
   execuc,ao usando parametros configuraveis.

30.5. IPFILTER (IPF)

   O IPFILTER, tambem conhecido como IPF, e um firewall cross-platform de
   codigo aberto que foi portado para varios sistemas operacionais, incluindo
   FreeBSD, NetBSD, OpenBSD e Solaris(TM).

   O IPFILTER e um firewall kernel-side e um mecanismo NAT que pode ser
   controlado e monitorado por programas da area de usuario. As regras de
   firewall podem ser definidas ou excluidas usando ipf, as regras NAT podem
   ser definidas ou excluidas usando ipnat, estatisticas em tempo de
   execuc,ao para as partes do kernel IPFILTER podem ser informadas usando
   ipfstat, e ipmon pode ser usado para logar ac,oes do IPFILTER nos arquivos
   de log do sistema.

   O IPF foi originalmente escrito usando uma logica de processamento de
   regra de que "a ultima regra que corresponder, ganha" e era utilizado
   apenas regras stateless. Desde entao, IPF foi aprimorado para incluir as
   opc,oes quick e keep state.

   O FAQ IPF esta em http://www.phildev.net/ipf/index.html. Um arquivo
   liberado para buscas da lista de discussao IPFilter esta disponivel em
   http://marc.info/?l=ipfilter.

   Esta sec,ao do Handbook foca no IPF no que se refere ao FreeBSD. Ele
   fornece exemplos de regras que contem as opc,oes quick e keep state.

  30.5.1. Ativando o IPF

   O IPF esta incluido na instalac,ao base do FreeBSD como um modulo
   carregavel do kernel, o que significa que um kernel personalizado nao e
   necessario para habilitar o IPF.

   Para usuarios que preferem compilar estaticamente o suporte ao IPF em um
   kernel personalizado, consulte as instruc,oes em Capitulo 8, Configurando
   o kernel do FreeBSD. As seguintes opc,oes do kernel estao disponiveis:

 options IPFILTER
 options IPFILTER_LOG
 options IPFILTER_LOOKUP
 options IPFILTER_DEFAULT_BLOCK

   onde options IPFILTER ativa o suporte para o IPFILTER, options
   IPFILTER_LOG ativa o log do IPF usando o pseudo-dispositivo de log ipl
   para cada regra que tenha a palavra-chave log, IPFILTER_LOOKUP ativa as
   pools IP para acelerar IP lookups, e options IPFILTER_DEFAULT_BLOCK altera
   o comportamento padrao para que qualquer pacote que nao corresponda a uma
   regra pass do firewall seja bloqueado.

   Para configurar o sistema para ativar o IPF no momento da inicializac,ao,
   adicione as seguintes entradas ao /etc/rc.conf. Essas entradas tambem
   ativarao o log e o default pass all. Para alterar a politica padrao para
   block all sem compilar um kernel personalizado, lembre-se de adicionar uma
   regra block all no final do conjunto de regras.

 ipfilter_enable="YES"             # Start ipf firewall
 ipfilter_rules="/etc/ipf.rules"   # loads rules definition text file
 ipmon_enable="YES"                # Start IP monitor log
 ipmon_flags="-Ds"                 # D = start as daemon
                                   # s = log to syslog
                                   # v = log tcp window, ack, seq
                                   # n = map IP & port to names

   Se a funcionalidade NAT for necessaria, adicione tambem estas linhas:

 gateway_enable="YES"              # Enable as LAN gateway
 ipnat_enable="YES"                # Start ipnat function
 ipnat_rules="/etc/ipnat.rules"    # rules definition file for ipnat

   Entao, inicie o IPF:

 # service ipfilter start

   Para carregar as regras de firewall, especifique o nome do arquivo do
   conjunto de regras usando ipf. O comando a seguir pode ser usado para
   substituir as regras de firewall que esta em execuc,ao:

 # ipf -Fa -f /etc/ipf.rules

   onde -Fa limpa todas as tabelas de regras internas e -f especifica o
   arquivo que contem as regras a serem carregadas.

   Isso fornece a capacidade de fazer alterac,oes em um conjunto de regras
   personalizado e atualizar o firewall em execuc,ao com uma nova copia das
   regras sem precisar reinicializar o sistema. Esse metodo e conveniente
   para testar novas regras, pois o procedimento pode ser executado quantas
   vezes forem necessarias.

   Consulte ipf(8) para detalhes sobre as outras flags disponiveis com este
   comando.

  30.5.2. Sintaxe de Regras IPF

   Esta sec,ao descreve a sintaxe de regras IPF usada para criar regras
   stateful. Ao criar regras, lembre-se de que, a menos que a palavra-chave
   quick aparec,a em uma regra, todas as regras sao lidas em ordem, com a
   ultima regra correspondente sendo a aplicada. Isso significa que, mesmo
   que a primeira regra que corresponder a um pacote seja pass, se houver uma
   regra de correspondencia posterior que seja block, o pacote sera
   descartado. Os conjuntos de regras de exemplo podem ser encontrados em
   /usr/share/examples/ipfilter.

   Ao criar regras, um caractere # e usado para marcar o inicio de um
   comentario e pode aparecer no final de uma regra, para explicar a func,ao
   dessa regra ou em sua propria linha. Todas as linhas em branco sao
   ignoradas.

   As palavras-chave usadas nas regras devem ser escritas em uma ordem
   especifica, da esquerda para a direita. Algumas palavras-chave sao
   obrigatorias, enquanto outras sao opcionais. Algumas palavras-chave tem
   sub-opc,oes que podem ser palavras-chave e tambem incluem mais
   sub-opc,oes. A ordem das palavras-chave e a seguinte, em que as palavras
   mostradas em maiusculas representam uma variavel e as palavras mostradas
   em minusculas devem preceder a variavel que a segue:

   ACTION DIRECTION OPTIONS proto PROTO_TYPE from SRC_ADDR SRC_PORT to
   DST_ADDR DST_PORT TCP_FLAG|ICMP_TYPE keep state STATE

   Esta sec,ao descreve cada uma dessas palavras-chave e suas opc,oes. Nao e
   uma lista exaustiva de todas as opc,oes possiveis. Consulte ipf(5) para
   obter uma descric,ao completa da sintaxe de regra que pode ser usada ao
   criar regras IPF e exemplos para usar de cada palavra-chave.

   ACTION

           A palavra-chave action indica o que fazer com o pacote se
           corresponder a essa regra. Toda regra deve ter uma ac,ao. As
           seguintes ac,oes sao reconhecidas:

           block: descarta o pacote.

           pass: permite o pacote.

           log: gera um registro de log.

           count: conta o numero de pacotes e bytes que podem fornecer uma
           indicac,ao da frequencia com que uma regra e usada.

           auth: enfileira o pacote para processamento adicional por outro
           programa.

           call: fornece acesso a func,oes embutidas no IPF que permitem
           ac,oes mais complexas.

           decapsulate: remove quaisquer cabec,alhos para processar o
           conteudo do pacote.

   DIRECTION

           Em seguida, cada regra deve indicar explicitamente a direc,ao do
           trafego usando uma dessas palavras-chave:

           in: a regra e aplicada em um pacote de entrada.

           out: a regra e aplicada em um pacote de saida.

           all: a regra se aplica em qualquer direc,ao.

           Se o sistema tiver varias interfaces, a interface pode ser
           especificada junto com a direc,ao. Um exemplo seria in on fxp0.

   OPTIONS

           Opc,oes sao opcionais. No entanto, se varias opc,oes forem
           especificadas, elas deverao ser usadas na ordem apresentada aqui.

           log: ao executar a ACTION especificada, o conteudo dos cabec,alhos
           do pacote sera gravado no pseudo-dispositivo de log ipl(4).

           quick: se um pacote corresponder a essa regra, a ACTION
           especificada pela regra ocorrera e nenhum processamento adicional
           das regras a seguir ocorrera para este pacote.

           on: deve ser seguido pelo nome da interface conforme exibido pelo
           ifconfig(8). A regra correspondera somente se o pacote estiver
           passando pela interface especificada na direc,ao especificada.

           Ao usar a palavra-chave log, os seguintes qualificadores podem ser
           usados nesta ordem:

           body: indica que os primeiros 128 bytes do conteudo do pacote
           serao registrados apos os cabec,alhos.

           first: se a palavra-chave log estiver sendo usada em conjunto com
           uma opc,ao keep state, esta opc,ao e recomendada para que somente
           o pacote acionador seja logado e nao todos os pacotes que
           corresponde `a conexao stateful.

           Opc,oes adicionais estao disponiveis para especificar mensagens de
           retorno de erro. Consulte ipf(5) para mais detalhes.

   PROTO_TYPE

           O tipo de protocolo e opcional. No entanto, e obrigatorio se a
           regra precisar especificar um SRC_PORT ou um DST_PORT, uma vez que
           isso requer o tipo de protocolo. Ao especificar o tipo de
           protocolo, use a palavra-chave proto seguida de um numero de
           protocolo ou nome de /etc/protocols. Exemplos de nomes de
           protocolos incluem tcp, udp ou icmp. Se PROTO_TYPE for
           especificado, mas nenhum SRC_PORT ou DST_PORT for especificado,
           todos os numeros de porta desse protocolo corresponderao a essa
           regra.

   SRC_ADDR

           A palavra-chave from e obrigatoria e e seguida por uma
           palavra-chave que representa a origem do pacote. A origem pode ser
           um nome de host, um enderec,o IP seguido pela mascara CIDR, um
           pool de enderec,os ou a palavra-chave all. Consulte ipf(5) para
           exemplos.

           Nao ha como definir intervalos de enderec,os de IP que nao se
           expressam facilmente usando a notac,ao de formato numerico com
           ponto / mascara. O pacote ou port net-mgmt/ipcalc pode ser usado
           para facilitar o calculo da mascara CIDR. Informac,oes adicionais
           estao disponiveis na pagina web da ferramenta:
           http://jodies.de/ipcalc.

   SRC_PORT

           O numero da porta da origem e opcional. No entanto, se for usado,
           ela exige que o PROTO_TYPE seja definido primeiramente na regra. O
           numero da porta tambem deve ser precedido pela palavra-chave
           proto.

           Diferentes operadores de comparac,ao sao suportados: = (igual a),
           != (diferente de), < (menor que), > (maior que), <= (menor ou
           igual a) e >= (maior que ou igual a).

           Para especificar intervalos de porta, coloque os dois numeros de
           porta entre <> (menor que e maior que), >< (maior que e menor que)
           ou : (maior que ou igual a e menor que ou igual a).

   DST_ADDR

           A palavra-chave to e obrigatoria e e seguida por uma palavra-chave
           que representa o destino do pacote. Semelhante ao SRC_ADDR, ela
           pode ser um nome de host, um enderec,o IP seguido pela mascara
           CIDR, um pool de enderec,os ou a palavra-chave all.

   DST_PORT

           Semelhante ao SRC_PORT, o numero da porta do destino e opcional.
           No entanto, se for usada, ela exige que o PROTO_TYPE seja definido
           primeiramente na regra. O numero da porta tambem deve ser
           precedido pela palavra-chave proto.

   TCP_FLAG|ICMP_TYPE

           Se tcp for especificado como o PROTO_TYPE, flags poderao ser
           especificadas como letras, onde cada letra representa uma das
           possiveis flags TCP utilizadas para determinar o estado de uma
           conexao. Os valores possiveis sao: S (SYN), A (ACK), P (PSH), F
           (FIN), U (URG), R (RST), C (CWN), e E (ECN).

           Se o icmp for especificado como o PROTO_TYPE, o tipo ICMP para
           correspondencia pode ser especificado. Consulte o ipf(5) para os
           tipos permitidos.

   STATE

           Se uma regra pass contiver keep state, o IPF incluira uma entrada
           em sua tabela de estados dinamicos e permitira o trafego os
           pacotes subsequentes que correspondam `a conexao. O IPF pode
           rastrear o estado das sessoes TCP, UDP e ICMP. Qualquer pacote que
           o IPF tenha certeza de que faz parte de uma sessao ativa, mesmo
           que seja um protocolo diferente, sera liberado.

           No IPF, os pacotes destinados a sair pela interface conectada `a
           Internet publica sao verificados primeiro na tabela de estados
           dinamicos. Se o pacote corresponder ao proximo pacote esperado,
           compreendendo uma sessao ativa, ele saira do firewall e o estado
           do fluxo da sessao sera atualizado na tabela de estados dinamicos.
           Os pacotes que nao pertencem a uma sessao ja ativa sao verificados
           no conjunto de regras de saida. Os pacotes vindos da interface
           conectada `a Internet publica sao verificados primeiro na tabela
           de estados dinamicos. Se o pacote corresponder ao proximo pacote
           esperado que compreende uma sessao ativa, ele saira do firewall e
           o estado do fluxo da sessao sera atualizado na tabela de estados
           dinamicos. Os pacotes que nao pertencem a uma sessao ja ativa sao
           verificados no conjunto de regras de entrada.

           Varias palavras-chave podem ser adicionadas depois de keep state.
           Se usadas, essas palavras-chave definem varias opc,oes que
           controlam a filtragem stateful, como a configurac,ao de limites de
           conexao ou o tempo de vida da conexao. Consulte ipf(5) para obter
           a lista de opc,oes disponiveis e suas descric,oes.

  30.5.3. Exemplo de Conjunto de Regras

   Esta sec,ao demonstra como criar um conjunto de regras de exemplo que
   permite apenas servic,os que correspondam `as regras pass e bloqueie todo
   o resto.

   O FreeBSD usa a interface de loopback (lo0) e o enderec,o IP 127.0.0.1
   para comunicac,ao interna. O conjunto de regras do firewall deve conter
   regras para permitir o livre movimento desses pacotes usados internamente:

 # no restrictions on loopback interface
 pass in quick on lo0 all
 pass out quick on lo0 all

   A interface publica conectada `a Internet e usada para autorizar e
   controlar o acesso de todas as conexoes de entrada e saida. Se uma ou mais
   interfaces forem cabeadas para redes privadas, essas interfaces internas
   poderao exigir regras para permitir que os pacotes originados da LAN fluam
   entre as redes internas ou para a interface conectada `a Internet. O
   conjunto de regras deve ser organizado em tres sec,oes principais:
   quaisquer interfaces internas confiaveis, conexoes de saida por meio da
   interface publica e conexoes de entrada por meio da interface publica.

   Essas duas regras permitem que todo o trafego passe por uma interface
   confiavel LAN chamada xl0:

 # no restrictions on inside LAN interface for private network
 pass out quick on xl0 all
 pass in quick on xl0 all

   As regras para as sec,oes de saida e entrada da interface publica devem
   ter as regras correspondidas com mais frequencia antes das regras menos
   comuns, com a ultima regra na sec,ao bloqueando e registrando todos os
   pacotes para essa interface e direc,ao.

   Este conjunto de regras define a sec,ao de saida da interface publica
   denominada dc0. Essas regras mantem o estado e identificam os servic,os
   especificos que os sistemas internos estao autorizados para acesso publico
   `a Internet. Todas as regras usam quick e especificam os numeros de porta
   apropriados e, quando aplicavel, os enderec,os de destino.

 # interface facing Internet (outbound)
 # Matches session start requests originating from or behind the
 # firewall, destined for the Internet.

 # Allow outbound access to public DNS servers.
 # Replace x.x.x. with address listed in /etc/resolv.conf.
 # Repeat for each DNS server.
 pass out quick on dc0 proto tcp from any to x.x.x. port = 53 flags S keep state
 pass out quick on dc0 proto udp from any to xxx port = 53 keep state

 # Allow access to ISP's specified DHCP server for cable or DSL networks.
 # Use the first rule, then check log for the IP address of DHCP server.
 # Then, uncomment the second rule, replace z.z.z.z with the IP address,
 # and comment out the first rule
 pass out log quick on dc0 proto udp from any to any port = 67 keep state
 #pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state

 # Allow HTTP and HTTPS
 pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state
 pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

 # Allow email
 pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
 pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

 # Allow NTP
 pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

 # Allow FTP
 pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

 # Allow SSH
 pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

 # Allow ping
 pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

 # Block and log everything else
 block out log first quick on dc0 all

   Neste exemplo de regras na sec,ao de entrada da interface publica todos os
   pacotes indesejaveis sao bloqueados primeiro. Isso reduz o numero de
   pacotes registrados pela ultima regra.

 # interface facing Internet (inbound)
 # Block all inbound traffic from non-routable or reserved address spaces
 block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
 block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
 block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
 block in quick on dc0 from 127.0.0.0/8 to any       #loopback
 block in quick on dc0 from 0.0.0.0/8 to any         #loopback
 block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
 block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
 block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
 block in quick on dc0 from 224.0.0.0/3 to any       #Class D & E multicast

 # Block fragments and too short tcp packets
 block in quick on dc0 all with frags
 block in quick on dc0 proto tcp all with short

 # block source routed packets
 block in quick on dc0 all with opt lsrr
 block in quick on dc0 all with opt ssrr

 # Block OS fingerprint attempts and log first occurrence
 block in log first quick on dc0 proto tcp from any to any flags FUP

 # Block anything with special options
 block in quick on dc0 all with ipopts

 # Block public pings and ident
 block in quick on dc0 proto icmp all icmp-type 8
 block in quick on dc0 proto tcp from any to any port = 113

 # Block incoming Netbios services
 block in log first quick on dc0 proto tcp/udp from any to any port = 137
 block in log first quick on dc0 proto tcp/udp from any to any port = 138
 block in log first quick on dc0 proto tcp/udp from any to any port = 139
 block in log first quick on dc0 proto tcp/udp from any to any port = 81

   Sempre que houver mensagens de log em uma regra com a opc,ao log first,
   execute ipfstat -hio para saber quantas vezes a regra foi correspondida.
   Um grande numero de correspondencias pode indicar que o sistema esta sob
   ataque.

   O restante das regras na sec,ao de entrada define quais conexoes podem ser
   iniciadas a partir da Internet. A ultima regra nega todas as conexoes que
   nao foram explicitamente permitidas pelas regras anteriores desta sec,ao.

 # Allow traffic in from ISP's DHCP server. Replace z.z.z.z with
 # the same IP address used in the outbound section.
 pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

 # Allow public connections to specified internal web server
 pass in quick on dc0 proto tcp from any to x.x.x.x port = 80 flags S keep state

 # Block and log only first occurrence of all remaining traffic.
 block in log first quick on dc0 all

  30.5.4. Configurando o NAT

   Para ativar o NAT, adicione estas instruc,oes ao arquivo /etc/rc.conf e
   especifique o nome do arquivo que contem as regras de NAT:

 gateway_enable="YES"
 ipnat_enable="YES"
 ipnat_rules="/etc/ipnat.rules"

   As regras de NAT sao flexiveis e podem realizar muitas coisas diferentes
   para atender `as necessidades dos usuarios comerciais e domesticos. A
   sintaxe da regra apresentada aqui foi simplificada para demonstrar um uso
   comum. Para obter uma descric,ao completa da sintaxe da regra, consulte
   ipnat(5).

   A sintaxe basica para uma regra NAT e a seguinte, onde map inicia a regra
   e IF deve ser substituido pelo nome da interface externa:

 map IF LAN_IP_RANGE -> PUBLIC_ADDRESS

   O LAN_IP_RANGE e o intervalo de enderec,os IP usados pelos clientes
   internos. Geralmente, e um intervalo de enderec,os privados, como
   192.168.1.0/24. O PUBLIC_ADDRESS pode ser o enderec,o IP externo estatico
   ou a palavra-chave 0/32 que representa o enderec,o IP atribuido para IF.

   No IPF, quando um pacote chega ao firewall a partir da LAN com um destino
   publico, ele primeiro passa pelas regras de saida do conjunto de regras do
   firewall. Em seguida, o pacote e passado para o conjunto de regras NAT, o
   qual e lido de cima para baixo, onde a primeira regra correspondente
   ganha. O IPF testa cada regra de NAT em relac,ao ao nome da interface e ao
   enderec,o IP de origem do pacote. Quando o nome da interface de um pacote
   corresponde a uma regra NAT, o enderec,o IP de origem do pacote na LAN
   privada e verificado para ver se ele esta dentro do intervalo de
   enderec,os IP especificado em LAN_IP_RANGE. Se corresponder, o pacote tem
   seu enderec,o IP de origem reescrito com o enderec,o IP publico
   especificado por PUBLIC_ADDRESS. O IPF adiciona uma entrada em sua tabela
   NAT interna para que, quando o pacote retornar da Internet, possa ser
   mapeado de volta para seu enderec,o IP privado original antes de ser
   passado para as regras de firewall para processamento adicional.

   Para redes que possuem um grande numero de sistemas internos ou varias
   sub-redes, o processo de afunilar todo enderec,o IP em um unico enderec,o
   IP publico se torna um problema de recursos. Dois metodos estao
   disponiveis para aliviar esse problema.

   O primeiro metodo e atribuir um intervalo de portas para usar como portas
   de origem. Adicionando a palavra-chave portmap, o NAT pode ser direcionado
   para usar apenas portas de origem no intervalo especificado:

 map dc0 192.168.1.0/24 -> 0/32 portmap tcp/udp 20000:60000

   Como alternativa, use a palavra-chave auto que informa ao NAT para
   determinar as portas que estao disponiveis para uso:

 map dc0 192.168.1.0/24 -> 0/32 portmap tcp/udp auto

   O segundo metodo e usar um pool de enderec,os publicos. Isso e util quando
   existem muitos clientes na LAN para para usar um unico enderec,o publico e
   um bloco de enderec,os publicos de IP esta disponivel. Esses enderec,os
   publicos podem ser usados como um pool do qual o NAT seleciona um
   enderec,o IP `a medida que o enderec,o de um pacote e mapeado ao sair.

   O intervalo de enderec,os IP publicos pode ser especificado usando uma
   notac,ao de netmask ou CIDR. Essas duas regras sao equivalentes:

 map dc0 192.168.1.0/24 -> 204.134.75.0/255.255.255.0
 map dc0 192.168.1.0/24 -> 204.134.75.0/24

   Uma pratica comum e ter um servidor web ou servidor de email publicamente
   acessivel isolado a um segmento de rede interno. O trafego desses
   servidores ainda precisa passar por NAT, mas o redirecionamento de porta e
   necessario para direcionar o trafego de entrada para o servidor correto.
   Por exemplo, para mapear um servidor web usando o enderec,o interno
   10.0.10.25 para seu enderec,o IP publico 20.20.20.5, use esta regra:

 rdr dc0 20.20.20.5/32 port 80 -> 10.0.10.25 port 80

   Se for o unico servidor web, essa regra tambem funcionara, pois
   redirecionara todas as solicitac,oes HTTP externas para 10.0.10.25:

 rdr dc0 0.0.0.0/0 port 80 -> 10.0.10.25 port 80

   O IPF possui um proxy FTP embutido que pode ser usado com o NAT. Ele
   monitora todo o trafego de saida de conexoes ativa ou passiva de FTP e
   cria dinamicamente regras de filtro temporario contendo o numero de porta
   usado pelo canal de dados FTP. Isso elimina a necessidade de abrir grandes
   intervalos de portas altas para conexoes de FTP.

   Neste exemplo, a primeira regra chama o proxy no trafego de saida FTP da
   LAN interna. A segunda regra passa o trafego de FTP do firewall para a
   Internet, e a terceira regra lida com todo o trafego nao FTP da LAN
   interna:

 map dc0 10.0.10.0/29 -> 0/32 proxy port 21 ftp/tcp
 map dc0 0.0.0.0/0 -> 0/32 proxy port 21 ftp/tcp
 map dc0 10.0.10.0/29 -> 0/32

   As regras map de FTP vem antes da regra NAT, de modo que quando um pacote
   corresponder a uma regra FTP, o proxy FTP crie regras temporarias de
   filtragem para permitir que os pacotes da sessao FTP sejam liberados e que
   passem pelo NAT. Todos os pacotes de rede local que nao sejam FTP nao
   corresponderao `as regras de FTP, mas serao liberados pelo NAT se
   corresponderem `a terceira regra.

   Sem o proxy FTPem, as seguintes regras de firewall seriam necessarias.
   Note que sem o proxy, todas as portas acima de 1024 precisam ser
   permitidas:

 # Allow out LAN PC client FTP to public Internet
 # Active and passive modes
 pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

 # Allow out passive mode data channel high order port numbers
 pass out quick on rl0 proto tcp from any to any port > 1024 flags S keep state

 # Active mode let data channel in from FTP server
 pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state

   Sempre que o arquivo contendo as regras de NAT for editado, execute ipnat
   com -CF para excluir as regras atuais de NAT e liberar o conteudo da
   tabela de traduc,ao dinamica. Inclua -f e especifique o nome do conjunto
   de regras NAT para carregar:

 # ipnat -CF -f /etc/ipnat.rules

   Para exibir as estatisticas de NAT:

 # ipnat -s

   Para listar os mapeamentos atuais da tabela NAT:

 # ipnat -l

   Para ativar o modo verbose e exibir informac,oes relacionadas ao
   processamento de regras, regras ativas e registros nas tabelas:

 # ipnat -v

  30.5.5. Visualizando Estatisticas do IPF

   O IPF inclui o ipfstat(8) que pode ser usado para recuperar e exibir
   estatisticas das regras sendo utilizadas enquanto os pacotes passam pelo
   firewall. As estatisticas sao acumuladas desde que o firewall foi iniciado
   pela ultima vez ou desde a ultima vez que foram redefinidas para zero
   usando ipf -Z.

   A saida padrao do ipfstat e semelhante a esta:

 input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
  output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
  input packets logged: blocked 99286 passed 0
  output packets logged: blocked 0 passed 0
  packets logged: input 0 output 0
  log failures: input 3898 output 0
  fragment state(in): kept 0 lost 0
  fragment state(out): kept 0 lost 0
  packet state(in): kept 169364 lost 0
  packet state(out): kept 431395 lost 0
  ICMP replies: 0 TCP RSTs sent: 0
  Result cache hits(in): 1215208 (out): 1098963
  IN Pullups succeeded: 2 failed: 0
  OUT Pullups succeeded: 0 failed: 0
  Fastroute successes: 0 failures: 0
  TCP cksum fails(in): 0 (out): 0
  Packet log flags set: (0)

   Varias opc,oes estao disponiveis. Quando executado com -i para entrada ou
   -o para saida, o comando recuperara e exibira a lista apropriada de regras
   de filtro atualmente instaladas e em uso pelo kernel. Para tambem ver os
   numeros das regras, inclua -n. Por exemplo, ipfstat -on exibe a tabela de
   regras de saida com os numeros de regra:

 @1 pass out on xl0 from any to any
 @2 block out on dc0 from any to any
 @3 pass out quick on dc0 proto tcp/udp from any to any keep state

   Inclua -h para prefixar cada regra com uma contagem de quantas vezes a
   regra foi utilizada. Por exemplo, ipfstat -oh exibe a tabela de regras
   internas de saida, prefixando cada regra com sua contagem de uso:

 2451423 pass out on xl0 from any to any
 354727 block out on dc0 from any to any
 430918 pass out quick on dc0 proto tcp/udp from any to any keep state

   Para exibir a tabela de estados em um formato similar ao top(1), use
   ipfstat -t. Quando o firewall esta sob ataque, essa opc,ao fornece a
   capacidade de identificar e ver os pacotes de ataque. As sub-flags
   opcionais dao a possibilidade de selecionar o IP destino ou origem, porta
   ou protocolo a ser monitorado em tempo real. Consulte ipfstat(8) para
   detalhes.

  30.5.6. Log do IPF

   O IPF fornece o ipmon, que pode ser usado para gravar as informac,oes de
   log do firewall em um formato legivel por humanos. Isso requer que as
   opc,oes IPFILTER_LOG sejam primeiramente adicionadas a um kernel
   personalizado usando as instruc,oes em Capitulo 8, Configurando o kernel
   do FreeBSD.

   Esse comando geralmente e executado no modo daemon para fornecer um
   arquivo de log continuo do sistema para que o registro de eventos passados
   possa ser revisado. Como o FreeBSD possui um recurso syslogd(8) integrado
   para rotacionar automaticamente os logs do sistema, a instruc,ao
   ipmon_flags no arquivo rc.conf por padrao utiliza -Ds:

 ipmon_flags="-Ds" # D = start as daemon
                   # s = log to syslog
                   # v = log tcp window, ack, seq
                   # n = map IP & port to names

   O registro em log fornece a capacidade de revisar, apos o fato,
   informac,oes como quais pacotes foram descartados, de que enderec,os eles
   vieram e para onde estavam indo. Esta informac,ao e util para rastrear
   invasores.

   Uma vez que o recurso de criac,ao de log esteja ativado no arquivo rc.conf
   e iniciado com o servic,o ipmon start, o IPF ira registrar apenas as
   regras que contem a palavra-chave log. O administrador do firewall decide
   quais regras no conjunto de regras devem ser logadas e normalmente apenas
   as regras de negac,ao sao registradas. E costume incluir a palavra-chave
   log na ultima regra do conjunto de regras. Isso possibilita ver todos os
   pacotes que nao correspondem a nenhuma das regras do conjunto de regras.

   Por padrao, o modo ipmon -Ds usa local0 como o recurso de log. Os niveis
   de registro a seguir podem ser usados para separar ainda mais os dados
   logados:

 LOG_INFO - pacotes logados usando a palavra-chave "log" ao inves da ac,ao  pass ou block.
 LOG_NOTICE - pacotes logados que tambem sao liberados
 LOG_WARNING - pacotes logados que tambem sao bloqueados
 LOG_ERR - pacotes que foram logados e que podem ser considerados insuficientes devido a um cabec,alho incompleto

   Para configurar o IPF para logar todos os dados em /var/log/ipfilter.log,
   primeiro crie o arquivo vazio:

 # touch /var/log/ipfilter.log

   Em seguida, para gravar todas as mensagens de log no arquivo especificado,
   inclua a seguinte instruc,ao no arquivo /etc/syslog.conf:

 local0.* /var/log/ipfilter.log

   Para ativar as alterac,oes e instruir o syslogd(8) para ler o arquivo
   modificado /etc/syslog.conf, execute service syslogd reload.

   Nao se esquec,a de editar o /etc/newsyslog.conf para rotacionar o novo
   arquivo de log.

   As mensagens geradas pelo ipmon consistem em campos de dados separados por
   espac,os em branco. Campos comuns a todas as mensagens sao:

    1. A data do recebimento do pacote.

    2. O horario do recebimento do pacote. Isto esta no formato HH:MM:SS.F,
       para horas, minutos, segundos e frac,oes de segundo.

    3. O nome da interface que processou o pacote.

    4. O grupo e o numero da regra no formato @0:17.

    5. A ac,ao: p para liberado (pass), b para bloqueado, S para um pacote
       com problema (short), n nao corresponde a nenhuma regra e L para uma
       regra de log.

    6. Os enderec,os escritos em tres campos: o enderec,o de origem e porta
       separados por uma virgula, o simbolo -> , e o enderec,o e porta de
       destino. Por exemplo: 209.53.17.22,80 -> 198.73.220.17,1722.

    7. PR seguido pelo nome ou numero do protocolo: por exemplo, PR tcp.

    8. len seguido pelo tamanho do cabec,alho e comprimento total do pacote:
       por exemplo, len 20 40.

   Se o pacote for um pacote TCP, havera um campo adicional comec,ando com um
   hifen seguido por letras correspondentes a quaisquer flags que foram
   configuradas. Consulte ipf(5) para obter uma lista de letras e suas flags.

   Se o pacote for um pacote ICMP, havera dois campos no final: o primeiro
   sempre sendo "icmp" e o proximo sendo a mensagem ICMP e sub-tipo de
   mensagem, separados por uma barra. Por exemplo: icmp 3/3 para uma mensagem
   port unreachable.

30.6. Blacklistd

   O Blacklistd e um daemon que escuta sockets para receber notificac,oes de
   outros daemons sobre tentativas de conexao que falharam ou foram
   bem-sucedidas. E mais amplamente utilizado no bloqueio de muitas
   tentativas de conexao em portas abertas. Um exemplo excelente e o SSH,
   executado na Internet, recebendo muitas solicitac,oes de conexao de bots
   ou scripts tentando adivinhar senhas e obter acesso. Utilizando
   blacklistd, o daemon pode notificar o firewall para criar uma regra de
   filtro para bloquear tentativas excessivas de conexao de uma unica origem
   apos varias tentativas. O Blacklistd foi desenvolvido pela primeira vez no
   NetBSD e apareceu na versao 7. O FreeBSD 11 importou o blacklistd do
   NetBSD.

   Este capitulo descreve como instalar o blacklistd, configura-lo e fornece
   exemplos de como usa-la. Os leitores devem estar familiarizados com os
   conceitos basicos de firewall, como regras. Para detalhes, consulte o
   capitulo sobre firewall. O PF e usado nos exemplos, mas outros firewalls
   disponiveis no FreeBSD tambem devem funcionar com o blacklistd.

  30.6.1. Habilitando a Blacklistd

   A configurac,ao principal do blacklistd e armazenada em
   blacklistd.conf(5). Varias opc,oes de linha de comando tambem estao
   disponiveis para alterar o comportamento em tempo de execuc,ao do
   blacklistd. Para persistir as configurac,oes em uma reinicializac,ao do
   sistema, deve se armazenar as opc,oes em /etc/blacklistd.conf. Para ativar
   o daemon durante a inicializac,ao do sistema, adicione a linha
   blacklistd_enable no /etc/rc.conf assim:

 # sysrc blacklistd_enable=yes

   Para iniciar o servic,o manualmente, execute este comando:

 # service blacklistd start

  30.6.2. Criando um conjunto de regras no Blacklistd

   As regras do blacklistd sao configuradas em blacklistd.conf(5) com uma
   opc,ao por linha. Cada regra contem uma tupla separada por espac,os ou
   tabulac,oes. As regras pertencem a um local ou a um remote, que se aplica
   `a maquina em que o blacklistd esta sendo executado ou a uma origem
   externa, respectivamente.

    30.6.2.1. Regras Locais

   Um exemplo de entrada blacklistd.conf para uma regra local se parece com
   isso:

 [local]
 ssh             stream  *       *               *       3       24h

   Todas as regras que seguem a sec,ao [local] sao tratadas como regras
   locais (que e o padrao), aplicadas `a maquina local. Quando uma sec,ao
   [remote] e encontrada, todas as regras a seguir sao tratadas como regras
   de maquina remota.

   Sete campos definem uma regra separada por tabulac,oes ou espac,os. Os
   quatro primeiros campos identificam o trafego que deve estar na lista
   negra. Os tres campos a seguir definem o comportamento do backlistd. Os
   curingas sao indicados como asteriscos (*), correspondendo a qualquer
   coisa nesse campo. O primeiro campo define a localizac,ao. Nas regras
   locais, essas sao as portas de rede. A sintaxe para o campo local e a
   seguinte:

 [address|interface][/mask][:port]

   Os enderec,os podem ser especificados como IPv4 no formato numerico ou
   IPv6 entre colchetes. Um nome de interface como em0 tambem pode ser usado.

   O tipo de socket e definido pelo segundo campo. Os socket TCP sao do tipo
   stream, enquanto UDP e indicado como dgram. O exemplo acima usa TCP, pois
   o SSH esta usando esse protocolo.

   Um protocolo pode ser usado no terceiro campo de uma regra de lista negra.
   Os seguintes protocolos podem ser usados: tcp, udp, tcp6, udp6 ou
   numerico. Um curinga, como no exemplo, geralmente e usado para
   corresponder a todos os protocolos, a menos que haja um motivo para
   distinguir o trafego por um determinado protocolo.

   No quarto campo, o usuario ou proprietario efetivo do processo daemon que
   esta reportando o evento e definido. O nome de usuario ou o UID pode ser
   usado aqui, bem como um curinga (veja a regra de exemplo acima).

   O nome da regra do packet filter e declarado pelo quinto campo, que inicia
   a parte de comportamento da regra. Por padrao, blacklistd coloca todos os
   blocos sob uma ancora pf chamada blacklistd em pf.conf assim:

 anchor "blacklistd/*" in on $ext_if
 block in
 pass out

   Para blacklists separadas, um nome de ancora pode ser usado neste campo.
   Em outros casos, o curinga sera suficiente. Quando um nome comec,a com um
   hifen (-), significa que uma ancora com o nome de regra padrao precedido
   deve ser usada. Uma modificac,ao do exemplo acima usando o hifen ficaria
   assim:

 ssh             stream  *       *               -ssh       3       24h

   Com essa regra, quaisquer novas regras de blacklist sao adicionadas a uma
   ancora chamada blacklistd-ssh.

   Para bloquear sub-redes inteiras para uma unica violac,ao de regra, um /
   no nome da regra pode ser usado. Isso faz com que a parte restante do nome
   seja interpretada como a mascara a ser aplicada ao enderec,o especificado
   na regra. Por exemplo, esta regra bloquearia todos os enderec,os
   adjacentes a /24.

 22              stream  tcp       *               */24    3       24h

  Nota:

   E importante especificar o protocolo apropriado aqui. O IPv4 e o IPv6
   tratam o /24 de maneira diferente, e por isso que * nao pode ser usado no
   terceiro campo para esta regra.

   Esta regra define que, se qualquer host dessa rede estiver se comportando
   mal, todo o resto da rede tambem sera bloqueado.

   O sexto campo, chamado nfail, define o numero de falhas de login
   necessarias para colocar na blacklist o IP remoto em questao. Quando um
   curinga e usado nessa posic,ao, isso significa que o bloqueio nunca ira
   acontecer. Na regra de exemplo acima, um limite de tres e definido, o que
   significa que, apos tres tentativas de logon no SSH em uma conexao, o IP e
   bloqueado.

   O ultimo campo em uma definic,ao de regra do blacklistd especifica por
   quanto tempo um host ficara na lista negra. A unidade padrao e segundos,
   mas sufixos como m, h e d tambem podem ser especificados por minutos,
   horas e dias, respectivamente.

   A regra de exemplo na integra significa que, apos tres vezes a
   autenticac,ao no SSH, resultara em uma nova regra de bloqueio de PF para
   esse host. As correspondencias de regras sao realizadas verificando
   primeiro as regras locais, uma apos a outra, da mais especifica `a menos
   especifica. Quando ocorre uma correspondencia, as regras remote sao
   aplicadas e o nome nfail e os campos de desativac,ao sao alterados pela
   regra remote correspondente.

    30.6.2.2. Regras Remotas

   As regras remotas sao usadas para especificar como o blacklistd muda seu
   comportamento, dependendo do host remoto que esta sendo avaliado no
   momento. Cada campo em uma regra remota e o mesmo que em uma regra local.
   A unica diferenc,a esta na maneira como o blacklistd os usa. Para
   explicar, esta regra de exemplo e usada:

 [remote]
 203.0.113.128/25 *      *       *               =/25    =       48h

   O campo de enderec,o pode ser um enderec,o IP (v4 ou v6), uma porta ou
   ambas. Isso permite definir regras especiais para um intervalo de
   enderec,os remotos especifico, como neste exemplo. Os campos para tipo,
   protocolo e proprietario sao identicamente interpretados como na regra
   local.

   Porem, os campos de nome sao diferentes: o sinal de igual (=) em uma regra
   remota diz ao blacklistd para usar o valor da regra local correspondente.
   Isso significa que a entrada da regra de firewall e obtida e o prefixo /25
   (uma mascara de rede 255.255.255.128) e adicionada. Quando uma conexao
   desse intervalo de enderec,os e colocada na lista negra, toda a sub-rede e
   afetada. Um nome de ancora PF tambem pode ser usado aqui; nesse caso, o
   blacklisted adicionara regras para esse bloco de enderec,os `a ancora
   desse nome. A tabela padrao e usada quando um curinga e especificado.

   Um numero personalizado de falhas na coluna nfail pode ser definido para
   um enderec,o. Isso e util para excec,oes a uma regra especifica, talvez
   para permitir a alguem uma aplicac,ao menos rigorosa de regras ou um pouco
   mais de clemencia nas tentativas de login. O bloqueio e desativado quando
   um asterisco e usado neste sexto campo.

   As regras remotas permitem uma aplicac,ao mais rigorosa dos limites das
   tentativas de logon, em comparac,ao com as tentativas provenientes de uma
   rede local como um escritorio.

  30.6.3. Configurac,ao do cliente no Blacklistd

   Existem alguns pacotes de software no FreeBSD que podem utilizar a
   funcionalidade do blacklistd. Os dois mais proeminentes sao ftpd(8) e
   sshd(8) para bloquear tentativas excessivas de conexao. Para ativar o
   blacklistd no daemon SSH, adicione a seguinte linha ao
   /etc/ssh/sshd_config:

 UseBlacklist yes

   Reinicie o sshd posteriormente para que essas alterac,oes entrem em vigor.

   A lista negra do ftpd(8) e ativada usando -B, em /etc/inetd.conf ou como
   uma flag no /etc/rc.conf assim:

 ftpd_flags="-B"

   Isso e tudo o que e necessario para que esses programas conversem com o
   blacklistd.

  30.6.4. Gerenciamento do Blacklistd

   O Blacklistd fornece ao usuario um utilitario de gerenciamento chamado
   blacklistctl(8). Ele exibe enderec,os e redes bloqueados que estao na
   lista negra pelas regras definidas em blacklistd.conf(5). Para ver a lista
   de hosts atualmente bloqueados, use dump combinado com -b assim.

 # blacklistctl dump -b
       address/ma:port id      nfail   last access
 213.0.123.128/25:22   OK      6/3     2019/06/08 14:30:19

   Este exemplo mostra que houve 6 de tres tentativas permitidas na porta 22
   provenientes do intervalo de enderec,os 213.0.123.128/25. Ha mais
   tentativas listadas do que sao permitidas porque o SSH permite que um
   cliente tente varios logins em uma unica conexao TCP. Uma conexao que esta
   em andamento no momento nao e interrompida pelo blacklistd. A ultima
   tentativa de conexao esta listada na coluna last access da saida.

   Para ver o tempo restante em que esse host estara na lista negra, adicione
   -r ao comando anterior.

 # blacklistctl dump -br
       address/ma:port id      nfail   remaining time
 213.0.123.128/25:22   OK      6/3     36s

   Neste exemplo, restam 36 segundos para que este host nao seja mais
   bloqueado.

  30.6.5. Removendo hosts da lista de bloqueios

   As vezes, e necessario remover um host da lista de bloqueios antes que o
   tempo restante expire. Infelizmente, nao ha funcionalidade no blacklistd
   para fazer isso. No entanto, e possivel remover o enderec,o da tabela PF
   usando pfctl. Para cada porta bloqueada, existe uma ancora filha dentro da
   ancora do blacklistd definida em /etc/pf.conf. Por exemplo, se houver uma
   ancora filha para bloquear a porta 22, ela sera chamada blacklistd/22. Ha
   uma tabela dentro dessa ancora filha que contem os enderec,os bloqueados.
   Essa tabela e chamada de port seguida pelo numero da porta. Neste exemplo,
   ele seria chamada de port22. Com essas informac,oes em maos, agora e
   possivel usar o pfctl(8) para exibir todos os enderec,os listados desta
   maneira:

 # pfctl -a blacklistd/22 -t port22 -T show
 ...
 213.0.123.128/25
 ...

   Depois de identificar o enderec,o a ser desbloqueado da lista, o seguinte
   comando o remove da lista:

 # pfctl -a blacklistd/22 -t port22 -T delete 213.0.123.128/25

   O enderec,o agora foi removido do PF, mas ainda sera exibido no
   blacklistctl, pois ele nao conhece nenhuma alterac,ao feita no PF. A
   entrada no banco de dados do blacklistd expirara e sera removida de sua
   saida eventualmente. A entrada sera adicionada novamente se o host estiver
   correspondendo a uma das regras de bloqueio no blacklistd novamente.

Capitulo 31. Rede Avanc,ada

   Indice

   31.1. Sinopse

   31.2. Gateways e Rotas

   31.3. Rede sem fio

   31.4. USB Tethering

   31.5. Bluetooth

   31.6. Bridging

   31.7. Agregac,ao de links e failover

   31.8. Operac,ao Diskless com PXE

   31.9. IPv6

   31.10. Protocolo Comum de Redundancia de Enderec,os (CARP)

   31.11. VLANs

31.1. Sinopse

   Este capitulo aborda varios topicos avanc,ados de rede.

   Depois de ler este capitulo, voce sabera:

     * O basico de gateways e rotas.

     * Como configurar o USB tethering.

     * Como configurar os dispositivos IEEE(R) 802.11 e Bluetooth(R).

     * Como fazer o FreeBSD atuar como uma Bridge.

     * Como configurar a inicializac,ao via PXE na rede.

     * Como configurar o IPv6 em uma maquina FreeBSD.

     * Como habilitar e utilizar os recursos do Protocolo CARP (Common
       Address Redundancy Protocol) no FreeBSD.

     * Como configurar multiplas VLANs no FreeBSD.

     * Como configurar um fone de ouvido bluetooth.

   Antes de ler este capitulo, voce deve:

     * Entender os fundamentos dos scripts /etc/rc.

     * Estar familiarizado com a terminologia basica de rede.

     * Saber como configurar e instalar um novo kernel do FreeBSD
       (Capitulo 8, Configurando o kernel do FreeBSD).

     * Saber como instalar software adicional de terceiros (Capitulo 4,
       Instalando Aplicativos: Pacotes e Ports).

31.2. Gateways e Rotas

   Contribuic,ao deCoranth Gryphon.

   O roteamento e o mecanismo que permite que um sistema encontre o caminho
   da rede para outro sistema. Uma rota e um par definido de enderec,os que
   representam o "destino" e um "gateway". A rota indica que, ao tentar
   chegar ao destino especificado, voce devera enviar os pacotes pelo gateway
   especificado. Existem tres tipos de destinos: hosts individuais, sub-redes
   e "padrao". A "rota padrao" e usada se nenhuma outra rota for aplicada.
   Existem tambem tres tipos de gateways: hosts individuais, interfaces,
   tambem chamados de links, e enderec,os de hardware Ethernet (MAC). Rotas
   conhecidas sao armazenadas em uma tabela de roteamento.

   Esta sec,ao fornece uma visao geral dos fundamentos de roteamento. Em
   seguida, ele demonstra como configurar um sistema FreeBSD como um roteador
   e oferece algumas dicas de soluc,ao de problemas.

  31.2.1. Fundamentos de roteamento

   Para ver a tabela de roteamento de um sistema FreeBSD, use netstat(1):

 % netstat -r
 Routing tables

 Internet:
 Destination      Gateway            Flags     Refs     Use     Netif Expire
 default          outside-gw         UGS        37      418       em0
 localhost        localhost          UH          0      181       lo0
 test0            0:e0:b5:36:cf:4f   UHLW        5    63288       re0     77
 10.20.30.255     link#1             UHLW        1     2421
 example.com      link#1             UC          0        0
 host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
 host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 =>
 host2.example.com link#1            UC          0        0
 224              link#1             UC          0        0

   As entradas neste exemplo sao as seguintes:

   padrao

           A primeira rota nesta tabela especifica a rota padrao. Quando o
           sistema local precisa estabelecer uma conexao com um host remoto,
           ele verifica a tabela de roteamento para determinar se existe um
           caminho conhecido. Se o host remoto corresponder a uma entrada na
           tabela, o sistema verificara se pode se conectar usando a
           interface especificada nessa entrada.

           Se o destino nao corresponder a uma entrada ou se todos os
           caminhos conhecidos falharem, o sistema usara a entrada para a
           rota padrao. Para hosts em uma rede local, o campo Gateway na rota
           padrao e definido para o sistema que possui uma conexao direta com
           a internet. Ao ler esta entrada, verifique se a coluna Flags
           indica que o gateway e utilizavel (UG).

           A rota padrao para uma maquina que esta funcionando como gateway
           para o mundo externo sera a maquina de gateway no provedor de
           servic,os de Internet (ISP).

   localhost

           A segunda rota e a localhost. A interface especificada na coluna
           Netif para localhost e lo0, tambem conhecido como o dispositivo de
           loopback. Isso indica que todo o trafego para esse destino deve
           ser interno, em vez de envia-lo pela rede.

   Enderec,o MAC

           Os enderec,os que comec,am com 0:e0: sao enderec,os de MAC. O
           FreeBSD ira identificar automaticamente quaisquer hosts, test0 no
           exemplo, na Ethernet local e adicionara uma rota para aquele host
           atraves da interface Ethernet, re0. Esse tipo de rota tem um tempo
           limite, visto na coluna Expire, que e usada se o host nao
           responder em um periodo de tempo especifico. Quando isso
           acontecer, a rota para esse host sera automaticamente excluida.
           Esses hosts sao identificados usando o protocolo de informac,oes
           de roteamento (RIP), que calcula rotas para hosts locais com base
           em uma determinac,ao de caminho mais curto.

   sub-rede

           O FreeBSD ira adicionar automaticamente rotas de sub-rede para a
           sub-rede local. Neste exemplo, 10.20.30.255 e o enderec,o de
           broadcast da sub-rede 10.20.30 e example.com e o nome de dominio
           associado a essa sub-rede. A designac,ao link#1 refere-se `a
           primeira placa Ethernet na maquina.

           Hosts de rede local e sub-redes locais tem suas rotas configuradas
           automaticamente por um daemon chamado routed(8). Se ele nao
           estiver em execuc,ao, somente as rotas definidas estaticamente
           pelo administrador existirao.

   host

           A linha host1 refere-se ao host pelo seu enderec,o Ethernet. Como
           e o host de envio, o FreeBSD sabe usar a interface de loopback
           (lo0) em vez da interface Ethernet.

           As duas linhas host2 representam os aliases que foram criados
           usando ifconfig(8). O simbolo => apos a interface lo0 diz que um
           alias foi definido alem do enderec,o de loopback. Tais rotas so
           aparecem no host que suporta o alias e todos os outros hosts na
           rede local terao uma linha link#1 para tais rotas.

   224

           A linha final (destino subnet 224) lida com multicasting.

   Varios atributos de cada rota podem ser vistos na coluna Flags. A
   Tabela 31.1, "Flags da Tabela de Roteamento Frequentemente Observados"
   resume algumas destas flags e seus significados:

   Tabela 31.1. Flags da Tabela de Roteamento Frequentemente Observados

   Comando                             Proposito                              
   U       A rota esta ativa (up).                                            
   H       O destino da rota e um unico host.                                 
   G       Envie qualquer coisa para este destino por este gateway, que ele   
           ira descobrir a partir dai para onde envia-lo.                     
   S       Esta rota foi configurada estaticamente.                           
           Clona uma nova rota baseada nessa rota para as maquinas se         
   C       conectarem. Esse tipo de rota e normalmente usado para redes       
           locais.                                                            
   W       A rota foi configurada automaticamente com base em uma rota de     
           rede local (clone).                                                
   L       A rota envolve referencias a um hardware Ethernet (link).          

   Em um sistema FreeBSD, a rota padrao pode ser definida no /etc/rc.conf
   especificando o enderec,o IP do gateway padrao:

 defaultrouter="10.20.30.1"

   Tambem e possivel adicionar manualmente a rota usando o comando route:

 # route add default 10.20.30.1

   Observe que as rotas adicionadas manualmente nao sobreviverao a uma
   reinicializac,ao. Para obter mais informac,oes sobre a manipulac,ao manual
   das tabelas de roteamento de rede, consulte route(8).

  31.2.2. Configurando um roteador com rotas estaticas

   Contribuido por Al Hoang.

   Um sistema FreeBSD pode ser configurado como o gateway padrao, ou
   roteador, para uma rede se for um sistema dual-homed. Um sistema
   dual-homed e um host que reside em pelo menos duas redes diferentes.
   Normalmente, cada rede e conectada a uma interface de rede separada,
   embora o aliasing IP possa ser usado para vincular varios enderec,os, cada
   um em uma sub-rede diferente, a uma interface fisica.

   Para que o sistema encaminhe os pacotes entre as interfaces, o FreeBSD
   deve ser configurado como um roteador. Padroes da Internet e boas praticas
   de engenharia impedem o Projeto FreeBSD de habilitar esse recurso por
   padrao, mas ele pode ser configurado para iniciar na inicializac,ao
   adicionando esta linha ao /etc/rc.conf:

 gateway_enable="YES"          # Set to YES if this host will be a gateway

   Para habilitar o roteamento agora, defina a variavel sysctl(8)
   net.inet.ip.forwarding para 1. Para parar o roteamento, redefina essa
   variavel para 0.

   A tabela de roteamento de um roteador precisa de rotas adicionais para
   saber como acessar outras redes. Rotas podem ser adicionadas manualmente
   usando rotas estaticas ou rotas podem ser aprendidas automaticamente
   usando um protocolo de roteamento. As rotas estaticas sao apropriadas para
   redes pequenas e esta sec,ao descreve como adicionar uma entrada de
   roteamento estatico para uma rede pequena.

  Nota:

   Para grandes redes, as rotas estaticas se tornam nao escalaveis
   rapidamente. O FreeBSD vem com o daemon de roteamento BSD padrao
   routed(8), que fornece os protocolos de roteamento RIP, versoes 1 e 2 e
   IRDP. O suporte para os protocolos de roteamento BGP e OSPF pode ser
   instalado usando o pacote ou port net/zebra.

   Considere a seguinte rede:

   Neste cenario, o RouterA e uma maquina FreeBSD que esta agindo como um
   roteador para o resto da Internet. Ele tem uma rota padrao definida como
   10.0.0.1, que permite a conexao com o mundo externo. O RouterB ja esta
   configurado para usar 192.168.1.1 como seu gateway padrao.

   Antes de adicionar rotas estaticas, a tabela de roteamento no RouterA se
   parece com:

 % netstat -nr
 Routing tables

 Internet:
 Destination        Gateway            Flags    Refs      Use  Netif  Expire
 default            10.0.0.1           UGS         0    49378    xl0
 127.0.0.1          127.0.0.1          UH          0        6    lo0
 10.0.0.0/24        link#1             UC          0        0    xl0
 192.168.1.0/24     link#2             UC          0        0    xl1

   Com a tabela de roteamento atual, o RouterA nao tem uma rota para a rede
   192.168.2.0/24. O comando a seguir adiciona a rede Internal Net 2 `a
   tabela de roteamento do RouterA usando 192.168.1.2 como o proximo salto:

 # route add -net 192.168.2.0/24 192.168.1.2

   Agora, o RouterA pode alcanc,ar qualquer host na rede 192.168.2.0/24. No
   entanto, as informac,oes de roteamento nao persistirao se o sistema
   FreeBSD for reinicializado. Se uma rota estatica precisar ser persistente,
   adicione-a ao /etc/rc.conf:

 # Add Internal Net 2 as a persistent static route
 static_routes="internalnet2"
 route_internalnet2="-net 192.168.2.0/24 192.168.1.2"

   A variavel de configurac,ao static_routes e uma lista de strings separadas
   por um espac,o, onde cada string faz referencia a um nome de rota. A
   variavel route_internalnet2 contem a rota estatica para esse nome de rota.

   Usar mais de uma string em static_routes cria varias rotas estaticas. A
   seguir, e mostrado um exemplo de adic,ao de rotas estaticas para as redes
   192.168.0.0/24 e 192.168.1.0/24:

 static_routes="net1 net2"
 route_net1="-net 192.168.0.0/24 192.168.0.1"
 route_net2="-net 192.168.1.0/24 192.168.1.1"

  31.2.3. Soluc,ao de problemas

   Quando um espac,o de enderec,amento e atribuido a uma rede, o provedor de
   servic,os configura suas tabelas de roteamento para que todo o trafego da
   rede seja enviado para o link do site. Mas como os sites externos sabem
   enviar seus pacotes para a rede do ISP?

   Existe um sistema que rastreia todos os espac,os de enderec,amento e
   define seu ponto de conexao com o backbone da Internet, ou as principais
   linhas que transportam o trafego da Internet pelo pais e pelo mundo. Cada
   maquina de backbone possui uma copia de um conjunto mestre de tabelas, que
   direciona o trafego de uma rede especifica para uma portadora de backbone
   especifica e, a partir dai, desce a cadeia de provedores de servic,os ate
   alcanc,ar uma determinada rede.

   E tarefa do provedor de servic,os anunciar aos sites de backbone que eles
   sao o ponto de conexao e, assim, o caminho para dentro de um site. Isso e
   conhecido como propagac,ao de rota.

   As vezes, ha um problema com a propagac,ao de rotas e alguns sites nao
   conseguem se conectar. Talvez o comando mais util para tentar descobrir
   onde o roteamento esta quebrando seja o traceroute. Ele e util quando o
   ping falha.

   Ao usar o traceroute , inclua o enderec,o do host remoto para se conectar.
   A saida mostrara os gateway ao longo do caminho da tentativa,
   eventualmente atingindo o host de destino ou encerrando devido `a falta de
   conexao. Para mais informac,oes, consulte traceroute(8).

  31.2.4. Considerac,oes sobre Multicast

   O FreeBSD suporta nativamente tanto aplicativos multicast e quanto
   roteamento multicast. Os aplicativos multicast nao exigem nenhuma
   configurac,ao especial para serem executados no FreeBSD. O suporte ao
   roteamento multicast requer que a seguinte opc,ao seja compilada em um
   kernel personalizado:

 options MROUTING

   O daemon de roteamento multicast, mrouted, pode ser instalado usando o
   pacote ou port net/mrouted. Este daemon implementa o protocolo de
   roteamento multicast DVMRP e e configurado editando o
   /usr/local/etc/mrouted.conf para configurar os tuneis e o DVMRP. A
   instalac,ao do mrouted tambem instala o map-mbone e o mrinfo, bem como
   suas paginas de manual associadas. Consulte estes documentos para exemplos
   de configurac,ao.

  Nota:

   O DVMRP foi amplamente substituido pelo protocolo PIM em muitas
   instalac,oes multicast. Consulte pim(4) para obter maiores informac,oes.

31.3. Rede sem fio

   Loader, Marc Fonvieille e Murray Stokely.

  31.3.1. Noc,oes basicas sobre redes sem fio

   A maioria das redes sem fio e baseada nos padroes IEEE(R)802.11. Uma rede
   sem fio basica consiste em varias estac,oes que se comunicam com radios
   que transmitem na banda de 2,4 GHz ou 5 GHz, embora isso varie de acordo
   com a localidade e tambem esteja mudando para permitir a comunicac,ao nas
   faixas de 2,3 GHz e 4,9 GHz.

   As redes 802.11 sao organizadas de duas maneiras. No modo de
   infra-estrutura, uma estac,ao atua como mestre para todas as outras
   estac,oes que se associam a ela, a rede e conhecida como BSS e a estac,ao
   mestre e denominada ponto de acesso. (AP). Em um BSS, toda a comunicac,ao
   passa pelo AP; mesmo quando uma estac,ao deseja se comunicar com outra
   estac,ao sem fio, as mensagens devem passar pelo AP. Na segunda forma de
   rede, nao ha mestre e as estac,oes se comunicam diretamente. Esta forma de
   rede e denominada IBSS e e comumente conhecida como uma rede ad-hoc.

   As redes 802.11 foram implantadas pela primeira vez na banda de 2,4 GHz
   usando protocolos definidos pelo padrao 802.11 e 802.11b da IEEE(R). Essas
   especificac,oes incluem as frequencias operacionais e as caracteristicas
   da camada MAC, incluindo as taxas de enquadramento e transmissao, pois a
   comunicac,ao pode ocorrer em varias taxas. Posteriormente, o padrao
   802.11a definiu a operac,ao na faixa de 5GHz, incluindo diferentes
   mecanismos de sinalizac,ao e taxas de transmissao mais altas. Mais tarde,
   o padrao 802.11g definiu o uso de mecanismos de sinalizac,ao e transmissao
   802.11a na banda de 2,4 GHz de modo a ser compativel com redes 802.11b.

   Separadas das tecnicas de transmissao basicas, as redes 802.11 possuem uma
   variedade de mecanismos de seguranc,a. As especificac,oes originais do
   802.11 definiam um protocolo de seguranc,a simples chamado WEP. Este
   protocolo usa uma chave pre-compartilhada fixa e a criptografia
   criptografica RC4 para codificar dados transmitidos em uma rede. Todas as
   estac,oes devem concordar com a chave fixa para se comunicar. Esse esquema
   mostrou-se de facil quebra e agora raramente e usado, exceto para
   desencorajar usuarios transitorios a se juntarem a uma rede. A pratica
   atual de seguranc,a e dada pela especificac,ao 802.11i do IEEE(R) que
   define novas cifras criptograficas e um protocolo adicional para
   autenticar estac,oes para um ponto de acesso e para trocar chaves para
   comunicac,ao de dados. As chaves criptograficas sao atualizadas
   periodicamente e existem mecanismos para detectar e combater tentativas de
   invasao. Outra especificac,ao de protocolo de seguranc,a comumente usada
   em redes sem fio e denominada WPA, que foi um precursor do 802.11i. O WPA
   especifica um subconjunto dos requisitos encontrados no 802.11i e foi
   projetado para implementac,ao em hardware legado. Especificamente, o WPA
   requer apenas a codificac,ao TKIP derivada da codificac,ao original WEP. O
   802.11i permite o uso do TKIP, mas tambem requer suporte para uma
   criptografia mais forte, o AES-CCM, para criptografar os dados. A
   codificac,ao AES nao era exigida no WPA porque foi considerada
   demasiadamente cara computacionalmente para ser executada em hardware
   legado.

   Um outro padrao a se ter em conta e o 802.11e. Ele define protocolos para
   a implantac,ao de aplicativos multimidia, como streaming de video e voz
   sobre IP (VoIP), em uma rede 802.11. Como o 802.11i, o 802.11e tambem tem
   uma especificac,ao de precursor denominada WME (posteriormente renomeada
   como WMM) que foi definida por um grupo industrial como um subconjunto do
   802.11e que pode ser implantado agora para habilitar aplicativos
   multimidia enquanto aguarda a ratificac,ao final do 802.11e. O mais
   importante a saber sobre o 802.11e e o WME/WMM e que ele permite o trafego
   prioritario atraves de uma rede sem fio atraves de protocolos de Qualidade
   de Servic,o (QoS) e protocolos de acesso de midia aprimorados. A
   implementac,ao adequada desses protocolos permite o aumento rapido de
   dados e o fluxo de trafego priorizado.

   O FreeBSD suporta redes que operam usando 802.11a, 802.11b e 802.11g. Os
   protocolos de seguranc,a WPA e 802.11i tambem sao suportados (em conjunto
   com qualquer um dos 11a, 11b e 11g) e o QoS e priorizac,ao de trafego
   exigidos pelo protocolo WME/WMM sao suportados por um conjunto limitado de
   dispositivos sem fio.

  31.3.2. Inicio Rapido

   Conectar um computador a uma rede sem fio existente e uma situac,ao muito
   comum. Este procedimento mostra as etapas necessarias.

    1. Obtenha o SSID (identificador de conjunto de servic,os) e PSK (chave
       pre-compartilhada) para a rede sem fio do administrador da rede.

    2. Identifique o adaptador sem fio. O kernel GENERIC do FreeBSD inclui
       drivers para muitos adaptadores sem fio comuns. Se o adaptador sem fio
       for um desses modelos, ele sera mostrado na saida do ifconfig(8):

 % ifconfig | grep -B3 -i wireless

       No FreeBSD 11 ou superior, use este comando:

 % sysctl net.wlan.devices

       Se um adaptador sem fio nao estiver listado, um modulo adicional do
       kernel pode ser necessario, ou pode ser um modelo nao suportado pelo
       FreeBSD.

       Este exemplo mostra o adaptador wireless Atheros ath0.

    3. Adicione uma entrada para esta rede ao /etc/wpa_supplicant.conf . Se o
       arquivo nao existir, crie-o. Substitua myssid e mypsk pelo SSID e PSK
       fornecidos pelo administrador da rede.

 network={
         ssid="myssid"
         psk="mypsk"
 }

    4. Adicione entradas ao /etc/rc.conf para configurar a rede na
       inicializac,ao:

 wlans_ath0="wlan0"
 ifconfig_wlan0="WPA SYNCDHCP"

    5. Reinicie o computador ou reinicie o servic,o de rede para conectar-se
       `a rede:

 # service netif restart

  31.3.3. Configurac,ao basica

    31.3.3.1. Configurac,ao do Kernel

   Para usar a rede sem fio, uma placa de rede sem fio e necessaria e o
   kernel precisa ser configurado com o suporte de rede sem fio apropriado. O
   kernel e separado em varios modulos para que apenas o suporte necessario
   precise ser configurado.

   Os dispositivos sem fio mais comumente usados sao aqueles que usam pec,as
   fabricadas pela Atheros. Estes dispositivos sao suportados pelo ath(4) e
   requerem que a seguinte linha seja adicionada ao /boot/loader.conf :

 if_ath_load="YES"

   O driver Atheros e dividido em tres partes separadas: o driver (ath(4)), a
   camada de suporte de hardware que lida com func,oes especificas do chip
   (ath_hal(4)) e um algoritmo para selecionar a taxa de transmissao de
   quadros. Quando este suporte e carregado como modulo do kernel, quaisquer
   dependencias sao tratadas automaticamente. Para carregar o suporte para um
   tipo diferente de dispositivo sem fio, especifique o modulo para esse
   dispositivo. Este exemplo e para dispositivos baseados no driver Intersil
   Prism parts (wi(4)):

 if_wi_load="YES"

  Nota:

   Os exemplos nesta sec,ao usam um dispositivoath(4) e o nome do dispositivo
   nos exemplos deve ser alterado de acordo com a configurac,ao. Uma lista de
   drivers sem fio disponiveis e adaptadores suportados pode ser encontrada
   nas Notas de Hardware do FreeBSD, disponiveis nas Informac,oes de Release
   da pagina do site do FreeBSD. Se um driver nativo do FreeBSD para o
   dispositivo sem fio nao existir, pode ser possivel usar o driver
   Windows(R) com a ajuda do wrapper de driver NDIS.

   Alem disso, os modulos que implementam o suporte criptografico para os
   protocolos de seguranc,a devem ser carregados. Estes destinam-se a ser
   dinamicamente carregados sob demanda pelo modulo wlan ( 4 ), mas por
   enquanto eles devem ser configurados manualmente. Os seguintes modulos
   estao disponiveis: wlan_wep(4), wlan_ccmp(4), e wlan_tkip(4). Os drivers
   wlan_ccmp(4) e wlan_tkip(4) sao necessario apenas ao usar os protocolos de
   seguranc,a WPA ou 802.11i. Se a rede nao usar criptografia, o suporte a
   wlan_wep(4) nao sera necessario. Para carregar estes modulos no momento da
   inicializac,ao, adicione as seguintes linhas ao /boot/loader.conf:

 wlan_wep_load="YES"
 wlan_ccmp_load="YES"
 wlan_tkip_load="YES"

   Uma vez que esta informac,ao tenha sido adicionada ao /boot/loader.conf,
   reinicie a caixa FreeBSD. Como alternativa, carregue os modulos
   manualmente usando kldload(8).

  Nota:

   Para usuarios que nao querem usar modulos, e possivel compilar esses
   drivers no kernel adicionando as seguintes linhas a um arquivo de
   configurac,ao de kernel personalizado:

 device wlan              # 802.11 support
 device wlan_wep          # 802.11 WEP support
 device wlan_ccmp         # 802.11 CCMP support
 device wlan_tkip         # 802.11 TKIP support
 device wlan_amrr         # AMRR transmit rate control algorithm
 device ath               # Atheros pci/cardbus NIC's
 device ath_hal           # pci/cardbus chip support
 options AH_SUPPORT_AR5416 # enable AR5416 tx/rx descriptors
 device ath_rate_sample   # SampleRate tx rate control for ath

   Com esta informac,ao no arquivo de configurac,ao do kernel, recompile o
   kernel e reinicie a maquina do FreeBSD.

   Informac,oes sobre o dispositivo sem fio devem aparecer nas mensagens de
   inicializac,ao, assim:

 ath0: <Atheros 5212> mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
 ath0: [ITHREAD]
 ath0: AR2413 mac 7.9 RF2413 phy 4.5

    31.3.3.2. Definindo a Regiao Correta

   Como a situac,ao regulatoria e diferente em varias partes do mundo, e
   necessario definir corretamente os dominios que se aplicam `a sua
   localizac,ao para obter as informac,oes corretas sobre quais canais podem
   ser usados.

   As definic,oes de regiao disponiveis podem ser encontradas em
   /etc/regdomain.xml. Para definir os dados em tempo de execuc,ao, use o
   ifconfig:

 # ifconfig wlan0 regdomain ETSI country AT

   Para persistir as configurac,oes, adicione-o ao /etc/rc.conf:

 # sysrc create_args_wlan0="country AT regdomain ETSI"

  31.3.4. Modo de Infraestrutura

   O modo de infra-estrutura (BSS) e o modo normalmente usado. Neste modo,
   varios pontos de acesso sem fio sao conectados a uma rede com fio. Cada
   rede sem fio tem seu proprio nome, chamado de SSID. Os clientes sem fio se
   conectam aos pontos de acesso sem fio.

    31.3.4.1. Clientes do FreeBSD

      31.3.4.1.1. Como encontrar pontos de acesso

   Para procurar redes disponiveis, use ifconfig(8). Essa solicitac,ao pode
   demorar alguns instantes para ser concluida, pois exige que o sistema
   alterne para cada frequencia sem fio disponivel e sonde os pontos de
   acesso disponiveis. Apenas o superusuario pode iniciar uma varredura:

 # ifconfig wlan0 create wlandev ath0
 # ifconfig wlan0 up scan
 SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
 dlinkap         00:13:46:49:41:76   11   54M -90:96   100 EPS  WPA WME
 freebsdap       00:11:95:c3:0d:ac    1   54M -83:96   100 EPS  WPA

  Nota:

   A interface deve estar up antes de poder efetuar a busca. Pedidos de
   varredura subsequentes nao exigem que a interface seja marcada como up
   novamente.

   A saida de uma solicitac,ao de varredura lista cada rede BSS/IBSS
   encontrada. Alem de listar o nome da rede, o SSID, a saida tambem mostra o
   BSSID, que e o enderec,o MAC do ponto de acesso. O campo CAPS identifica o
   tipo de cada rede e os recursos das estac,oes que operam la:

   Tabela 31.2. Codigos de capacidade da estac,ao

   Codigo de capacidade                      Significado                      
                        Conjunto de servic,os estendidos (ESS). Indica que a  
   E                    estac,ao faz parte de uma rede de infraestrutura em   
                        vez de uma rede IBSS/ad-hoc.                          
   I                    Rede IBSS/ad-hoc. Indica que a estac,ao faz parte de  
                        uma rede ad-hoc em vez de uma rede ESS.               
                        Privacidade. A criptografia e necessaria para todos   
   P                    os quadros de dados trocados dentro do BSS usando     
                        meios criptograficos como o WEP, o TKIP ou o          
                        AES-CCMP.                                             
                        Preambulo Curto. Indica que a rede esta usando        
                        preambulos curtos, definidos em 802.11b de Alta       
   S                    Taxa/DSSS PHYS, e utiliza um campo de sincronizac,ao  
                        de 56 bits em vez do campo de 128 bits usado no modo  
                        de preambulo longo.                                   
                        Tempo de slot curto. Indica que a rede 802.11g esta   
   s                    usando um tempo de slot curto porque nao ha estac,oes 
                        legadas (802.11b) presentes.                          

   Pode-se tambem exibir a lista atual de redes conhecidas com:

 # ifconfig wlan0 list scan

   Essas informac,oes podem ser atualizadas automaticamente pelo adaptador ou
   manualmente com uma solicitac,ao de scan. Dados antigos sao
   automaticamente removidos do cache, entao com o tempo essa lista pode
   diminuir a menos que mais varreduras sejam feitas.

      31.3.4.1.2. Configurac,oes basicas

   Esta sec,ao fornece um exemplo simples de como fazer com que o adaptador
   de rede sem fio funcione no FreeBSD sem criptografia. Uma vez
   familiarizado com esses conceitos, e altamente recomendavel usar o WPA
   para configurar a rede sem fio.

   Existem tres etapas basicas para configurar uma rede sem fio: selecionar
   um ponto de acesso, autenticar a estac,ao e configurar um enderec,o IP. As
   sec,oes a seguir discutem cada etapa.

        31.3.4.1.2.1. Selecionando um ponto de acesso

   Na maioria das vezes, e suficiente deixar o sistema escolher um ponto de
   acesso usando a heuristica integrada. Este e o comportamento padrao quando
   uma interface e marcada como up ou esta listada em /etc/rc.conf:

 wlans_ath0="wlan0"
 ifconfig_wlan0="DHCP"

   Se houver varios pontos de acesso, um especifico pode ser selecionado pelo
   seu SSID:

 wlans_ath0="wlan0"
 ifconfig_wlan0="ssid your_ssid_here DHCP"

   Em um ambiente em que ha varios pontos de acesso com o mesmo SSID, o que
   geralmente e feito para simplificar o roaming, talvez seja necessario
   associa-lo a um dispositivo especifico. Neste caso, o BSSID do ponto de
   acesso pode ser especificado, com ou sem o SSID:

 wlans_ath0="wlan0"
 ifconfig_wlan0="ssid your_ssid_here bssid xx:xx:xx:xx:xx:xx DHCP"

   Existem outras maneiras de restringir a escolha de um ponto de acesso,
   como limitar o conjunto de frequ:encias que o sistema fara a varredura.
   Isso pode ser util para uma placa sem fio de banda multipla, pois a
   varredura de todos os canais possiveis pode consumir muito tempo. Para
   limitar a operac,ao a uma banda especifica, use o parametro mode:

 wlans_ath0="wlan0"
 ifconfig_wlan0="mode 11g ssid your_ssid_here DHCP"

   Este exemplo forc,ara a placa a operar em 802.11g, que e definido apenas
   para frequ:encias de 2.4GHz, portanto, qualquer canal de 5GHz nao sera
   considerado. Isso tambem pode ser obtido com o parametro channel, que
   bloqueia a operac,ao para uma frequencia especifica, e o parametro
   chanlist, para especificar uma lista de canais para varredura. Maiores
   informac,oes sobre esses parametros podem ser encontradas em ifconfig(8).

        31.3.4.1.2.2. Autenticac,ao

   Quando um ponto de acesso e selecionado, a estac,ao precisa se autenticar
   antes de poder transmitir dados. A autenticac,ao pode acontecer de varias
   maneiras. O esquema mais comum, autenticac,ao aberta, permite que qualquer
   estac,ao entre na rede e se comunique. Essa e a autenticac,ao a ser usada
   para fins de teste na primeira vez em que uma rede sem fio e configurada.
   Outros esquemas exigem que os handshakes criptograficos sejam concluidos
   antes que o trafego de dados possa fluir, usando chaves ou segredos
   pre-compartilhados ou esquemas mais complexos que envolvam servic,os de
   back-end, como o RADIUS. Autenticac,ao aberta e a configurac,ao padrao. A
   proxima configurac,ao mais comum e o WPA-PSK, tambem conhecido como WPA
   Pessoal, que e descrito em Sec,ao 31.3.4.1.3.1, "WPA-PSK".

  Nota:

   Se estiver usando uma estac,ao base Extreme AirPort(R) da Apple(R) para um
   ponto de acesso, a autenticac,ao de chave compartilhada juntamente com um
   WEP chave precisa ser configurada. Isto pode ser configurado em
   /etc/rc.conf ou usando wpa_supplicant(8). Para uma unica estac,ao base
   AirPort(R), o acesso pode ser configurado com:

 wlans_ath0="wlan0"
 ifconfig_wlan0="authmode shared wepmode on weptxkey 1 wepkey 01234567 DHCP"

   Em geral, a autenticac,ao de chave compartilhada deve ser evitada porque
   ela usa o material de chave WEP de uma maneira altamente restrita,
   facilitando ainda mais a quebra da chave. Se o WEP deve ser usado para
   compatibilidade com dispositivos legados, e melhor usar o WEP com a
   autenticac,ao open. Mais informac,oes sobre o WEP podem ser encontradas em
   Sec,ao 31.3.4.1.4, "WEP".

        31.3.4.1.2.3. Obtendo um enderec,o IP com DHCP

   Quando um ponto de acesso e selecionado e os parametros de autenticac,ao
   sao definidos, um enderec,o IP deve ser obtido para se comunicar. Na
   maioria das vezes, o enderec,o IP e obtido atraves do DHCP. Para isso,
   edite o /etc/rc.conf e adicione o DHCP `a configurac,ao do dispositivo:

 wlans_ath0="wlan0"
 ifconfig_wlan0="DHCP"

   A interface sem fio esta agora pronta para subir:

 # service netif start

   Quando a interface estiver rodando, use o ifconfig(8) para ver o status da
   interface ath0:

 # ifconfig wlan0
 wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
         ether 00:11:95:d5:43:62
         inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
         media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
         status: associated
         ssid dlinkap channel 11 (2462 Mhz 11g) bssid 00:13:46:49:41:76
         country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
         scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
         roam:rate 5 protmode CTS wme burst

   A linha status: associated significa que esta conectada `a rede sem fio. O
   bssid 00:13:46:49:41:76 e o enderec,o MAC do ponto de acesso e o authmode
   OPEN indica que a comunicac,ao e nao criptografada.

        31.3.4.1.2.4. Enderec,o IP estatico

   Se um enderec,o IP nao puder ser obtido de um servidor DHCP, defina um
   enderec,o de IP fixo. Substitua a palavra-chave DHCP mostrada acima pelas
   informac,oes do enderec,o. Certifique-se de reter quaisquer outros
   parametros para selecionar o ponto de acesso:

 wlans_ath0="wlan0"
 ifconfig_wlan0="inet 192.168.1.100 netmask 255.255.255.0 ssid your_ssid_here"

      31.3.4.1.3. WPA

   O Wi-Fi Protected Access (WPA) e um protocolo de seguranc,a usado em
   conjunto com redes 802.11 para resolver a falta de autenticac,ao adequada
   e a fraqueza do WEP. O WPA utiliza o protocolo de autenticac,ao 802.1X e
   usa uma das varias codificac,oes disponiveis em vez do WEP para
   integridade de dados. A unica codificac,ao exigida pelo WPA e o protocolo
   de integridade de chave temporaria (TKIP). O TKIP e uma codificac,ao que
   estende a codificac,ao basica RC4 usada pelo WEP, adicionando verificac,ao
   de integridade, detecc,ao de adulterac,ao e medidas para responder a
   intrusoes detectadas. O TKIP foi projetado para funcionar em hardware
   legado apenas com uma modificac,ao de software. Ele representa um
   compromisso que melhora a seguranc,a, mas ainda nao e totalmente imune a
   ataques. O WPA tambem especifica a codificac,ao AES-CCMP como uma
   alternativa para o TKIP, e e preferivel quando possivel. Para esta
   especificac,ao, o termo WPA2 ou RSN e comumente usado.

   O WPA define protocolos de autenticac,ao e criptografia. A autenticac,ao e
   mais comumente feita usando uma de duas tecnicas: por 802.1X e um servic,o
   de autenticac,ao backend, como o RADIUS, ou por um handshake minimo entre
   a estac,ao e o ponto de acesso usando um segredo pre-compartilhado. O
   primeiro e comumente chamado de WPA Enterprise e o ultimo e conhecido como
   WPA Pessoal. Como a maioria das pessoas nao configurara um servidor
   backend RADIUS para sua rede sem fio, o WPA-PSK e de longe a configurac,ao
   mais comumente encontrada para o WPA .

   O controle da conexao sem fio e a negociac,ao ou autenticac,ao de chave
   com um servidor e feito usando o wpa_supplicant(8). Este programa requer
   um arquivo de configurac,ao, o /etc/wpa_supplicant.conf, para ser
   executado. Maiores informac,oes sobre este arquivo podem ser encontradas
   em wpa_supplicant.conf(5).

        31.3.4.1.3.1. WPA-PSK

   O WPA-PSK, tambem conhecido como WPA Pessoal, e baseado em uma chave
   pre-compartilhada (PSK) que e gerada a partir de uma determinada senha e
   usado como chave mestra na rede sem fio. Isso significa que todos os
   usuarios sem fio compartilharao a mesma chave. O WPA-PSK destina-se a
   redes pequenas em que o uso de um servidor de autenticac,ao nao e possivel
   ou desejado.

  Atenc,ao:

   Sempre use senhas fortes que sejam suficientemente longas e feitas de um
   alfabeto rico para que elas nao sejam facilmente adivinhadas ou atacadas.

   O primeiro passo e a configurac,ao do /etc/wpa_supplicant.conf com o SSID
   e a chave pre-compartilhada da rede:

 network={
   ssid="freebsdap"
   psk="freebsdmall"
 }

   Entao, em /etc/rc.conf, indique que a configurac,ao do dispositivo sem fio
   sera feita com o WPA e o enderec,o IP sera obtido com o DHCP:

 wlans_ath0="wlan0"
 ifconfig_wlan0="WPA DHCP"

   Entao, suba a interface:

 # service netif start
 Starting wpa_supplicant.
 DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
 DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
 DHCPOFFER from 192.168.0.1
 DHCPREQUEST on wlan0 to 255.255.255.255 port 67
 DHCPACK from 192.168.0.1
 bound to 192.168.0.254 -- renewal in 300 seconds.
 wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
       ether 00:11:95:d5:43:62
       inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
       media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
       status: associated
       ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
       country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
       AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
       bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
       wme burst roaming MANUAL

   Ou, tente configurar a interface manualmente usando as informac,oes em
   /etc/wpa_supplicant.conf:

 # wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf
 Trying to associate with 00:11:95:c3:0d:ac (SSID='freebsdap' freq=2412 MHz)
 Associated with 00:11:95:c3:0d:ac
 WPA: Key negotiation completed with 00:11:95:c3:0d:ac [PTK=CCMP GTK=CCMP]
 CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed (auth) [id=0 id_str=]

   A proxima operac,ao e iniciar o dhclient(8) para obter o enderec,o IP do
   servidor DHCP:

 # dhclient wlan0
 DHCPREQUEST on wlan0 to 255.255.255.255 port 67
 DHCPACK from 192.168.0.1
 bound to 192.168.0.254 -- renewal in 300 seconds.
 # ifconfig wlan0
 wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
       ether 00:11:95:d5:43:62
       inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
       media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
       status: associated
       ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
       country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
       AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
       bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
       wme burst roaming MANUAL

  Nota:

   Se o /etc/rc.conf tiver uma entrada ifconfig_wlan0="DHCP", dhclient(8)
   sera iniciado automaticamente apos o wpa_supplicant(8) associar-se ao
   ponto de acesso.

   Se o DHCP nao for possivel ou desejado, defina um enderec,o IP estatico
   apos o wpa_supplicant(8) autenticar a estac,ao:

 # ifconfig wlan0 inet 192.168.0.100 netmask 255.255.255.0
 # ifconfig wlan0
 wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
       ether 00:11:95:d5:43:62
       inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
       media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
       status: associated
       ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
       country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
       AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
       bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
       wme burst roaming MANUAL

   Quando o DHCP nao e usado, o gateway padrao e o servidor de nomes tambem
   precisam ser definidos manualmente:

 # route add default your_default_router
 # echo "nameserver your_DNS_server" >> /etc/resolv.conf

        31.3.4.1.3.2. WPA com EAP-TLS

   A segunda maneira de usar o WPA e com um servidor de autenticac,ao de
   backend 802.1X. Neste caso, o WPA e chamado de WPA Enterprise para
   diferencia-lo do WPA Pessoal menos seguro. A autenticac,ao no WPA
   Enterprise e baseada no protocolo de autenticac,ao extensivel (EAP).

   O EAP nao vem com um metodo de criptografia. Em vez disso, o EAP e
   incorporado dentro de um tunel criptografado. Existem muitos metodos de
   autenticac,ao EAP, mas o EAP-TLS, o EAP-TTLS e o EAP-PEAP sao os mais
   comum.

   O EAP com Seguranc,a da Camada de Transporte (EAP-TLS) e um protocolo de
   autenticac,ao sem fio bem suportado, ja que foi o primeiro metodo EAP a
   ser certificado pela WiFi Alliance. O EAP-TLS requer tres certificados
   para executar: o certificado da Autoridade de Certificac,ao (CA) instalado
   em todas as maquinas, o certificado do servidor para o servidor de
   autenticac,ao e um certificado de cliente para cada cliente sem fio. Nesse
   metodo EAP, o servidor de autenticac,ao e o cliente sem fio autenticam um
   ao outro apresentando seus respectivos certificados e, em seguida,
   verificam se esses certificados foram assinados pela CA da organizac,ao.

   Como anteriormente, a configurac,ao e feita atraves do
   /etc/wpa_supplicant.conf:

 network={
   ssid="freebsdap" 1
   proto=RSN  2
   key_mgmt=WPA-EAP 3
   eap=TLS 4
   identity="loader" 5
   ca_cert="/etc/certs/cacert.pem" 6
   client_cert="/etc/certs/clientcert.pem" 7
   private_key="/etc/certs/clientkey.pem" 8
   private_key_passwd="freebsdmallclient" 9
 }

   1 Este campo indica o nome da rede (SSID).                                 
   2 Este exemplo usa o protocolo 802.11i RSN IEEE(R), tambem conhecido como  
     WPA2.                                                                    
   3 A linha key_mgmt refere-se ao protocolo de gerenciamento de chaves a ser 
     usado. Neste exemplo, e o WPA usando a autenticac,ao EAP.                
   4 Este campo indica o metodo EAP para a conexao.                           
   5 O campo identity contem a sequencia de identidade para EAP.              
   6 O campo ca_cert indica o nome do caminho do arquivo de certificado CA.   
     Este arquivo e necessario para verificar o certificado do servidor.      
   7 A linha client_cert fornece o nome do caminho para o arquivo de          
     certificado do cliente. Este certificado e exclusivo para cada cliente   
     sem fio da rede.                                                         
   8 O campo private_key e o nome do caminho para o arquivo de chave privada  
     do certificado do cliente.                                               
   9 O campo private_key_passwd contem a frase secreta para a chave privada.  

   Em seguida, adicione as seguintes linhas ao /etc/rc.conf:

 wlans_ath0="wlan0"
 ifconfig_wlan0="WPA DHCP"

   O proximo passo e subir a interface:

 # service netif start
 Starting wpa_supplicant.
 DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
 DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
 DHCPACK from 192.168.0.20
 bound to 192.168.0.254 -- renewal in 300 seconds.
 wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
       ether 00:11:95:d5:43:62
       inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
       media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
       status: associated
       ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
       country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
       AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
       bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
       wme burst roaming MANUAL

   Tambem e possivel subir a interface manualmente usando wpa_supplicant(8) e
   ifconfig(8).

        31.3.4.1.3.3. WPA com EAP-TTLS

   Com o EAP-TLS, o servidor de autenticac,ao e o cliente precisam de um
   certificado. Com o EAP-TTLS, um certificado de cliente e opcional. Esse
   metodo e semelhante a um servidor da Web que cria um tunel seguro SSL,
   mesmo se os visitantes nao tiverem certificados do lado do cliente. O
   EAP-TTLS usa um tunel TLS criptografado para o transporte seguro dos dados
   de autenticac,ao.

   A configurac,ao necessaria pode ser adicionada ao
   /etc/wpa_supplicant.conf:

 network={
   ssid="freebsdap"
   proto=RSN
   key_mgmt=WPA-EAP
   eap=TTLS 1
   identity="test" 2
   password="test" 3
   ca_cert="/etc/certs/cacert.pem" 4
   phase2="auth=MD5" 5
 }

   1 Este campo especifica o metodo EAP para a conexao.                       
   2 O campo identity contem a sequencia de identidade para a autenticac,ao   
     EAP dentro do tunel TLS criptografado.                                   
   3 O campo password contem a senha para a autenticac,ao EAP.                
   4 O campo ca_cert indica o nome do caminho do arquivo de certificado CA.   
     Este arquivo e necessario para verificar o certificado do servidor.      
   5 Este campo especifica o metodo de autenticac,ao usado no tunel TLS       
     criptografado. Neste exemplo, o EAP com desafio MD5 e usado. A fase de   
     "inner authentication" e frequ:entemente chamada de "phase2".            

   Em seguida, adicione as seguintes linhas ao /etc/rc.conf:

 wlans_ath0="wlan0"
 ifconfig_wlan0="WPA DHCP"

   O proximo passo e subir a interface:

 # service netif start
 Starting wpa_supplicant.
 DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
 DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
 DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
 DHCPACK from 192.168.0.20
 bound to 192.168.0.254 -- renewal in 300 seconds.
 wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
       ether 00:11:95:d5:43:62
       inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
       media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
       status: associated
       ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
       country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
       AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
       bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
       wme burst roaming MANUAL

        31.3.4.1.3.4. WPA com EAP-PEAP

  Nota:

   O PEAPv0/EAP-MSCHAPv2 e o metodo PEAP mais comum. Neste capitulo, o termo
   PEAP e usado para se referir a esse metodo.

   O EAP protegido (PEAP) foi criado como uma alternativa ao EAP-TTLS e e o
   padrao mais usado do EAP apos o EAP-TLS. Em uma rede com sistemas
   operacionais mistos, o PEAP deve ser o padrao mais suportado apos o
   EAP-TLS.

   O PEAP e semelhante ao EAP-TTLS, pois usa um certificado do lado do
   servidor para autenticar clientes criando um tunel TLS criptografado entre
   o cliente e o servidor de autenticac,ao, que protege a troca subsequente
   das informac,oes de autenticac,ao. A autenticac,ao PEAP difere do
   EAP-TTLS, pois transmite o nome de usuario em texto aberto e somente a
   senha e enviada no tunel TLS criptografado. O EAP-TTLS usara o tunel TLS
   para o nome de usuario e para a senha.

   Adicione as seguintes linhas ao /etc/wpa_supplicant.conf para ajustar as
   configurac,oes relacionadas ao EAP-PEAP:

 network={
   ssid="freebsdap"
   proto=RSN
   key_mgmt=WPA-EAP
   eap=PEAP 1
   identity="test" 2
   password="test" 3
   ca_cert="/etc/certs/cacert.pem" 4
   phase1="peaplabel=0" 5
   phase2="auth=MSCHAPV2" 6
 }

   1 Este campo especifica o metodo EAP para a conexao.                       
   2 O campo identity contem a sequencia de identidade para a autenticac,ao   
     EAP dentro do tunel TLS criptografado.                                   
   3 O campo password contem a senha para a autenticac,ao EAP.                
   4 O campo ca_cert indica o nome do caminho do arquivo de certificado CA.   
     Este arquivo e necessario para verificar o certificado do servidor.      
   5 Este campo contem os parametros para a primeira fase de autenticac,ao, o 
     tunel TLS. De acordo com o servidor de autenticac,ao usado, especifique  
     um label especifico para autenticac,ao. Na maioria das vezes, o label    
     sera "client EAP encryption" que e definido usando peaplabel=0. Maiores  
     informac,oes podem ser encontradas em wpa_supplicant.conf(5).            
   6 Este campo especifica o protocolo de autenticac,ao usado no tunel TLS    
     criptografado. No caso do PEAP, e auth=MSCHAPV2.                         

   Adicione o seguinte ao /etc/rc.conf:

 wlans_ath0="wlan0"
 ifconfig_wlan0="WPA DHCP"

   Entao, suba a interface:

 # service netif start
 Starting wpa_supplicant.
 DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
 DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
 DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
 DHCPACK from 192.168.0.20
 bound to 192.168.0.254 -- renewal in 300 seconds.
 wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
       ether 00:11:95:d5:43:62
       inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
       media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
       status: associated
       ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
       country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
       AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
       bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
       wme burst roaming MANUAL

      31.3.4.1.4. WEP

   A privacidade equivalente com fio (WEP) faz parte do padrao 802.11
   original. Nao ha mecanismo de autenticac,ao, apenas uma forma fraca de
   controle de acesso que e facilmente quebrada.

   O WEP pode ser configurado usando o ifconfig(8):

 # ifconfig wlan0 create wlandev ath0
 # ifconfig wlan0 inet 192.168.1.100 netmask 255.255.255.0 \
             ssid my_net wepmode on weptxkey 3 wepkey 3:0x3456789012

     * O weptxkey especifica qual chave WEP sera usada na transmissao. Este
       exemplo usa a terceira chave. Isso deve corresponder `a configurac,ao
       no ponto de acesso. Quando nao tiver certeza de qual chave e usada
       pelo ponto de acesso, tente 1 (a primeira chave) para esse valor.

     * O wepkey seleciona uma das chaves WEP. Deve estar no formato
       index:key. A chave 1 e usada por padrao; o indice so precisa ser
       definido ao usar uma chave diferente da primeira.

  Nota:

       Substitua o 0x3456789012 com a chave configurada para uso no ponto de
       acesso.

   Consulte o ifconfig(8) para obter maiores informac,oes.

   O recurso wpa_supplicant(8) pode ser usado para configurar uma interface
   sem fio com o WEP. O exemplo acima pode ser configurado adicionando as
   seguintes linhas ao /etc/wpa_supplicant.conf:

 network={
   ssid="my_net"
   key_mgmt=NONE
   wep_key3=3456789012
   wep_tx_keyidx=3
 }

   Entao:

 # wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf
 Trying to associate with 00:13:46:49:41:76 (SSID='dlinkap' freq=2437 MHz)
 Associated with 00:13:46:49:41:76

  31.3.5. Modo Ad-hoc

   O modo IBSS, tambem chamado de modo ad-hoc, e projetado para conexoes
   ponto a ponto. Por exemplo, para estabelecer uma rede ad-hoc entre as
   maquinas A e B, escolha dois enderec,os IP e um SSID.

   Em A:

 # ifconfig wlan0 create wlandev ath0 wlanmode adhoc
 # ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap
 # ifconfig wlan0
   wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
           ether 00:11:95:c3:0d:ac
           inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
           media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <adhoc>
           status: running
           ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
           country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
           protmode CTS wme burst

   O parametro adhoc indica que a interface esta sendo executada no modo
   IBSS.

   B deve ser capaz de detectar A:

 # ifconfig wlan0 create wlandev ath0 wlanmode adhoc
 # ifconfig wlan0 up scan
   SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
   freebsdap       02:11:95:c3:0d:ac    2   54M -64:-96  100 IS   WME

   O I na saida confirma que A esta no modo ad-hoc. Agora, configure B com um
   enderec,o IP diferente:

 # ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap
 # ifconfig wlan0
   wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
           ether 00:11:95:d5:43:62
           inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
           media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <adhoc>
           status: running
           ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
           country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
           protmode CTS wme burst

   Ambos A e B agora estao prontos para trocar informac,oes.

  31.3.6. Pontos de Acesso com um host FreeBSD

   O FreeBSD pode atuar como um Access Point (AP), o que elimina a
   necessidade de comprar um hardware AP ou executar uma rede ad-hoc. Isso
   pode ser particularmente util quando uma maquina FreeBSD esta atuando como
   um gateway para outra rede, como a Internet.

    31.3.6.1. Configurac,oes basicas

   Antes de configurar uma maquina FreeBSD como um AP, o kernel deve ser
   configurado com o suporte de rede apropriado para a placa wireless assim
   como os protocolos de seguranc,a que estao sendo usados. Para maiores
   detalhes, veja Sec,ao 31.3.3, "Configurac,ao basica".

  Nota:

   O wrapper do driver NDIS para os drivers Windows(R) nao suporta atualmente
   a operac,ao AP. Somente os drivers nativos de rede sem fio do FreeBSD
   suportam o modo AP.

   Quando o suporte `a rede sem fio estiver carregado, verifique se o
   dispositivo sem fio oferece suporte ao modo de ponto de acesso baseado em
   host, tambem conhecido como modo hostap:

 # ifconfig wlan0 create wlandev ath0
 # ifconfig wlan0 list caps
 drivercaps=6f85edc1<STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG>
 cryptocaps=1f<WEP,TKIP,AES,AES_CCM,TKIPMIC>

   Esta saida exibe os recursos da placa. A palavra HOSTAP confirma que esta
   placa sem fio pode atuar como um AP. Diversas cifras suportadas tambem sao
   listadas: WEP, TKIP e AES. Esta informac,ao indica quais protocolos de
   seguranc,a podem ser usados no AP.

   O dispositivo sem fio so pode ser colocado no modo hostap durante a
   criac,ao do pseudo-dispositivo de rede, portanto, um dispositivo criado
   anteriormente deve ser destruido primeiro:

 # ifconfig wlan0 destroy

   e entao regenerado com a opc,ao correta antes de configurar os outros
   parametros:

 # ifconfig wlan0 create wlandev ath0 wlanmode hostap
 # ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1

   Use o ifconfig(8) novamente para ver o status da interface wlan0:

 # ifconfig wlan0
   wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
           ether 00:11:95:c3:0d:ac
           inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
           media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <hostap>
           status: running
           ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
           country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
           protmode CTS wme burst dtimperiod 1 -dfs

   O parametro hostap indica que a interface esta sendo executada no modo de
   ponto de acesso baseado em host.

   A configurac,ao da interface pode ser feita automaticamente no momento da
   inicializac,ao, adicionando as seguintes linhas ao /etc/rc.conf:

 wlans_ath0="wlan0"
 create_args_wlan0="wlanmode hostap"
 ifconfig_wlan0="inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1"

    31.3.6.2. Ponto de acesso baseado em host sem autenticac,ao ou criptografia

   Embora nao seja recomendado executar um AP sem nenhuma autenticac,ao ou
   criptografia, esta e uma maneira simples de verificar se o AP esta
   funcionando. Essa configurac,ao tambem e importante para depurar problemas
   do cliente.

   Quando o AP estiver configurado, inicie uma verificac,ao de outra maquina
   sem fio para encontrar o AP:

 # ifconfig wlan0 create wlandev ath0
 # ifconfig wlan0 up scan
 SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
 freebsdap       00:11:95:c3:0d:ac    1   54M -66:-96  100 ES   WME

   A maquina cliente encontrou o AP e pode ser associado a ele:

 # ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap
 # ifconfig wlan0
   wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
           ether 00:11:95:d5:43:62
           inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
           media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
           status: associated
           ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
           country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
           scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
           roam:rate 5 protmode CTS wme burst

    31.3.6.3. Ponto de acesso baseado em host com WPA2

   Esta sec,ao se concentra na configurac,ao de um ponto de acesso do FreeBSD
   usando o protocolo de seguranc,a WPA2. Maiores detalhes sobre WPA e a
   configurac,ao de clientes sem fio baseados em WPA podem ser encontrados em
   Sec,ao 31.3.4.1.3, "WPA".

   O daemon hostapd(8) e usado para lidar com a autenticac,ao de clientes e o
   gerenciamento de chaves no AP com WPA2 habilitado.

   As seguintes operac,oes de configurac,ao sao executadas na maquina FreeBSD
   atuando como o AP. Uma vez que o AP esteja funcionando corretamente, o
   hostapd(8) pode ser iniciado automaticamente na inicializac,ao com essa
   linha em /etc/rc.conf:

 hostapd_enable="YES"

   Antes de tentar configurar o hostapd(8), primeiro defina as configurac,oes
   basicas introduzidas em Sec,ao 31.3.6.1, "Configurac,oes basicas" .

      31.3.6.3.1. WPA2-PSK

   O WPA2-PSK destina-se a redes pequenas em que o uso de um servidor de
   autenticac,ao backend nao e possivel ou desejado.

   A configurac,ao e feita em /etc/hostapd.conf:

 interface=wlan0                  1
 debug=1                          2
 ctrl_interface=/var/run/hostapd  3
 ctrl_interface_group=wheel       4
 ssid=freebsdap                   5
 wpa=2                            6
 wpa_passphrase=freebsdmall       7
 wpa_key_mgmt=WPA-PSK             8
 wpa_pairwise=CCMP                9

   1 Interface sem fio usada para o ponto de acesso.                          
   2 Nivel de detalhamento usado durante a execuc,ao de hostapd(8). Um valor  
     de 1 representa o nivel minimo.                                          
   3 Nome do caminho de diretorio usado pelo hostapd(8) para armazenar        
     arquivos de soquete de dominio para comunicac,ao com programas externos, 
     como hostapd_cli(8). O valor padrao e usado neste exemplo.               
   4 O grupo permitiu acessar os arquivos da interface de controle.           
   5 O nome da rede sem fio, ou SSID, que aparecera nas varreduras sem fio.   
   6 Ative o WPA e especifique qual protocolo de autenticac,ao WPA sera       
     necessario. Um valor de 2 configura o AP para WPA2 e e recomendado.      
     Defina como 1 apenas se o WPA obsoleto for necessario.                   
   7 Senha ASCII para autenticac,ao WPA.                                      
                                                                              
       Atenc,ao:                                                              
                                                                              
     Sempre use senhas fortes com pelo menos 8 caracteres de comprimento e    
     feitas de um alfabeto rico, para que elas nao sejam facilmente           
     adivinhadas ou atacadas.                                                 
   8 O protocolo de gerenciamento de chaves a ser usado. Este exemplo define  
     o WPA-PSK.                                                               
   9 Algoritmos de criptografia aceitos pelo ponto de acesso. Neste exemplo,  
     apenas a codificac,ao CCMP (AES) e aceita. O CCMP e uma alternativa ao   
     TKIP e e fortemente preferido quando possivel. O TKIP so deve ser        
     permitido quando houver estac,oes incapazes de usar o CCMP.              

   O proximo passo e iniciar hostapd(8):

 # service hostapd forcestart

 # ifconfig wlan0
 wlan0: flags=8943<UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST> metric 0 mtu 1500
         ether 04:f0:21:16:8e:10
         inet6 fe80::6f0:21ff:fe16:8e10%wlan0 prefixlen 64 scopeid 0x9
         nd6 options=21<PERFORMNUD,AUTO_LINKLOCAL>
         media: IEEE 802.11 Wireless Ethernet autoselect mode 11na <hostap>
         status: running
         ssid No5ignal channel 36 (5180 MHz 11a ht/40+) bssid 04:f0:21:16:8e:10
         country US ecm authmode WPA2/802.11i privacy MIXED deftxkey 2
         AES-CCM 2:128-bit AES-CCM 3:128-bit txpower 17 mcastrate 6 mgmtrate 6
         scanvalid 60 ampdulimit 64k ampdudensity 8 shortgi wme burst
         dtimperiod 1 -dfs
         groups: wlan

   Quando o AP esta em execuc,ao, os clientes podem associar-se a ele. Veja
   Sec,ao 31.3.4.1.3, "WPA" para maiores detalhes. E possivel ver as
   estac,oes associadas ao AP usando o ifconfig wlan0 list sta.

    31.3.6.4. Ponto de acesso baseado em host WEP

   Nao e recomendado o uso do WEP para configurar um AP, ja que nao ha
   mecanismo de autenticac,ao e a criptografia e facilmente quebrada. Algumas
   placas sem fio legadas suportam apenas o WEP e essas placas suportarao
   apenas um AP sem autenticac,ao ou criptografia.

   O dispositivo sem fio agora pode ser colocado no modo hostap e configurado
   com o enderec,o SSID e IP corretos:

 # ifconfig wlan0 create wlandev ath0 wlanmode hostap
 # ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 \
         ssid freebsdap wepmode on weptxkey 3 wepkey 3:0x3456789012 mode 11g

     * O weptxkey indica qual a chave WEP sera usada na transmissao. Este
       exemplo usa a terceira chave, pois a numerac,ao de chaves comec,a com
       1. Esse parametro deve ser especificado para criptografar os dados.

     * O wepkey define a chave WEP selecionada. Ela deve estar no formato
       index:key. Se o indice nao for fornecido, a chave 1 sera configurada.
       O indice precisa ser definido ao usar chaves diferentes da primeira
       chave.

   Use o ifconfig(8) para ver o status da interface wlan0:

 # ifconfig wlan0
   wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
           ether 00:11:95:c3:0d:ac
           inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
           media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <hostap>
           status: running
           ssid freebsdap channel 4 (2427 Mhz 11g) bssid 00:11:95:c3:0d:ac
           country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
           txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 -dfs

   De uma outra maquina sem fio, agora e possivel iniciar uma varredura para
   encontrar o AP:

 # ifconfig wlan0 create wlandev ath0
 # ifconfig wlan0 up scan
 SSID            BSSID              CHAN RATE  S:N   INT CAPS
 freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS

   Neste exemplo, a maquina cliente encontrou o AP e pode associa-lo usando
   os parametros corretos. Veja Sec,ao 31.3.4.1.4, "WEP" para maiores
   detalhes.

  31.3.7. Usando conexoes com fio e sem fio

   Uma conexao com fio oferece melhor desempenho e confiabilidade, enquanto
   uma conexao sem fio fornece flexibilidade e mobilidade. Os usuarios de
   laptop normalmente querem se movimentar perfeitamente entre os dois tipos
   de conexao.

   No FreeBSD, e possivel combinar duas ou mais interfaces de rede em um
   "failover". Esse tipo de configurac,ao usa a conexao mais prioritaria e
   disponivel de um grupo de interfaces de rede, e o sistema operacional
   alterna automaticamente quando o estado do link e alterado.

   A agregac,ao de links e o failover sao cobertos em Sec,ao 31.7,
   "Agregac,ao de links e failover" e um exemplo para usar conexoes com e sem
   fio e fornecido em Exemplo 31.3, "Modo de failover entre interfaces
   Ethernet e sem fio".

  31.3.8. Soluc,ao de problemas

   Esta sec,ao descreve varias etapas para ajudar a solucionar problemas
   comuns de rede sem fio.

     * Se o ponto de acesso nao estiver listado durante a verificac,ao,
       verifique se a configurac,ao nao limitou o dispositivo sem fio a um
       conjunto limitado de canais.

     * Se o dispositivo nao puder se associar a um ponto de acesso, verifique
       se a configurac,ao corresponde `as configurac,oes no ponto de acesso.
       Isso inclui o esquema de autenticac,ao e qualquer protocolo de
       seguranc,a. Simplifique a configurac,ao tanto quanto possivel. Se
       estiver usando um protocolo de seguranc,a, como o WPA ou o WEP,
       configure o ponto de acesso para autenticac,ao aberta e nenhuma
       seguranc,a para ver se o trafego ira passar.

       O suporte a depurac,ao e fornecido pelo wpa_supplicant(8). Tente
       executar este utilitario manualmente com a opc,ao -dd e examine os
       logs do sistema.

     * Uma vez que o sistema possa se associar com o ponto de acesso,
       diagnostique a configurac,ao da rede usando ferramentas como o
       ping(8).

     * Existem muitas ferramentas de depurac,ao de nivel inferior. As
       mensagens de depurac,ao podem ser ativadas na camada de suporte do
       protocolo 802.11 usando o wlandebug(8). Por exemplo, para habilitar
       mensagens do console relacionadas `a varredura de pontos de acesso e
       aos handshakes do protocolo 802.11 necessarios para organizar a
       comunicac,ao:

 # wlandebug -i wlan0 +scan+auth+debug+assoc
   net.wlan.0.debug: 0 => 0xc80000<assoc,auth,scan>

       Muitas estatisticas uteis sao mantidas pela camada 802.11 e o
       wlanstats, encontrado em /usr/src/tools/tools/net80211, vai despejar
       esta informac,ao. Essas estatisticas devem exibir todos os erros
       identificados pela camada 802.11. No entanto, alguns erros sao
       identificados nos drivers de dispositivo que estao abaixo da camada
       802.11, portanto eles podem nao aparecer. Para diagnosticar problemas
       especificos do dispositivo, consulte a documentac,ao do driver.

   Se as informac,oes acima nao ajudarem a esclarecer o problema, envie um
   relatorio de problemas e inclua a saida das ferramentas acima.

31.4. USB Tethering

   Muitos telefones celulares oferecem a opc,ao de compartilhar sua conexao
   de dados sobre o USB (muitas vezes chamado de "tethering"). Este recurso
   usa o RNDIS, CDC ou um protocolo personalizado Apple(R) iPhone(R)/iPad(R).

     * Os dispositivos Android(TM) geralmente utilizam o driver urndis(4).

     * Os dispositivos Apple(R) utilizam o driver ipheth(4).

     * Dispositivos mais antigos geralmente utilizam o driver cdce(4).

   Antes de conectar um dispositivo, carregue o driver apropriado no kernel:

 # kldload if_urndis
 # kldload if_cdce
 # kldload if_ipheth

   Uma vez que o dispositivo esteja conectado, ue0 estara disponivel para uso
   como um dispositivo de rede normal. Certifique-se de que a opc,ao "USB
   Tethering" esteja ativada no dispositivo.

   Para tornar essa alterac,ao permanente e carregar o driver como um modulo
   no momento da inicializac,ao, coloque a linha apropriada abaixo em
   /boot/loader.conf:

 if_urndis_load="YES"
 if_cdce_load="YES"
 if_ipheth_load="YES"

31.5. Bluetooth

   Escrito por Pav Lucistnik .

   O bluetooth e uma tecnologia sem fio para a criac,ao de redes pessoais que
   operam na faixa nao licenciada de 2,4 GHz, com um alcance de 10 metros. As
   redes geralmente sao formadas em modo ad-hoc a partir de dispositivos
   portateis, como telefones celulares, computadores de mao e laptops. Ao
   contrario da tecnologia sem fio Wi-Fi, o Bluetooth oferece perfis de
   servic,os de nivel superior, como servidores de arquivos semelhantes ao
   FTP, envio de arquivos, transporte de voz, emulac,ao de linha serial e
   muito mais.

   Esta sec,ao descreve o uso de um dongle Bluetooth USB em um sistema
   FreeBSD. Em seguida, descreve os varios protocolos e utilitarios
   Bluetooth.

  31.5.1. Carregando o Suporte Bluetooth

   A pilha Bluetooth no FreeBSD e implementada usando o framework
   netgraph(4). Uma ampla variedade de dongles Bluetooth USB e suportada pelo
   ng_ubt(4). Os dispositivos Bluetooth baseados no Broadcom BCM2033 sao
   suportados pelos drivers ubtbcmfw(4) e ng_ubt(4). A placa 3Com Bluetooth
   PC Card 3CRWB60-A e suportada pelo driver ng_bt3c(4). Dispositivos
   Bluetooth baseados em Portas Seriais e UART sao suportados por sio(4),
   ng_h4(4), e hcseriald(8).

   Antes de conectar um dispositivo, determine qual dos drivers acima ele usa
   e, em seguida, carregue o driver. Por exemplo, se o dispositivo usar o
   driver ng_ubt(4):

 # kldload ng_ubt

   Se o dispositivo Bluetooth for conectado ao sistema durante a
   inicializac,ao do sistema, o sistema pode ser configurado para carregar o
   modulo no momento da inicializac,ao, adicionando o driver ao
   /boot/loader.conf:

 ng_ubt_load="YES"

   Quando o driver estiver carregado, conecte o dongle USB. Se a carga do
   driver tiver sido bem-sucedida, uma saida semelhante `a seguinte deve
   aparecer no console e em /var/log/messages:

 ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
 ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
 ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
       wMaxPacketSize=49, nframes=6, buffer size=294

   Para iniciar e parar a stack Bluetooth, use seu script de inicializac,ao.
   E uma boa ideia parar a stack antes de desconectar o dispositivo. Iniciar
   a stack bluetooth pode exigir que o hcsecd(8) seja iniciado. Ao iniciar a
   stack, a saida deve ser semelhante `a seguinte:

 # service bluetooth start ubt0
 BD_ADDR: 00:02:72:00:d4:1a
 Features: 0xff 0xff 0xf 00 00 00 00 00
 <3-Slot> <5-Slot> <Encryption> <Slot offset>
 <Timing accuracy> <Switch> <Hold mode> <Sniff mode>
 <Park mode> <RSSI> <Channel quality> <SCO link>
 <HV2 packets> <HV3 packets> <u-law log> <A-law log> <CVSD>
 <Paging scheme> <Power control> <Transparent SCO data>
 Max. ACL packet size: 192 bytes
 Number of ACL packets: 8
 Max. SCO packet size: 64 bytes
 Number of SCO packets: 8

  31.5.2. Encontrando outros dispositivos Bluetooth

   A Interface do Controlador do Host (HCI) fornece um metodo uniforme para
   acessar os recursos de banda basica do Bluetooth. No FreeBSD, um no
   netgraph HCI e criado para cada dispositivo Bluetooth. Para mais detalhes,
   consulte ng_hci(4).

   Uma das tarefas mais comuns e a descoberta de dispositivos Bluetooth
   dentro da proximidade RF. Esta operac,ao e chamada inquiry. Investigac,ao
   e outras operac,oes relacionadas a HCI sao feitas usando hccontrol(8). O
   exemplo abaixo mostra como descobrir quais dispositivos Bluetooth estao ao
   alcance. A lista de dispositivos deve ser exibida em alguns segundos. Note
   que um dispositivo remoto so ira responder a pergunta se estiver
   configurado para o modo detectavel.

 % hccontrol -n ubt0hci inquiry
 Inquiry result, num_responses=1
 Inquiry result #0
        BD_ADDR: 00:80:37:29:19:a4
        Page Scan Rep. Mode: 0x1
        Page Scan Period Mode: 00
        Page Scan Mode: 00
        Class: 52:02:04
        Clock offset: 0x78ef
 Inquiry complete. Status: No error [00]

   O BD_ADDR e o enderec,o exclusivo de um dispositivo Bluetooth, semelhante
   ao enderec,o MAC de uma placa de rede. Este enderec,o e necessario para
   uma comunicac,ao posterior com um dispositivo e e possivel atribuir um
   nome legivel a um BD_ADDR. Informac,oes sobre os hosts Bluetooth
   conhecidos estao contidas em /etc/bluetooth/hosts. O exemplo a seguir
   mostra como obter o nome legivel que foi atribuido ao dispositivo remoto:

 % hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4
 BD_ADDR: 00:80:37:29:19:a4
 Name: Pav's T39

   Se uma consulta for realizada em um dispositivo Bluetooth remoto, ele
   encontrara o computador como "your.host.name (ubt0)". O nome atribuido ao
   dispositivo local pode ser alterado a qualquer momento.

   Dispositivos remotos podem receber aliases em /etc/bluetooth/hosts.
   Maiores informac,oes sobre o arquivo /etc/bluetooth/hosts podem ser
   encontradas em bluetooth.hosts(5).

   O sistema Bluetooth fornece uma conexao ponta-a-ponto entre duas unidades
   Bluetooth ou uma conexao ponto-a-multiponto que e compartilhada entre
   varios dispositivos Bluetooth. O exemplo a seguir mostra como criar uma
   conexao a um dispositivo remoto:

 % hccontrol -n ubt0hci create_connection BT_ADDR

   O create_connection aceita BT_ADDR, bem como aliases de host em
   /etc/bluetooth/hosts.

   O exemplo a seguir mostra como obter a lista de conexoes de banda base
   ativas para o dispositivo local:

 % hccontrol -n ubt0hci read_connection_list
 Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
 00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN

   Um identificador de conexao e util quando a finalizac,ao da conexao de
   banda base e necessaria, embora normalmente nao seja necessario fazer isso
   manualmente. A stack terminara automaticamente as conexoes de banda basica
   inativas.

 # hccontrol -n ubt0hci disconnect 41
 Connection handle: 41
 Reason: Connection terminated by local host [0x16]

   Digite hccontrol help para obter uma lista completa dos comandos HCI
   disponiveis. A maioria dos comandos HCI nao requer privilegios de
   superusuario.

  31.5.3. Emparelhamento de dispositivos

   Por padrao, a comunicac,ao Bluetooth nao e autenticada e qualquer
   dispositivo pode conversar com qualquer outro dispositivo. Um dispositivo
   Bluetooth, como um telefone celular, pode optar por exigir autenticac,ao
   para fornecer um servic,o especifico. A autenticac,ao Bluetooth e
   normalmente feita com um PIN code, uma string ASCII com ate 16 caracteres
   de comprimento. O usuario e obrigado a digitar o mesmo codigo de PIN em
   ambos os dispositivos. Depois que o usuario inserir o codigo de PIN, ambos
   os dispositivos gerarao uma chave de link. Depois disso, a chave de link
   pode ser armazenada nos dispositivos ou em um armazenamento persistente.
   Na proxima vez, os dois dispositivos usarao a chave de link gerada
   anteriormente. Este procedimento e chamado de emparelhamento. Observe que,
   se a chave de link for perdida por um dos dispositivos, o emparelhamento
   devera ser repetido.

   O daemon hcsecd(8) e responsavel por tratar os pedidos de autenticac,ao
   Bluetooth. O arquivo de configurac,ao padrao e o
   /etc/bluetooth/hcsecd.conf. Uma sec,ao de exemplo para um telefone celular
   com o codigo PIN definido como 1234 e mostrada abaixo:

 device {
         bdaddr  00:80:37:29:19:a4;
         name    "Pav's T39";
         key     nokey;
         pin     "1234";
       }

   A unica limitac,ao nos codigos de PIN e o comprimento. Alguns
   dispositivos, como fones de ouvido Bluetooth, podem ter um codigo PIN
   integrado fixo. A opc,ao -d forc,a o hcsecd(8) a ficar em primeiro plano,
   entao e facil ver o que esta acontecendo. Configure o dispositivo remoto
   para receber o emparelhamento e inicie a conexao Bluetooth ao dispositivo
   remoto. O dispositivo remoto deve indicar que o pareamento foi aceito e
   solicitar o codigo de PIN. Digite o mesmo codigo de PIN listado em
   hcsecd.conf. Agora o computador e o dispositivo remoto estao emparelhados.
   Alternativamente, o emparelhamento pode ser iniciado no dispositivo
   remoto.

   A seguinte linha pode ser adicionada ao /etc/rc.conf para configurar o
   hcsecd(8) para iniciar automaticamente quando o sistema inicializar:

 hcsecd_enable="YES"

   A seguir, um exemplo da saida do daemon hcsecd(8):

 hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
 hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
 hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
 hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
 hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
 hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4

  31.5.4. Acesso `a rede com perfis PPP

   Um perfil de rede dial-up (DUN) pode ser usado para configurar um telefone
   celular como um modem sem fio para a conexao a um servidor de acesso `a
   Internet dial-up. Tambem pode ser usado para configurar um computador para
   receber chamadas de dados de um telefone celular.

   O acesso `a rede com um perfil PPP pode ser usado para fornecer acesso LAN
   a um unico dispositivo Bluetooth ou a varios dispositivos Bluetooth. Ele
   tambem pode fornecer uma conexao PC para PC usando uma rede PPP sobre uma
   emulac,ao de cabo serial.

   No FreeBSD, esses perfis sao implementados com o ppp(8) e o wrapper
   rfcomm_pppd(8) que converte uma conexao Bluetooth em algo que o PPP pode
   usar. Antes que um perfil possa ser usado, um novo label PPP deve ser
   criado em /etc/ppp/ppp.conf. Consulte rfcomm_pppd(8) para exemplos.

   Neste exemplo, o rfcomm_pppd(8) e usado para abrir uma conexao com um
   dispositivo remoto com um BD_ADDR de 00:80:37:29:19:a4 em um canal DUN
   RFCOMM:

 # rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup

   O numero real do canal sera obtido a partir do dispositivo remoto usando o
   protocolo SDP. E possivel especificar manualmente o canal RFCOMM e, nesse
   caso, o rfcomm_pppd(8) nao executara a consulta SDP. Use o sdpcontrol(8)
   para descobrir o canal RFCOMM no dispositivo remoto.

   Para fornecer acesso `a rede com o servic,o PPP LAN, o sdpd(8) precisa
   estar sendo executado e uma nova entrada para clientes LAN deve ser criada
   em /etc/ppp/ppp.conf. Consulte rfcomm_pppd(8) para exemplos. Por fim,
   inicie o servidor RFCOMM PPP em um numero de canal RFCOMM valido. O
   servidor RFCOMM PPP registrara automaticamente o servic,o Bluetooth LAN
   com o daemon local SDP. O exemplo abaixo mostra como iniciar o servidor
   RFCOMM PPP.

 # rfcomm_pppd -s -C 7 -l rfcomm-server

  31.5.5. Protocolos Bluetooth

   Esta sec,ao fornece uma visao geral dos varios protocolos Bluetooth, suas
   func,oes e utilitarios associados.

    31.5.5.1. Controle de Link Logico e Protocolo de Adaptac,ao (L2CAP)

   O Protocolo de Adaptac,ao e Controle de Link Logico (L2CAP) fornece
   servic,os de dados orientados a conexao e sem conexao para protocolos de
   camada superior. O L2CAP permite que protocolos e aplicativos de alto
   nivel transmitam e recebam pacotes de dados L2CAP de ate 64 kilobytes de
   comprimento.

   O L2CAP e baseado no conceito de canais. Um canal e uma conexao logica em
   cima de uma conexao de banda base, na qual cada canal e vinculado a um
   unico protocolo de maneira many-to-one. Varios canais podem ser vinculados
   ao mesmo protocolo, mas um canal nao pode ser vinculado a varios
   protocolos. Cada pacote L2CAP recebido em um canal e direcionado para o
   protocolo apropriado de nivel superior. Varios canais podem compartilhar a
   mesma conexao de banda base.

   No FreeBSD, um no netgraph L2CAP e criado para cada dispositivo Bluetooth.
   Esse no e normalmente conectado ao no Bluetooth HCI downstream e aos nos
   de soquete Bluetooth upstream. O nome padrao para o no L2CAP e
   "devicel2cap". Para mais detalhes, consulte ng_l2cap(4).

   Um comando util e o l2ping(8), que pode ser usado para executar ping em
   outros dispositivos. Algumas implementac,oes Bluetooth podem nao retornar
   todos os dados enviados para elas, portanto, a saida 0 bytes no exemplo a
   seguir e normal.

 # l2ping -a 00:80:37:29:19:a4
 0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
 0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
 0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
 0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0

   O utilitario l2control(8) e usado para executar varias operac,oes em nos
   L2CAP. Este exemplo mostra como obter a lista de conexoes logicas (canais)
   e a lista de conexoes de banda base para o dispositivo local:

 % l2control -a 00:02:72:00:d4:1a read_channel_list
 L2CAP channels:
 Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
 00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
 % l2control -a 00:02:72:00:d4:1a read_connection_list
 L2CAP connections:
 Remote BD_ADDR    Handle Flags Pending State
 00:07:e0:00:0b:ca     41 O           0 OPEN

   Outra ferramenta de diagnostico e o btsockstat(1). Ele e semelhante ao
   netstat(1), mas para estruturas de dados relacionadas `a rede Bluetooth. O
   exemplo abaixo mostra a mesma conexao logica que l2control(8) acima.

 % btsockstat
 Active L2CAP sockets
 PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
 c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
 Active RFCOMM sessions
 L2PCB    PCB      Flag MTU   Out-Q DLCs State
 c2afe900 c2b53380 1    127   0     Yes  OPEN
 Active RFCOMM sockets
 PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
 c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN

    31.5.5.2. Comunicac,ao por radiofrequencia (RFCOMM)

   O protocolo RFCOMM fornece emulac,ao de portas seriais sobre o protocolo
   L2CAP. O RFCOMM e um protocolo de transporte simples, com disposic,oes
   adicionais para emular os 9 circuitos das portas seriais RS-232
   (EIATIA-232-E). Suporta ate 60 conexoes simultaneas (canais RFCOMM) entre
   dois dispositivos Bluetooth.

   Para fins do RFCOMM, um caminho de comunicac,ao completo envolve dois
   aplicativos em execuc,ao nos terminais de comunicac,ao com um segmento de
   comunicac,ao entre eles. O RFCOMM destina-se a abranger aplicativos que
   fazem uso das portas seriais dos dispositivos em que residem. O segmento
   de comunicac,ao e um link Bluetooth de conexao direta de um dispositivo
   para outro.

   O RFCOMM esta relacionado apenas com a conexao entre os dispositivos no
   caso de conexao direta ou entre o dispositivo e um modem no caso de rede.
   O RFCOMM pode suportar outras configurac,oes, como modulos que se
   comunicam via tecnologia sem fio Bluetooth de um lado e fornecem uma
   interface com fio no outro lado.

   No FreeBSD, o RFCOMM e implementado na camada de sockets do Bluetooth.

    31.5.5.3. Protocolo de Descoberta de Servic,os (SDP)

   O Protocolo de Descoberta de Servic,os (SDP) fornece os meios para os
   aplicativos clientes descobrirem a existencia de servic,os fornecidos por
   aplicativos de servidor, bem como os atributos desses servic,os. Os
   atributos de um servic,o incluem o tipo ou classe de servic,o oferecido e
   as informac,oes de mecanismo ou protocolo necessarias para utilizar o
   servic,o.

   O SDP envolve a comunicac,ao entre um servidor SDP e um cliente SDP. O
   servidor mantem uma lista de registros de servic,o que descrevem as
   caracteristicas dos servic,os associados ao servidor. Cada registro de
   servic,o contem informac,oes sobre um unico servic,o. Um cliente pode
   recuperar informac,oes de um registro de servic,o mantido pelo servidor
   SDP emitindo uma solicitac,ao SDP. Se o cliente, ou um aplicativo
   associado ao cliente, decidir usar um servic,o, ele devera abrir uma
   conexao separada com o provedor de servic,os para utilizar o servic,o. O
   SDP fornece um mecanismo para descobrir servic,os e seus atributos, mas
   nao fornece um mecanismo para utilizar esses servic,os.

   Normalmente, um cliente SDP procura servic,os baseados em algumas
   caracteristicas desejadas dos servic,os. No entanto, ha momentos em que e
   desejavel descobrir quais tipos de servic,os sao descritos pelos registros
   de servic,o de um servidor SDP, sem qualquer informac,ao previa sobre os
   servic,os. Este processo de procurar por qualquer servic,o oferecido e
   chamado de navegac,ao.

   O servidor Bluetooth SDP, sdpd(8) e o cliente de linha de comandos,
   sdpcontrol(8), estao incluidos na instalac,ao padrao do FreeBSD. O exemplo
   a seguir mostra como executar uma consulta de navegac,ao SDP.

 % sdpcontrol -a 00:01:03:fc:6e:ec browse
 Record Handle: 00000000
 Service Class ID List:
         Service Discovery Server (0x1000)
 Protocol Descriptor List:
         L2CAP (0x0100)
                 Protocol specific parameter #1: u/int/uuid16 1
                 Protocol specific parameter #2: u/int/uuid16 1

 Record Handle: 0x00000001
 Service Class ID List:
         Browse Group Descriptor (0x1001)

 Record Handle: 0x00000002
 Service Class ID List:
         LAN Access Using PPP (0x1102)
 Protocol Descriptor List:
         L2CAP (0x0100)
         RFCOMM (0x0003)
                 Protocol specific parameter #1: u/int8/bool 1
 Bluetooth Profile Descriptor List:
         LAN Access Using PPP (0x1102) ver. 1.0

   Observe que cada servic,o tem uma lista de atributos, como o canal RFCOMM.
   Dependendo do servic,o, o usuario pode precisar anotar alguns dos
   atributos. Algumas implementac,oes Bluetooth nao suportam a navegac,ao de
   servic,o e podem retornar uma lista vazia. Nesse caso, e possivel procurar
   pelo servic,o especifico. O exemplo abaixo mostra como pesquisar o
   servic,o OBEX Object Push (OPUSH) :

 % sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH

   A oferta de servic,os no FreeBSD para clientes Bluetooth e feita com o
   servidor sdpd(8). A seguinte linha pode ser adicionada ao /etc/rc.conf:

 sdpd_enable="YES"

   Entao o daemon sdpd(8) pode ser iniciado com:

 # service sdpd start

   O aplicativo de servidor local que deseja fornecer um servic,o Bluetooth a
   clientes remotos registrara o servic,o com o daemon SDP local . Um exemplo
   de tal aplicativo e o rfcomm_pppd(8). Uma vez iniciado, ele registrara o
   servic,o LAN Bluetooth com o daemon local SDP.

   A lista de servic,os registrados no servidor SDPlocal pode ser obtida
   atraves da emissao de uma consulta de navegac,ao SDP atraves do canal de
   controle local:

 # sdpcontrol -l browse

    31.5.5.4. OBEX Object Push (OPUSH)

   Object Exchange (OBEX) e um protocolo amplamente utilizado para
   transferencias de arquivos simples entre dispositivos moveis. Seu
   principal uso e na comunicac,ao por infravermelho, onde e usado para
   transferencias de arquivos genericos entre notebooks ou PDAs, e para
   enviar cartoes de visita ou entradas de calendario entre telefones
   celulares e outros dispositivos com Personal Information Manager (PIM).

   O servidor e o cliente OBEX sao implementados pelo obexapp, que pode ser
   instalado usando o pacote ou port comms/obexapp.

   O cliente OBEX e usado para empurrar e/ou puxar objetos do servidor OBEX.
   Um exemplo de objeto e um cartao de visita ou um compromisso. O cliente
   OBEX pode obter o numero do canal RFCOMM do dispositivo remoto via SDP.
   Isso pode ser feito especificando o nome do servic,o em vez do numero do
   canal RFCOMM. Os nomes de servic,os suportados sao: IrMC, FTRN e OPUSH.
   Tambem e possivel especificar o canal RFCOMM como um numero. Abaixo esta
   um exemplo de uma sessao OBEX em que o objeto de informac,oes do
   dispositivo e extraido do telefone celular e um novo objeto, o cartao de
   visita, e inserido no diretorio do telefone.

 % obexapp -a 00:80:37:29:19:a4 -C IrMC
 obex> get telecom/devinfo.txt devinfo-t39.txt
 Success, response: OK, Success (0x20)
 obex> put new.vcf
 Success, response: OK, Success (0x20)
 obex> di
 Success, response: OK, Success (0x20)

   Para fornecer o servic,o OPUSH, o sdpd(8) deve estar em execuc,ao e uma
   pasta raiz, onde todos os objetos recebidos serao armazenados, deve ser
   criado. O caminho padrao para a pasta raiz e /var/spool/obex. Por fim,
   inicie o servidor OBEX em um numero de canal RFCOMM valido. O servidor
   OBEX registrara automaticamente o servic,o OPUSH com o daemon SDP local. O
   exemplo abaixo mostra como iniciar o servidor OBEX.

 # obexapp -s -C 10

    31.5.5.5. Perfil de porta serial (SPP)

   O perfil de porta serial (SPP) permite que dispositivos Bluetooth executem
   emulac,ao de cabo serial. Este perfil permite que aplicativos legados usem
   o Bluetooth como um substituto de cabos, atraves de uma abstrac,ao de
   porta serial virtual.

   No FreeBSD, o rfcomm_sppd(1) implementa o SPP e uma pseudo tty e usada
   como uma abstrac,ao de porta serial virtual. O exemplo abaixo mostra como
   se conectar ao servic,o de porta serial de um dispositivo remoto. Um canal
   RFCOMM nao precisa ser especificado uma vez que o rfcomm_sppd(1) pode
   obte-lo a partir do dispositivo remoto via SDP. Para sobrescrever isso,
   especifique um canal RFCOMM na linha de comando.

 # rfcomm_sppd -a 00:07:E0:00:0B:CA -t
 rfcomm_sppd[94692]: Starting on /dev/pts/6...
 /dev/pts/6

   Uma vez conectado, o pseudo-tty pode ser usado como porta serial:

 # cu -l /dev/pts/6

   A pseudo-tty e impressa no stdout e pode ser lida por scripts de wrapper:

 PTS=`rfcomm_sppd -a 00:07:E0:00:0B:CA -t`
 cu -l $PTS

  31.5.6. Soluc,ao de problemas

   Por padrao, quando o FreeBSD esta aceitando uma nova conexao, ele tenta
   executar uma troca de func,ao e se tornar o mestre. Alguns dispositivos
   Bluetooth mais antigos que nao suportam a troca de func,ao nao poderao se
   conectar. Como a troca de func,ao e executada quando uma nova conexao esta
   sendo estabelecida, nao e possivel perguntar ao dispositivo remoto se ele
   suporta a troca de func,ao. No entanto, ha uma opc,ao HCI para desativar a
   alternancia de func,oes no lado local:

 # hccontrol -n ubt0hci write_node_role_switch 0

   Para exibir pacotes Bluetooth, use o pacote de terceiros hcidump, que pode
   ser instalado usando o pacote ou port comms/hcidump. Este utilitario e
   semelhante ao tcpdump(1) e pode ser usado para exibir o conteudo dos
   pacotes Bluetooth no terminal e para descarregar os pacotes Bluetooth para
   um arquivo.

31.6. Bridging

   Escrito por Andre Thompson .

   As vezes, e util dividir uma rede, como um segmento Ethernet, em segmentos
   de rede sem precisar criar subnets IP e usar um roteador para conectar os
   segmentos. Um dispositivo que conecta duas redes dessa maneira e chamado
   de "bridge".

   Uma bridge funciona aprendendo os enderec,os MAC dos dispositivos em cada
   uma das suas interfaces de rede. Ele encaminha o trafego entre as redes
   somente quando os enderec,os de origem e destino MAC estao em redes
   diferentes. Em muitos aspectos, uma brifge e como um switch Ethernet com
   poucas portas. Um sistema FreeBSD com multiplas interfaces de rede pode
   ser configurado para atuar como uma bridge.

   Construir uma bridge pode ser util nas seguintes situac,oes:

   Conectar Redes

           A operac,ao basica de uma bridge e unir dois ou mais segmentos de
           rede. Existem muitas razoes para usar uma bridge baseada em host
           em vez de equipamentos de rede, tais como restric,oes de
           cabeamento ou firewall. Uma bridge tambem pode conectar uma
           interface sem fio em execuc,ao no modo hostap a uma rede com fio e
           atuar como um ponto de acesso.

   Firewall de Filtragem / Limitac,ao de Trafego

           Uma bridge pode ser usada quando a funcionalidade de firewall e
           necessaria sem a realizac,ao de roteamento ou conversao de
           enderec,os de rede (NAT).

           Um exemplo e uma pequena empresa conectada via DSL ou ISDN a um
           ISP. Existem treze enderec,os IP publicos do ISP e dez
           computadores na rede. Nessa situac,ao, e dificil usar um firewall
           baseado em roteador devido a problemas de sub-rede. Um firewall
           baseado em bridge pode ser configurado sem qualquer problema de
           enderec,amento IP.

   Inspec,ao de Rede

           Uma bridge pode unir dois segmentos de rede para inspecionar todos
           os pacotes Ethernet que passam entre elas usando bpf(4) e
           tcpdump(1) na interface de bridge ou enviando uma copia de todos
           os frames para uma interface adicional conhecida como span port.

   VPN de Camada 2

           Duas redes Ethernet podem ser unidas atraves de um link IP ligando
           as redes a um tunel EtherIP ou a uma soluc,ao baseada no tap(4)
           tal como o OpenVPN.

   Redundancia de Camada 2

           Uma rede pode ser conectada com varios links e usar o protocolo
           Spanning Tree (STP) para bloquear caminhos redundantes.

   Esta sec,ao descreve como configurar um sistema FreeBSD como uma bridge
   usando o if_bridge(4). Um driver de bridge netgraph tambem esta disponivel
   e e descrito em ng_bridge(4).

  Nota:

   A filtragem de pacotes pode ser usada com qualquer pacote de firewall que
   se conecte ao framework pfil(9). A bridge pode ser usada como um modelador
   de trafego com o altq(4) ou dummynet(4).

  31.6.1. Habilitando a Bridge

   No FreeBSD, o if_bridge(4) e um modulo do kernel que e carregado
   automaticamente pelo ifconfig(8) ao criar uma interface de bridge. Tambem
   e possivel compilar o suporte de bridge em um kernel customizado
   adicionando device if_bridge ao arquivo de configurac,ao do kernel
   personalizado.

   A bridge e criada usando clonagem de interface. Para criar a interface da
   bridge:

 # ifconfig bridge create
 bridge0
 # ifconfig bridge0
 bridge0: flags=8802<BROADCAST,SIMPLEX,MULTICAST> metric 0 mtu 1500
         ether 96:3d:4b:f1:79:7a
         id 00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
         maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
         root id 00:00:00:00:00:00 priority 0 ifcost 0 port 0

   Quando uma interface de bridge e criada, ela recebe automaticamente um
   enderec,o Ethernet gerado aleatoriamente. Os parametros maxaddr e timeout
   controlam quantos enderec,os MAC a bridge mantera em sua tabela de
   encaminhamento e quantos segundos o sistema ira esperar antes de cada
   entrada ser removida apos um enderec,o MAC ser visto pela ultima vez. Os
   outros parametros controlam como o STP opera.

   Em seguida, especifique quais interfaces de rede adicionar como membros da
   bridge. Para a bridge encaminhar pacotes, todas as interfaces de membros e
   a bridge precisam estar ativas:

 # ifconfig bridge0 addm fxp0 addm fxp1 up
 # ifconfig fxp0 up
 # ifconfig fxp1 up

   A bridge agora pode encaminhar quadros Ethernet entre fxp0 e fxp1.
   Adicione as seguintes linhas ao /etc/rc.conf para que a bridge seja criada
   na inicializac,ao:

 cloned_interfaces="bridge0"
 ifconfig_bridge0="addm fxp0 addm fxp1 up"
 ifconfig_fxp0="up"
 ifconfig_fxp1="up"

   Se o host de ponte precisar de um enderec,o IP, defina-o na interface de
   bridge, nao nas interfaces de membro. O enderec,o pode ser definido
   estaticamente ou via DHCP. Este exemplo define um enderec,o IP estatico:

 # ifconfig bridge0 inet 192.168.0.1/24

   Tambem e possivel atribuir um enderec,o IPv6 a uma interface de bridge.
   Para tornar as mudanc,as permanentes, adicione as informac,oes de
   enderec,amento ao /etc/rc.conf.

  Nota:

   Quando a filtragem de pacotes esta habilitada, os pacotes passarao pela
   entrada do filtro na interface de origem na interface da bridge e na saida
   nas interfaces apropriadas. Qualquer estagio pode ser desativado. Quando a
   direc,ao do fluxo de pacotes e importante, e melhor usar o firewall nas
   interfaces de membros, em vez da propria bridge.

   A bridge tem varias opc,oes configuraveis para o trafego de pacotes IP e
   nao-IP, e a filtragem de pacotes layer2 com o ipfw(8). Veja if_bridge(4)
   para maiores informac,oes.

  31.6.2. Ativando o Spanning Tree

   Para que uma rede Ethernet funcione corretamente, somente um caminho ativo
   pode existir entre dois dispositivos. O protocolo STP detecta loops e
   coloca links redundantes em um estado bloqueado. Se um dos links ativos
   falhar, o STP calcula uma arvore diferente e habilita um dos caminhos
   bloqueados para restaurar a conectividade a todos os pontos da rede.

   O protocolo Rapid Spanning Tree (RSTP ou 802.1w) fornece compatibilidade
   retroativa com o STP legado. O RSTP fornece uma convergencia mais rapida e
   troca informac,oes com os switches vizinhos para fazer a transic,ao rapida
   para o modo de encaminhamento sem criar loops. O FreeBSD suporta o RSTP e
   o STP como modos de operac,ao, com o RSTP sendo o modo padrao.

   O STP pode ser ativado nas interfaces de membro usando o ifconfig(8). Para
   uma bridge com fxp0 e fxp1 como as interfaces atuais, ative o STP com:

 # ifconfig bridge0 stp fxp0 stp fxp1
 bridge0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
         ether d6:cf:d5:a0:94:6d
         id 00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
         maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
         root id 00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
         member: fxp0 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>
                 port 3 priority 128 path cost 200000 proto rstp
                 role designated state forwarding
         member: fxp1 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>
                 port 4 priority 128 path cost 200000 proto rstp
                 role designated state forwarding

   Essa ponte possui um spanning tree ID de 00:01:02:4b:d4:50 e uma
   prioridade de 32768. Como o root id e o mesmo, indica que esta e a bridge
   raiz para a arvore.

   Outra bridge na rede tambem tem o STP ativado:

 bridge0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
         ether 96:3d:4b:f1:79:7a
         id 00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
         maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
         root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
         member: fxp0 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>
                 port 4 priority 128 path cost 200000 proto rstp
                 role root state forwarding
         member: fxp1 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>
                 port 5 priority 128 path cost 200000 proto rstp
                 role designated state forwarding

   A linha root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
   mostra que a bridge raiz e 00:01:02:4b:d4:50 e tem um custo de caminho de
   400000 desta bridge. O caminho para a bridge raiz e via port 4, que e
   fxp0.

  31.6.3. Parametros da Interface de Bridge

   Varios parametros do ifconfig sao exclusivos para interligar interfaces.
   Esta sec,ao resume alguns usos comuns para esses parametros. A lista
   completa de parametros disponiveis e descrita em ifconfig(8).

   privado

           Uma interface privada nao encaminha qualquer trafego para qualquer
           outra porta que tambem seja designada como uma interface privada.
           O trafego e bloqueado incondicionalmente para que nenhum quadro
           Ethernet seja encaminhado, incluindo pacotes ARP. Se o trafego
           precisar ser bloqueado seletivamente, um firewall deve ser usado
           no lugar.

   span

           Uma porta span transmite uma copia de cada quadro Ethernet
           recebido pela bridge. O numero de portas de span configuradas em
           uma bridge e ilimitado, mas se uma interface for designada como
           uma porta de span, ela tambem nao podera ser usada como uma porta
           de bridge comum. Isso e mais util para espionar passivamente uma
           rede em bridge a partir de outro host conectado a uma das portas
           da bridge. Por exemplo, para enviar uma copia de todos os quadros
           para fora da interface denominada fxp4:

 # ifconfig bridge0 span fxp4

   sticky

           Se uma interface de membro de uma bridge estiver marcada como
           fixa, as entradas de enderec,o aprendidas dinamicamente serao
           tratadas como entradas estaticas no cache de encaminhamento.
           Entradas fixas nunca sao eliminadas do cache ou substituidas,
           mesmo que o enderec,o seja visto em uma interface diferente. Isso
           oferece o beneficio de entradas de enderec,o estatico sem a
           necessidade de preencher previamente a tabela de encaminhamento.
           Os clientes aprendidos em um segmento especifico da bridge nao
           podem se deslocar para outro segmento.

           Um exemplo do uso de enderec,os fixos e combinar a bridge com
           VLANs para isolar redes de clientes sem desperdic,ar espac,o de
           enderec,o IP. Considere que CustomerA esta em vlan100, CustomerB
           esta em vlan101, e a bridge tem o enderec,o 192.168.0.1:

 # ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101
 # ifconfig bridge0 inet 192.168.0.1/24

           Neste exemplo, os dois clientes veem 192.168.0.1 como seu gateway
           padrao. Como o cache da bridge e fixo, um host nao pode falsificar
           o enderec,o MAC do outro cliente para interceptar o trafego.

           Qualquer comunicac,ao entre as VLANs pode ser bloqueada usando um
           firewall ou, como visto neste exemplo, interfaces privadas:

 # ifconfig bridge0 private vlan100 private vlan101

           Os clientes sao completamente isolados uns dos outros e o
           intervalo completo de enderec,os /24 pode ser alocado sem criac,ao
           de sub-redes.

           O numero de enderec,os MAC de origem exclusivos por tras de uma
           interface pode ser limitado. Quando o limite e atingido, os
           pacotes com enderec,os de origem desconhecidos sao descartados ate
           que uma entrada de cache do host existente expire ou seja
           removida.

           O exemplo a seguir define o numero maximo de dispositivos Ethernet
           para CustomerA em vlan100 para 10:

 # ifconfig bridge0 ifmaxaddr vlan100 10

   As interfaces de bridge tambem suportam o modo monitor, onde os pacotes
   sao descartados apos processamento do bpf(4) e nao sao processados ou
   encaminhados. Isso pode ser usado para multiplexar a entrada de duas ou
   mais interfaces em um unico fluxo bpf(4). Isso e util para reconstruir o
   trafego de taps de rede que transmitem os sinais RX/TX atraves de duas
   interfaces separadas. Por exemplo, para ler a entrada de quatro interfaces
   de rede como um fluxo:

 # ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up
 # tcpdump -i bridge0

  31.6.4. Monitoramento SNMP

   A interface de bridge e os parametros de STP podem ser monitorados via o
   bsnmpd(1) o qual esta incluido no sistema basico do FreeBSD. A MIB
   exportada da bridge esta em conformidade com os padroes IETF, portanto,
   qualquer cliente ou pacote de monitoramento SNMP pode ser usado para
   recuperar os dados.

   Para ativar o monitoramento na bridge, descomente esta linha em
   /etc/snmpd.config removendo o simbolo inicial #:

 begemotSnmpdModulePath."bridge" = "/usr/lib/snmp_bridge.so"

   Outras configurac,oes, como nomes de comunidades e listas de acesso, podem
   precisar ser modificadas nesse arquivo. Consulte bsnmpd(1) e
   snmp_bridge(3) para maiores informac,oes. Depois que essas edic,oes forem
   salvas, adicione esta linha ao /etc/rc.conf:

 bsnmpd_enable="YES"

   Em seguida, inicie o bsnmpd(1):

 # service bsnmpd start

   Os exemplos a seguir usam o software Net-SNMP (net-mgmt/net-snmp) para
   consultar uma bridge a partir de um sistema cliente. O port
   net-mgmt/bsnmptools tambem pode ser usado. Do cliente SNMP que esta
   executando o Net-SNMP, adicione as seguintes linhas ao
   $HOME/.snmp/snmp.conf para importar as definic,oes da bridge MIB:

 mibdirs +/usr/share/snmp/mibs
 mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB

   Para monitorar uma unica bridge usando o IETF BRIDGE-MIB (RFC4188):

 % snmpwalk -v 2c -c public bridge1.example.com mib-2.dot1dBridge
 BRIDGE-MIB::dot1dBaseBridgeAddress.0 = STRING: 66:fb:9b:6e:5c:44
 BRIDGE-MIB::dot1dBaseNumPorts.0 = INTEGER: 1 ports
 BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 = Timeticks: (189959) 0:31:39.59 centi-seconds
 BRIDGE-MIB::dot1dStpTopChanges.0 = Counter32: 2
 BRIDGE-MIB::dot1dStpDesignatedRoot.0 = Hex-STRING: 80 00 00 01 02 4B D4 50
 ...
 BRIDGE-MIB::dot1dStpPortState.3 = INTEGER: forwarding(5)
 BRIDGE-MIB::dot1dStpPortEnable.3 = INTEGER: enabled(1)
 BRIDGE-MIB::dot1dStpPortPathCost.3 = INTEGER: 200000
 BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
 BRIDGE-MIB::dot1dStpPortDesignatedCost.3 = INTEGER: 0
 BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
 BRIDGE-MIB::dot1dStpPortDesignatedPort.3 = Hex-STRING: 03 80
 BRIDGE-MIB::dot1dStpPortForwardTransitions.3 = Counter32: 1
 RSTP-MIB::dot1dStpVersion.0 = INTEGER: rstp(2)

   O valor dot1dStpTopChanges.0 e dois, indicando que a topologia da bridge
   STP foi alterada duas vezes. Uma alterac,ao de topologia significa que um
   ou mais links na rede foram alterados ou falharam e uma nova arvore foi
   calculada. O valor de dot1dStpTimeSinceTopologyChange.0 sera exibido
   quando isso acontecer.

   Para monitorar varias interfaces de bridge, o BEGEMOT-BRIDGE-MIB privado
   pode ser usado:

 % snmpwalk -v 2c -c public bridge1.example.com
 enterprises.fokus.begemot.begemotBridge
 BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge0" = STRING: bridge0
 BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge2" = STRING: bridge2
 BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge0" = STRING: e:ce:3b:5a:9e:13
 BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge2" = STRING: 12:5e:4d:74:d:fc
 BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge0" = INTEGER: 1
 BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge2" = INTEGER: 1
 ...
 BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge0" = Timeticks: (116927) 0:19:29.27 centi-seconds
 BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge2" = Timeticks: (82773) 0:13:47.73 centi-seconds
 BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge0" = Counter32: 1
 BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge2" = Counter32: 1
 BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge0" = Hex-STRING: 80 00 00 40 95 30 5E 31
 BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge2" = Hex-STRING: 80 00 00 50 8B B8 C6 A9

   Para alterar a interface da bridge que esta sendo monitorada atraves da
   subarvore mib-2.dot1dBridge:

 % snmpset -v 2c -c private bridge1.example.com
 BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2

31.7. Agregac,ao de links e failover

   Escrito por Andre Thompson .

   O FreeBSD fornece a interface lagg(4) que pode ser usada para agregar
   varias interfaces de rede em uma interface virtual para fornecer failover
   e agregac,ao de links. O failover permite que o trafego continue a fluir,
   desde que pelo menos uma interface de rede agregada tenha um link
   estabelecido. A agregac,ao de links funciona melhor em switches
   compativeis com LACP, pois esse protocolo distribui o trafego
   bidirecionalmente ao responder `a falha de links individuais.

   Os protocolos de agregac,ao suportados pela interface lagg determinam
   quais portas sao usadas para o trafego de saida e se uma porta especifica
   aceita trafego de entrada. Os seguintes protocolos sao suportados pelo
   lagg(4):

   failover

           Este modo envia e recebe trafego somente atraves da porta
           principal. Se a porta principal ficar indisponivel, a proxima
           porta ativa sera usada. A primeira interface adicionada `a
           interface virtual e a porta principal e todas as interfaces
           adicionadas posteriormente sao usadas como dispositivos de
           failover. Se ocorrer um failover em uma porta nao mestre, a porta
           original se tornara a principal quando estiver disponivel
           novamente.

   fec / loadbalance

           Cisco(R) Fast EtherChannel(R) (FEC) e encontrado em versoes
           anteriores de switches Cisco (R). Ele fornece uma configurac,ao
           estatica e nao negocia a agregac,ao com o par ou troca quadros
           para monitorar o link. Se o switch suportar LACP, isso deve ser
           usado em seu lugar.

   lacp

           O protocolo de controle de agregac,ao de links IEEE(R) 802.3ad
           (LACP) negocia um conjunto de links agregaveis com o peer em um ou
           mais grupos agregados de links (LAGs). Cada LAG e composto de
           portas da mesma velocidade, configuradas para operac,ao
           full-duplex e o trafego e balanceado entre as portas no LAG com a
           maior velocidade total. Normalmente, ha apenas um LAG que contem
           todas as portas. No caso de alterac,oes na conectividade fisica, o
           LACP convergira rapidamente para uma nova configurac,ao.

           O LACP equilibra o trafego de saida nas portas ativas com base nas
           informac,oes de hash do cabec,alho do protocolo e aceita trafego
           de entrada de qualquer porta ativa. O hash inclui o enderec,o
           Ethernet de origem e destino e, se disponivel, a tag VLAN e o
           enderec,o de origem e destino IPv4 ou IPv6.

   roundrobin

           Esse modo distribui o trafego de saida usando um agendador
           round-robin por meio de todas as portas ativas e aceita trafego de
           entrada de qualquer porta ativa. Como esse modo viola a ordenac,ao
           de quadros Ethernet, ele deve ser usado com cautela.

  31.7.1. Exemplos de configurac,ao

   Esta sec,ao demonstra como configurar um switch Cisco(R) e um sistema
   FreeBSD para balanceamento de carga LACP. Em seguida, ele mostra como
   configurar duas interfaces Ethernet no modo de failover, alem de como
   configurar o modo de failover entre uma Ethernet e uma interface sem fio.

   Exemplo 31.1. Agregac,ao LACP com um switch Cisco(R)

   Este exemplo conecta duas interfaces Ethernet fxp(4) em uma maquina
   FreeBSD `as duas primeiras portas Ethernet em um switch Cisco(R) como um
   link de carga unica balanceada e tolerante a falhas. Mais interfaces podem
   ser adicionadas para aumentar o rendimento e a tolerancia a falhas.
   Substitua os nomes das portas Cisco(R), dos dispositivos Ethernet, do
   numero do grupo de canais e do enderec,o IP mostrado no exemplo para
   corresponder `a configurac,ao local.

   A ordenac,ao de quadros e obrigatoria em links Ethernet e qualquer trafego
   entre duas estac,oes sempre flui pelo mesmo link fisico, limitando a
   velocidade maxima `aquela de uma interface. O algoritmo de transmissao
   tenta usar o maximo de informac,oes possivel para distinguir diferentes
   fluxos de trafego e equilibrar os fluxos entre as interfaces disponiveis.

   No switch Cisco(R), adicione as interfaces FastEthernet0/1 e
   FastEthernet0/2 ao grupo de canais 1:

 interface FastEthernet0/1
  channel-group 1 mode active
  channel-protocol lacp
 !
 interface FastEthernet0/2
  channel-group 1 mode active
  channel-protocol lacp

   No sistema FreeBSD, crie a interface lagg(4) usando as interfaces fisicas
   fxp0 e fxp1 e suba as interfaces com o enderec,o IP de 10.0.0.3/24:

 # ifconfig fxp0 up
 # ifconfig fxp1 up
 # ifconfig lagg0 create
 # ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24

   Em seguida, verifique o status da interface virtual:

 # ifconfig lagg0
 lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
         options=8<VLAN_MTU>
         ether 00:05:5d:71:8d:b8
         inet 10.0.0.3 netmask 0xffffff00 broadcast 10.0.0.255
         media: Ethernet autoselect
         status: active
         laggproto lacp
         laggport: fxp1 flags=1c<ACTIVE,COLLECTING,DISTRIBUTING>
         laggport: fxp0 flags=1c<ACTIVE,COLLECTING,DISTRIBUTING>

   Portas marcadas como ACTIVE fazem parte do LAG que foi negociado com o
   switch remoto. O trafego sera transmitido e recebido atraves dessas portas
   ativas. Adicione -v ao comando acima para ver os identificadores LAG.

   Para ver o status da porta no switch Cisco(R):

 switch# show lacp neighbor
 Flags:  S - Device is requesting Slow LACPDUs
         F - Device is requesting Fast LACPDUs
         A - Device is in Active mode       P - Device is in Passive mode

 Channel group 1 neighbors

 Partner's information:

                   LACP port                        Oper    Port     Port
 Port      Flags   Priority  Dev ID         Age     Key     Number   State
 Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
 Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D

   Para mais detalhes, digite show lacp neighbor detail.

   Para manter esta configurac,ao atraves de reinicializac,oes, adicione as
   seguintes entradas ao /etc/rc.conf no sistema FreeBSD:

 ifconfig_fxp0="up"
 ifconfig_fxp1="up"
 cloned_interfaces="lagg0"
 ifconfig_lagg0="laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24"

   Exemplo 31.2. Modo de Failover

   O modo de failover pode ser usado para alternar para uma interface
   secundaria se o link for perdido na interface principal. Para configurar o
   failover, certifique-se de que as interfaces fisicas subjacentes estejam
   ativadas e crie a interface lagg(4). Neste exemplo, fxp0 e a interface
   principal, fxp1 e a interface secundaria e a interface virtual recebeu um
   enderec,o IP de 10.0.0.15/24:

 # ifconfig fxp0 up
 # ifconfig fxp1 up
 # ifconfig lagg0 create
 # ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24

   A interface virtual deve ser algo como isto:

 # ifconfig lagg0
 lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
         options=8<VLAN_MTU>
         ether 00:05:5d:71:8d:b8
         inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
         media: Ethernet autoselect
         status: active
         laggproto failover
         laggport: fxp1 flags=0<>
         laggport: fxp0 flags=5<MASTER,ACTIVE>

   O trafego sera transmitido e recebido em fxp0. Se o link for perdido em
   fxp0, fxp1 se tornara o link ativo. Se o link for restaurado na interface
   principal, ele se tornara novamente o link ativo.

   Para manter essa configurac,ao atraves de reinicializac,oes, adicione as
   seguintes entradas ao /etc/rc.conf:

 ifconfig_fxp0="up"
 ifconfig_fxp1="up"
 cloned_interfaces="lagg0"
 ifconfig_lagg0="laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24"

   Exemplo 31.3. Modo de failover entre interfaces Ethernet e sem fio

   Para usuarios de laptop, geralmente e desejavel configurar o dispositivo
   sem fio como secundario, que e usado somente quando a conexao Ethernet nao
   esta disponivel. Com lagg(4), e possivel configurar um failover que
   preferia a conexao Ethernet por motivos de desempenho e de seguranc,a,
   mantendo a capacidade de transferencia dados atraves da conexao sem fio.

   Isso e obtido substituindo o enderec,o MAC da interface Ethernet com o da
   interface wireless.

  Nota:

   Em teoria, o enderec,o MAC da Ethernet ou da wireless pode ser alterado
   para corresponder ao outro. No entanto, algumas interfaces wireless
   populares nao tem suporte para substituir o enderec,o MAC. Portanto,
   recomendamos substituir o enderec,o MAC da Ethernet para esse fim.

   Neste exemplo, a interface Ethernet, re0, e a interface principal e a
   interface sem fio, wlan0, e o failover. A interface wlan0 foi criada a
   partir da interface wireless ath0, e a interface Ethernet sera configurada
   com o enderec,o MAC da interface wireless. Primeiro, determine o enderec,o
   MAC da interface wireless:

 # ifconfig wlan0
 wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
         ether b8:ee:65:5b:32:59
         groups: wlan
         ssid Bbox-A3BD2403 channel 6 (2437 MHz 11g ht/20) bssid 00:37:b7:56:4b:60
         regdomain ETSI country FR indoor ecm authmode WPA2/802.11i privacy ON
         deftxkey UNDEF AES-CCM 2:128-bit txpower 30 bmiss 7 scanvalid 60
         protmode CTS ampdulimit 64k ampdudensity 8 shortgi -stbctx stbcrx
         -ldpc wme burst roaming MANUAL
         media: IEEE 802.11 Wireless Ethernet MCS mode 11ng
         status: associated
         nd6 options=29<PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL>

   Substitua wlan0 para corresponder ao nome da interface wireless do
   sistema. A linha ether contera o enderec,o MAC da interface especificada.
   Agora, altere o enderec,o MAC da interface Ethernet subjacente:

 # ifconfig re0 ether b8:ee:65:5b:32:59

   Suba a interface sem fio (substituindo FR pelo seu proprio codigo de pais
   com duas letras), mas nao defina um enderec,o IP:

 # ifconfig wlan0 create wlandev ath0 country FR ssid my_router up

   Certifique-se de que a interface re0 esteja ativa, entao crie a interface
   lagg(4) com a re0 como master com failover para awlan0:

 # ifconfig re0 up
 # ifconfig lagg0 create
 # ifconfig lagg0 up laggproto failover laggport re0 laggport wlan0

   A interface virtual deve ser algo como isto:

 # ifconfig lagg0
 lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
         options=8<VLAN_MTU>
         ether b8:ee:65:5b:32:59
         laggproto failover lagghash l2,l3,l4
         laggport: re0 flags=5<MASTER,ACTIVE>
         laggport: wlan0 flags=0<>
         groups: lagg
         media: Ethernet autoselect
         status: active

   Em seguida, inicie o cliente DHCP para obter um enderec,o IP:

 # dhclient lagg0

   Para manter essa configurac,ao atraves de reinicializac,oes, adicione as
   seguintes entradas ao /etc/rc.conf:

 ifconfig_re0="ether b8:ee:65:5b:32:59"
 wlans_ath0="wlan0"
 ifconfig_wlan0="WPA"
 create_args_wlan0="country FR"
 cloned_interfaces="lagg0"
 ifconfig_lagg0="up laggproto failover laggport re0 laggport wlan0 DHCP"

31.8. Operac,ao Diskless com PXE

   Atualizado por Jean-Franc,ois Dockes .
   Reorganizado e aprimorado por Alex Dupre .

   O Ambiente de execuc,ao de pre-inicializac,ao da Intel(R) (PXE) permite
   que um sistema operacional inicialize pela rede. Por exemplo, um sistema
   FreeBSD pode inicializar atraves da rede e operar sem um disco local,
   usando sistemas de arquivos montados a partir de um servidor NFS. O
   suporte para PXE geralmente esta disponivel no BIOS. Para usar o PXE
   quando a maquina iniciar, selecione a opc,ao Inicializac,ao da rede na
   configurac,ao do BIOS ou digite uma tecla de func,ao durante a
   inicializac,ao do sistema.

   Para fornecer os arquivos necessarios para um sistema operacional
   inicializar pela rede, uma configurac,ao do PXE tambem requer o DHCP, TFTP
   configurado corretamente e Servidores NFS, onde:

     * Parametros iniciais, como enderec,o de IP, nome e localizac,ao do
       arquivo de inicializac,ao executavel, nome do servidor e caminho do
       root sao obtidos do servidor DHCP.

     * O arquivo do carregador do sistema operacional e inicializado usando
       TFTP.

     * Os sistemas de arquivos sao carregados usando o NFS.

   Quando um computador PXE inicializa, ele recebe informac,oes por meio do
   DHCP sobre onde obter o arquivo inicial do carregador de boot. Depois que
   o computador host recebe essa informac,ao, ele faz o download do
   carregador de boot via TFTP e, em seguida, executa o carregador de boot.
   No FreeBSD, o arquivo do gerenciador de boot e o /boot/pxeboot. Depois que
   o /boot/pxeboot e executado, o kernel do FreeBSD e carregado e o resto da
   sequ:encia de inicializac,ao do FreeBSD continua, como descrito em
   Capitulo 12, O processo de inicializac,ao do FreeBSD.

   Esta sec,ao descreve como configurar estes servic,os em um sistema FreeBSD
   para que outros sistemas possam inicializar o PXE a partir do FreeBSD.
   Consulte diskless(8) para obter maiores informac,oes.

  Cuidado:

   Conforme descrito, o sistema que fornece esses servic,os e inseguro. Ele
   deve ficar em uma area protegida de uma rede e nao deve ser considerado
   confiavel por outros hosts.

  31.8.1. Configurando o ambiente PXE

   Escrito por Craig Rodrigues .

   As etapas mostradas nesta sec,ao configuram os servidores internos de NFS
   e TFTP. A proxima sec,ao demonstra como instalar e configurar o servidor
   DHCP. Neste exemplo, o diretorio que contera os arquivos usados pelos
   usuarios do PXE e o /b/tftpboot/FreeBSD/install. E importante que este
   diretorio exista e que o mesmo nome de diretorio seja configurado no
   /etc/inetd.conf e no /usr/local/etc/dhcpd.conf.

    1. Crie o diretorio raiz que ira conter uma instalac,ao do FreeBSD para
       ser montado por NFS:

 # export NFSROOTDIR=/b/tftpboot/FreeBSD/install
 # mkdir -p ${NFSROOTDIR}

    2. Ative o servidor NFS adicionando esta linha ao /etc/rc.conf:

 nfs_server_enable="YES"

    3. Exporte o diretorio raiz sem disco via NFS adicionando o seguinte ao
       /etc/exports:

 /b -ro -alldirs -maproot=root

    4. Inicie o servidor NFS:

 # service nfsd start

    5. Ative o inetd(8) adicionando a seguinte linha ao /etc/rc.conf:

 inetd_enable="YES"

    6. Descomente a seguinte linha no /etc/inetd.conf certificando-se de que
       ela nao comece com um simbolo #:

 tftp dgram udp wait root /usr/libexec/tftpd tftpd -l -s /b/tftpboot

  Nota:

       Algumas versoes do PXE exigem a versao TCP do TFTP. Neste caso, remova
       o comentario da segunda linha tftp que contem stream tcp.

    7. Inicie o inetd(8):

 # service inetd start

    8. Instale o sistema basico em ${NFSROOTDIR}, seja descompactando os
       arquivos oficiais ou recompilando o kernel do FreeBSD e o userland
       (consulte Sec,ao 23.5, "Atualizando o FreeBSD a partir do codigo
       fonte" para instruc,oes mais detalhadas, mas nao esquec,a de adicionar
       DESTDIR=${NFSROOTDIR} ao executar os comandos make installkernel e
       make installworld.

    9. Teste que o servidor TFTP funciona e que pode baixar o gerenciador de
       boot que sera obtido via PXE:

 # tftp localhost
 tftp> get FreeBSD/install/boot/pxeboot
 Received 264951 bytes in 0.1 seconds

   10. Edite o ${NFSROOTDIR}/etc/fstab e crie uma entrada para montar o
       sistema de arquivos raiz por meio do NFS:

 # Device                                         Mountpoint    FSType   Options  Dump Pass
 myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0

       Substitua myhost.example.com pelo nome do host ou pelo enderec,o IP do
       servidor NFS. Neste exemplo, o sistema de arquivos raiz e montado como
       somente leitura para evitar que os clientes do NFS excluam
       potencialmente o conteudo do sistema de arquivos raiz.

   11. Defina a senha de root no ambiente PXE para as maquinas clientes que
       serao inicializadas por PXE:

 # chroot ${NFSROOTDIR}
 # passwd

   12. Se necessario, ative o login do root via ssh(1) para as maquinas
       clientes que estao inicializando por PXE editando o
       ${NFSROOTDIR}/etc/ssh/sshd_config e habilitando o PermitRootLogin.
       Esta opc,ao esta documentada em sshd_config(5).

   13. Execute qualquer outra customizac,ao necessaria do ambiente PXE no
       ${NFSROOTDIR}. Estas customizac,oes podem incluir coisas como instalar
       pacotes ou editar o arquivo de senha com o vipw(8).

   Ao inicializar de um volume raiz NFS, o /etc/rc detecta a inicializac,ao
   do NFS e executa o /etc/rc.initdiskless. Neste caso, o /etc e /var
   precisam ser sistemas de arquivos montados em memoria para que estes
   diretorios sejam gravaveis mas o diretorio raiz NFS seja apenas de
   leitura:

 # chroot ${NFSROOTDIR}
 # mkdir -p conf/base
 # tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc
 # tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var

   Quando o sistema inicializar, os sistemas de arquivos em memoria para o
   /etc e o /var serao criados e montados e o conteudo dos arquivos cpio.gz
   sera copiado para eles. Por padrao, esses sistemas de arquivos tem uma
   capacidade maxima de 5 megabytes. Se seus arquivos nao couberem, o que
   geralmente e o caso do /var quando pacotes binarios foram instalados,
   solicite um tamanho maior colocando o numero de setores de 512 bytes
   necessarios (por exemplo, 5 megabytes e 10240 setores) nos arquivos
   ${NFSROOTDIR}/conf/base/etc/md_size e ${NFSROOTDIR}/conf/base/var/md_size
   para os sistemas de arquivos /etc e o /var respectivamente.

  31.8.2. Configurando o servidor DHCP

   O servidor DHCP nao precisa ser a mesma maquina que o servidor TFTP e NFS,
   mas ele precisa estar acessivel na rede.

   O DHCP nao faz parte do sistema basico do FreeBSD, mas pode ser instalado
   usando o port ou pacote net/isc-dhcp43-server.

   Uma vez instalado, edite o arquivo de configurac,ao,
   /usr/local/etc/dhcpd.conf. Configure as diretivas next-server, filename e
   root-path conforme mostrado neste exemplo:

 subnet 192.168.0.0 netmask 255.255.255.0 {
    range 192.168.0.2 192.168.0.3 ;
    option subnet-mask 255.255.255.0 ;
    option routers 192.168.0.1 ;
    option broadcast-address 192.168.0.255 ;
    option domain-name-servers 192.168.35.35, 192.168.35.36 ;
    option domain-name "example.com";

    # IP address of TFTP server
    next-server 192.168.0.1 ;

    # path of boot loader obtained via tftp
    filename "FreeBSD/install/boot/pxeboot" ;

    # pxeboot boot loader will try to NFS mount this directory for root FS
    option root-path "192.168.0.1:/b/tftpboot/FreeBSD/install/" ;

 }

   A diretiva next-server e usada para especificar o enderec,o IP do servidor
   TFTP.

   A diretiva filename define o caminho para o /boot/pxeboot. Um nome de
   arquivo relativo e usado, significando que /b/tftpboot nao esta incluido
   no caminho.

   A diretiva root-path define o caminho para o sistema de arquivos raiz a
   ser montado por NFS.

   Depois que as edic,oes forem salvas, ative o DHCP no momento da
   inicializac,ao adicionando a seguinte linha ao /etc/rc.conf:

 dhcpd_enable="YES"

   Entao inicie o servic,o DHCP:

 # service isc-dhcpd start

  31.8.3. Depurando problemas de PXE

   Uma vez que todos os servic,os estejam configurados e iniciados, os
   clientes de PXE devem poder carregar automaticamente o FreeBSD pela rede.
   Se um determinado cliente nao conseguir se conectar, quando a maquina
   cliente inicializar, entre no menu de configurac,ao da BIOS e confirme se
   ela esta configurada para inicializar a partir da rede.

   Esta sec,ao descreve algumas dicas de soluc,ao de problemas para isolar a
   origem do problema de configurac,ao, caso nenhum cliente seja capaz de
   inicializar o PXE.

    1. Use o pacote ou port net/wireshark para depurar o trafego de rede
       envolvido durante o processo de inicializac,ao do PXE, que esta
       ilustrado no diagrama abaixo.

       Figura 31.1. Processo de inicializac,ao PXE com o sistema de arquivos
       raiz montado por NFS
       Processo de inicializac,ao PXE com o sistema de arquivos raiz montado
       por NFS

       1 O cliente transmite uma mensagem DHCPDISCOVER.                       
       2 O servidor DHCP responde com as informac,oes de enderec,o IP,        
         next-server, filename e root-path.                                   
       3 O cliente envia uma solicitac,ao TFTP para o next-server,            
         solicitando acesso ao filename.                                      
       4 O servidor TFTP responde e envia o filename para o cliente.          
       5 O cliente executa o filename, que e o pxeboot(8), o qual entao       
         carrega o kernel. Quando o kernel e executado, o sistema de arquivos 
         raiz especificado por root-path e montado sobre o NFS.               

    2. No servidor TFTP, leia o /var/log/xferlog para garantir que o pxeboot
       esteja sendo recuperado do local correto. Para testar esta
       configurac,ao de exemplo:

 # tftp 192.168.0.1
 tftp> get FreeBSD/install/boot/pxeboot
 Received 264951 bytes in 0.1 seconds

       As sec,oes de BUGS do tftpd(8) e tftp(1) documenta algumas limitac,oes
       com o TFTP.

    3. Certifique-se de que o sistema de arquivos raiz possa ser montado via
       NFS. Para testar esta configurac,ao de exemplo:

 # mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt

31.9. IPv6

   Originalmente escrito por Aaron Kaplan .
   Reestruturado e adicionado por Tom Rhodes .
   estendido por Brad Davis .

   O IPv6 e a nova versao do conhecido protocolo IP, tambem conhecido como
   IPv4. O IPv6 oferece varias vantagens sobre o IPv4, alem de muitos
   recursos novos:

     * Seu espac,o de enderec,os de 128 bits permite
       340.282.366.920.938.463.463.374.607.431.768.211.456 enderec,os. Isso
       corrige a falta de enderec,os do IPv4 e o eventual esgotamento do
       enderec,o de IPv4.

     * Os roteadores armazenam apenas enderec,os de agregac,ao de rede em
       suas tabelas de roteamento, reduzindo assim o espac,o medio de uma
       tabela de roteamento para 8192 entradas. Isso resolve os problemas de
       escalabilidade associados ao IPv4, que exigia que cada bloco alocado
       de enderec,os IPv4 fossem trocados entre roteadores da Internet,
       fazendo com que suas tabelas de roteamento ficassem muito grandes para
       permitir um roteamento eficiente .

     * Autoconfigurac,ao de enderec,o (RFC2462).

     * Enderec,os multicast obrigatorios.

     * IPsec Embutido (Seguranc,a IP).

     * Estrutura simplificada do cabec,alho.

     * Suporte para mobile IP.

     * Mecanismos de transic,ao IPv6-to-IPv4.

   O FreeBSD inclui a implementac,ao de referencia do http://www.kame.net/
   IPv6 e vem com tudo necessario usar o IPv6. Esta sec,ao se concentra em
   configurar e executar o IPv6.

  31.9.1. Informac,oes sobre enderec,os de IPv6

   Existem tres tipos diferentes de enderec,os de IPv6:

   Unicast

           Um pacote enviado para um enderec,o unicast chega `a interface
           pertencente ao enderec,o.

   Anycast

           Esses enderec,os sao sintaticamente indistinguiveis dos enderec,os
           unicast, mas eles tratam de um grupo de interfaces. O pacote
           destinado a um enderec,o anycast chegara `a interface do roteador
           mais proxima. Enderec,os anycast sao usados apenas por roteadores.

   Multicast

           Esses enderec,os identificam um grupo de interfaces. Um pacote
           destinado a um enderec,o multicast chegara a todas as interfaces
           pertencentes ao grupo multicast. O enderec,o de broadcast IPv4 ,
           geralmente xxx.xxx.xxx.255, e expresso por enderec,os multicast em
           IPv6.

   Ao ler um enderec,o IPv6, a forma canonica e representada como
   x:x:x:x:x:x:x:x, onde cada x representa um valor hexadecimal de 16 bits.
   Um exemplo e FEBC:A574:382B:23C1:AA49:4592:4EFE:9982.

   Muitas vezes, um enderec,o tera substrings longas apenas com zeros. Um ::
   (dois-pontos duplos) pode ser usado para substituir uma subcadeia por
   enderec,o. Alem disso, ate tres valores 0s iniciais por valor hexadecimal
   podem ser omitidos. Por exemplo, fe80::1 corresponde `a forma canonica
   fe80:0000:0000:0000:0000:0000:0000:0001.

   Uma terceira forma e escrever os ultimos 32 bits usando a conhecida
   notac,ao IPv4. Por exemplo, 2002::10.0.0.1 corresponde `a representac,ao
   canonica hexadecimal 2002:0000:0000:0000:0000:0000:0a00:0001, que por sua
   vez e equivalente a 2002::a00:1.

   Para visualizar o enderec,o IPv6 do sistema FreeBSD, use ifconfig(8):

 # ifconfig

 rl0: flags=8943<UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST> mtu 1500
          inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
          inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
          ether 00:00:21:03:08:e1
          media: Ethernet autoselect (100baseTX )
          status: active

   Neste exemplo, a interface rl0 esta usando fe80::200:21ff:fe03:8e1%rl0, um
   enderec,o local de link auto-configurado que foi gerado automaticamente a
   partir do enderec,o MAC.

   Alguns enderec,os do IPv6 sao reservados. Um resumo destes enderec,os
   reservados e visto em Tabela 31.3, "Enderec,os IPv6 reservados":

   Tabela 31.3. Enderec,os IPv6 reservados

    enderec,o IPv6  Prefixlength    Descric,ao               Notas            
                       (Bits)    
   ::               128 bits     nao especificado Equivalente a 0.0.0.0 em    
                                                  IPv4.                       
   ::1              128 bits     enderec,o de     Equivalente ao 127.0.0.1 no 
                                 loopback         IPv4.                       
   ::00:xx:xx:xx:xx 96 bits      IPv4 Embarcado   Os 32 bits inferiores sao o 
                                                  enderec,o IPv4 compativel.  
                                 O enderec,o IPv4 Os 32 bits mais baixos sao  
   ::ff:xx:xx:xx:xx 96 bits      mapeado do       o enderec,o IPv4 para hosts 
                                 enderec,o IPv6   que nao suportam o IPv6.    
   fe80::/10        10 bits      link-local       Equivalente a               
                                                  169.254.0.0/16 em IPv4.     
                                                  Enderec,os locais           
                                                  exclusivos sao destinados   
   fc00::/7         7 bits       unique-local     `a comunicac,ao local e so  
                                                  podem ser roteados dentro   
                                                  de um conjunto de sites     
                                                  cooperantes.                
   ff00::           8 bits       multicast                                    
                                                  Todos os enderec,os unicast 
   2000::-3fff::    3 bits       unicast global   globais sao atribuidos a    
                                                  partir desse pool. Os       
                                                  primeiros 3 bits sao 001.   

   Para maiores informac,oes sobre a estrutura dos enderec,os do IPv6,
   consulte a RFC3513.

  31.9.2. Configurando o IPv6

   Para configurar um sistema FreeBSD como um cliente IPv6, adicione estas
   duas linhas ao rc.conf:

 ifconfig_rl0_ipv6="inet6 accept_rtadv"
 rtsold_enable="YES"

   A primeira linha permite que a interface especificada receba mensagens de
   solicitac,ao do roteador. A segunda linha ativa o daemon de solicitac,ao
   do roteador, rtsol(8).

   Se a interface precisar de um enderec,o IPv6 atribuido estaticamente,
   adicione uma entrada para especificar o enderec,o estatico e o comprimento
   do prefixo associado:

 ifconfig_rl0_ipv6="inet6 2001:db8:4672:6565:2026:5043:2d42:5344 prefixlen 64"

   Para atribuir um roteador padrao, especifique seu enderec,o:

 ipv6_defaultrouter="2001:db8:4672:6565::1"

  31.9.3. Conectando-se a um provedor

   Para se conectar a outras redes IPv6, e necessario ter um provedor ou um
   tunel que suporte IPv6:

     * Entre em contato com um provedor de servic,os de Internet para saber
       se eles oferecem IPv6.

     * O Hurricane Electric oferece tuneis com endpoints em todo o mundo.

  Nota:

   Instale o pacote ou port net/freenet6 para uma conexao dial-up.

   Esta sec,ao demonstra como obter as direc,oes de um provedor de tuneis e
   converte-las em configurac,oes do /etc/rc.conf que persistirao durante as
   reinicializac,oes.

   A primeira entrada /etc/rc.conf cria a interface de encapsulamento
   generica gif0:

 cloned_interfaces="gif0"

   Em seguida, configure essa interface com os enderec,os IPv4 dos pontos de
   extremidade locais e remotos. Substitua MY_IPv4_ADDR e REMOTE_IPv4_ADDR
   pelos enderec,os atuais de IPv4:

 create_args_gif0="tunnel MY_IPv4_ADDR REMOTE_IPv4_ADDR"

   Para aplicar o enderec,o IPv6 que foi atribuido para uso como o ponto
   final do tunel IPv6, adicione esta linha, substituindo
   MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR pelo enderec,o atribuido:

 ifconfig_gif0_ipv6="inet6 MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR"

   Em seguida, defina a rota padrao para o outro lado do tunel IPv6.
   Substitua MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR pelo enderec,o do gateway
   padrao atribuido pelo provedor:

 ipv6_defaultrouter="MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR"

   Se o sistema FreeBSD ira rotear pacotes IPv6 entre o resto da rede e o
   mundo, habilite o gateway usando esta linha:

 ipv6_gateway_enable="YES"

  31.9.4. Anuncio do roteador e configurac,ao automatica do host

   Esta sec,ao demonstra como configurar o rtadvd(8) para anunciar a rota
   padrao de IPv6.

   Para ativar rtadvd(8), inclua o seguinte no /etc/rc.conf:

 rtadvd_enable="YES"

   E importante especificar a interface na qual fazer a solicitac,ao do
   roteador IPv6. Por exemplo, para informar o rtadvd(8) para usar rl0:

 rtadvd_interfaces="rl0"

   Em seguida, crie o arquivo de configurac,ao, /etc/rtadvd.conf como visto
   neste exemplo:

 rl0:\
         :addrs#1:addr="2001:db8:1f11:246::":prefixlen#64:tc=ether:

   Substitua rl0 com a interface a ser usada e 2001:db8:1f11:246:: com o
   prefixo da alocac,ao.

   Para uma sub-rede /64 dedicada, nada mais precisa ser alterado. Caso
   contrario, altere o prefixlen# para o valor correto.

  31.9.5. IPv6 e o mapeamento de enderec,os IPv6

   Quando o IPv6 esta habilitado em um servidor, pode ser necessario ativar a
   comunicac,ao de enderec,os IPv4 mapeados para IPv6. Esta opc,ao de
   compatibilidade permite que enderec,os IPv4 sejam representados como
   enderec,os de IPv6. Permitir que aplicativos IPv6 se comuniquem com IPv4 e
   vice-versa pode ser um problema de seguranc,a.

   Essa opc,ao pode nao ser necessaria na maioria dos casos e esta disponivel
   apenas para compatibilidade. Esta opc,ao permitira que os aplicativos que
   suportam apenas o IPv6 funcionem com IPv4 em um ambiente de pilha dupla.
   Isso e mais util para aplicativos de terceiros que podem nao suportar um
   ambiente somente de IPv6. Para habilitar esse recurso, adicione o seguinte
   ao /etc/rc.conf:

 ipv6_ipv4mapping="YES"

   Revisar as informac,oes da RFC 3493, sec,ao 3.6 e 3.7, bem como da RFC
   4038 sec,ao 4.2, pode ser util para alguns administradores.

31.10. Protocolo Comum de Redundancia de Enderec,os (CARP)

   Contribuido por Tom Rhodes.
   Atualizado por Allan Jude .

   O Protocolo Comum de Redundancia de Enderec,os (CARP) permite que varios
   hosts compartilhem o mesmo enderec,o IP e ID de Host Virtual (VHID) para
   fornecer alta disponibilidade para um ou mais servic,os. Isso significa
   que um ou mais hosts podem falhar e os outros hosts assumem o controle de
   modo transparente, de modo que os usuarios nao percebam uma falha de
   servic,o.

   Alem do enderec,o IP compartilhado, cada host tem seu proprio enderec,o IP
   para gerenciamento e configurac,ao. Todas as maquinas que compartilham um
   enderec,o IP tem o mesmo VHID. O VHID para cada enderec,o virtual de IP
   deve ser exclusivo no dominio de broadcast da interface de rede.

   A alta disponibilidade usando o CARP e nativa no FreeBSD, embora os passos
   para configura-lo variem um pouco dependendo da versao do FreeBSD. Esta
   sec,ao fornece a mesma configurac,ao de exemplo para versoes anteriores,
   iguais ou posteriores ao FreeBSD 10.

   Este exemplo configura o suporte a failover com tres hosts, todos com
   enderec,os exclusivos de IP, mas que fornecem o mesmo conteudo da web. Ele
   tem dois mestres diferentes chamados hosta.example.org e
   hostb.example.org, com um backup compartilhado chamado hostc.example.org.

   O balanceamento de carga destas maquinas e feito por meio de uma
   configurac,ao de DNS Round Robin. As maquinas principais e de backup sao
   configuradas de forma identica, exceto por seus nomes de host e enderec,os
   de gerenciamento IP. Esses servidores devem ter a mesma configurac,ao e
   executar os mesmos servic,os. Quando o failover ocorre, as solicitac,oes
   para o servic,o no enderec,o IP compartilhado so podem ser respondidas
   corretamente se o servidor de backup tiver acesso ao mesmo conteudo. A
   maquina de backup tem duas interfaces CARP adicionais, uma para cada
   enderec,o IP do servidor de conteudo mestre. Quando ocorre uma falha, o
   servidor de backup selecionara o enderec,o IP da maquina mestre com falha.

  31.10.1. Usando CARP no FreeBSD 10 e superiores

   Ative o suporte para CARP na inicializac,ao do sistema, adicionando uma
   entrada para o modulo do kernel carp.ko em /boot/loader.conf:

 carp_load="YES"

   Para carregar o modulo agora sem reiniciar:

 # kldload carp

   Para usuarios que preferem usar um kernel personalizado, inclua a seguinte
   linha no arquivo de configurac,ao do kernel personalizado e compile o
   kernel como descrito em Capitulo 8, Configurando o kernel do FreeBSD:

 device  carp

   O nome do host, o enderec,o IP de gerenciamento e a mascara de sub-rede, o
   enderec,o IP compartilhado e o VHID sao definidos adicionando entradas ao
   /etc/rc.conf. Este exemplo e para o hosta.example.org:

 hostname="hosta.example.org"
 ifconfig_em0="inet 192.168.1.3 netmask 255.255.255.0"
 ifconfig_em0_alias0="inet vhid 1 pass testpass alias 192.168.1.50/32"

   O proximo conjunto de entradas e para o hostb.example.org. Como ele
   representa um segundo mestre, ele usa um enderec,o IP compartilhado
   diferente e VHID. No entanto, as senhas especificadas com pass devem ser
   identicas, pois o CARP somente ouvira e aceitara anuncios de maquinas com
   a senha correta.

 hostname="hostb.example.org"
 ifconfig_em0="inet 192.168.1.4 netmask 255.255.255.0"
 ifconfig_em0_alias0="inet vhid 2 pass testpass alias 192.168.1.51/32"

   A terceira maquina, hostc.example.org, e configurada para lidar com o
   failover de um dos mestres. Esta maquina e configurada com dois CARP
   VHIDs, um para manipular o enderec,o IP virtual para cada um dos hosts
   principais. O desvio de publicidade CARP, advskew, e definida para
   garantir que o host de backup seja anunciado depois do mestre, pois
   advskew controla a ordem de precedencia quando existem varios servidores
   de backup.

 hostname="hostc.example.org"
 ifconfig_em0="inet 192.168.1.5 netmask 255.255.255.0"
 ifconfig_em0_alias0="inet vhid 1 advskew 100 pass testpass alias 192.168.1.50/32"
 ifconfig_em0_alias1="inet vhid 2 advskew 100 pass testpass alias 192.168.1.51/32"

   Ter dois CARP VHIDs configurados significa que o hostc.example.org notara
   se um dos servidores principais ficar indisponivel. Se um mestre falhar em
   anunciar antes do servidor de backup, o servidor de backup selecionara o
   enderec,o IP compartilhado ate que o mestre se torne disponivel novamente.

  Nota:

   Se o servidor mestre original se tornar disponivel novamente, o
   hostc.example.org nao liberara o enderec,o virtual IP de volta a ele
   automaticamente. Para que isso acontec,a, a preempc,ao deve ser ativada. O
   recurso esta desabilitado por padrao, ele e controlado por meio da
   variavel sysctl(8) net.inet.carp.preempt. O administrador pode forc,ar o
   servidor de backup a retornar o enderec,o IP para o mestre:

 # ifconfig em0 vhid 1 state backup

   Quando a configurac,ao estiver concluida, reinicie a rede ou reinicie cada
   um dos sistemas. A alta disponibilidade esta agora ativada.

   A funcionalidade CARP pode ser controlada atraves de diversas variaveis
   sysctl(8) documentadas nas paginas de manual do carp(4). Outras ac,oes
   podem ser acionadas a partir de eventos CARP usando devd(8).

  31.10.2. Usando CARP no FreeBSD 9 e anteriores

   A configurac,ao para estas versoes do FreeBSD e similar `aquela descrita
   na sec,ao anterior, exceto que o dispositivo CARP deve ser criado primeiro
   e referenciado na configurac,ao.

   Ative o suporte de tempo de inicializac,ao para o CARP carregando o modulo
   do kernel if_carp.ko no /boot/loader.conf:

 if_carp_load="YES"

   Para carregar o modulo agora sem reiniciar:

 # kldload carp

   Para usuarios que preferem usar um kernel personalizado, inclua a seguinte
   linha no arquivo de configurac,ao do kernel personalizado e compile o
   kernel como descrito em Capitulo 8, Configurando o kernel do FreeBSD:

 device  carp

   Em seguida, em cada host, crie um dispositivo CARP:

 # ifconfig carp0 create

   Defina o nome do host, o enderec,o IP de gerenciamento, o enderec,o IP
   compartilhado e o VHID adicionando as linhas necessarias ao /etc/rc.conf.
   Como um dispositivo virtual CARP e usado em vez de um alias, uma mascara
   de subrede real /24 e usada em vez de uma /32. Aqui estao as entradas para
   o hosta.example.org:

 hostname="hosta.example.org"
 ifconfig_fxp0="inet 192.168.1.3 netmask 255.255.255.0"
 cloned_interfaces="carp0"
 ifconfig_carp0="vhid 1 pass testpass 192.168.1.50/24"

   Em hostb.example.org:

 hostname="hostb.example.org"
 ifconfig_fxp0="inet 192.168.1.4 netmask 255.255.255.0"
 cloned_interfaces="carp0"
 ifconfig_carp0="vhid 2 pass testpass 192.168.1.51/24"

   A terceira maquina, hostc.example.org, esta configurada para lidar com o
   failover de qualquer um dos hosts principais:

 hostname="hostc.example.org"
 ifconfig_fxp0="inet 192.168.1.5 netmask 255.255.255.0"
 cloned_interfaces="carp0 carp1"
 ifconfig_carp0="vhid 1 advskew 100 pass testpass 192.168.1.50/24"
 ifconfig_carp1="vhid 2 advskew 100 pass testpass 192.168.1.51/24"

  Nota:

   A preempc,ao esta desabilitada no kernel GENERIC do FreeBSD. Se a
   preempc,ao tiver sido ativada com um kernel personalizado, o
   hostc.example.org podera nao liberar o enderec,o IP de volta ao servidor
   de conteudo original. O administrador pode forc,ar o servidor de backup a
   retornar o enderec,o IP para o mestre com o comando:

 # ifconfig carp0 down && ifconfig carp0 up

   Isso deve ser feito na interface carp, que corresponde ao host correto.

   Quando a configurac,ao estiver concluida, reinicie a rede ou reinicie cada
   um dos sistemas. A alta disponibilidade esta agora ativada.

31.11. VLANs

   As VLANs sao uma forma de dividir virtualmente uma rede em varias
   sub-redes diferentes, tambem conhecida como segmentac,ao. Cada segmento
   tera seu proprio dominio de broadcast e sera isolado de outras VLANs.

   No FreeBSD, as VLANs devem ser suportadas pelo driver da placa de rede.
   Para ver quais drivers suportam vlans, consulte a pagina de manual
   vlan(4).

   Ao configurar uma VLAN, algumas informac,oes devem ser conhecidas.
   Primeiro, qual a interface de rede? Segundo, qual e a tag da VLAN?

   Para configurar uma VLANs em tempo de execuc,ao, com uma NIC em0 e uma tag
   VLAN de 5 o comando ficaria assim:

 # ifconfig em0.5 create vlan 5 vlandev em0 inet 192.168.20.20/24

  Nota:

   Viu como o nome da interface inclui o nome do driver da NIC e a tag VLAN,
   separados por um ponto final? Essa e uma pratica recomendada para
   facilitar a manutenc,ao da configurac,ao de VLAN quando muitas VLANs
   estiverem presentes em uma maquina.

   Para configurar uma VLANs no momento da inicializac,ao, o /etc/rc.conf
   deve ser atualizado. Para duplicar a configurac,ao acima, sera necessario
   adicionar o seguinte:

 vlans_em0="5"
 ifconfig_em0_5="inet 192.168.20.20/24"

   VLANs adicionais podem ser inseridas, simplesmente adicionando a tag ao
   campo vlans_em0 e incrementando uma linha de configurac,ao da rede nessa
   interface da tag VLAN.

   E util atribuir um nome simbolico a uma interface para que, quando o
   hardware associado for alterado, apenas algumas variaveis de configurac,ao
   precisem ser atualizadas. Por exemplo, cameras de seguranc,a precisam ser
   executadas pela VLAN 1 em em0. Posteriormente, se a placa em0 for
   substituida por uma placa que use o driver ixgb(4), todas as referencias a
   em0.1 nao precisarao ser alterado para ixgb0.1.

   Para configurar a VLAN 5, na NIC em0, atribua o nome de interface cameras,
   e atribua `a interface um enderec,o IP de 192.168.20.20 com um prefixo
   24-bit, use este comando:

 # ifconfig em0.5 create vlan 5 vlandev em0 name cameras inet 192.168.20.20/24

   Para uma interface denominada video, use o seguinte:

 # ifconfig video.5 create vlan 5 vlandev video name cameras inet 192.168.20.20/24

   Para aplicar as mudanc,as no momento da inicializac,ao, adicione as
   seguintes linhas ao /etc/rc.conf:

 vlans_video="cameras"
 create_args_cameras="vlan 5"
 ifconfig_cameras="inet 192.168.20.20/24"

                               Parte V. Apendices

   Indice

   A. Obtendo o FreeBSD

                A.1. CD and DVD Sets

                A.2. Sites de FTP

                A.3. Usando o Subversion

                A.4. Usando o rsync

   B. Bibliografia

                B.1. Livros especificos para o FreeBSD

                B.2. Guias de usuarios

                B.3. Guias de Administradores

                B.4. Guias de programadores

                B.5. Internals do sistema operacional

                B.6. Referencias de seguranc,a

                B.7. Referencias de Hardware

                B.8. Historia do UNIX(R)

                B.9. Periodicos, Jornais e Revistas

   C. Recursos na Internet

                C.1. Websites

                C.2. Listas de Discussao

                C.3. Grupos de Noticias Usenet

                C.4. Espelhos Oficiais

   D. Chaves OpenPGP

                D.1. Administradores

Apendice A. Obtendo o FreeBSD

   Indice

   A.1. CD and DVD Sets

   A.2. Sites de FTP

   A.3. Usando o Subversion

   A.4. Usando o rsync

A.1. CD and DVD Sets

   Os conjuntos de CD and DVD do FreeBSD estao disponiveis em varios
   varejistas on-line:

     * FreeBSD Mall, Inc.
         2420 Sand Creek Rd C-1 #347
         Brentwood, CA
         94513
         USA
         Phone: +1 925 240-6652
         Fax: +1 925 674-0821
         Email: <info@freebsdmall.com>
         WWW: https://www.freebsdmall.com

     * Getlinux
         78 Rue de la Croix Rochopt
         Epinay-sous-Senart
         91860
         France
         Email: <contact@getlinux.fr>
         WWW: http://www.getlinux.fr/

     * Dr. Hinner EDV
         Kochelseestr. 11
         D-81371 Mu:nchen
         Germany
         Phone: (0177) 428 419 0
         Email: <infow@hinner.de>
         WWW: http://www.hinner.de/linux/freebsd.html

     * Linux Center
         Galernaya Street, 55
         Saint-Petersburg
         190000
         Russia
         Phone: +7-812-309-06-86
         Email: <info@linuxcenter.ru>
         WWW: http://linuxcenter.ru/shop/freebsd

A.2. Sites de FTP

   As fontes oficiais do FreeBSD estao disponiveis no FTP anonimo de um
   conjunto mundial de sites espelho. O site
   ftp://ftp.FreeBSD.org/pub/FreeBSD/ esta disponivel via HTTP e FTP. Ele e
   composto de muitas maquinas operadas pelos administradores de cluster do
   projeto e fica atras de uma estrutura de GeoDNS que direciona os usuarios
   para o espelho disponivel mais proximo.

   Adicionalmente, o FreeBSD esta disponivel via FTP anonimo a partir dos
   seguintes sites espelho. Ao obter o FreeBSD via FTP anonimo, por favor
   tente usar um site proximo. Os sites espelhos listados como "Sites
   Espelhos Primarios" geralmente possuem o arquivo completo do FreeBSD
   (todas as versoes atualmente disponiveis para cada uma das arquiteturas),
   mas velocidades de download mais rapidas provavelmente estao disponiveis
   em um site que esteja em seu pais ou regiao. Os sites regionais carregam
   as versoes mais recentes para a(s) arquitetura(s) mais populare(s), mas
   podem nao carregar o arquivo completo do FreeBSD. Todos os sites fornecem
   acesso via FTP anonimo, mas alguns sites tambem fornecem acesso por meio
   de outros metodos. Os metodos de acesso disponiveis para cada site sao
   fornecidos entre parenteses apos o nome do host.

   Servidores Centrais, Sites Espelhos Primarios, Armenia, Australia,
   Austria, Brazil, Czech Republic, Denmark, Estonia, Finland, France,
   Germany, Greece, Hong Kong, Ireland, Japan, Korea, Latvia, Lithuania,
   Netherlands, New Zealand, Norway, Poland, Russia, Saudi Arabia, Slovenia,
   South Africa, Spain, Sweden, Switzerland, Taiwan, Ukraine, United Kingdom,
   USA.

   (a partir de UTC)

   Servidores centrais
              * ftp://ftp.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 /
                http://ftp.FreeBSD.org/pub/FreeBSD/ /
                http://ftp.FreeBSD.org/pub/FreeBSD/)

   Sites Espelhos Primarios

           Em caso de problemas, entre em contato com o hostmaster
           <mirror-admin@FreeBSD.org> para este dominio.

              * ftp://ftp1.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp2.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp3.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp4.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 /
                http://ftp4.FreeBSD.org/pub/FreeBSD/ /
                http://ftp4.FreeBSD.org/pub/FreeBSD/)

              * ftp://ftp5.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp6.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp7.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp10.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 /
                http://ftp10.FreeBSD.org/pub/FreeBSD/ /
                http://ftp10.FreeBSD.org/pub/FreeBSD/)

              * ftp://ftp11.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp13.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp14.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp14.FreeBSD.org/pub/FreeBSD/)

   Armenia

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@am.FreeBSD.org > para este dominio.

              * ftp://ftp1.am.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp1.am.FreeBSD.org/pub/FreeBSD/ / rsync)

   Australia

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@au.FreeBSD.org > para este dominio.

              * ftp://ftp.au.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp2.au.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp3.au.FreeBSD.org/pub/FreeBSD/ (ftp)

   Austria

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@at.FreeBSD.org > para este dominio.

              * ftp://ftp.at.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 /
                http://ftp.at.FreeBSD.org/pub/FreeBSD/ /
                http://ftp.at.FreeBSD.org/pub/FreeBSD/)

   Brasil

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@br.FreeBSD.org > para este dominio.

              * ftp://ftp2.br.FreeBSD.org/FreeBSD/ (ftp /
                http://ftp2.br.FreeBSD.org/)

              * ftp://ftp3.br.FreeBSD.org/pub/FreeBSD/ (ftp / rsync)

              * ftp://ftp4.br.FreeBSD.org/pub/FreeBSD/ (ftp)

   Republica Checa

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@cz.FreeBSD.org > para este dominio.

              * ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/ (ftp /
                ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/ /
                http://ftp.cz.FreeBSD.org/pub/FreeBSD/ /
                http://ftp.cz.FreeBSD.org/pub/FreeBSD/ / rsync / rsyncv6)

              * ftp://ftp2.cz.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp2.cz.FreeBSD.org/pub/FreeBSD/)

   Dinamarca

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@dk.FreeBSD.org > para este dominio.

              * ftp://ftp.dk.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 /
                http://ftp.dk.FreeBSD.org/pub/FreeBSD/ /
                http://ftp.dk.FreeBSD.org/pub/FreeBSD/)

   Estonia

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@ee.FreeBSD.org > para este dominio.

              * ftp://ftp.ee.FreeBSD.org/pub/FreeBSD/ (ftp)

   Finlandia

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@fi.FreeBSD.org > para este dominio.

              * ftp://ftp.fi.FreeBSD.org/pub/FreeBSD/ (ftp)

   Franc,a

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@fr.FreeBSD.org > para este dominio.

              * ftp://ftp.fr.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp1.fr.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp1.fr.FreeBSD.org/pub/FreeBSD/ / rsync)

              * ftp://ftp3.fr.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp5.fr.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/ (ftp / rsync)

              * ftp://ftp7.fr.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp8.fr.FreeBSD.org/pub/FreeBSD/ (ftp)

   Alemanha

           Em caso de problemas, entre em contato com o hostmaster <
           de-bsd-hubs@de.FreeBSD.org > para este dominio.

              * ftp://ftp.de.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp1.de.FreeBSD.org/freebsd/ (ftp /
                http://www1.de.FreeBSD.org/freebsd/ /
                rsync://rsync3.de.FreeBSD.org/freebsd/)

              * ftp://ftp2.de.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp2.de.FreeBSD.org/pub/FreeBSD/ / rsync)

              * ftp://ftp4.de.FreeBSD.org/FreeBSD/ (ftp /
                http://ftp4.de.FreeBSD.org/pub/FreeBSD/)

              * ftp://ftp5.de.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp7.de.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp7.de.FreeBSD.org/pub/FreeBSD/)

              * ftp://ftp8.de.FreeBSD.org/pub/FreeBSD/ (ftp)

   Grecia

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@gr.FreeBSD.org > para este dominio.

              * ftp://ftp.gr.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp2.gr.FreeBSD.org/pub/FreeBSD/ (ftp)

   Hong Kong
              * ftp://ftp.hk.FreeBSD.org/pub/FreeBSD/ (ftp)

   Irlanda

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@ie.FreeBSD.org > para este dominio.

              * ftp://ftp3.ie.FreeBSD.org/pub/FreeBSD/ (ftp / rsync)

   Japan

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@jp.FreeBSD.org > para este dominio.

              * ftp://ftp.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp2.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp3.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp4.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp5.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp6.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp7.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp8.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp9.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

   Coreia

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@kr.FreeBSD.org > para este dominio.

              * ftp://ftp.kr.FreeBSD.org/pub/FreeBSD/ (ftp / rsync)

              * ftp://ftp2.kr.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp2.kr.FreeBSD.org/pub/FreeBSD/)

   Letonia

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@lv.FreeBSD.org > para este dominio.

              * ftp://ftp.lv.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp.lv.FreeBSD.org/pub/FreeBSD/)

   Lituania

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@lt.FreeBSD.org > para este dominio.

              * ftp://ftp.lt.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp.lt.FreeBSD.org/pub/FreeBSD/)

   Paises Baixos

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@nl.FreeBSD.org > para este dominio.

              * ftp://ftp.nl.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp.nl.FreeBSD.org/os/FreeBSD/ / rsync)

              * ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD/ (ftp)

   Nova Zelandia
              * ftp://ftp.nz.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp.nz.FreeBSD.org/pub/FreeBSD/)

   Noruega

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@no.FreeBSD.org > para este dominio.

              * ftp://ftp.no.FreeBSD.org/pub/FreeBSD/ (ftp / rsync)

   Polonia

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@pl.FreeBSD.org > para este dominio.

              * ftp://ftp.pl.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp2.pl.FreeBSD.org

   Russia

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@ru.FreeBSD.org > para este dominio.

              * ftp://ftp.ru.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp.ru.FreeBSD.org/FreeBSD/ / rsync)

              * ftp://ftp2.ru.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp2.ru.FreeBSD.org/pub/FreeBSD/ / rsync)

              * ftp://ftp4.ru.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp5.ru.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp5.ru.FreeBSD.org/pub/FreeBSD/ / rsync)

              * ftp://ftp6.ru.FreeBSD.org/pub/FreeBSD/ (ftp)

   Arabia Saudita

           Em caso de problemas, entre em contato com o hostmaster <
           ftpadmin@isu.net.sa > para este dominio.

              * ftp://ftp.isu.net.sa/pub/ftp.freebsd.org/ (ftp)

   Eslovenia

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@si.FreeBSD.org > para este dominio.

              * ftp://ftp.si.FreeBSD.org/pub/FreeBSD/ (ftp)

   Africa do Sul

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@za.FreeBSD.org > para este dominio.

              * ftp://ftp.za.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp2.za.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp4.za.FreeBSD.org/pub/FreeBSD/ (ftp)

   Espanha

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@es.FreeBSD.org > para este dominio.

              * ftp://ftp.es.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp.es.FreeBSD.org/pub/FreeBSD/)

              * ftp://ftp3.es.FreeBSD.org/pub/FreeBSD/ (ftp)

   Suecia

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@se.FreeBSD.org > para este dominio.

              * ftp://ftp.se.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp2.se.FreeBSD.org/pub/FreeBSD/ (ftp /
                rsync://ftp2.se.FreeBSD.org/)

              * ftp://ftp3.se.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/ (ftp /
                ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/ /
                http://ftp4.se.FreeBSD.org/pub/FreeBSD/ /
                http://ftp4.se.FreeBSD.org/pub/FreeBSD/ /
                rsync://ftp4.se.FreeBSD.org/pub/FreeBSD/ /
                rsync://ftp4.se.FreeBSD.org/pub/FreeBSD/)

              * ftp://ftp6.se.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp6.se.FreeBSD.org/pub/FreeBSD/)

   Suic,a

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@ch.FreeBSD.org > para este dominio.

              * ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp.ch.FreeBSD.org/pub/FreeBSD/)

   Taiwan

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@tw.FreeBSD.org > para este dominio.

              * ftp://ftp.tw.FreeBSD.org/pub/FreeBSD/ (ftp /
                ftp://ftp.tw.FreeBSD.org/pub/FreeBSD/ / rsync / rsyncv6)

              * ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/ (ftp /
                ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/ /
                http://ftp2.tw.FreeBSD.org/pub/FreeBSD/ /
                http://ftp2.tw.FreeBSD.org/pub/FreeBSD/ / rsync / rsyncv6)

              * ftp://ftp4.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp6.tw.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp6.tw.FreeBSD.org/ / rsync)

              * ftp://ftp7.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp8.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp11.tw.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp11.tw.FreeBSD.org/FreeBSD/)

              * ftp://ftp12.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp13.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp14.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp15.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

   Ucrania
              * ftp://ftp.ua.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp.ua.FreeBSD.org/pub/FreeBSD/)

              * ftp://ftp6.ua.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp6.ua.FreeBSD.org/pub/FreeBSD /
                rsync://ftp6.ua.FreeBSD.org/FreeBSD/)

              * ftp://ftp7.ua.FreeBSD.org/pub/FreeBSD/ (ftp)

   Reino Unido

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@uk.FreeBSD.org > para este dominio.

              * ftp://ftp.uk.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp2.uk.FreeBSD.org/pub/FreeBSD/ (ftp /
                rsync://ftp2.uk.FreeBSD.org/ftp.freebsd.org/pub/FreeBSD/)

              * ftp://ftp3.uk.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp4.uk.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp5.uk.FreeBSD.org/pub/FreeBSD/ (ftp)

   USA

           Em caso de problemas, entre em contato com o hostmaster <
           hostmaster@us.FreeBSD.org > para este dominio.

              * ftp://ftp1.us.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp2.us.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp3.us.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp4.us.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 /
                http://ftp4.us.FreeBSD.org/pub/FreeBSD/ /
                http://ftp4.us.FreeBSD.org/pub/FreeBSD/)

              * ftp://ftp5.us.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp6.us.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp8.us.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp10.us.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp11.us.FreeBSD.org/pub/FreeBSD/ (ftp)

              * ftp://ftp13.us.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp13.us.FreeBSD.org/pub/FreeBSD/ / rsync)

              * ftp://ftp14.us.FreeBSD.org/pub/FreeBSD/ (ftp /
                http://ftp14.us.FreeBSD.org/pub/FreeBSD/)

              * ftp://ftp15.us.FreeBSD.org/pub/FreeBSD/ (ftp)

A.3. Usando o Subversion

  A.3.1. Introduc,ao

   Desde de julho de 2012, o FreeBSD usa o Subversion como o unico sistema de
   controle de versao para armazenar todo o codigo-fonte do FreeBSD, a
   documentac,ao e a colec,ao de ports.

  Nota:

   O Subversion e geralmente uma ferramenta de desenvolvimento. Os usuarios
   podem preferir usar o freebsd-update (Sec,ao 23.2, "Atualizac,ao do
   FreeBSD") para atualizar o sistema basico do FreeBSD, e o portsnap
   (Sec,ao 4.5, "Usando a Colec,ao de Ports") para atualizar a colec,ao de
   ports do FreeBSD.

   Esta sec,ao demonstra como instalar o Subversion em um sistema FreeBSD e
   usa-lo para criar uma copia local de um repositorio do FreeBSD.
   Informac,oes adicionais sobre o uso de Subversion estao incluidas.

  A.3.2. Certificados Raiz SSL

   A instalac,ao do security/ca_root_nss permite que o Subversion verifique a
   identidade dos servidores de repositorio HTTPS. Os certificados raiz SSL
   podem ser instalados a partir de um port:

 # cd /usr/ports/security/ca_root_nss
 # make install clean

   ou como um pacote:

 # pkg install ca_root_nss

  A.3.3. Svnlite

   Uma versao leve do Subversion ja esta instalada no FreeBSD como svnlite. A
   versao do port ou pacote do Subversion e necessaria apenas se a API do
   Python ou do Perl for necessaria, ou se uma versao posterior do Subversion
   for desejada.

   A unica diferenc,a do uso normal do Subversion e que o nome do comando e
   svnlite.

  A.3.4. Instalac,ao

   Se o svnlite nao estiver disponivel ou a versao completa do Subversion for
   necessaria, ele devera ser instalado.

   O Subversion pode ser instalado a partir da colec,ao de ports:

 # cd /usr/ports/devel/subversion
 # make install clean

   O Subversion tambem pode ser instalado como um pacote:

 # pkg install subversion

  A.3.5. Executando o Subversion

   Para obter uma copia limpa do codigo-fonte em um diretorio local, use svn.
   Os arquivos neste diretorio sao chamados de copia de trabalho local.

  Atenc,ao:

   Mova ou exclua o diretorio de destino existente antes de usar o checkout
   pela primeira vez.

   O checkout em cima de um diretorio nao-svn existente pode causar conflitos
   entre os arquivos existentes e aqueles trazidos do repositorio.

   O Subversion usa URLs para designar um repositorio, sob a forma de
   protocol://hostname/path. O primeiro componente do caminho e o repositorio
   do FreeBSD para acessar. Existem tres repositorios diferentes, base para o
   codigo-fonte do sistema basico do FreeBSD, ports para a colec,ao de ports,
   e doc para a documentac,ao. Por exemplo, o URL
   https://svn.FreeBSD.org/ports/head/ especifica a ramificac,ao principal do
   repositorio de ports, usando o protocolo https.

   Um checkout de um determinado repositorio e executado com um comando como
   este:

 # svn checkout https://svn.FreeBSD.org/repository/branch lwcdir

   Onde:

     * O repository e um dos repositorios do Projecto: base, ports, ou doc.

     * A branch depende do repositorio usado. O ports e o doc sao normalmente
       atualizados na ramificac,ao head, enquanto base mantem a ultima versao
       de -CURRENT em head e as respectivas versoes mais recentes das
       ramificac,oes -STABLE em stable/9 (9.x) e stable/10 (10.x).

     * O lwcdir e o diretorio de destino onde o conteudo do ramo especificado
       deve ser colocado. Isso geralmente e /usr/ports para o ports, /usr/src
       para a base, e /usr/doc para o doc.

   Este exemplo obtem a colec,ao de ports do repositorio do FreeBSD usando o
   protocolo HTTPS, colocando a copia de trabalho local em /usr/ports. Se o
   /usr/ports ja estiver presente, mas nao tiver sido criado pelo svn,
   lembre-se de renomea-lo ou exclui-lo antes do checkout.

 # svn checkout https://svn.FreeBSD.org/ports/head /usr/ports

   Como o checkout inicial deve fazer o download da ramificac,ao completa do
   repositorio remoto, isso pode demorar um pouco. Por favor, seja paciente.

   Apos o checkout inicial, a copia de trabalho local pode ser atualizada
   executando:

 # svn update lwcdir

   Para atualizar o /usr/ports criado no exemplo acima, use:

 # svn update /usr/ports

   O update e muito mais rapido do que um checkout, transferindo apenas os
   arquivos que foram alterados.

   Uma maneira alternativa de atualizar a copia de trabalho local apos o
   checkout e fornecida pelo Makefile existente em /usr/ports, /usr/src, e
   /usr/doc. Configure o SVN_UPDATE e use o destino atualizar. Por exemplo,
   para atualizar /usr/src:

 # cd /usr/src
 # make update SVN_UPDATE=yes

  A.3.6. Sites Espelho do Subversion

   O repositorio Subversion do FreeBSD e:

 svn.FreeBSD.org

   Essa e uma rede de espelhos acessivel publicamente a qual usa o GeoDNS
   para selecionar um servidor de backend apropriado. Para visualizar os
   repositorios Subversion do FreeBSD atraves de um navegador, use
   https://svnweb.FreeBSD.org/.

   O HTTPS e o protocolo preferido, mas o pacote security/ca_root_nss
   precisara ser instalado para validar os certificados automaticamente.

  A.3.7. Para Maiores Informac,oes

   Para outras informac,oes sobre o uso do Subversion, por favor veja o
   "Subversion Book", intitulado Version Controle com Subversion, ou o
   Documentac,ao do Subversion.

A.4. Usando o rsync

   Estes sites disponibilizam o FreeBSD atraves do protocolo rsync. O
   utilitario rsync transfere apenas as diferenc,as entre dois conjuntos de
   arquivos. Isto e util para sites espelho do servidor de FTP do FreeBSD . O
   pacote rsync esta disponivel para muitos sistemas operacionais, no
   FreeBSD, veja o port net/rsync ou use o pacote.

   Republica Checa

           rsync://ftp.cz.FreeBSD.org/

           Colec,oes disponiveis:

              * ftp: Um espelho parcial do servidor de FTP do FreeBSD.

              * FreeBSD: Um espelho completo do servidor de FTP do FreeBSD.

   Paises Baixos

           rsync://ftp.nl.FreeBSD.org/

           Colec,oes disponiveis:

              * FreeBSD: Um espelho completo do servidor de FTP do FreeBSD.

   Russia

           rsync://ftp.mtu.ru/

           Colec,oes disponiveis:

              * FreeBSD: Um espelho completo do servidor de FTP do FreeBSD.

              * FreeBSD-Archive: Um espelho do servidor de FTP do FreeBSD
                Archive.

   Suecia

           rsync://ftp4.se.freebsd.org/

           Colec,oes disponiveis:

              * FreeBSD: Um espelho completo do servidor de FTP do FreeBSD.

   Taiwan

           rsync://ftp.tw.FreeBSD.org/

           rsync://ftp2.tw.FreeBSD.org/

           rsync://ftp6.tw.FreeBSD.org/

           Colec,oes disponiveis:

              * FreeBSD: Um espelho completo do servidor de FTP do FreeBSD.

   Reino Unido

           rsync://rsync.mirrorservice.org/

           Colec,oes disponiveis:

              * ftp.freebsd.org: Um espelho completo do servidor de FTP do
                FreeBSD.

   Estados Unidos da America

           rsync://ftp-master.FreeBSD.org/

           Este servidor so pode ser usado por sites espelhos primarios do
           FreeBSD.

           Colec,oes disponiveis:

              * FreeBSD: O arquivo master do servidor de FTP do FreeBSD.

              * acl: A lista do ACL mestre do FreeBSD.

           rsync://ftp13.FreeBSD.org/

           Colec,oes disponiveis:

              * FreeBSD: Um espelho completo do servidor de FTP do FreeBSD.

Apendice B. Bibliografia

   Indice

   B.1. Livros especificos para o FreeBSD

   B.2. Guias de usuarios

   B.3. Guias de Administradores

   B.4. Guias de programadores

   B.5. Internals do sistema operacional

   B.6. Referencias de seguranc,a

   B.7. Referencias de Hardware

   B.8. Historia do UNIX(R)

   B.9. Periodicos, Jornais e Revistas

   Enquanto paginas manuais fornecem uma referencia definitiva para partes
   individuais do sistema operacional FreeBSD, elas raramente ilustram como
   juntar as pec,as para fazer todo o sistema operacional rodar sem
   problemas. Para isso, nao ha substituto para um bom livro ou manual do
   usuario na administrac,ao do sistema UNIX(R).

B.1. Livros especificos para o FreeBSD

   Livros internacionais:

     * Using FreeBSD (in Traditional Chinese), published by Drmaster, 1997.
       ISBN 9-578-39435-7.

     * FreeBSD Unleashed (Simplified Chinese translation), published by China
       Machine Press. ISBN 7-111-10201-0.

     * FreeBSD From Scratch Second Edition (in Simplified Chinese), published
       by China Machine Press. ISBN 7-111-10286-X.

     * FreeBSD Handbook Second Edition (Simplified Chinese translation),
       published by Posts & Telecom Press. ISBN 7-115-10541-3.

     * FreeBSD & Windows (in Simplified Chinese), published by China Railway
       Publishing House. ISBN 7-113-03845-X

     * FreeBSD Internet Services HOWTO (in Simplified Chinese), published by
       China Railway Publishing House. ISBN 7-113-03423-3

     * FreeBSD (in Japanese), published by CUTT. ISBN 4-906391-22-2 C3055
       P2400E.

     * Complete Introduction to FreeBSD (in Japanese), published by Shoeisha
       Co., Ltd. ISBN 4-88135-473-6 P3600E.

     * Personal UNIX Starter Kit FreeBSD (in Japanese), published by ASCII.
       ISBN 4-7561-1733-3 P3000E.

     * FreeBSD Handbook (Japanese translation), published by ASCII. ISBN
       4-7561-1580-2 P3800E.

     * FreeBSD mit Methode (in German), published by Computer und Literatur
       Verlag/Vertrieb Hanser, 1998. ISBN 3-932311-31-0.

     * FreeBSD de Luxe (in German), published by Verlag Modere Industrie,
       2003. ISBN 3-8266-1343-0.

     * FreeBSD Install and Utilization Manual (in Japanese), published by
       Mainichi Communications Inc., 1998. ISBN 4-8399-0112-0.

     * Onno W Purbo, Dodi Maryanto, Syahrial Hubbany, Widjil Widodo Building
       Internet Server with FreeBSD (in Indonesia Language), published by
       Elex Media Komputindo.

     * Absolute BSD: The Ultimate Guide to FreeBSD (Traditional Chinese
       translation), published by GrandTech Press, 2003. ISBN 986-7944-92-5.

     * The FreeBSD 6.0 Book (in Traditional Chinese), published by Drmaster,
       2006. ISBN 9-575-27878-X.

   Livros de lingua inglesa:

     * Absolute FreeBSD, 2nd Edition: The Complete Guide to FreeBSD,
       published by No Starch Press, 2007. ISBN: 978-1-59327-151-0

     * The Complete FreeBSD, published by O'Reilly, 2003. ISBN: 0596005164

     * The FreeBSD Corporate Networker's Guide, published by Addison-Wesley,
       2000. ISBN: 0201704811

     * FreeBSD: An Open-Source Operating System for Your Personal Computer,
       published by The Bit Tree Press, 2001. ISBN: 0971204500

     * Teach Yourself FreeBSD in 24 Hours, published by Sams, 2002. ISBN:
       0672324245

     * FreeBSD 6 Unleashed, published by Sams, 2006. ISBN: 0672328755

     * FreeBSD: The Complete Reference, published by McGrawHill, 2003. ISBN:
       0072224096

B.2. Guias de usuarios

     * Ohio State University has written a UNIX Introductory Course which is
       available online in HTML and PostScript format.

       An Italian translation of this document is available as part of the
       FreeBSD Italian Documentation Project.

     * Edinburgh University has written an Online Guide for newcomers to the
       UNIX environment.

B.3. Guias de Administradores

     * Jpman Project, Japan FreeBSD Users Group. FreeBSD System
       Administrator's Manual (Japanese translation). Mainichi Communications
       Inc., 1998. ISBN4-8399-0109-0 P3300E.

     * Dreyfus, Emmanuel. Cahiers de l'Admin: BSD 2nd Ed. (in French),
       Eyrolles, 2004. ISBN 2-212-11463-X

B.4. Guias de programadores

     * Computer Systems Research Group, UC Berkeley. 4.4BSD Programmer's
       Reference Manual. O'Reilly & Associates, Inc., 1994. ISBN
       1-56592-078-3

     * Computer Systems Research Group, UC Berkeley. 4.4BSD Programmer's
       Supplementary Documents. O'Reilly & Associates, Inc., 1994. ISBN
       1-56592-079-1

     * Harbison, Samuel P. and Steele, Guy L. Jr. C: A Reference Manual. 4th
       Ed. Prentice Hall, 1995. ISBN 0-13-326224-3

     * Kernighan, Brian and Dennis M. Ritchie. The C Programming Language.
       2nd Ed. PTR Prentice Hall, 1988. ISBN 0-13-110362-8

     * Lehey, Greg. Porting UNIX Software. O'Reilly & Associates, Inc., 1995.
       ISBN 1-56592-126-7

     * Plauger, P. J. The Standard C Library. Prentice Hall, 1992. ISBN
       0-13-131509-9

     * Spinellis, Diomidis. Code Reading: The Open Source Perspective.
       Addison-Wesley, 2003. ISBN 0-201-79940-5

     * Spinellis, Diomidis. Code Quality: The Open Source Perspective.
       Addison-Wesley, 2006. ISBN 0-321-16607-8

     * Stevens, W. Richard and Stephen A. Rago. Advanced Programming in the
       UNIX Environment. 2nd Ed. Reading, Mass. : Addison-Wesley, 2005. ISBN
       0-201-43307-9

     * Stevens, W. Richard. UNIX Network Programming. 2nd Ed, PTR Prentice
       Hall, 1998. ISBN 0-13-490012-X

B.5. Internals do sistema operacional

     * Andleigh, Prabhat K. UNIX System Architecture. Prentice-Hall, Inc.,
       1990. ISBN 0-13-949843-5

     * Jolitz, William. "Porting UNIX to the 386". Dr. Dobb's Journal.
       January 1991-July 1992.

     * Leffler, Samuel J., Marshall Kirk McKusick, Michael J Karels and John
       Quarterman The Design and Implementation of the 4.3BSD UNIX Operating
       System. Reading, Mass. : Addison-Wesley, 1989. ISBN 0-201-06196-1

     * Leffler, Samuel J., Marshall Kirk McKusick, The Design and
       Implementation of the 4.3BSD UNIX Operating System: Answer Book.
       Reading, Mass. : Addison-Wesley, 1991. ISBN 0-201-54629-9

     * McKusick, Marshall Kirk, Keith Bostic, Michael J Karels, and John
       Quarterman. The Design and Implementation of the 4.4BSD Operating
       System. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-54979-4

       (Chapter 2 of this book is available online as part of the FreeBSD
       Documentation Project.)

     * Marshall Kirk McKusick, George V. Neville-Neil The Design and
       Implementation of the FreeBSD Operating System. Boston, Mass. :
       Addison-Wesley, 2004. ISBN 0-201-70245-2

     * Marshall Kirk McKusick, George V. Neville-Neil, Robert N. M. Watson
       The Design and Implementation of the FreeBSD Operating System, 2nd
       Ed.. Westford, Mass. : Pearson Education, Inc., 2014. ISBN
       0-321-96897-2

     * Stevens, W. Richard. TCP/IP Illustrated, Volume 1: The Protocols.
       Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-63346-9

     * Schimmel, Curt. Unix Systems for Modern Architectures. Reading, Mass.
       : Addison-Wesley, 1994. ISBN 0-201-63338-8

     * Stevens, W. Richard. TCP/IP Illustrated, Volume 3: TCP for
       Transactions, HTTP, NNTP and the UNIX Domain Protocols. Reading, Mass.
       : Addison-Wesley, 1996. ISBN 0-201-63495-3

     * Vahalia, Uresh. UNIX Internals -- The New Frontiers. Prentice Hall,
       1996. ISBN 0-13-101908-2

     * Wright, Gary R. and W. Richard Stevens. TCP/IP Illustrated, Volume 2:
       The Implementation. Reading, Mass. : Addison-Wesley, 1995. ISBN
       0-201-63354-X

B.6. Referencias de seguranc,a

     * Cheswick, William R. and Steven M. Bellovin. Firewalls and Internet
       Security: Repelling the Wily Hacker. Reading, Mass. : Addison-Wesley,
       1995. ISBN 0-201-63357-4

     * Garfinkel, Simson. PGP Pretty Good Privacy O'Reilly & Associates,
       Inc., 1995. ISBN 1-56592-098-8

B.7. Referencias de Hardware

     * Anderson, Don and Tom Shanley. Pentium Processor System Architecture.
       2nd Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40992-5

     * Ferraro, Richard F. Programmer's Guide to the EGA, VGA, and Super VGA
       Cards. 3rd ed. Reading, Mass. : Addison-Wesley, 1995. ISBN
       0-201-62490-7

     * Intel Corporation publishes documentation on their CPUs, chipsets and
       standards on their developer web site, usually as PDF files.

     * Shanley, Tom. 80486 System Architecture. 3rd Ed. Reading, Mass. :
       Addison-Wesley, 1995. ISBN 0-201-40994-1

     * Shanley, Tom. ISA System Architecture. 3rd Ed. Reading, Mass. :
       Addison-Wesley, 1995. ISBN 0-201-40996-8

     * Shanley, Tom. PCI System Architecture. 4th Ed. Reading, Mass. :
       Addison-Wesley, 1999. ISBN 0-201-30974-2

     * Van Gilluwe, Frank. The Undocumented PC, 2nd Ed. Reading, Mass:
       Addison-Wesley Pub. Co., 1996. ISBN 0-201-47950-8

     * Messmer, Hans-Peter. The Indispensable PC Hardware Book, 4th Ed.
       Reading, Mass : Addison-Wesley Pub. Co., 2002. ISBN 0-201-59616-4

B.8. Historia do UNIX(R)

     * Lion, John Lion's Commentary on UNIX, 6th Ed. With Source Code. ITP
       Media Group, 1996. ISBN 1573980137

     * Raymond, Eric S. The New Hacker's Dictionary, 3rd edition. MIT Press,
       1996. ISBN 0-262-68092-0. Also known as the Jargon File

     * Salus, Peter H. A quarter century of UNIX. Addison-Wesley Publishing
       Company, Inc., 1994. ISBN 0-201-54777-5

     * Simon Garfinkel, Daniel Weise, Steven Strassmann. The UNIX-HATERS
       Handbook. IDG Books Worldwide, Inc., 1994. ISBN 1-56884-203-1. Out of
       print, but available online.

     * Don Libes, Sandy Ressler Life with UNIX - special edition.
       Prentice-Hall, Inc., 1989. ISBN 0-13-536657-7

     * The BSD family tree.
       https://svnweb.freebsd.org/base/head/share/misc/bsd-family-tree?view=co
       or /usr/share/misc/bsd-family-tree on a FreeBSD machine.

     * Networked Computer Science Technical Reports Library.

     * Old BSD releases from the Computer Systems Research group (CSRG).
       http://www.mckusick.com/csrg/: The 4CD set covers all BSD versions
       from 1BSD to 4.4BSD and 4.4BSD-Lite2 (but not 2.11BSD, unfortunately).
       The last disk also holds the final sources plus the SCCS files.

B.9. Periodicos, Jornais e Revistas

     * Admin Magazin (in German), published by Medialinx AG. ISSN: 2190-1066

     * BSD Magazine, published by Software Press Sp. z o.o. SK. ISSN:
       1898-9144

     * BSD Now - Video Podcast, published by Jupiter Broadcasting LLC

     * BSD Talk Podcast, by Will Backman

     * FreeBSD Journal, published by S&W Publishing, sponsored by The FreeBSD
       Foundation. ISBN: 978-0-615-88479-0

Apendice C. Recursos na Internet

   Indice

   C.1. Websites

   C.2. Listas de Discussao

   C.3. Grupos de Noticias Usenet

   C.4. Espelhos Oficiais

   O ritmo acelerado do progresso do FreeBSD torna a midia impressa
   impraticavel como um meio de acompanhar os desenvolvimentos mais recentes.
   Os recursos eletronicos sao a melhor maneira, se nao a unica, de se manter
   informado sobre os ultimos avanc,os. Como o FreeBSD e um esforc,o
   voluntario, a propria comunidade de usuarios geralmente serve como um
   "departamento de suporte tecnico", com o correio eletronico, foruns na web
   e noticias da USENET sendo a maneira mais eficaz de alcanc,ar essa
   comunidade.

   Os pontos mais importantes de contato com a comunidade de usuarios do
   FreeBSD sao descritos abaixo. Por favor, envie outros recursos nao
   mencionados aqui para a lista de discussao do projeto de documentac,ao do
   FreeBSD para que eles tambem possam ser incluidos.

C.1. Websites

     * The FreeBSD Forums fornecem um forum de discussao baseado na web para
       questoes sobre o FreeBSD e para discussao tecnica.

     * O Canal do YouTube BSDConferences oferece uma colec,ao de videos de
       alta qualidade de conferencias sobre o BSD em todo o mundo. Esta e uma
       otima maneira de assistir desenvolvedores-chave fazerem apresentac,oes
       sobre novos trabalhos no FreeBSD.

C.2. Listas de Discussao

   As listas de discussao sao a maneira mais direta de abordar questoes ou
   abrir uma discussao tecnica para um publico concentrado do FreeBSD. Ha uma
   grande variedade de listas em varios topicos diferentes do FreeBSD. Enviar
   perguntas para a lista de discussao mais adequada invariavelmente
   garantira uma resposta mais rapida e precisa.

   Os charters das varias listas sao dadas na parte inferior deste documento.
   Por favor, leia o regulamento antes de se cadastrar ou enviar e-mails para
   qualquer lista. A maioria dos assinantes de listas recebe muitas centenas
   de mensagens relacionadas ao FreeBSD todos os dias, e os charters e regras
   de uso visam manter a relac,ao sinal-ruido das listas altas. Para fazer
   menos, as listas de discussao acabarao por falhar como um meio de
   comunicac,ao eficaz para o Projeto.

  Nota:

   Para testar a capacidade de enviar email para as listas do FreeBSD, envie
   uma mensagem de teste para freebsd-test.Por favor, nao envie mensagens de
   teste para qualquer outra lista.

   Em caso de duvida sobre a lista para colocar uma pergunta, consulte Como
   obter os melhores resultados da lista de discussao FreeBSD-questions.

   Antes de postar em qualquer lista, aprenda sobre a melhor forma de usar as
   listas de discussao, por exemplo, como ajudar a evitar discussoes
   repetidas com frequencia, lendo o documento de Perguntas Frequentes das
   Mailing Lists (FAQ).

   Os arquivos sao mantidos para todas as listas de discussao e podem ser
   pesquisados usando o servidor da World Wide Web do FreeBSD. A busca por
   palavras-chaves no arquivo oferece uma excelente maneira de encontrar
   respostas para perguntas frequ:entes e deve ser consultada antes de postar
   uma pergunta. Note que isso tambem significa que as mensagens enviadas
   para as listas de discussao do FreeBSD sao arquivadas perpetuamente. Se a
   protec,ao da sua privacidade e uma preocupac,ao, considere usar um
   enderec,o de e-mail secundario descartavel e postar apenas informac,oes
   publicas.

  C.2.1. Sumario

   Listas gerais: A seguir, listas gerais das quais qualquer pessoa e livre
   (e incentivada) a participar:

               Lista                               Proposito                  
   freebsd-advocacy               Evangelismo do FreeBSD                      
   freebsd-announce               Eventos importantes e marcos do projeto     
                                  (moderado)                                  
   freebsd-arch                   Discussoes de arquitetura e design          
                                  Discussoes relativas `a manutenc,ao do      
   freebsd-bugbusters             banco de dados de relatorios de problemas   
                                  do FreeBSD e ferramentas relacionadas       
   freebsd-bugs                   Relatorio de erros                          
   freebsd-chat                   Itens nao tecnicos relacionados `a          
                                  comunidade FreeBSD                          
   freebsd-chromium               Problemas do Chromium especificos do        
                                  FreeBSD                                     
   freebsd-current                Discussao sobre o uso do FreeBSD-CURRENT    
   freebsd-isp                    Problemas para provedores de servic,os de   
                                  Internet usando o FreeBSD                   
   freebsd-jobs                   Vagas de empregos para trabalhar com        
                                  FreeBSD e oportunidades de consultoria      
   freebsd-questions              Perguntas de usuarios e suporte tecnico     
   freebsd-security-notifications Notificac,oes de seguranc,a (moderadas)     
   freebsd-stable                 Discussao sobre o uso do FreeBSD-STABLE     
   freebsd-test                   Lista para qual enviar mensagens de teste   
                                  em vez de para uma das listas reais         
   freebsd-women                  Defesa do FreeBSD para mulheres             

   Listas tecnicas: As listas a seguir sao para discussao tecnica. Leia
   atentamente o regulamento de cada lista antes de aderir ou enviar e-mails
   para uma, pois ha diretrizes firmes para seu uso e conteudo.

           Lista                               Proposito                      
   freebsd-acpi           ACPI e desenvolvimento de gerenciamento de energia  
   freebsd-amd64          Portando FreeBSD para sistemas AMD64 (moderado)     
   freebsd-apache         Discussao sobre ports relacionados ao Apache        
   freebsd-arm            Portando o FreeBS para processadores ARM (R)        
   freebsd-atm            Usando a rede ATM com o FreeBSD                     
   freebsd-bluetooth      Usando a tecnologia Bluetooth (R) no FreeBSD        
   freebsd-cloud          FreeBSD em plataformas em nuvem (EC2, GCE, Azure,   
                          etc.)                                               
   freebsd-cluster        Usando o FreeBSD em um ambiente clusterizado        
   freebsd-database       Discutindo o uso e desenvolvimento do banco de      
                          dados no FreeBSD                                    
   freebsd-desktop        Usando e melhorando o FreeBSD na area de trabalho   
   dev-ci                 Construa e teste relatorios dos servidores de       
                          integrac,ao continua                                
   dev-reviews            Notificac,oes do sistema de revisao do FreeBSD      
   freebsd-doc            Criando documentos relacionados ao FreeBSD          
   freebsd-drivers        Escrevendo drivers de dispositivos para o FreeBSD   
   freebsd-dtrace         Usando e trabalhando no DTrace no FreeBSD           
   freebsd-eclipse        Usuarios FreeBSD do Eclipse IDE, ferramentas,       
                          aplicativos rich client e ports.                    
   freebsd-elastic        Discussoes especificas sobre ElasticSearch no       
                          FreeBSD                                             
   freebsd-embedded       Usando o FreeBSD em aplicativos embarcados          
   freebsd-eol            Peer suporte a softwares relacionados ao FreeBSD    
                          que nao sao mais suportado pelo Projeto FreeBSD.    
   freebsd-emulation      Emulac,ao de outros sistemas como o                 
                          Linux/MS-DOS(R)/Windows(R)                          
   freebsd-enlightenment  Portando o Enlightenment e aplicativos              
                          Enlightenment                                       
   freebsd-erlang         Discussoes especificas sobre Erlang no FreeBSD      
   freebsd-firewire       Discussao tecnica do FreeBSD FireWire(R) (iLink,    
                          IEEE 1394)                                          
   freebsd-fortran        Fortran no FreeBSD                                  
   freebsd-fs             Sistemas de arquivos                                
   freebsd-games          Suporte para jogos no FreeBSD                       
   freebsd-gecko          Problemas do Gecko Rendering Engine                 
   freebsd-geom           Discussoes e implementac,oes especificas do GEOM    
   freebsd-git            Discussao sobre o uso do git no projeto FreeBSD     
   freebsd-gnome          Portando aplicativos GNOME e o GNOME                
   freebsd-hackers        Discussao tecnica geral                             
   freebsd-haskell        Questoes e discussoes sobre o Haskell especificas   
                          do FreeBSD                                          
   freebsd-hardware       Discussao geral de hardware para executar o FreeBSD 
   freebsd-i18n           Internacionalizac,ao do FreeBSD                     
   freebsd-infiniband     Infiniband no FreeBSD                               
   freebsd-ipfw           Discussao tecnica sobre o redesenho do codigo de    
                          firewall de IP                                      
   freebsd-isdn           Desenvolvedores ISDN                                
   freebsd-jail           Discussoes sobre jail(8)                            
   freebsd-java           Desenvolvedores Java(TM) e pessoas trabalhando no   
                          port dos JDK(TM)s para o FreeBSD                    
   freebsd-kde            Portando aplicativos KDE e o KDE                    
   freebsd-lfs            Portando o LFS para o FreeBSD                       
   freebsd-mips           Portando o FreeBS para MIPS (R)                     
   freebsd-mono           Aplicativos Mono e C # no FreeBSD                   
   freebsd-multimedia     Aplicac,oes multimidia                              
   freebsd-new-bus        Discussoes tecnicas sobre arquitetura de barramento 
   freebsd-net            Discussao de rede e codigo-fonte TCP/IP             
   freebsd-numerics       Discussoes sobre a implementac,ao de alta qualidade 
                          de func,oes libm                                    
   freebsd-ocaml          Discussoes especificas sobre OCaml no FreeBSD       
   freebsd-office         Aplicativos do Office no FreeBSD                    
   freebsd-performance    Perguntas de ajuste de desempenho para instalac,oes 
                          de alto desempenho/carga                            
   freebsd-perl           Manutenc,ao de varia\os ports relacionados ao Perl  
   freebsd-pf             Discussao e perguntas sobre o sistema de firewall   
                          de filtro de pacotes                                
   freebsd-pkg            Gerenciamento de pacotes binarios e discussao de    
                          ferramentas de pacote                               
   freebsd-pkg-fallout    Registros de fallout da construc,ao de pacotes      
   freebsd-pkgbase        Empacotando o sistema basico do FreeBSD             
   freebsd-platforms      No que diz respeito ao port para plataformas de     
                          arquitetura nao Intel(R)                            
   freebsd-ports          Discussao da Colec,ao de Ports                      
   freebsd-ports-announce Noticias e instruc,oes importantes sobre a colec,ao 
                          de ports (moderada)                                 
   freebsd-ports-bugs     Discussao dos bugs/PRs dos ports                    
   freebsd-ppc            Portando o FreeBSD para o PowerPC (R)               
   freebsd-proliant       Discussao tecnica do FreeBSD em plataformas de      
                          servidores HP ProLiant                              
   freebsd-python         Problemas especificos do Python para FreeBSD        
   freebsd-rc             Discussao relacionada ao sistema rc.d e seu         
                          desenvolvimento                                     
   freebsd-realtime       Desenvolvimento de extensoes em tempo real para o   
                          FreeBSD                                             
   freebsd-ruby           Discussoes especificas sobre o Ruby no FreeBSD      
   freebsd-scsi           O subsistema SCSI                                   
   freebsd-security       Problemas de seguranc,a que afetam o FreeBSD        
   freebsd-snapshots      Anuncios de Snapshots dos ramos de Desenvolvimento  
                          do FreeBSD                                          
   freebsd-sparc64        Portando o FreeBSD para sistemas baseados em SPARC  
                          (R)                                                 
   freebsd-standards      Conformidade do FreeBSD com os padroes C99 e POSIX  
                          (R)                                                 
   freebsd-sysinstall     Desenvolvimento do sysinstall(8)                    
   freebsd-tcltk          Discussoes Tcl / Tk especificas do FreeBSD          
   freebsd-testing        Testando no FreeBSD                                 
   freebsd-tex            Portando o TeX e seus aplicativos para o FreeBSD    
   freebsd-threads        Threads no FreeBSD                                  
   freebsd-tilera         Portando o FreeBSD para a familia Tilera de CPUs    
   freebsd-tokenring      Suporte Token Ring no FreeBSD                       
   freebsd-toolchain      Manutenc,ao do toolchain integrado do FreeBSD       
   freebsd-translators    Traduzindo documentos e programas do FreeBSD        
   freebsd-transport      Discussoes de protocolos de rede em nivel de        
                          transporte no FreeBSD                               
   freebsd-usb            Discutindo o suporte do FreeBSD para USB            
   freebsd-virtualization Discussao de varias tecnicas de virtualizac,ao      
                          suportadas pelo FreeBSD                             
   freebsd-vuxml          Discussao sobre a infraestrutura VuXML              
   freebsd-x11            Manutenc,ao e suporte do X11 no FreeBSD             
   freebsd-xen            Discussao do port do FreeBSD para o Xen(TM) -       
                          implementac,ao e uso                                
   freebsd-xfce           XFCE para o FreeBSD - portando e mantendo           
   freebsd-zope           Zope para o FreeBSD - portando e mantendo           

   Listas limitadas: As listas a seguir sao para publicos mais especializados
   (e exigentes) e provavelmente nao sao de interesse para o publico em
   geral. Tambem e uma boa ideia estabelecer uma presenc,a nas listas
   tecnicas antes de entrar em uma dessas listas limitadas para entender a
   etiqueta de comunicac,ao envolvida.

          Lista                              Proposito                        
   freebsd-hubs        Pessoas executando sites espelho (suporte              
                       infraestrutural)                                       
   freebsd-user-groups Coordenac,ao de grupo de usuarios                      
   freebsd-wip-status  FreeBSD Work-In-Progress Status                        
   freebsd-wireless    Discussoes da pilha 802.11, ferramentas,               
                       desenvolvimento de drivers de dispositivos             

   Listas de resumo: Todas as listas acima estao disponiveis em formato
   resumido. Uma vez inscrito em uma lista, as opc,oes de resumo podem ser
   alteradas na sec,ao de opc,oes da conta.

   Listas de SVN: As listas a seguir sao para pessoas interessadas em ver as
   mensagens de log para alterac,oes em varias areas da arvore de
   codigo-fonte. Elas sao listas de somente leitura e nao devem ter correio
   enviado para elas.

          Lista           Area do Fonte     Descric,ao da area (fonte para)   
                                          Todas as alterac,oes no repositorio 
   svn-doc-all          /usr/doc          Subversion do doc (exceto para      
                                          user, projects e translations)      
                                          Todas as alterac,oes na             
   svn-doc-head         /usr/doc          ramificac,ao "head" do repositorio  
                                          do Subversion do doc                
                                          Todas as alterac,oes na area        
   svn-doc-projects     /usr/doc/projects projects do repositorio Subversion  
                                          do doc                              
                                          Todas as mudanc,as nos scripts      
   svn-doc-svnadmin     /usr/doc          administrativos, hooks e outros     
                                          dados de configurac,ao do           
                                          repositorio do Subversion do doc    
   svn-ports-all        /usr/ports        Todas as mudanc,as no repositorio   
                                          do Subversion do ports              
                                          Todas as mudanc,as na ramificac,ao  
   svn-ports-head       /usr/ports        " head " do repositorio do          
                                          Subversion do ports                 
                                          Todas as mudanc,as nos scripts      
   svn-ports-svnadmin   /usr/ports        administrativos, hooks e outros     
                                          dados de configurac,ao do           
                                          repositorio Subversion das portas   
                                          Todas as mudanc,as no repositorio   
   svn-src-all          /usr/src          src Subversion (exceto para user e  
                                          projects)                           
                                          Todas as mudanc,as na ramificac,ao  
   svn-src-head         /usr/src          " head " do repositorio src         
                                          Subversion (a ramificac,ao          
                                          FreeBSD-CURRENT)                    
   svn-src-projects     /usr/projects     Todas as mudanc,as na area projects 
                                          do repositorio src do Subversion    
   svn-src-release      /usr/src          Todas as mudanc,as na area releases 
                                          do repositorio src do Subversion    
                                          Todas as mudanc,as nas              
   svn-src-releng       /usr/src          ramificac,oes releng do repositorio 
                                          src Subversion (as ramificac,oes de 
                                          engenharia de seguranc,a/release)   
                                          Todas as mudanc,as para todos os    
   svn-src-stable       /usr/src          ramos estaveis do repositorio src   
                                          Subversion                          
                                          Todas as alterac,oes na             
   svn-src-stable-6     /usr/src          ramificac,ao stable/6 do            
                                          repositorio src Subversion          
                                          Todas as alterac,oes na             
   svn-src-stable-7     /usr/src          ramificac,ao stable/7 do            
                                          repositorio src Subversion          
                                          Todas as mudanc,as na ramificac,ao  
   svn-src-stable-8     /usr/src          stable/8 do repositorio src         
                                          Subversion                          
                                          Todas as alterac,oes na             
   svn-src-stable-9     /usr/src          ramificac,ao stable/9 do            
                                          repositorio src Subversion          
                                          Todas as mudanc,as na ramificac,ao  
   svn-src-stable-10    /usr/src          stable/10 do repositorio src do     
                                          Subversion                          
                                          Todas as alterac,oes na             
   svn-src-stable-11    /usr/src          ramificac,ao stable/11 do           
                                          repositorio src Subversion          
                                          Todas as mudanc,as na ramificac,ao  
   svn-src-stable-12    /usr/src          stable/12 do repositorio src do     
                                          Subversion                          
                                          Todas as mudanc,as para os ramos    
   svn-src-stable-other /usr/src          mais antigos stable do repositorio  
                                          src Subversion                      
                                          Todas as mudanc,as nos scripts      
   svn-src-svnadmin     /usr/src          administrativos, hooks e outros     
                                          dados de configurac,ao do           
                                          repositorio src do Subversion       
                                          Todas as mudanc,as na area          
   svn-src-user         /usr/src          experimental user do repositorio    
                                          src do Subversion                   
                                          Todas as mudanc,as na area de       
   svn-src-vendor       /usr/src          trabalho do fornecedor do           
                                          repositorio src Subversion          

  C.2.2. Como se inscrever

   Para se inscrever em uma lista, clique no nome da lista em
   http://lists.FreeBSD.org/mailman/listinfo . A pagina exibida deve conter
   todas as instruc,oes de inscric,ao necessarias para essa lista.

   Para realmente postar em uma determinada lista, envie um email para
   <listname@FreeBSD.org>. Ele sera entao redistribuido para membros da lista
   de discussao em todo o mundo.

   Para cancelar a inscric,ao em uma lista, clique no URL encontrado na parte
   inferior de todos os e-mails recebidos da lista. Tambem e possivel enviar
   um email para <listname-unsubscribe@FreeBSD.org> para cancelar a
   inscric,ao.

   E importante manter a discussao nas listas de discussao tecnicas em uma
   trilha tecnica. Para receber apenas os anuncios importantes, junte-se `a
   lista de discussao de anuncios do FreeBSD, que e destinada a trafego pouco
   frequente .

  C.2.3. Estatutos das Listas

   Todas as listas de discussao do FreeBSD possuem certas regras basicas que
   devem ser seguidas por qualquer pessoa que as utilize. O nao cumprimento
   destas diretrizes resultara em dois (2) avisos escritos do Postmaster do
   FreeBSD <postmaster@FreeBSD.org>, apos o que, em uma terceira ofensa, o
   usuario sera removido de todas as listas de discussao do FreeBSD e
   filtrados de postagem posterior para elas. Lamentamos que tais regras e
   medidas sejam absolutamente necessarias, mas a Internet de hoje e um
   ambiente bastante hostil, ao que parece, e muitos nao conseguem perceber o
   quao frageis sao alguns de seus mecanismos.

   Regras Basicas:

     * O topico de qualquer postagem deve estar de acordo com o regulamento
       basico da lista para a qual ele e postado. Se a lista for sobre
       questoes tecnicas, a mensagem deve conter discussao tecnica. Conversa
       irrelevante em curso ou provocac,oes apenas prejudicam o valor da
       lista de discussao para todos e nao sera tolerado. Para discussoes de
       forma livre sobre um topico em particular, a lista de discussao do
       chat do FreeBSD esta disponivel gratuitamente e deve ser usada para
       isso.

     * Nenhuma postagem deve ser feita para mais de 2 listas de discussao, e
       apenas para 2 quando houver necessidade clara e obvia de postar nas
       duas listas. Para a maioria das listas, ja existe uma grande
       quantidade de sobreposic,oes de assinantes e, exceto pelas mixagens
       mais esotericas (digamos " -stable & -scsi "), nao ha motivo para
       postar em mais de uma lista ao mesmo tempo. Se uma mensagem for
       recebida com varias listas de discussao na linha Cc, ajuste a linha Cc
       antes de responder. A pessoa que responde ainda e responsavel por
       postagens cruzadas, independentemente de quem tenha sido o remetente.

     * Ataques pessoais e palavroes (no contexto de um argumento) nao sao
       permitidos, e isso inclui usuarios e desenvolvedores. Violac,oes
       brutais da netiqueta, como a extrac,ao ou repostagem de
       correspondencia privada quando a permissao para fazer isso nao existe,
       sao desaprovadas, mas nao especificamente forc,adas. No entanto,
       tambem existem muito poucos casos em que tal conteudo se encaixaria no
       estatuto de uma lista e, portanto, provavelmente ele geraria uma
       advertencia (ou proibic,ao).

     * A publicidade de produtos ou servic,os nao relacionados ao FreeBSD e
       estritamente proibida e resultara em uma proibic,ao imediata se for
       claro que o ofensor esta anunciando por spam.

   Estatutos individuais das listas:

   freebsd-acpi

           ACPI e desenvolvimento de gestao de energia

   freebsd-announce

           Eventos / marcos importantes

           Esta e a lista de discussao para pessoas interessadas apenas em
           anuncios ocasionais de eventos significativos do FreeBSD. Isso
           inclui anuncios sobre snapshots e outros releases. Ela contem
           anuncios de novos recursos do FreeBSD. Pode conter chamadas para
           voluntarios, etc. Esta e uma lista de discussao de baixo volume,
           estritamente moderada.

   freebsd-arch

           Discussao sobre arquitetura e design

           Esta lista e para discussao da arquitetura do FreeBSD. As
           mensagens serao principalmente mantidas estritamente de natureza
           tecnica. Exemplos de topicos adequados sao:

              * Como fazer um re-vamp do sistema de compilac,ao para ter
                varias compilac,oes personalizadas em execuc,ao ao mesmo
                tempo.

              * O que precisa ser corrigido com o VFS para fazer com que as
                camadas Heidemann funcionem.

              * Como podemos mudar a interface do driver de dispositivo para
                poder usar os mesmos drivers de forma limpa em muitos
                barramentos e arquiteturas.

              * Como escrever um driver de rede.

   freebsd-bluetooth

           Bluetooth (R) no FreeBSD

           Este e o forum onde os usuarios de Bluetooth(R) no FreeBSD se
           reunem. Problemas de design, detalhes de implementac,ao, patches,
           relatorios de bugs, relatorios de status, solicitac,oes de
           recursos e todos os assuntos relacionados a Bluetooth (R) sao bem
           vindos.

   freebsd-bugbusters

           Coordenac,ao sobre o esforc,o de manuseio dos Relatorios de
           Problemas

           O objetivo desta lista e servir como um forum de coordenac,ao e
           discussao para o Bugmeister, seus Bugbusters e quaisquer outras
           partes que tenham interesse genuino no banco de dados de RP. Esta
           lista nao e para discussoes sobre bugs especificos, patches ou
           PRs.

   freebsd-bugs

           Relatorios de bugs

           Esta e a lista de discussao para reportar bugs no FreeBSD. Sempre
           que possivel, os bugs devem ser submetidos usando a interface web
           .

   freebsd-chat

           Itens nao tecnicos relacionados `a comunidade FreeBSD

           Esta lista contem o overflow de outras listas sobre informac,oes
           sociais nao tecnicas. Ela inclui discussoes sobre se Jordan se
           parece com um furao ou nao, se deve ou nao digitar em maiusculas,
           quem esta tomando muito cafe, onde a melhor cerveja e preparada,
           quem esta fazendo cerveja no porao, e assim por diante. Anuncios
           ocasionais de eventos importantes (como festas, casamentos,
           nascimentos, novos empregos, etc) podem ser feitos para as listas
           tecnicas, mas os acompanhamentos devem ser direcionados para esta
           lista de bate-papo.

   freebsd-chromium

           Questoes especificas sobre o Chromium no FreeBSD

           Esta e uma lista para a discussao do suporte ao Chromium no
           FreeBSD. Esta e uma lista tecnica para discutir o desenvolvimento
           e a instalac,ao do Chromium.

   freebsd-cloud

           Executando o FreeBSD em varias plataformas de nuvem

           Esta lista discute a execuc,ao do FreeBSD no Amazon EC2, no Google
           Compute Engine, no Microsoft Azure e em outras plataformas de
           computac,ao em nuvem.

   freebsd-core

           FreeBSD core team

           Esta e uma lista de discussao interna para uso pelos membros do
           core team. Mensagens podem ser enviadas quando um assunto serio
           relacionado ao FreeBSD requer arbitragem ou escrutinio de alto
           nivel.

   freebsd-current

           Discussoes sobre o uso do FreeBSD-CURRENT

           Esta e a lista de discussao para usuarios do FreeBSD-CURRENT. Ela
           inclui avisos sobre novos recursos que estao sendo lanc,ados no
           -CURRENT que afetarao os usuarios e instruc,oes sobre as etapas
           que devem ser seguidas para permanecer no -CURRENT. Qualquer um
           que esteja executando o "CURRENT" deve se inscrever nesta lista.
           Esta e uma lista de discussao tecnica para a qual e esperado
           conteudo estritamente tecnico.

   freebsd-desktop

           Usando e melhorando o FreeBSD no desktop

           Este e um forum para discussao do FreeBSD no desktop. E
           principalmente um lugar para portadores de desktop e usuarios
           discutirem problemas e melhorarem o suporte do FreeBSD para
           desktops.

   dev-ci

           Coordenac,ao do Relatorio de Problemas sobre o esforc,o de
           manuseio

           Todos os relatorios de integrac,ao continua, resultados de
           compilac,ao e testes

   dev-reviews

           Notificac,oes do trabalho em andamento na ferramenta de revisao do
           FreeBSD

           Notificac,oes automatizadas de trabalhos em andamento para revisao
           nas ferramentas de revisao do FreeBSD, incluindo patches.

   freebsd-doc

           Projeto de Documentac,ao

           Esta lista de discussao e para a discussao de questoes e projetos
           relacionados `a criac,ao de documentac,ao para o FreeBSD. Os
           membros desta lista sao coletivamente referidos como "The FreeBSD
           Documentation Project". E uma lista aberta; sinta-se `a vontade
           para participar e contribuir!

   freebsd-drivers

           Escrevendo drivers de dispositivos para o FreeBSD

           Este e um forum para discussoes tecnicas relacionadas a drivers de
           dispositivos no FreeBSD. E principalmente um lugar para os
           criadores de drivers de dispositivo fazerem perguntas sobre como
           escreverem drivers de dispositivo usando as APIs no kernel do
           FreeBSD.

   freebsd-dtrace

           Usando e trabalhando no DTrace no FreeBSD

           O DTrace e um componente integrado do FreeBSD que fornece uma
           estrutura para entender o kernel, bem como programas de espac,o do
           usuario em tempo de execuc,ao. A lista de discussao e uma
           discussao arquivada para desenvolvedores do codigo, bem como
           aqueles que a usam.

   freebsd-eclipse

           Usuarios FreeBSD do IDE Eclipse, ferramentas, aplicativos e ports
           rich clients.

           A intenc,ao desta lista e fornecer suporte mutuo para tudo
           relacionado com a escolha, instalac,ao, uso, desenvolvimento e
           manutenc,ao do IDE Eclipse, ferramentas, aplicativos rich client
           na plataforma FreeBSD e para assistencia na portabilidade do IDE
           Eclipse e seus plugins para o ambiente FreeBSD.

           A intenc,ao e tambem facilitar a troca de informac,oes entre a
           comunidade Eclipse e a comunidade FreeBSD para beneficio mutuo de
           ambas.

           Embora essa lista esteja focada principalmente nas necessidades
           dos usuarios do Eclipse, ela tambem fornecera um forum para
           aqueles que gostariam de desenvolver aplicativos especificos para
           o FreeBSD usando o Framework do Eclipse.

   freebsd-embedded

           Usando o FreeBSD em aplicac,oes embarcadas

           Esta lista discute topicos relacionados ao uso do FreeBSD em
           sistemas embarcados. Esta e uma lista de discussao tecnica para a
           qual e esperado conteudo estritamente tecnico. Para o proposito
           desta lista, os sistemas embarcados sao aqueles dispositivos de
           computac,ao que nao sao desktops e que geralmente servem a um
           unico proposito, ao inves de serem ambientes de computac,ao geral.
           Os exemplos incluem, mas nao estao limitados a, todos os tipos de
           aparelhos telefonicos, equipamentos de rede, como roteadores,
           switches e PBXs, equipamentos de medic,ao remota, PDAs, sistemas
           Point Of Sale e assim por diante.

   freebsd-emulation

           Emulac,ao de outros sistemas como o Linux/MS-DOS(R)/Windows(R)

           Este e um forum para discussoes tecnicas relacionadas `a execuc,ao
           no FreeBSD de programas escritos para outros sistemas
           operacionais.

   freebsd-enlightenment

           Enlightenment

           Discussoes sobre o Ambiente de Desktop Enlightenment para sistemas
           FreeBSD. Esta e uma lista de discussao tecnica para a qual e
           esperado conteudo estritamente tecnico.

   freebsd-eol

           Suporte de pares para softwares relacionados ao FreeBSD que nao
           sao mais suportados pelo Projeto FreeBSD.

           Esta lista e para aqueles interessados em fornecer ou fazer uso de
           suporte de software relacionado ao FreeBSD para o qual o Projeto
           FreeBSD nao fornece mais suporte oficial na forma de avisos e
           patches de seguranc,a.

   freebsd-firewire

           FireWire(R) (iLink, IEEE 1394)

           Esta e uma lista para discussao do design e implementac,ao de um
           subsistema FireWire(R) (tambem conhecido como IEEE 1394 aka iLink)
           para o FreeBSD. Topicos relevantes incluem especificamente os
           padroes, dispositivos de barramento e seus protocolos, placas
           adaptadoras / placas / chips sets e a arquitetura e implementac,ao
           de codigo para seu suporte adequado.

   freebsd-fortran

           Fortran no FreeBSD

           Esta e a lista para discussao de ports relacionados ao Fortran no
           FreeBSD: compiladores, bibliotecas, aplicativos cientificos e de
           engenharia, de laptops a clusters de HPC.

   freebsd-fs

           Sistemas de arquivos

           Discussoes sobre os sistemas de arquivos do FreeBSD. Esta e uma
           lista de discussao tecnica para a qual e esperado conteudo
           estritamente tecnico.

   freebsd-games

           Jogos no FreeBSD

           Esta e uma lista tecnica para discussoes relacionadas a trazer
           jogos para o FreeBSD. E para individuos trabalhando ativamente em
           portar jogos para o FreeBSD, para trazer problemas ou discutir
           soluc,oes alternativas. Individuos interessados em acompanhar a
           discussao tecnica tambem sao bem vindos.

   freebsd-gecko

           Motor Gecko de Renderizac,ao

           Este e um forum sobre aplicativos Gecko usando o FreeBSD.

           Discussao em torno dos Ports dos aplicativos Gecko, sua
           instalac,ao, seu desenvolvimento e seu suporte dentro do FreeBSD.

   freebsd-geom

           GEOM

           Discussoes especificas sobre o GEOM e implementac,oes
           relacionadas. Esta e uma lista de discussao tecnica para a qual e
           esperado conteudo estritamente tecnico.

   freebsd-git

           Uso do git no projeto FreeBSD

           Discussoes sobre como usar o git na infra-estrutura do FreeBSD,
           incluindo o espelho do github e outros usos do git para
           colaborac,ao no projeto. Area de discussao para pessoas usando o
           git no espelho do FreeBSD no github. Pessoas que querem comec,ar
           com o espelho ou o git em geral no FreeBSD podem fazer perguntas
           aqui.

   freebsd-gnome

           GNOME

           Discussoes relativas ao ambiente de trabalho GNOME para sistemas
           FreeBSD. Esta e uma lista de discussao tecnica para a qual e
           esperado conteudo estritamente tecnico.

   freebsd-infiniband

           Infiniband no FreeBSD

           Lista tecnica para discutir Infiniband, OFED e OpenSM no FreeBSD.

   freebsd-ipfw

           Firewall IP

           Este e o forum para discussoes tecnicas sobre o redesenho do
           codigo de firewall IP no FreeBSD. Esta e uma lista de discussao
           tecnica para a qual e esperado conteudo estritamente tecnico.

   freebsd-isdn

           Comunicac,oes ISDN

           Esta e a lista de discussao para pessoas discutindo o
           desenvolvimento do suporte a ISDN para o FreeBSD.

   freebsd-java

           Desenvolvimento Java(TM)

           Esta e a lista de discussao para as pessoas que discutem o
           desenvolvimento de aplicac,oes Java(TM) para o FreeBSD e a
           portabilidade e manutenc,ao de JDK(TM)s.

   freebsd-jobs

           Ofertas e Procura de Emprego

           Este e um forum para postar avisos de emprego especificamente
           relacionados ao FreeBSD e curriculos daqueles que buscam emprego
           relacionado ao FreeBSD. Esta nao e uma lista de discussao para
           questoes gerais de emprego, ja que foruns adequados para isso ja
           existem em outros lugares.

           Note que esta lista, como as demais listas de discussao do
           FreeBSD.org, e distribuida em todo o mundo. Seja claro sobre a
           localizac,ao geografica e ate que ponto o trabalho remoto ou a
           assistencia `a realocac,ao estao disponiveis.

           O email deve usar somente formatos abertos - preferencialmente
           texto puro, mas o formato basico de documento portatil (PDF), HTML
           e alguns outros sao aceitaveis para muitos leitores. Formatos
           fechados como Microsoft(R) Word (.doc) serao rejeitados pelo
           servidor da lista de discussao.

   freebsd-kde

           KDE

           Discussoes sobre o KDE em sistemas FreeBSD. Esta e uma lista de
           discussao tecnica para a qual e esperado conteudo estritamente
           tecnico.

   freebsd-hackers

           Discussoes tecnicas

           Este e um forum para discussoes tecnicas relacionadas ao FreeBSD.
           Esta e a principal lista de discussao tecnica. E para individuos
           trabalhando ativamente no FreeBSD, para trazer problemas ou
           discutir soluc,oes alternativas. Individuos interessados em
           acompanhar a discussao tecnica tambem sao bem vindos. Esta e uma
           lista de discussao tecnica para a qual e esperado conteudo
           estritamente tecnico.

   freebsd-hardware

           Discussao geral sobre hardware no FreeBSD

           Discussao geral sobre os tipos de hardware em que o FreeBSD
           executa, varios problemas e sugestoes sobre o que comprar ou
           evitar.

   freebsd-hubs

           Sites Espelhos

           Anuncios e discussoes para pessoas que executam sites espelho do
           FreeBSD.

   freebsd-isp

           Problemas para provedores de servic,os de Internet

           Esta lista de discussao e para discutir topicos relevantes para
           provedores de servic,os de Internet (ISPs) usando o FreeBSD. Esta
           e uma lista de discussao tecnica para a qual e esperado conteudo
           estritamente tecnico.

   freebsd-mono

           Aplicac,oes Mono e C# no FreeBSD

           Esta e uma lista de discussoes relacionadas ao framework de
           desenvolvimento Mono no FreeBSD. Esta e uma lista de discussao
           tecnica. E para individuos trabalhando ativamente na portabilidade
           de aplicativos Mono ou C# para o FreeBSD, para trazer problemas ou
           discutir soluc,oes alternativas. Individuos interessados em
           acompanhar a discussao tecnica tambem sao bem vindos.

   freebsd-ocaml

           Discussoes especificas sobre OCaml no FreeBSD

           Esta e uma lista para discussoes relacionadas ao suporte OCaml no
           FreeBSD. Esta e uma lista de discussao tecnica. E para pessoas que
           trabalham com ports OCaml, bibliotecas de terceiros e frameworks.
           Individuos interessados na discussao tecnica tambem sao bem
           vindos.

   freebsd-office

           Aplicativos de Escritorio no FreeBSD

           Discussao em torno de aplicativos de escritorio, sua instalac,ao,
           seu desenvolvimento e seu suporte dentro do FreeBSD.

   freebsd-ops-announce

           Anuncios de infra-estrutura do projeto

           Esta e a lista de discussao para pessoas interessadas em mudanc,as
           e questoes relacionadas `a infra-estrutura do Projeto FreeBSD.org.

           Esta lista moderada e estritamente para anuncios: sem respostas,
           pedidos, discussoes ou opinioes.

   freebsd-performance

           Discussoes sobre o tunning ou acelerac,ao do FreeBSD

           Esta lista de discussao existe para fornecer um local para
           hackers, administradores e/ou partes interessadas discutirem
           topicos relacionados ao desempenho do FreeBSD. Temas aceitaveis
           incluem falar sobre instalac,oes do FreeBSD que estao sob alta
           carga, que estao tendo problemas de desempenho ou que estao
           forc,ando os limites do FreeBSD. Partes interessadas que estejam
           dispostas a trabalhar para melhorar o desempenho do FreeBSD sao
           altamente encorajadas a assinar esta lista. Esta e uma lista
           altamente tecnica destinada para usuarios experientes do FreeBSD,
           hackers ou administradores interessados em manter o FreeBSD
           rapido, robusto e escalavel. Essa lista nao e uma lista de
           perguntas e respostas que substitui a leitura da documentac,ao,
           mas e um local para fazer contribuic,oes ou perguntar sobre
           topicos nao respondidos relacionados ao desempenho.

   freebsd-pf

           Discussao sobre o sistema de firewall de filtro de pacotes

           Discussao sobre o sistema de firewall de filtro de pacotes (pf) no
           FreeBSD. A discussao tecnica e as perguntas dos usuarios sao
           bem-vindas. Esta lista tambem e um lugar para discutir o framework
           ALTQ QoS.

   freebsd-pkg

           Discussao sobre o gerenciamento de pacotes binarios e as
           ferramentas de pacotes

           Discussao de todos os aspectos de gerenciamento de sistemas
           FreeBSD usando pacotes binarios para instalar software, incluindo
           toolkits e formatos de pacotes binarios, seu desenvolvimento e
           suporte dentro do FreeBSD, gerenciamento de repositorios de
           pacotes e pacotes de terceiros.

           Observe que a discussao de ports que nao conseguem gerar pacotes
           corretamente geralmente deve ser considerada como um problema do
           port e, portanto, e inadequada para essa lista.

   freebsd-pkg-fallout

           Registros de fallout da construc,ao de pacotes

           Todos os logs de falha na compilac,ao de pacotes nos clusters de
           compilac,ao de pacotes

   freebsd-pkgbase

           Empacotando do sistema basico do FreeBSD.

           Discussoes sobre a implementac,ao e questoes relacionadas ao
           empacotamento do sistema base do FreeBSD.

   freebsd-platforms

           Portando para plataformas nao Intel(R)

           Problemas de plataforma cruzada do FreeBSD, discussao geral e
           propostas para ports do FreeBSD para plataformas nao Intel(R).
           Esta e uma lista de discussao tecnica para a qual e esperado
           conteudo estritamente tecnico.

   freebsd-ports

           Discussao dos "ports"

           Discussoes relativas `a colec,ao de "ports" (/usr/ports) do
           FreeBSD, infra-estrutura de ports e esforc,os gerais de
           coordenac,ao de ports. Esta e uma lista de discussao tecnica para
           a qual e esperado conteudo estritamente tecnico.

   freebsd-ports-announce

           Noticias e instruc,oes importantes sobre a "colec,ao de ports" do
           FreeBSD

           Noticias importantes para desenvolvedores, porters e usuarios da
           "Colec,ao de Ports" (/usr/ports), incluindo alterac,oes de
           arquitetura / infraestrutura, novos recursos, instruc,oes criticas
           de upgrade e informac,oes sobre a engenharia de releases. Esta e
           uma lista de discussao de baixo volume, destinada a anuncios.

   freebsd-ports-bugs

           Discussao de bugs dos "ports"

           Discussoes sobre relatorios de problemas para a "colec,ao de
           ports" do FreeBSD (/usr/ports), ports propostos ou modificac,oes
           nos ports. Esta e uma lista de discussao tecnica para a qual e
           esperado conteudo estritamente tecnico.

   freebsd-proliant

           Discussao tecnica do FreeBSD nas plataformas de servidores HP
           ProLiant

           Esta lista de discussao deve ser usada para a discussao tecnica do
           uso do FreeBSD em servidores HP ProLiant, incluindo a discussao de
           drivers especificos do ProLiant, software de gerenciamento,
           ferramentas de configurac,ao e atualizac,oes do BIOS. Como tal,
           este e o principal local para discutir os modulos hpasmd, hpasmcli
           e hpacucli.

   freebsd-python

           Python no FreeBSD

           Esta e uma lista de discussoes relacionadas `a melhoria do suporte
           ao Python no FreeBSD. Esta e uma lista de discussao tecnica. E
           para individuos que estao trabalhando na portabilidade do Python,
           seus modulos de terceiros e coisas do Zope para o FreeBSD.
           Individuos interessados em acompanhar a discussao tecnica tambem
           sao bem vindos.

   freebsd-questions

           Questoes do usuario

           Esta e a lista de discussao para questoes sobre o FreeBSD. Nao
           envie perguntas do tipo "how to" para as listas tecnicas, a menos
           que a questao seja bastante tecnica.

   freebsd-ruby

           Discussoes sobre Ruby especificas para o FreeBSD

           Esta e uma lista para discussoes relacionadas ao suporte Ruby no
           FreeBSD. Esta e uma lista de discussao tecnica. E para pessoas que
           trabalham com ports Ruby, bibliotecas de terceiros e frameworks.

           Individuos interessados na discussao tecnica tambem sao bem
           vindos.

   freebsd-scsi

           Subsistema SCSI

           Esta e a lista de discussao para pessoas que trabalham no
           subsistema SCSI do FreeBSD. Esta e uma lista de discussao tecnica
           para a qual e esperado conteudo estritamente tecnico.

   freebsd-security

           Questoes de seguranc,a

           Problemas de seguranc,a do FreeBSD (DES, Kerberos, falhas de
           seguranc,a conhecidas e correc,oes, etc). Esta e uma lista de
           discussao tecnica para a qual se espera uma discussao estritamente
           tecnica. Note que esta nao e uma lista de perguntas e respostas,
           mas as contribuic,oes (ambas as perguntas e respostas) para o FAQ
           sao bem-vindas.

   freebsd-security-notifications

           Notificac,oes de seguranc,a

           Notificac,oes de problemas de seguranc,a e correc,oes do FreeBSD.
           Esta nao e uma lista de discussao. A lista de discussao e a
           FreeBSD-security.

   freebsd-snapshots

           Anuncios de Snapshots de Desenvolvimento do FreeBSD

           Esta lista fornece notificac,oes sobre a disponibilidade de novos
           snapshots de desenvolvimento do FreeBSD para head/ e stable/
           branches.

   freebsd-stable

           Discussoes sobre o uso do FreeBSD-STABLE

           Esta e a lista de discussao para usuarios do FreeBSD-STABLE. O
           "STABLE" e o ramo onde o desenvolvimento continua depois de um
           RELEASE, incluindo correc,oes de bugs e novos recursos. O ABI e
           mantido estavel para compatibilidade binaria. Ela inclui avisos
           sobre novos recursos que estarao sendo incorporados no -STABLE e
           que afetarao os usuarios e instruc,oes sobre as etapas que devem
           ser seguidas para permanecer -STABLE. Qualquer um que esteja
           executando o "STABLE" deve assinar esta lista. Esta e uma lista de
           discussao tecnica para a qual e esperado conteudo estritamente
           tecnico.

   freebsd-standards

           Conformidade C99 & POSIX

           Este e um forum para discussoes tecnicas relacionadas `a
           Conformidade do FreeBSD com os padroes C99 e POSIX.

   freebsd-teaching

           Ensinando com o FreeBSD

           Lista de discussao nao tecnica para discutir o ensino com o
           FreeBSD.

   freebsd-testing

           Testando no FreeBSD

           Lista de discussao tecnica discutindo testes no FreeBSD, incluindo
           ATF/Kyua, infraestrutura de testes, testes de port para o FreeBSD
           de outros sistemas operacionais (NetBSD, ...), etc.

   freebsd-tex

           Portando o TeX e seus aplicativos para o FreeBSD

           Esta e uma lista de discussao tecnica para discussoes relacionadas
           ao TeX e suas aplicac,oes no FreeBSD. E destinada aos individuos
           que estao trabalhando ativamente na portabilidade do TeX para o
           FreeBSD, para trazer problemas ou discutir soluc,oes alternativas.
           Individuos interessados em acompanhar a discussao tecnica tambem
           sao bem vindos.

   freebsd-toolchain

           Manutenc,ao do toolchain integrado do FreeBSD

           Esta e a lista para discussoes relacionadas `a manutenc,ao do
           conjunto de ferramentas fornecido com o FreeBSD. Isso pode incluir
           o estado do Clang e do GCC, mas tambem partes de software, como
           assemblers, vinculadores e depuradores.

   freebsd-transport

           Discussoes de protocolos de rede em nivel de transporte no FreeBSD

           A lista de discussao de transporte existe para a discussao de
           problemas e projetos em torno dos protocolos de nivel de
           transporte na pilha de rede do FreeBSD, incluindo TCP, SCTP e UDP.
           Outros topicos de rede, incluindo questoes especificas de driver e
           protocolos de rede, devem ser discutidos na lista de discussao
           FreeBSD networking .

   freebsd-translators

           Traduzindo documentos e programas do FreeBSD

           Uma lista de discussao em que tradutores de documentos do FreeBSD
           do ingles para outros idiomas podem falar sobre metodos e
           ferramentas de traduc,ao. Novos membros sao convidados a se
           apresentar e mencionar os idiomas em que estao interessados em
           traduzir.

   freebsd-usb

           Discutindo o suporte do FreeBSD para USB

           Esta e uma lista de discussao para discussoes tecnicas
           relacionadas ao suporte do FreeBSD para USB.

   freebsd-user-groups

           Lista de Coordenac,ao do Grupo de Usuarios

           Esta e a lista de discussao dos coordenadores de cada um dos
           Grupos de Usuarios da area local para discutir assuntos entre si e
           um individuo designado do Core Team. Essa lista de e-mail deve se
           limitar a atender a sinopse e a coordenac,ao de projetos que
           abranjam Grupos de usuarios.

   freebsd-virtualization

           Discussao de varias tecnicas de virtualizac,ao suportadas pelo
           FreeBSD

           Uma lista para discutir as varias tecnicas de virtualizac,ao
           suportadas pelo FreeBSD. Por um lado, o foco estara na
           implementac,ao da funcionalidade basica, bem como na adic,ao de
           novos recursos. Por outro lado, os usuarios terao um forum para
           pedir ajuda em caso de problemas ou para discutir seus casos de
           uso.

   freebsd-wip-status

           Status do andamento do trabalho no FreeBSD

           Esta lista de discussao pode ser usada pelos desenvolvedores para
           anunciar a criac,ao e o progresso do trabalho relacionado ao
           FreeBSD. As mensagens serao moderadas. Sugere-se enviar a mensagem
           "Para:" uma lista mais atual do FreeBSD e apenas "BCC:" esta
           lista. Dessa forma, o WIP tambem pode ser discutido na lista de
           topicos, ja que nenhuma discussao e permitida nesta lista.

           Olhe dentro dos arquivos para exemplos de mensagens adequadas.

           Um resumo editorial das mensagens para esta lista pode ser postado
           no site do FreeBSD todos os meses como parte dos Relatorios de
           Status [3]. Relatorios anteriores sao arquivados.

   freebsd-wireless

           Discussoes da pilha 802.11, desenvolvimento de driver de
           dispositivo de ferramentas

           A lista FreeBSD-wireless se concentra na pilha 802.11
           (sys/net80211), no driver do dispositivo e no desenvolvimento de
           ferramentas. Isso inclui bugs, novos recursos e manutenc,ao.

   freebsd-xen

           Discussao do port do FreeBSD para Xen (TM) - implementac,ao e uso

           Uma lista focada no port do Xen(TM) para o FreeBSD. O nivel de
           trafego previsto e pequeno o suficiente para servir como um forum
           para discussoes tecnicas sobre os detalhes de implementac,ao e
           design, bem como problemas administrativos de implantac,ao.

   freebsd-xfce

           XFCE

           Este e um forum para discussoes relacionadas a trazer o ambiente
           XFCE para o FreeBSD. Esta e uma lista de discussao tecnica. E para
           individuos que trabalham ativamente portando o XFCE para o
           FreeBSD, para trazer problemas ou discutir soluc,oes alternativas.
           Individuos interessados em acompanhar a discussao tecnica tambem
           sao bem vindos.

   freebsd-zope

           Zope

           Este e um forum para discussoes relacionadas a trazer o ambiente
           Zope para o FreeBSD. Esta e uma lista de discussao tecnica. E para
           individuos que trabalham ativamente portando o Zope para o
           FreeBSD, para trazer problemas ou discutir soluc,oes alternativas.
           Individuos interessados em acompanhar a discussao tecnica tambem
           sao bem vindos.

  C.2.4. Filtros nas Listas de Discussao

   As listas de discussao do FreeBSD sao filtradas de varias maneiras para
   evitar a distribuic,ao de spam, virus e outros e-mails indesejados. As
   ac,oes de filtragem descritas nesta sec,ao nao incluem todas aquelas
   usadas para proteger as listas de discussao.

   Apenas determinados tipos de anexos sao permitidos nas listas de
   discussao. Todos os anexos com um tipo de conteudo MIME nao encontrado na
   lista abaixo serao removidos antes que um email seja distribuido nas
   listas de discussao.

     * application/octet-stream

     * application/pdf

     * application/pgp-signature

     * application/x-pkcs7-signature

     * message/rfc822

     * multipart/alternative

     * multipart/related

     * multipart/signed

     * text/html

     * text/plain

     * text/x-diff

     * text/x-patch

  Nota:

   Algumas das listas de discussao podem permitir anexos de outros tipos de
   conteudo MIME, mas a lista acima deve ser aplicavel para a maioria das
   listas de discussao.

   Se um email contiver uma versao em HTML e uma em texto simples, a versao
   em HTML sera removida. Se um email contiver somente uma versao em HTML,
   ele sera convertido em texto simples.

C.3. Grupos de Noticias Usenet

   Alem de dois grupos de noticias especificos sobre FreeBSD, existem muitos
   outros em que o FreeBSD e discutido ou que sao relevantes para usuarios do
   FreeBSD.

  C.3.1. Grupos de noticias especificos do BSD

     * comp.unix.bsd.freebsd.announce

     * comp.unix.bsd.freebsd.misc

     * de.comp.os.unix.bsd (German)

     * fr.comp.os.bsd (French)

  C.3.2. Outros Newsgroups de interesse sobre UNIX(R)

     * comp.unix

     * comp.unix.questions

     * comp.unix.admin

     * comp.unix.programmer

     * comp.unix.shell

     * comp.unix.misc

     * comp.unix.bsd

  C.3.3. X Window System

     * comp.windows.x

C.4. Espelhos Oficiais

   Servidores Centrais, Armenia, Australia, Austria, Czech Republic, Denmark,
   Finland, France, Germany, Hong Kong, Ireland, Japan, Latvia, Lithuania,
   Netherlands, Norway, Russia, Slovenia, South Africa, Spain, Sweden,
   Switzerland, Taiwan, United Kingdom, USA.

   (a partir de UTC)

     * Servidores Centrais

          * https://www.FreeBSD.org/

     * Armenia

          * http://www1.am.FreeBSD.org/ (IPv6)

     * Australia

          * http://www.au.FreeBSD.org/

          * http://www2.au.FreeBSD.org/

     * Austria

          * http://www.at.FreeBSD.org/ (IPv6)

     * Republica Checa

          * http://www.cz.FreeBSD.org/ (IPv6)

     * Dinamarca

          * http://www.dk.FreeBSD.org/ (IPv6)

     * Finlandia

          * http://www.fi.FreeBSD.org/

     * Franc,a

          * http://www1.fr.FreeBSD.org/

     * Alemanha

          * http://www.de.FreeBSD.org/

     * Hong Kong

          * http://www.hk.FreeBSD.org/

     * Irlanda

          * http://www.ie.FreeBSD.org/

     * Japao

          * http://www.jp.FreeBSD.org/www.FreeBSD.org/ (IPv6)

     * Letonia

          * http://www.lv.FreeBSD.org/

     * Lituania

          * http://www.lt.FreeBSD.org/

     * Paises Baixos

          * http://www.nl.FreeBSD.org/

     * Noruega

          * http://www.no.FreeBSD.org/

     * Russia

          * http://www.ru.FreeBSD.org/ (IPv6)

     * Eslovenia

          * http://www.si.FreeBSD.org/

     * Africa do Sul

          * http://www.za.FreeBSD.org/

     * Espanha

          * http://www.es.FreeBSD.org/

          * http://www2.es.FreeBSD.org/

     * Suecia

          * http://www.se.FreeBSD.org/

     * Suic,a

          * http://www.ch.FreeBSD.org/ (IPv6)

          * http://www2.ch.FreeBSD.org/ (IPv6)

     * Taiwan

          * http://www.tw.FreeBSD.org/

          * http://www2.tw.FreeBSD.org/

          * http://www4.tw.FreeBSD.org/

          * http://www5.tw.FreeBSD.org/ (IPv6)

     * Reino Unido

          * http://www1.uk.FreeBSD.org/

          * http://www3.uk.FreeBSD.org/

     * EUA

          * http://www5.us.FreeBSD.org/ (IPv6)

     ----------------------------------------------------------------------

   [3] https://www.freebsd.org/news/status/

Apendice D. Chaves OpenPGP

   Indice

   D.1. Administradores

   As chaves OpenPGP dos Administradores do FreeBSD.org sao mostradas aqui.
   Essas chaves podem ser usadas para verificar uma assinatura ou para enviar
   um email criptografado para um dos administradores. A lista completa das
   chaves OpenPGP do FreeBSD esta disponivel no artigo Chaves PGP. O keyring
   completo pode ser baixado em https://www.FreeBSD.org/doc/pgpkeyring.txt .

D.1. Administradores

  D.1.1. Security Officer Team <security-officer@FreeBSD.org>

 pub   rsa4096/D39792F49EA7E5C2 2017-08-16 [SC] [expires: 2023-01-02]
       Key fingerprint = FC0E 878A E5AF E788 028D  6355 D397 92F4 9EA7 E5C2
 uid                            FreeBSD Security Officer <security-officer@FreeBSD.org>
 sub   rsa4096/6DD0A349F26ADEFD 2017-08-16 [E] [expires: 2023-01-02]


 -----BEGIN PGP PUBLIC KEY BLOCK-----

 mQINBFmT2+ABEACrTVJ7Z/MuDeyKFqoTFnm5FrGG55k66RLeKivzQzq/tT/6RKO9
 K8DaEvSIqD9b0/xgK02KgLSdp0Bucq8HLDFYUk3McFa6Z3YwjobNCWkxc72ipvVl
 uAOGN4H6fuoYOpeg4cLK1H9pktUIrzONTCixaZzc/Bu6X+aX4ywGeCfsuu8g5v03
 fLCPBLLgf3Bm5wsyZ6ZaGmsmILrWzd+d/rbr35Mcc5BekdgywUI4R191qo1bdrw9
 mEJP1V7Ik3jpExOsNnuhMTvm5OQMeCTfUvVEOtBU15QtbT+1LXF5FIOgML0LwS5v
 RHZN+5w/xvzSnEULpj24UuMKLDs/u9rj8U/zET8QaE+oG7m/mr4jJWZEmdX8HKdO
 WrpnVj6UAppk72qdBIEfLsOW2xB/NOjJpppbCQH3+sw7DRYA2UnKE9Mptj/KKiE4
 cs4c8Cupo2WSu93lEZDC5rCrULpT2lFeEXnRYlC/5oIgY5w9sFide9VI4CzHkkWX
 Z2NPW/i1w3mFhoXjvnNLGOYMfAMKPxsRC2/Bn3bY0IhKvuIZ4rAeu7FTmKDDqFKQ
 YEcrUOW74ZVng17AB29xzjWr4zNJVvp/CybFiUb8JoKkwtVWRqAVZIEgenAjU40d
 G5+W4e+ccL0mfTQfEBbXRjnL2BL2tnaoBR42cTfbZGRucPHz7MrlKBEeZQARAQAB
 tDdGcmVlQlNEIFNlY3VyaXR5IE9mZmljZXIgPHNlY3VyaXR5LW9mZmljZXJARnJl
 ZUJTRC5vcmc+iQJUBBMBCgA+FiEE/A6HiuWv54gCjWNV05eS9J6n5cIFAlmT2+AC
 GwMFCQoek4AFCwkIBwMFFQoJCAsFFgIDAQACHgECF4AACgkQ05eS9J6n5cKd9A/9
 Fz3uGjNy28D0ALT1d/JJGzdQ2R3YwspHk9KHBr1LePkog9wf1WRalwCeNtPmA+g5
 cn24psuzOeh1tRElImTZ2eE2ENPZ9XzK/J0ok0nK42MvmIwmMCyz+CaWv9GXW+FK
 0oXnFmHi4YaQUVN3p+45TGkD9T+O5biVww7P47n/NnWsTfhLx0bzC7LyjPKXINai
 /LgPgtlcOgY65/YhW/qhADCkoU7qMp9is41jMjTu1WB3OBPJkUkNpHfu6r15y8FN
 Wqsk7K4W6Obr/WQ6VKGGXgh/a5mTcaEoFGMO16uHijAY4nXeb2HGZlBKxgmPH9Ur
 aT4A9Pz/n+rIRMrK+rs+msFPemQHHNBYxy+x99uBpRBNyT2Su6GouZIxu5J16aIM
 V0ZyOy/dy7m/uJ4sMhJPqKkd8a+MoQs/2L1M1y1EAzsO/QZqIrKrCluaftNN9k/B
 qU0XClSDqB6sRMF7HFzYqb+f+M6cwSL/3Cp1Yx4rZ/onEE/MdWp64+3R87dETTXd
 5tWXQw04qOhfPri5cBTI7r3t/qMO1iNXCGSG5RJbGkas6N6t6Mj83L4ItjI8doLf
 aSIWZjj1XP3/me2hFJ6h2G5y5A+khO4ZwhC0ATFSq1fYbVGHw5AtfthIgNn8FoWu
 +Sb8h7/RqTr7F6LgWagAoAh0GtVj02SVABZjcNZz/AKJAjcEEAEKACEWIQQc9/9v
 rfXKn74bjLLtZ+zWXc9q5wUCWZPcTAMFAngACgkQ7Wfs1l3PauflkRAAgYcaBX0Y
 ic4btxKoP/eOVpgUciOPPKEhDCiloQDyf4XQnZFDoMfjgcHpbLTBZ6kiAz2UzDGr
 fJ4yUqrD+xfixUfCd5YpwzsaSpCGzDzSxOBcP/SpuAFhe40awSOIf5MruQar9Mlf
 33JyslDLULXXeewAq2pcGk0/WrrOragI6Cs2vPGy9XP96VvLxyhjrWjlKmnO+//w
 UF8oIO5hhKoqbtoxxlcqJgsWVyHch0mnPzvr6GWwoPhFXocnh1oPdbLjX1AwmGm9
 ltEYMge4QxONIXlXJR0TvuDuJOaLNvTOC3OI8L97fdBcZS7eNJrG5FAYR5Ft3ISf
 KJowIsSLGDt/cYApqpyP2pv7FpCvnwHgXHYar7/q4zhngCFRxQ2DPUx1cIJQ3Bgh
 HZolKyK1X7XE5ZVDfZ3s3gcHSVKS89pipgHHZNr4sSmOanA8rXHcyHS4o2zSi1ie
 r4iBwnOk6cCd6UNzEIiq0y/XhP/sc7xeL0mn3wDuV7jDBP9sp65sexL1qtIAfnzL
 pLQevm0z41ifrUH5nNeL6RdbXpaoXc8M4PJJeQKJDu04KzLcQpZdUdCJsbS6QO9w
 srWR8enQXPEhz2CO4L77bM9TgYO29222jTqEPcbXcmxF/klxO1rpssTTHUnHHi1Z
 LUGYCbZPjt+laTJ2YPHTjUtN1Jw85vSKCEuJATMEEAEKAB0WIQS7KNQLNg7uk2rt
 FW/l97zLo73d+AUCWjSYRwAKCRDl97zLo73d+JKyB/9N5Ytao12nD5QzMLvceGh5
 otCLN99TUryYiDVDLoNkBivq3jHQA/hOX2rwEueFq0+LF8/2DnglJuUICNtCxIzL
 WXXf/Hr5iWBUQ0JxYNPQzzjdMSXGE0WMwYVpAbCGxHpIsetKLdHUCwneYhaywe3I
 KzmRJSDJGV1IJB0sAfoFtgybZXHgIR61jQjtnNmmyYXliYCd0wmIhXQDFN91tzzG
 +EZdJ3Fao9JsMC+x55jO6EOLVySZgRF5E8vCeKUWemQciKFC7EhKcljILPYAA21u
 NmHCAgRHKWU9JMdFK0w9lQuN2HQaNfkahjarTNM/Q6LwxY0dLG0vVYifE085WFAf
 uQINBFmT2+ABEACxi39m5nQZexzY3c9sg/w5mUYCD89ZNSkj427gduQMYYGn7YW6
 jSPfVJ/V3+PDK824c0a0XasyDapQFY1CPTZYrReRPoyjb8tJjsSVGXXCTFpJZlFU
 br6kS9mgcx58Sypke2PMVk73+W1N1Yco+nahfTECRuM2/T2zHHr0AdKuBPF28U+H
 TxyLatKoIgQwHDs4E/f4ZTbAoHvu3PixAl7XHVXCgz0cHaLhRljXizbZDXngOdGm
 lqdFlAIpL6/l8E3m1Er0m3IfFo6qSzWRHg/KaBGIL4YKetJ6ACjlkCe5qbatDpmk
 gWlg3Ux4RBVjyCK834Xh7eZpEcNf2iwpm28glWh7XMHGUplTHkU3PWQ4vGfNxXB8
 HBOd9r02/cHL6MiHwhCAfIzZGVtqR0i9Ira57TMdXTpJWNXUcgsCMsi/Bg2a+hsn
 aiYLrZc18uNL5nqOqsqKG3c1TcmeN7nbxVgnrNST4AjteulkhmB9p8tNOXA3u979
 OO0T5LPwdqIpobdZ0lfw4URnAGw4Wd4Sm9PtRw0RvuAk2M2e5KXNyxPWAuMVkoRR
 a7wG6h/R8pki54Gexyc+JkfB4ZcOrzHNLurw6DhxroyfRs8WEgX0wNIGmJvCXSBG
 54jb5w9qudYwzIg4YPfvuX8sfeY8MTNhal3rF0tvVloGj3l709wlaWlBYwARAQAB
 iQI8BBgBCgAmFiEE/A6HiuWv54gCjWNV05eS9J6n5cIFAlmT2+ACGwwFCQoek4AA
 CgkQ05eS9J6n5cKhWw/+PT0R4r2gPAxI8ESEe380BYOmneNAH24MFOgWXqWCj4zX
 Uz992BVnW2aL5nH4O5d822LGeCrYUC7SCpQvlifdHZHjobgtizLTwuu40bc3gSOz
 cxWlx2jKfx3Ezn6QQz2mhhK6fZ1AO0ObiQxQq25ldURep95L78E/C8XkCe11YlUR
 ng3wQKeHM7awZWRw/QBC92haHuVtU3cx7At+zQL7jTBKSZqd34zzs0uoXIhk2h94
 O07MMDZ8z8MeU337vdL+RKYtD2bljLwpf7/kqg1D/q44RJ4ZpZcha9G0GvtLaQg2
 +MAPlLg1vOWZ8wOTLaQHm+uzYRpkqxkIV8OuVd4UikCd8t3VNjNG5rG/YRNIAX0A
 UEzs6oMF5YOFE8LmykesbUHAbC07Vcb0AsT5u3XKixDiIpPdnYSwGlkvoOVVLdeh
 q/aXLK9V8BpViG5+a8xP2fdF1eMqdnrKAsiO4GEiq193PN/FA049VeIs3fd0izAa
 x7+ag1MGtoF5Pij5iTVJm6phH5SUd1P3FY3OmclxWj/MbL4ba/G/6FWcy5NXxdw9
 L1bRqaM2KEHJ67aF6NZz7UMldwExAWzFbUon1LUpKysAukxVf0EnntydBeVOQ+JO
 HdqEpirrVLMpxPttUB2xxbo947nMj7/Bnme2gvb0vxaC9xSGVxrpW9cg5iCwSdc=
 =8rds
 -----END PGP PUBLIC KEY BLOCK-----

  D.1.2. Security Team Secretary <secteam-secretary@FreeBSD.org>

 pub   4096R/3CB2EAFCC3D6C666 2013-09-24 [expires: 2018-01-01]
       Key fingerprint = FA97 AA04 4DF9 0969 D5EF  4ADA 3CB2 EAFC C3D6 C666
 uid                          FreeBSD Security Team Secretary <secteam-secretary@FreeBSD.org>
 sub   4096R/509B26612335EB65 2013-09-24 [expires: 2018-01-01]

 -----BEGIN PGP PUBLIC KEY BLOCK-----

 mQINBFJBjIIBEADadvvpXSkdnBOGV2xcsFwBBcSwAdryWuLk6v2VxjwsPcY6Lwqz
 NAZr2Ox1BaSgX7106Psa6v9si8nxoOtMc5BCM/ps/fmedFU48YtqOTGF+utxvACg
 Ou6SKintEMUa1eoPcww1jzDZ3mxx49bQaNAJLjVxeiAZoYHe9loTe1fxsprCONnx
 Era1hrI+YA2KjMWDORcwa0sSXRCI3V+b4PUnbMUOQa3fFVUriM4QjjUBU6hW0Ub0
 GDPcZq45nd7PoPPtb3/EauaYfk/zdx8Xt0OmuKTi9/vMkvB09AEUyShbyzoebaKH
 dKtXlzyAPCZoH9dihFM67rhUg4umckFLc8vc5P2tNblwYrnhgL8ymUaOIjZB/fOi
 Z2OZLVCiDeHNjjK3VZ6jLAiPyiYTG1Hrk9E8NaZDeUgIb9X/K06JXVBQIKNSGfX5
 LLp/j2wr+Kbg3QtEBkcStlUGBOzfcbhKpE2nySnuIyspfDb/6JbhD/qYqMJerX0T
 d5ekkJ1tXtM6aX2iTXgZ8cqv+5gyouEF5akrkLi1ySgZetQfjm+zhy/1x/NjGd0u
 35QbUye7sTbfSimwzCXKIIpy06zIO4iNA0P/vgG4v7ydjMvXsW8FRULSecDT19Gq
 xOZGfSPVrSRSAhgNxHzwUivxJbr05NNdwhJSbx9m57naXouLfvVPAMeJYwARAQAB
 tD9GcmVlQlNEIFNlY3VyaXR5IFRlYW0gU2VjcmV0YXJ5IDxzZWN0ZWFtLXNlY3Jl
 dGFyeUBGcmVlQlNELm9yZz6JAj0EEwEKACcFAlJBjIICGwMFCQgH7b8FCwkIBwMF
 FQoJCAsFFgIDAQACHgECF4AACgkQPLLq/MPWxmYt8Q/+IfFhPIbqglh4rwFzgR58
 8YonMZcq+5Op3qiUBh6tE6yRz6VEqBqTahyCQGIk4xGzrHSIOIj2e6gEk5a4zYtf
 0jNJprk3pxu2Og05USJmd8lPSbyBF20FVm5W0dhWMKHagL5dGS8zInlwRYxr6mMi
 UuJjj+2Hm3PoUNGAwL1SH2BVOeAeudtzu80vAlbRlujYVmjIDn/dWVjqnWgEBNHT
 SD+WpA3yW4mBJyxWil0sAJQbTlt5EM/XPORVZ2tvETxJIrXea/Sda9mFwvJ02pJn
 gHi6TGyOYydmbu0ob9Ma9AvUrRlxv8V9eN7eZUtvNa6n+IT8WEJj2+snJlO4SpHL
 D3Z+l7zwfYeM8FOdzGZdVFgxeyBU7t3AnPjYfHmoneqgLcCO0nJDKq/98ohz5T9i
 FbNR/vtLaEiYFBeX3C9Ee96pP6BU26BXhw+dRSnFeyIhD+4g+/AZ0XJ1CPF19D+5
 z0ojanJkh7lZn4JL+V6+mF1eOExiGrydIiiSXDA/p5FhavMMu8Om4S0sn5iaQ2aX
 wRUv2SUKhbHDqhIILLeQKlB3X26obx1Vg0nRhy47qNQn/xc9oSWLAQSVOgsShQeC
 6DSzrKIBdKB3V8uWOmuM7lWAoCP53bDRW+XIOu9wfpSaXN2VTyqzU7zpTq5BHX1a
 +XRw8KNHZGnCSAOCofZWnKyJAhwEEAEKAAYFAlJBjYgACgkQ7Wfs1l3PaudFcQ//
 UiM7EXsIHLwHxez32TzA/0uNMPWFHQN4Ezzg4PKB6Cc4amva5qbgbhoeCPuP+XPI
 2ELfRviAHbmyZ/zIgqplDC4nmyisMoKlpK0Yo1w4qbix9EVVZr2ztL8F43qN3Xe/
 NUSMTBgt/Jio7l5lYyhuVS3JQCfDlYGbq6NPk0xfYoYOMOZASoPhEquCxM5D4D0Z
 3J3CBeAjyVzdF37HUw9rVQe2IRlxGn1YAyMb5EpR2Ij612GFad8c/5ikzDh5q6JD
 tB9ApdvLkr0czTBucDljChSpFJ7ENPjAgZuH9N5Dmx2rRUj2mdBmi7HKqxAN9Kdm
 +pg/6vZ3vM18rBlXmw1poQdc3srAL+6MHmIfHHrq49oksLyHwyeL8T6BO4d4nTZU
 xObP7PLAeWrdrd1Sb3EWlZJ9HB/m2UL9w9Om1c6cb6X2DoCzQAStVypAE6SQCMBK
 pxkWRj90L41BS62snja+BlZTELuuLTHULRkWqS3fFkUxlDSMUn96QksWlwZLcxCv
 hKxJXOX+pHAiUuMIImaPQ0TBDBWWf5d8zOQlNPsyhSGFR5Skwzlg+m9ErQ+jy7Uz
 UmNCNztlYgRKeckXuvr73seoKoNXHrn7vWQ6qB1IRURj2bfphsqlmYuITmcBhfFS
 Dw0fdYXSDXrmG9wad98g49g4HwCJhPAl0j55f93gHLGIRgQQEQoABgUCUkGO5gAK
 CRAV1ogEymzfsol4AKCI7rOnptuoXgwYx2Z9HkUKuugSRwCgkyW9pxa5EovDijEF
 j1jG/cdxTOaJAhwEEAEKAAYFAlJBkdUACgkQkshDRW2mpm6aLxAAzpWNHMZVFt7e
 wQnCJnf/FMLTjduGTEhVFnVCkEtI+YKarveE6pclqKJfSRFDxruZ6PHGG2CDfMig
 J6mdDdmXCkN//TbIlRGowVgsxpIRg4jQVh4S3D0Nz50h+Zb7CHbjp6WAPVoWZz7b
 Myp+pN7qx/miJJwEiw22Eet4Hjj1QymKwjWyY146V928BV/wDBS/xiwfg3xIVPZr
 RqtiOGN/AGpMGeGQKKplkeITY7AXiAd+mL4H/eNf8b+o0Ce2Z9oSxSsGPF3DzMTL
 kIX7sWD3rjy3Xe2BM20stIDrJS2a1fbnIwFvqszS3Z3sF5bLc6W0iyPJdtbQ0pt6
 nekRl9nboAdUs0R+n/6QNYBkj4AcSh3jpZKe82NwnD/6WyzHWtC0SDRTVkcQWXPW
 EaWLmv8VqfzdBiw6aLcxlmXQSAr0cUA6zo6/bMQZosKwiCfGl3tR4Pbwgvbyjoii
 pF+ZXfz7rWWUqZ2C79hy3YTytwIlVMOnp3MyOV+9ubOsFhLuRDxAksIMaRTsO7ii
 5J4z1d+jzWMW4g1B50CoQ8W+FyAfVp/8qGwzvGN7wxN8P1iR+DZjtpCt7J+Xb9Pt
 L+lRKSO/aOgOfDksyt2fEKY4yEWdzq9A3VkRo1HCdUQY6SJ/qt7IyQHumxvL90F6
 vbB3edrR/fVGeJsz4vE10hzy7kI1QT65Ag0EUkGMggEQAMTsvyKEdUsgEehymKz9
 MRn9wiwfHEX5CLmpJAvnX9MITgcsTX8MKiPyrTBnyY/QzA0rh+yyhzkY/y55yxMP
 INdpL5xgJCS1SHyJK85HOdN77uKDCkwHfphlWYGlBPuaXyxkiWYXJTVUggSjuO4b
 jeKwDqFl/4Xc0XeZNgWVjqHtKF91wwgdXXgAzUL1/nwN3IglxiIR31y10GQdOQEG
 4T3ufx6gv73+qbFc0RzgZUQiJykQ3tZK1+Gw6aDirgjQYOc90o2Je0RJHjdObyZQ
 aQc4PTZ2DC7CElFEt2EHJCXLyP/taeLq+IdpKe6sLPckwakqtbqwunWVoPTbgkxo
 Q1eCMzgrkRu23B2TJaY9zbZAFP3cpL65vQAVJVQISqJvDL8K5hvAWJ3vi92qfBcz
 jqydAcbhjkzJUI9t44v63cIXTI0+QyqTQhqkvEJhHZkbb8MYoimebDVxFVtQ3I1p
 EynOYPfn4IMvaItLFbkgZpR/zjHYau5snErR9NC4AOIfNFpxM+fFFJQ7W88JP3cG
 JLl9dcRGERq28PDU/CTDH9rlk1kZ0xzpRDkJijKDnFIxT2ajijVOZx7l2jPL1njx
 s4xa1jK0/39kh6XnrCgK49WQsJM5IflVR2JAi8BLi2q/e0NQG2pgn0QL695Sqbbp
 NbrrJGRcRJD9sUkQTpMsLlQTABEBAAGJAiUEGAEKAA8FAlJBjIICGwwFCQgH7b8A
 CgkQPLLq/MPWxmZAew//et/LToMVR3q6/qP/pf9ob/QwQ3MgejkC0DY3Md7JBRl/
 6GWfySYnO0Vm5IoJofcv1hbhc/y3OeZTvK4s+BOQsNokYe34mCxZG4dypNaepkQi
 x0mLujeU/n4Y0p0LTLjhGLVdKina2dM9HmllgYr4KumT58g6eGjxs2oZD6z5ty0L
 viU5tx3lz3o0c3I9soH2RN2zNHVjXNW0EvWJwFLxFeLJbk/Y3UY1/kXCtcyMzLua
 S5L5012eUOEvaZr5iYDKjy+wOxY4SUCNYf0GPmSej8CBbwHOF2XCwXytSzm6hNb3
 5TRgCGbOSFTIy9MxfV5lpddQcdzijmuFSl8LySkL2yuJxjlI7uKNDN+NlfODIPMg
 rdH0hBSyKci6Uz7Nz/Up3qdE+aISq68k+Hk1fiKJG1UcBRJidheds29FCzj3hoyZ
 VDmf6OL60hL0YI1/4GjIkJyetlPzjMp8J7K3GweOUkfHcFihYZlbiMe7z+oIWEc7
 0fNScrAGF/+JN3L6mjXKB6Pv+ER5ztzpfuhBJ/j7AV5BaNMmDXAVO4aTphWl7Dje
 iecENuGTpkK8Ugv5cMJc4QJaWDkj/9sACc0EFgigPo68KjegvKg5R8jUPwb8E7T6
 lIjBtlclVhaUrE2uLx/yTz2Apbm+GAmD8M0dQ7IYsOFlZNBW9zjgLLCtWDW+p1A=
 =5gJ7
 -----END PGP PUBLIC KEY BLOCK-----

  D.1.3. Core Team Secretary <core-secretary@FreeBSD.org>

 pub   rsa2048/0CB403E4E95B96EC 2018-06-30 [SC] [expires: 2020-06-29]
       Key fingerprint = 9F02 836F 50D3 AD5A B75A  C588 0CB4 03E4 E95B 96EC
 uid                            FreeBSD Core Team Secretary <core-secretary@freebsd.org>
 sub   rsa2048/133C3338A5B95A60 2018-06-30 [E] [expires: 2020-06-29]
       Key fingerprint = FA37 B8AA C667 C3AA D310  751D 133C 3338 A5B9 5A60


 -----BEGIN PGP PUBLIC KEY BLOCK-----

 mQENBFs3wcYBCAC7nlaUTMqyT7PBSFLtW/LleSz7BNUwqSTo8LfUVJOY5G/pzWt5
 Mqjqh4oJcW/MvKFTDeRaJ2mHp+vELxIP7wO3gcP36dXgImw6sXwBTkPlKpmmFRm1
 M+QqnCCrrLHtCznWaDg+1fTHmyQpFHpg37XzA1Z5ev6PryEUYJkcBP77oNCTY933
 86sXOqRAJRywvN/LEkAoaawqBz0CpkNTOBACoJZRV8i9CIklEOy8J+hNzGtJpHkg
 FxUOXWj7z+2y6UOR4GzSpYAWJGbtwEcpGPfhqJk5M5eZ6PJcwzZ6LeLKgGFzNi6r
 tlShQh5LT7wAKkTrBsZ9vckyyuTEtqgdGCmhABEBAAG0OEZyZWVCU0QgQ29yZSBU
 ZWFtIFNlY3JldGFyeSA8Y29yZS1zZWNyZXRhcnlAZnJlZWJzZC5vcmc+iQFUBBMB
 CgA+FiEEnwKDb1DTrVq3WsWIDLQD5OlbluwFAls3wcYCGwMFCQPCZwAFCwkIBwMF
 FQoJCAsFFgMCAQACHgECF4AACgkQDLQD5OlbluyRZAf/VG9VWpIsofcoHwDxhYAL
 mm+xbuP/eq1/Q8HeO3XVhA/HZF5nvSKZbD8F+ujaHDH/waNStWb3wUK87l9AfB6G
 QFMVYjVQWrPwgpwFtGjL9zLMCBS3T+ysuub+xSuPhr1KQHgKB4+t6NLoBlSwP+76
 sLLx0SILGwTpsb0r84etaECgp5ymAXijbzIB0Pu44Y+DjZimBEVuw2YRZ4/Ug/3z
 pcNQqpjbrHNYjU6AOZEHXftbXwuWfgdjINnrWpvTwkKVnU0FhGXV9UYWP2UAxE5u
 OyAvIyYFbX10iSFQGUXle3eg6IuHncT5u6P1IxQM++d/TJIbKrQW+xdr+1I+vUrS
 rokCMwQQAQoAHRYhBHLPrCF5vLAktbVFkANvbJ7n856/BQJbOJDdAAoJEANvbJ7n
 856/1swQAN2QKGe1riRm9jKVxC8AMy57+Tzu1ITGDDUf6dH2+gxx0K5GoVmtdhLL
 2qrmDJEqP7K232T25cU5zStQnaTHpEIUklY8Rn1Fati8+IZBdpemG4BXTzGnNDQ0
 FS6PxuxOFvcELOFvuUil3PP7ArMKI9jfjxisEkOWFuwQVyIPeApcQuf8vyqrfTnV
 /Qes/XhySrvsEL+ehq2OEorl6YjMB2/lVK2lVWYrWJ91Oq8Vwp0G09whZEMhMabQ
 D1OxlmM6kofkTioM8DOmbGTbOXhiiiiCUI41pOAOzF9SrCqCpLV2OyrPFz7J+GU9
 6u+DPPZyy7O8NmjdDsyrDg2hhbTwWC4dvW+QMJSWZ8Bo8eMx8b5ti9RX0XPEIwao
 KrCKh3aemGgkP8zcVbFWOzOji8aXrpWrRr/oxQmJxE49d2j1oF4LydIfhDxOnfOF
 428pVhDXDLjf0xdUIVQqCsOBQvzwVPWTQVOFSakVFNRYP6/SXyF5eUf5E6iSExKn
 fn+G4FtrJd6QNwNUquI2LF8CEhJBpLNBqjJW3WEv1tDzU+rqS9QpHzSmLzLqtiE+
 5HqynvOPXGRRsAcUOLmV4fMUGRH8tpNoH4iBEc7LmoFTQXIf6oJClaiwRkFKuT9c
 2XlkJ4ca6fxU4KyoHtR6pmMNkLIcehfpoL11+TPyyBjNd2TwLpLbiQIzBBABCgAd
 FiEEwHv14xCuZL9hILD2NqfAX+Hs+bsFAls4kV0ACgkQNqfAX+Hs+bvRrw//QVea
 9diHHbzxq84yp4eOGQoj86usPSV+IOZN27+e6QDYR8ZsxqFE5wQycSAdyqo0n42Q
 EDE6tnn+/HhyFogr7kF8CRJMtsSlwKgDrMMYjVPnP2fP5VFxAF36epSRgcGC0Lqh
 Ris+xjfSzXM2oNiiebPu2MOe8qOe8LVGJMyuxJZbb/OuEfgLGLKtjcJ1SujKhzLl
 TVS8JSSVRbxk62huh/Mo80eCKHMV+/NmbHP4QKZBOVSWn0U/lrm+SyDR78l3EhtN
 x/KIfhiPZENYTjSBSxa8F/Vg19bcmUedLapcN9J8q2KVNx7VuiPz+X2ww/dOKFR0
 FxwOvCweGFRNRyoytF4ziw0Gwt78RHw4OdhQg8YH38kbrRFvf2YqiddGUA2UWwKi
 HRdj9ZGemzL++OE/MZvgODVhZA6V5QU/B9bR3xfnVcBsPyGTrlQ8XZ9aY1wBMTrS
 TTbS3sD7HuyS4PO8rt3iZy50UDMc5v55Pr5SIPiaUdyV8Y401oOWnKvKgKtHzBtC
 2ADT+iZk/I4a3iDj4hw07Y+O1Voqp72LaACGhqWqkN0zqoKq3TvD/ukEZwgsvDdP
 ErzPUanN31gn055PlpWYQBVoLjupH8SXahrdTmo15Xjdr97VHCuABNT4Kh3QDELU
 vQtF0IB+S+VQfTVR5wkC1OLj8J1edvoXlsVzREW5AQ0EWzfBxgEIAMZxwaI3hZ2G
 je7L8N1TFfPJA62kMGzzFDvFqeH8mDPOXkd4JC4y2EIBySPS36y0c1MJM79oOkKI
 6DQLyUb3p4hGZbEVKidAwXvp4t5x1QJ0bpodHc/7xh95EP11Lf8C/DFP5Js3YVPl
 MsdeVhx7J8itQuivoLJrZVTgKSgFepatLuXXKUttYAJNcU11ziPwTlzjEuTx4X6V
 RimPrp8+/dbkRmPhsDqMXrqJmjeNarYK9F0xKlaWnIhtyZnNXtHrdtQE/VOBjoXN
 0NXiuJg02JZGqZuBM80Ig7yBdmUlZdPrxkYw92+kxHIdySM3+WYbGu/e6T/VY6wx
 7KW2IV3u3b8AEQEAAYkBPAQYAQoAJhYhBJ8Cg29Q061at1rFiAy0A+TpW5bsBQJb
 N8HGAhsMBQkDwmcAAAoJEAy0A+TpW5bsp0AH/Rht32xeJQk59UgDf7BPHiiphgg8
 P1qmRVd6OZJ6GoVYWjJ87+gU9sChbZUTCFioiIYLWPbhm9AJKy1KDrcnP0zYjWL2
 SKjezMbru9cgFYk6R3LO+mK5DwtGMgyzipKAN8Kh92pX2WERUeMFulkYa4+rdVkP
 kBtB49hmDj25GPw/72Vuksg5m7sbpEZzt6JjXQN0ynDjBuizE/HYm2E8VW5tH1aH
 wdzVGruNVIOMMF3gHKbJbrxKiq/SPJfph0YGeL6v5bF9mgizGamEUn9YHVkCqZ7z
 wDuSIDVTSiQQOJesD58WOADCDINEP3uXFhlI1A0Au7X+XYyjIjHCdyTNhBI=
 =5VKx
 -----END PGP PUBLIC KEY BLOCK-----

  D.1.4. Ports Management Team Secretary <portmgr-secretary@FreeBSD.org>

 pub   rsa2048/D8294EC3BBC4D7D5 2012-07-24 [SC]
       Key fingerprint = FB37 45C8 6F15 E8ED AC81  32FC D829 4EC3 BBC4 D7D5
 uid                            FreeBSD Ports Management Team Secretary <portmgr-secretary@FreeBSD.org>
 sub   rsa2048/5CC117965F65CFE7 2012-07-24 [E]


 -----BEGIN PGP PUBLIC KEY BLOCK-----

 mQENBFAOzqYBCACYd+KGv0/DduIRpSEKWZG2yfDILStzWfdaQMD+8zdWihB0x7dd
 JDBUpV0o0Ixzt9mvu5CHybx+9lOHeFRhZshFXc+bIJOPyi+JrSs100o7Lo6jg6+c
 Si2vME0ixG4x9YjCi8DisXIGJ1kZiDXhmVWwCvL+vLInpeXrtJnK8yFkmszCOr4Y
 Q3GXuvdU0BF2tL/Wo/eCbSf+3U9syopVS2L2wKcP76bbYU0ioO35Y503rJEK6R5G
 TchwYvYjSXuhv4ec7N1/j3thrMC9GNpoqjVninTynOk2kn+YZuMpO3c6b/pfoNcq
 MxoizGlTu8VT4OO/SF1y52OkKjpAsENbFaNTABEBAAG0R0ZyZWVCU0QgUG9ydHMg
 TWFuYWdlbWVudCBUZWFtIFNlY3JldGFyeSA8cG9ydG1nci1zZWNyZXRhcnlARnJl
 ZUJTRC5vcmc+iQE4BBMBAgAiBQJQDs6mAhsDBgsJCAcDAgYVCAIJCgsEFgIDAQIe
 AQIXgAAKCRDYKU7Du8TX1QW2B/0coHe8utbTfGKpeM4BY9IyC+PFgkE58Hq50o8d
 shoB9gfommcUaK9PNwJPxTEJNlwiKPZy+VoKs/+dO8gahovchbRdSyP1ejn3CFy+
 H8pol0hDDU4n7Ldc50q54GLuZijdcJZqlgOloZqWOYtXFklKPZjdUvYN8KHAntgf
 u361rwM4DZ40HngYY9fdGc4SbXurGA5m+vLAURLzPv+QRQqHfaI1DZF6gzMgY49x
 qS1JBF4kPoicpgvs3o6CuX8MD9ewGFSAMM3EdzV6ZdC8pnpXC8+8Q+p6FjNqmtjk
 GpW39Zq/p8SJVg1RortCH6qWLe7dW7TaFYov7gF1V/DYwDN5iEYEEBECAAYFAlN2
 WksACgkQtzkaJjSHbFtuMwCg0MXdQTcGMMOma7LC3L5b4MEoZ+wAn0WyUHpHwHnn
 pn2oYDlfAbwTloWIiQEcBBABAgAGBQJQDuVrAAoJENk3EJekc8mQ3KwIAImNDMXA
 F8ajPwCZFpM6KDi3F/jpwyBPISGY1oWuYPEi1zN94k5jS90aZb3W8Y8x4JTh35Ew
 b6XODi3uGLSLCmnlqu2a80yPfXf5IuWmIQdFNQxvosj9UHrg+icZGFmm+f0hPJxM
 TsZREv3AvivQfnb/N3xIICxW4SjKSYXQcq4hr4ObhUx7GKnjayq+ofU2cRlujr87
 uOH0fO3xhOJG4+cX5mI1HGK38k0Csc1zqYa/66Qe5dnIZz+sNXpEPMLAHIt1a45U
 B967igJdZSDFN33bPl1QWmf3aUXU3d1VttiSyHkpm4kb9KgsDkUk1IJ5nUe9OXyd
 WtoqNW5afDa5N0aIRgQQEQIABgUCUA7lwwAKCRB59uBxdBRinNh2AJ41+zfsaQSR
 HWvSkqOXGcP/fgOduwCfUJDT+M1eXe2udmKof/9yzGYMirKJASIEEAECAAwFAlAa
 IT8FAwASdQAACgkQlxC4m8pXrXwCHAf+J7l+L7AvRpqlQcezjnjFS/zG1098qkDf
 lThHZlpVnrBMJZaXdvL6LzVgiIYVWZC5CSSazW9EWFjp9VjM7FBHdWFZNMV7GAuU
 t0jzx6gGXOWwi+/v/hs1P11RyDZN5hICHdPNmyZVupciDxe+sIEP9aEbVxcaiccq
 zM/pFzIVIMMP5tCiA42q6Mz3h0hy6hntUKptS8Uon6sje5cDVcVlKAUj1wO2cphC
 qkYlwMQfZV5J9f/hcW5ODriD3cBwK8SocA2Cq5JYF8kYDL1+pXnUutGnvAHUYt87
 RWvQdKmfXjzBcMFJ2LlPUB1+IFvwQ13V9R8j9B/EdLmSWQYT9qRA2okCHAQTAQoA
 BgUCV1XMpwAKCRCtu/hhCjeJt2CyD/9JLe+Ck23CJkeRSF8oC+4SFOUdSAmejSzn
 klPwmEClffABYd/kckO1T6um+2FUcXuJZQE1nKKUNvZ8pBWwsm1RDHsyroKi/XB1
 0a1Tdx/rvlU88ytbeLfUCLzoCrf6pkMQWoU6/3qS6elV0WwOlDufk+XjD1sja2wu
 sshG8y+1WCA5JjP3rZdD9NVdzo5DgkotTRUfuYN1LJIN4zlDgHj7FVP7wW7+R0cZ
 FoOiNsLJCA0FN8SiyU98UysjawLiIY9dTJz6XVA0DgB0TZWO3mWiDjITeKrdGcqf
 PNiJhmvUKBkn07YpTPNfkoTT/p/q5ChYmu0ubGeyS1ELKjmklJ+DzynfZLzvnXYX
 Ngo5ckeuqEqUNxM0J63v8lmfhDRROFveqHWdp0XMxXVmR5bMunSldg5EZsoLyQbN
 +ScIPnDTAEPGrCtf0t84RQxNQeET6/WBbZfzeSeAFmpBFCdicsZ6Mjwtwjr4+o15
 n1QMTZco1NaTqf8vXwzl9wM4aYtg1OkF4z8HdHuy50CHCet4mT5eJgwZUfFvXdbM
 pHXprEI0Y9OOL4aMinC1egF3dXt/0n57i6CE+E2k3UJPNvMrtp0HaDEnKZ8cfkBU
 EBzkUYi5wwqntHV2JRisqoRnHdvJT7ImlHMe7WaJsifBK874PnToaKg8P6K1Tph+
 FyLxULaYjYkCHAQSAQgABgUCVBg2zwAKCRDqsDxYv9xHj1klEADXYJdHC3zsdx7w
 DsJsttWdykcZoOd/VUKUdN0BAU72nLV0tLn4uFjETA6MhHZVxzwIDTeLB8kqyEpc
 fZnoVbqJIUJz1sJXMdOty7CwZzlZlAwmUaIfFiazJY1p398JbyYfSrVKNOpw9wCm
 Db7WP9dBritwvjaLzu8HQsiztO0S/5ha/EDfTU3qocBUTjbCtGR9LqAmPE4X8+li
 F2EfZMEoJd3rJWsYv2y/k6pSgC/MpQewnyr6f+JQ/781UoZB6PpxCxfu4D6xlOyd
 ERBUg+FfDAWYR+KX+DGOalRlUyaSz8Nvxl8/b0Im/AQhx9afqyEZxIDpg52zt8jJ
 t3wx23YP8EQGUgwF8pIrj3wFSBSG3a/cskiBNUIhChIR9hQrVPUahN/jx7DGAGxk
 /Ka9qsRGYTHfSr9jjTUQ+htfeFBRDR0nkZKMo5+Wk/cAcBKVbPlBpwvnzT3fh+wL
 cF3ErBbx5jp+BoFee8D6ATeUvQxMcgVbDPUkgMsy3EtKMVO10jhIoXoVV+Sg9GZ8
 zMEy1tORKn0zsd2ZgXC2sRJOm5ttCSdYQ4ddbM1A9jg6tiRx4hES16GDywvkL8P2
 M9+qyIfjQxjGU33f/r8zp9DyNT1VlrtwhFxtOoMdmrsbYOCTja4Xg14hK1hRac0k
 GB7bj6w97p8uMrQT3PlSMtoyrRyo7bkBDQRQDs6mAQgAzNxJYpf5PrqV8pdRXkn3
 6Fe45q671YtbZ2WrT7D0CVZ8Z+AZsxnP/tiY1SrM2MepCeA2xBAhKGsWBWo1aRk5
 mfZOksKsiXsi2XeBVhdZlCkrOMKBTVian7I1lH59ZnNIMX0Nl0tlj3L1IjeWWNvf
 ej43URV81S9EmSwpjaWboatr2A+1oJku5m7nPD9JIOckE1TzBsyhx7zIUN9w6MKr
 7gFw8DCzypwUKyYgKYToVm8QlkT/L3B0fuQHWhT6ROGk4o8SC71ia5tc1TzUzGEZ
 1AQO8bbnbmJLBDKveWHCoaeAkRzINzoD9wAn9z4pnilze59QtKC1cOqUksTvBSDh
 6wARAQABiQEfBBgBAgAJBQJQDs6mAhsMAAoJENgpTsO7xNfVOHoH/i5VyggVdwpq
 PX8YBmN5mXQziYZNQoiON8IhOsxpX4W2nXCj5m6MACV6nJDVV6wyUH8/VvDQC9nH
 arCe1oaNsHXJz0HamYt5gHJ0G1bYuBcuJp/FEjLa48XFI7nXQjJHn8rlwZMjK/PW
 j1lw2WZiekviuzTEDH8c3YStGJSa+gYe8Eyq3XJVAe2VQOhImoWgGDR3tWfgrya/
 IdEFb/jmjHSG5XUfbI0vNwqlf832BqSQKPG/Zix4MmBJgvAz4R71PH8WBmbmNFjD
 elxVyfz80+iMgEb9aL91MfeBNC2KB1pFmg91mQTsiq7ajwVLVJK8NplHAkdLmkBC
 O8MgMjzGhlE=
 =iw7d
 -----END PGP PUBLIC KEY BLOCK-----

  D.1.5. <doceng-secretary@FreeBSD.org>

 pub   rsa2048/E1C03580AEB45E58 2019-10-31 [SC] [expires: 2022-10-30]
       Key fingerprint = F24D 7B32 B864 625E 5541  A0E4 E1C0 3580 AEB4 5E58
 uid                            FreeBSD Doceng Team Secretary <doceng-secretary@freebsd.org>
 sub   rsa2048/9EA8D713509472FC 2019-10-31 [E] [expires: 2022-10-30]


 -----BEGIN PGP PUBLIC KEY BLOCK-----

 mQENBF27FFcBCADeoSsIgyQUY8vREwkTikwFFlNg31MVy5s/Nq1cNK1PRfRMnprS
 yfB62KqbYuz16bmQKaA9zHN4FGfiTvR6tl66LVHm1s/5HPiLv8sP14GsruLro9zN
 v72dO7a9i68bMw+jarPOnu9dGiDFEI0dACOkdCGEYKEUapQeNpmWRrQ46BeXyFwF
 JcNx76bJJUkwk6fWC0W63D762e6lCEX6ndoaPjjLBnFvtx13heNGUc8RukBwe2mA
 U5pSGHj47J05bdWiRSwZaXa8PcW+20zTWaP755w7zWe4h60GANY7OsT9nuOqsioJ
 QonxTrJuZweKRV8fNQ1EfDws3HZr7/7iXvO3ABEBAAG0PEZyZWVCU0QgRG9jZW5n
 IFRlYW0gU2VjcmV0YXJ5IDxkb2Nlbmctc2VjcmV0YXJ5QGZyZWVic2Qub3JnPokB
 VAQTAQoAPhYhBPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsDBQkFo5qABQsJ
 CAcDBRUKCQgLBRYDAgEAAh4BAheAAAoJEOHANYCutF5YB2IIALw+EPYmOz9qlqIn
 oTFmk/5MrcdzC5iLEfxubbF6TopDWsWPiOh5mAuvfEmROSGf6ctvdYe9UtQV3VNY
 KeeyskeFrIBOFo2KG/dFqKPAWef6IfhbW3HWDWo5uOBg01jHzQ/pB1n6SMKiXfsM
 idL9wN+UQKxF3Y7S/bVrZTV0isRUolO9+8kQeSYT/NMojVM0H2fWrTP/TaNEW4fY
 JBDAl5hsktzdl8sdbNqdC0GiX3xb4GvgVzGGQELagsxjfuXk6PfOyn6Wx2d+yRcI
 FrKojmhihBp5VGFQkntBIXQkaW0xhW+WBGxwXdaAl0drQlZ3W+edgdOl705x73kf
 Uw3Fh2a5AQ0EXbsUVwEIANEPAsltM4vFj2pi5xEuHEcZIrIX/ZJhoaBtZkqvkB+H
 4pu3/eQHK5hg0Dw12ugffPMz8mi57iGNI9TXd8ZYMJxAdvEZSDHCKZTX9G+FcxWa
 /AzKNiG25uSISzz7rMB/lV1gofCdGtpHFRFTiNxFcoacugTdlYDiscgJZMJSg/hC
 GXBdEKXR5WRAgAGandcL8llCToOt1lZEOkd5vJM861w6evgDhAZ2HGhRuG8/NDxG
 r4UtlnYGUCFof/Q4oPNbDJzmZXF+8OQyTNcEpVD3leEOWG1Uv5XWS2XKVHcHZZ++
 ISo/B5Q6Oi3SJFCVV9f+g09YF+PgfP/mVMBgif2fT20AEQEAAYkBPAQYAQoAJhYh
 BPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsMBQkFo5qAAAoJEOHANYCutF5Y
 kecIAMTh2VHQqjXHTszQMsy3NjiTVVITI3z+pzY0u2EYmLytXQ2pZMzLHMcklmub
 5po0X4EvL6bZiJcLMI2mSrOs0Gp8P3hyMI40IkqoLMp7VA2LFlPgIJ7K5W4oVwf8
 khY6lw7qg2l69APm/MM3xAyiL4p6MU8tpvWg5AncZ6lxyy27rxVflzEtCrKQuG/a
 oVaOlMjH3uxvOK6IIxlhvWD0nKs/e2h2HIAZ+ILE6ytS5ZEg2GXuigoQZdEnv71L
 xyvE9JANwGZLkDxnS5pgN2ikfkQYlFpJEkrNTQleCOHIIIp8vgJngEaP51xOIbQM
 CiG/y3cmKQ/ZfH7BBvlZVtZKQsI=
 =MQKT
 -----END PGP PUBLIC KEY BLOCK-----

                              Glossario do FreeBSD

   Este glossario contem termos e acronimos usados na comunidade e na
   documentac,ao do FreeBSD.

  UMA

   ACL

           Ver Lista de Controle de Acesso.

   ACPI

           Ver Configurac,ao avanc,ada e interface de energia.

   AMD

           Ver Daemon de Montagem Automatica.

   AML

           Ver Linguagem de maquina ACPI .

   API

           Ver Interface de programac,ao de aplicativos.

   APIC

           Ver Controlador Avanc,ado de Interrupc,ao Programavel.

   APM

           Ver Gerenciamento avanc,ado de energia.

   APOP

           Ver Protocolo autenticado do correio.

   ASL

           Ver ACPI Source Language.

   ATA

           Ver Anexo de Tecnologia Avanc,ada.

   ATM

           Ver Modo Assincrono de transferencia.

   Linguagem de maquina ACPI

           Pseudocodigo, interpretado por uma maquina virtual dentro de um
           sistema operacional compativel com ACPI, fornecendo uma camada
           entre o hardware subjacente e a interface documentada apresentada
           ao SO.

   ACPI Source Language

           A linguagem de programac,ao AML esta escrita em.

   Lista de Controle de Acesso

           Uma lista de permissoes anexadas a um objeto, geralmente um
           arquivo ou um dispositivo de rede.

   Configurac,ao avanc,ada e interface de energia

           Uma especificac,ao que fornece uma abstrac,ao da interface que o
           hardware apresenta ao sistema operacional, de modo que o sistema
           operacional nao precise saber nada sobre o hardware subjacente
           para aproveita-lo ao maximo. O ACPI evolui e substitui a
           funcionalidade fornecida anteriormente pelo APM, PNPBIOS e outras
           tecnologias e fornece recursos para controlar o consumo de
           energia, suspensao da maquina, e para habilitar e desabilitar
           dispositivos, etc.

   Interface de programac,ao de aplicativos

           Um conjunto de procedimentos, protocolos e ferramentas que
           especificam a interac,ao canonica de uma ou mais partes do
           programa; como, quando e por que trabalham juntos e quais dados
           compartilham ou operam.

   Gerenciamento avanc,ado de energia

           Uma API que permite que o sistema operacional funcione em conjunto
           com o BIOS para obter o gerenciamento de energia. O APM foi
           substituido pela especificac,ao muito mais generica e poderosa
           ACPI para a maioria das aplicac,oes.

   Controlador Avanc,ado de Interrupc,ao Programavel

   Anexo de Tecnologia Avanc,ada

   Modo Assincrono de transferencia

   Protocolo autenticado do correio

   Daemon de Montagem Automatica

           Um daemon que monta automaticamente um sistema de arquivos quando
           um arquivo ou diretorio dentro desse sistema de arquivos e
           acessado.

  B

   BARRA

           Ver Registo Base de Enderec,os.

   VINCULAR

           Ver Berkeley Internet Name Domain.

   BIOS

           Ver Sistema Basico de Entrada e Saida.

   BSD

           Ver Berkeley Software Distribution.

   Registo Base de Enderec,os

           Os registros que determinam em qual intervalo de enderec,os um
           dispositivo PCI ira responder.

   Sistema Basico de Entrada e Saida

           A definic,ao de BIOS depende um pouco do contexto. Algumas pessoas
           se referem a ele como o chip ROM com um conjunto basico de rotinas
           para fornecer uma interface entre software e hardware. Outros se
           referem a ele como o conjunto de rotinas contidas no chip que
           ajudam na inicializac,ao do sistema. Alguns tambem podem se
           referir a ele como a tela usada para configurar o processo de
           bootstrapping. O BIOS e especifico do PC, mas outros sistemas tem
           algo semelhante.

   Berkeley Internet Name Domain

           Uma implementac,ao dos protocolos DNS.

   Berkeley Software Distribution

           Esse e o nome que o CSRG (Computer Systems Research Group) da
           Universidade da California em Berkeley deu a suas melhorias e
           modificac,oes para AT & ; T's 32V UNIX (R). O FreeBSD e um
           descendente do trabalho do CSRG.

   Bikeshed Building

           Um fenomeno pelo qual muitas pessoas opinarao sobre um topico
           simples, enquanto um topico complexo recebe pouca ou nenhuma
           discussao. Consulte a FAQ para a origem do termo.

  C

   CD

           Ver Carrier Detect.

   CHAP

           Ver Protocolo de autenticac,ao de handshake de desafio.

   CLIP

           Ver Classico IP sobre ATM.

   COFF

           Ver Formato de arquivo de objeto comum.

   CPU

           Ver Unidade central de processamento.

   CTS

           Ver Clear To Send.

   Carrier Detect

           Um sinal RS232C indicando que uma portadora foi detectada.

   Unidade central de processamento

           Tambem conhecido como processador. Este e o cerebro do computador
           onde todos os calculos ocorrem. Existem varias arquiteturas
           diferentes com conjuntos de instruc,oes diferentes. Entre os mais
           conhecidos estao o Intel-x86 e derivados, Arm e PowerPC.

   Protocolo de autenticac,ao de handshake de desafio

           Um metodo de autenticac,ao de um usuario, baseado em um segredo
           compartilhado entre o cliente e o servidor.

   Classico IP sobre ATM

   Clear To Send

           Um sinal RS232C que permite ao sistema remoto enviar dados.

           Ver Tambem Pedido para enviar.

   Formato de arquivo de objeto comum

  D

   DAC

           Ver Controle de Acesso Discricionario.

   DDB

           Ver Depurador.

   DES

           Ver Padrao de Criptografia de Dados.

   DHCP

           Ver Protocolo de configurac,ao dinamica de hosts.

   DNS

           Ver Sistema de nomes de dominio.

   DSDT

           Ver Tabela de descric,ao de sistema diferenciada.

   DSR

           Ver Data Set Ready.

   DTR

           Ver Data Terminal Ready.

   DVMRP

           Ver Protocolo de roteamento de multidifusao de vetor de distancia.

   Controle de Acesso Discricionario

   Padrao de Criptografia de Dados

           Um metodo de criptografar informac,oes, tradicionalmente usado
           como metodo de criptografia para senhas UNIX(R) e para a func,ao
           crypt(3).

   Data Set Ready

           Um sinal RS232C enviado do modem para o computador ou terminal,
           indicando prontidao para enviar e receber dados.

           Ver Tambem Data Terminal Ready.

   Data Terminal Ready

           Um sinal RS232C enviado do computador ou terminal para o modem,
           indicando uma prontidao para enviar e receber dados.

   Depurador

           Um recurso interativo do kernel para examinar o status de um
           sistema, geralmente usado depois que um sistema falhou para
           estabelecer os eventos que cercam a falha.

   Tabela de descric,ao de sistema diferenciada

           Uma tabela ACPI, que fornece informac,oes basicas de configurac,ao
           sobre o sistema base.

   Protocolo de roteamento de multidifusao de vetor de distancia

   Sistema de nomes de dominio

           O sistema que converte nomes de host legiveis humanamente (ou
           seja, mail.example.net) em enderec,os da Internet e vice-versa.

   Protocolo de configurac,ao dinamica de hosts

           Um protocolo que atribui dinamicamente enderec,os IP a um
           computador (host) quando ele solicita um do servidor. A
           atribuic,ao de enderec,o e chamada de "lease".

  E

   ECOFF

           Ver Extensao COFF.

   ELF

           Ver Executable and Linking Format.

   ESP

           Ver Encapsulated Security Payload.

   Encapsulated Security Payload

   Executable and Linking Format

   Extensao COFF

  F

   FADT

           Ver Tabela de descric,ao fixa ACPI.

   FAT

           Ver Tabela de alocac,ao de arquivos.

   FAT16

           Ver Tabela de alocac,ao de arquivos (16 bits).

   FTP

           Ver Protocolo de transferencia de arquivos.

   Tabela de alocac,ao de arquivos

   Tabela de alocac,ao de arquivos (16 bits)

   Protocolo de transferencia de arquivos

           Um membro da familia de protocolos de alto nivel implementados em
           cima do TCP, que pode ser usado para transferir arquivos em uma
           rede TCP/IP .

   Tabela de descric,ao fixa ACPI

  G

   GUI

           Ver Interface grafica do usuario.

   Giant

           O nome de um mecanismo de exclusao mutua (um sleep mutex ) que
           protege um grande conjunto de recursos do kernel. Embora um
           mecanismo de bloqueio simples tenha sido adequado nos dias em que
           uma maquina podia ter apenas algumas dezenas de processos, uma
           placa de rede e, certamente, apenas um processador, nos tempos
           atuais isso e um gargalo de desempenho inaceitavel. Os
           desenvolvedores do FreeBSD estao trabalhando ativamente para
           substitui-lo por bloqueios que protegem os recursos individuais, o
           que permitira um grau muito maior de paralelismo para maquinas de
           processador unico e multiprocessador.

   Interface grafica do usuario

           Um sistema em que o usuario e o computador interagem com graficos.

  H

   HTML

           Ver Linguagem de marcac,ao de hipertexto.

   HUP

           Ver HangUp.

   HangUp

   Linguagem de marcac,ao de hipertexto

           A linguagem de marcac,ao usada para criar paginas da web.

  I

   I/O

           Ver Input/Output.

   IASL

           Ver Compilador Intel's ASL.

   IMAP

           Ver Internet Message Access Protocol.

   IP

           Ver protocolo de internet.

   IPFW

           Ver IP Firewall.

   IPP

           Ver Protocolo de impressao na Internet.

   IPv4

           Ver IP Versao 4.

   IPv6

           Ver IP Versao 6.

   ISP

           Ver Provedor de internet.

   IP Firewall

   IP Versao 4

           A versao 4 do protocolo IP, que usa 32 bits para enderec,amento.
           Esta versao ainda e a mais usada, mas esta sendo lentamente
           substituida pelo IPv6 .

           Ver Tambem IP Versao 6.

   IP Versao 6

           O novo protocolo IP. Inventado porque o espac,o de enderec,o em
           IPv4 esta acabando. Usa 128 bits para enderec,amento.

   Input/Output

   Compilador Intel's ASL

           Compilador da Intel para converter ASL em AML.

   Internet Message Access Protocol

           Um protocolo para acessar mensagens de email em um servidor de
           email, caracterizado por as mensagens normalmente serem mantidas
           no servidor, em vez de serem baixadas para o cliente do leitor de
           email.

           Ver Tambem Post Office Protocol Version 3.

   Protocolo de impressao na Internet

   protocolo de internet

           O protocolo de transmissao de pacotes que e o protocolo basico na
           Internet. Originalmente desenvolvido no Departamento de Defesa dos
           EUA e uma parte extremamente importante da pilha do TCP/IP . Sem o
           Internet Protocol, a Internet nao teria se tornado o que e hoje.
           Para maiores informac,oes, consulte RFC 791.

   Provedor de internet

           Uma empresa que fornece acesso `a Internet.

  K

   KAME

           Japones para "tartaruga", o termo KAME e usado em circulos de
           computac,ao para se referir ao Projeto KAME, eles trabalham em uma
           implementac,ao de IPv6.

   KDC

           Ver Centro de distribuic,ao de chaves.

   KLD

           Ver Kernel ld(1).

   KSE

           Ver Entidades do Agendador do Kernel.

   KVA

           Ver Enderec,o Virtual do Kernel.

   Kbps

           Ver Kilo Bits Per Second.

   Kernel ld(1)

           Um metodo de carregar dinamicamente a funcionalidade em um kernel
           do FreeBSD sem reiniciar o sistema.

   Entidades do Agendador do Kernel

           Um sistema de thread suportado pelo kernel. Veja a pagina inicial
           do projeto para maiores detalhes.

   Enderec,o Virtual do Kernel

   Centro de distribuic,ao de chaves

   Kilo Bits Per Second

           Usado para medir a largura de banda (quantos dados podem passar
           por um determinado ponto em um periodo de tempo especificado).
           Alternativas ao prefixo Kilo incluem Mega, Giga, Tera e assim por
           diante.

  L

   LAN

           Ver Rede local.

   LOR

           Ver Reversao de ordem de bloqueio.

   LPD

           Ver Line Printer Daemon.

   Line Printer Daemon

   Rede local

           Uma rede usada em uma area local, por exemplo escritorio, casa ou
           assim por diante.

   Reversao de ordem de bloqueio

           O kernel do FreeBSD usa diversos bloqueios de recursos para
           arbitrar contenc,ao para esses recursos. Um sistema de diagnostico
           de trava em tempo de execuc,ao encontrado nos kernels
           FreeBSD-CURRENT (mas removido para releases), chamado witness(4),
           detecta o potencial de deadlocks devido a erros de bloqueio. (O
           witness(4) e na verdade um pouco conservador, por isso e possivel
           obter falsos positivos.) Um relatorio positivo verdadeiro indica
           que "se voce foi azarado, um deadlock teria acontecido aqui".

           LORs positivos verdadeiros tendem a ser corrigidos rapidamente,
           entao verifique
           http://lists.FreeBSD.org/mailman/listinfo/freebsd-current e a
           pagina LORs Vistos antes de postar nas listas de discussao.

  M

   MAC

           Ver Controle de acesso obrigatorio.

   MADT

           Ver Tabela de descric,ao multipla APIC.

   MFC

           Ver Merge From Current.

   MFH

           Ver Merge From Head.

   MFS

           Ver Merge From Stable.

   MFV

           Ver Merge From Vendor.

   MIT

           Ver Instituto de Tecnologia de Massachusetts.

   MLS

           Ver Seguranc,a multinivel.

   MOTD

           Ver Message Of The Day.

   MTA

           Ver Mail Transfer Agent.

   MUA

           Ver Mail User Agent.

   Mail Transfer Agent

           Um aplicativo usado para transferir e-mail. Um MTA tem sido
           tradicionalmente parte do sistema basico do BSD. Hoje, o Sendmail
           esta incluido no sistema basico, mas existem muitos outros MTAs,
           como o postfix, o qmail e o Exim.

   Mail User Agent

           Um aplicativo usado pelos usuarios para exibir e escrever e-mail.

   Controle de acesso obrigatorio

   Instituto de Tecnologia de Massachusetts

   Merge From Current

           Para mesclar funcionalidade ou um patch do ramo -CURRENT para
           outro, na maioria das vezes -STABLE.

   Merge From Head

           Para mesclar funcionalidade ou um patch de um repositorio HEAD
           para um branch anterior.

   Merge From Stable

           No curso normal de desenvolvimento do FreeBSD, uma mudanc,a sera
           enviada para a ramificac,ao -CURRENT para teste antes de ser
           mesclada com -STABLE. Em raras ocasioes, uma alterac,ao entrara
           primeiro na -STABLE e depois sera mesclada na -CURRENT.

           Esse termo tambem e usado quando um patch e mesclado de -STABLE
           para um ramo de seguranc,a.

           Ver Tambem Merge From Current.

   Merge From Vendor

   Message Of The Day

           Uma mensagem, geralmente mostrada no login, geralmente usada para
           distribuir informac,oes aos usuarios do sistema.

   Seguranc,a multinivel

   Tabela de descric,ao multipla APIC

  N

   NAT

           Ver Network Address Translation.

   NDISulator

           Ver Project Evil.

   NFS

           Ver Network File System.

   NTFS

           Ver New Technology File System.

   NTP

           Ver Network Time Protocol.

   Network Address Translation

           Uma tecnica em que os pacotes IP sao reescritos no caminho atraves
           de um gateway, permitindo que muitas maquinas atras do gateway
           compartilhem efetivamente um unico enderec,o IP.

   Network File System

   New Technology File System

           Um sistema de arquivos desenvolvido pela Microsoft e disponivel em
           seus sistemas operacionais "New Technology", como Windows(R) 2000,
           Windows NT(R) e Windows(R) XP.

   Network Time Protocol

           Um meio de sincronizar relogios atraves de uma rede.

  O

   OBE

           Ver Overtaken By Events.

   ODMR

           Ver On-Demand Mail Relay.

   OS

           Ver Sistema operacional.

   On-Demand Mail Relay

   Sistema operacional

           Um conjunto de programas, bibliotecas e ferramentas que fornecem
           acesso aos recursos de hardware de um computador. Atualmente, os
           sistemas operacionais variam de projetos simplistas que suportam
           apenas um programa em execuc,ao, acessando apenas um dispositivo
           para sistemas totalmente multiusuarios, multitarefa e
           multiprocessos que podem atender a milhares de usuarios
           simultaneamente, cada um executando duzias de diferentes
           aplicac,oes.

   Overtaken By Events

           Indica uma alterac,ao sugerida (como um Relatorio de Problema ou
           uma solicitac,ao de recurso) que nao e mais relevante ou aplicavel
           devido a mudanc,as posteriores no FreeBSD, mudanc,as nos padroes
           de rede, o hardware afetado desde entao se tornou obsoleto e assim
           por diante.

  P

   PAE

           Ver Physical Address Extensions.

   PAM

           Ver Pluggable Authentication Modules.

   PAP

           Ver Password Authentication Protocol.

   PC

           Ver Computador pessoal.

   PCNSFD

           Ver Daemon do sistema de arquivos da rede de computadores
           pessoais.

   PDF

           Ver Portable Document Format.

   PID

           Ver Process ID.

   POLA

           Ver Principle Of Least Astonishment.

   POP

           Ver Post Office Protocol.

   POP3

           Ver Post Office Protocol Version 3.

   PPD

           Ver PostScript Printer Description.

   PPP

           Ver Point-to-Point Protocol.

   PPPoA

           Ver PPP over ATM.

   PPPoE

           Ver PPP over Ethernet.

   PPP over ATM

   PPP over Ethernet

   PR

           Ver Relatorio de Problemas.

   PXE

           Ver Ambiente de execuc,ao de pre-inicializac,ao.

   Password Authentication Protocol

   Computador pessoal

   Daemon do sistema de arquivos da rede de computadores pessoais

   Physical Address Extensions

           Um metodo para permitir acesso a ate 64 GB de RAM em sistemas que
           possuem apenas um espac,o de enderec,amento amplo de 32 bits (e,
           portanto, seriam limitados a 4 GB sem PAE).

   Pluggable Authentication Modules

   Point-to-Point Protocol

   Pointy Hat

           Um pedac,o mitico de equipamento de cabec,a, muito parecido com um
           dunce cap, concedido a qualquer committer do FreeBSD que quebre a
           compilac,ao, faz os numeros de revisao retrocederem ou cria
           qualquer outro tipo de confusao na base de codigo-fonte. Qualquer
           committer que valha a pena em breve acumulara uma grande colec,ao.
           O uso e (quase sempre?) Bem-humorado.

   Portable Document Format

   Post Office Protocol

           Ver Tambem Post Office Protocol Version 3.

   Post Office Protocol Version 3

           Um protocolo para acessar mensagens de e-mail em um servidor de
           e-mail, caracterizado por as mensagens serem geralmente baixadas
           do servidor para o cliente, em vez de permanecerem no servidor.

           Ver Tambem Internet Message Access Protocol.

   PostScript Printer Description

   Ambiente de execuc,ao de pre-inicializac,ao

   Principle Of Least Astonishment

           A medida que o FreeBSD evolui, as mudanc,as visiveis para o
           usuario devem ser mantidas como nao surpreendentes quanto
           possivel. Por exemplo, rearranjar arbitrariamente variaveis de
           inicializac,ao do sistema em /etc/defaults/rc.conf viola a POLA.
           Os desenvolvedores consideram o POLA ao contemplar alterac,oes no
           sistema visiveis ao usuario.

   Relatorio de Problemas

           Uma descric,ao de algum tipo de problema encontrado na fonte ou
           documentac,ao do FreeBSD. Veja o artigo Escrevendo Relatorios de
           Problemas do FreeBSD.

   Process ID

           Um numero, exclusivo para um processo especifico em um sistema,
           que o identifica e permite que ac,oes sejam tomadas contra ele.

   Project Evil

           O titulo provisorio para o NDISulator , escrito por Bill Paul, que
           o denominou referindo-se a quao horrivel e (do ponto de vista
           filosofico) precisar ter algo assim em primeiro lugar. O
           NDISulator e um modulo de compatibilidade especial para permitir
           que os drivers de rede de miniport do Microsoft Windows (TM) NDIS
           sejam usados com o FreeBSD/i386. Esta e geralmente a unica maneira
           de usar cartoes onde o driver e de codigo fechado. Veja
           src/sys/compat/ndis/subr_ndis.c.

  R

   RA

           Ver Router Advertisement.

   RAID

           Ver Matriz Redundante de Discos Economicos.

   RAM

           Ver Memoria de acesso aleatorio.

   RD

           Ver Received Data.

   RFC

           Ver Request For Comments.

   RISC

           Ver Computador de conjunto de instruc,oes reduzido.

   RPC

           Ver Chamada de Procedimento Remoto.

   RS232C

           Ver Padrao recomendado 232C.

   RTS

           Ver Pedido para enviar.

   Memoria de acesso aleatorio

   Sistema de Controle de Revisao

           O Sistema de Controle de Revisao ( RCS ) e um dos conjuntos de
           software mais antigos que implementam o "controle de revisao" para
           arquivos simples. Ele permite o armazenamento, recuperac,ao,
           arquivamento, registro, identificac,ao e fusao de varias revisoes
           para cada arquivo. O RCS consiste em muitas ferramentas pequenas
           que funcionam juntas. Ele nao possui alguns dos recursos
           encontrados em sistemas de controle de revisao mais modernos, como
           o Git, mas e muito simples de instalar, configurar e comec,ar a
           usar para um pequeno conjunto de arquivos.

           Ver Tambem Subversion.

   Received Data

           Um pino ou fio RS232C no qual os dados sao recebidos.

           Ver Tambem Transmitted Data.

   Padrao recomendado 232C

           Um padrao para comunicac,oes entre dispositivos seriais.

   Computador de conjunto de instruc,oes reduzido

           Uma abordagem ao design do processador, em que as operac,oes que o
           hardware pode executar, sao simplificadas, mas feitas da forma
           mais geral possivel. Isso pode levar a um menor consumo de
           energia, menos transistores e, em alguns casos, melhor desempenho
           e maior densidade de codigo. Exemplos de processadores RISC
           incluem o Alpha, SPARC (R), ARM (R) e PowerPC (R).

   Matriz Redundante de Discos Economicos

   Chamada de Procedimento Remoto

   Request For Comments

           Um conjunto de documentos definindo padroes da Internet,
           protocolos e assim por diante. Veja www.rfc-editor.org.

           Tambem usado como um termo geral quando alguem tem uma alterac,ao
           sugerida e deseja feedback.

   Pedido para enviar

           Um sinal RS232C solicitando que o sistema remoto inicie a
           transmissao de dados.

           Ver Tambem Clear To Send.

   Router Advertisement

  S

   SCI

           Ver Interrupc,ao de controle do sistema.

   SCSI

           Ver Small Computer System Interface.

   SG

           Ver Signal Ground.

   SMB

           Ver Server Message Block.

   SMP

           Ver Multiprocessador Simetrico.

   SMTP

           Ver Simple Mail Transfer Protocol.

   SMTP AUTH

           Ver Autenticac,ao SMTP.

   SSH

           Ver Secure Shell.

   STR

           Ver Suspender para RAM.

   SVN

           Ver Subversion.

   Autenticac,ao SMTP

   Server Message Block

   Signal Ground

           Um pino ou fio RS232 que e a referencia de terra para o sinal.

   Simple Mail Transfer Protocol

   Secure Shell

   Small Computer System Interface

   Subversion

           Subversion e um sistema de controle de versao atualmente usado
           pelo projeto FreeBSD.

   Suspender para RAM

   Multiprocessador Simetrico

   Interrupc,ao de controle do sistema

  T

   TCP

           Ver Transmission Control Protocol.

   TCP / IP

           Ver Transmission Control Protocol/Internet Protocol.

   TD

           Ver Transmitted Data.

   TFTP

           Ver Trivial FTP.

   TGT

           Ver Ticket-Granting Ticket.

   TSC

           Ver Time Stamp Counter.

   Ticket-Granting Ticket

   Time Stamp Counter

           Um contador de criac,ao de perfil interno dos modernos
           processadores Pentium(R) que conta os pulsos de clock de
           frequ:encia do nucleo.

   Transmission Control Protocol

           Um protocolo que fica no topo (por exemplo) do protocolo IP e
           garante que os pacotes sejam entregues de forma confiavel e
           ordenada.

   Transmission Control Protocol/Internet Protocol

           O termo para a combinac,ao do protocolo TCP executado sobre o
           protocolo IP. Grande parte da Internet roda sobre TCP/IP.

   Transmitted Data

           Um pino ou cabo RS232C no qual os dados sao transmitidos.

           Ver Tambem Received Data.

   Trivial FTP

  U

   UDP

           Ver User Datagram Protocol.

   UFS1

           Ver Versao 1 do sistema de arquivos Unix.

   UFS2

           Ver Versao 2 do sistema de arquivos Unix.

   UID

           Ver ID do Usuario.

   URL

           Ver Uniform Resource Locator.

   USB

           Ver Universal Serial Bus.

   Uniform Resource Locator

           Um metodo de localizar um recurso, como um documento na Internet e
           um meio para identificar esse recurso.

   Versao 1 do sistema de arquivos Unix

           O sistema de arquivos original do UNIX(R), as vezes chamado de
           Berkeley Fast File System.

   Versao 2 do sistema de arquivos Unix

           Uma extensao para o UFS1, introduzida no FreeBSD 5-CURRENT. O UFS2
           adiciona ponteiros de bloco de 64 bits (quebrando a barreira de
           1T), suporte para armazenamento de arquivos estendido e outras
           funcionalidades.

   Universal Serial Bus

           Um padrao de hardware usado para conectar uma grande variedade de
           perifericos de computador a uma interface universal.

   ID do Usuario

           Um numero exclusivo atribuido a cada usuario de um computador,
           pelo qual os recursos e as permissoes atribuidos a este usuario
           podem ser identificados.

   User Datagram Protocol

           Um protocolo de datagrama simples e nao confiavel que e usado para
           trocar dados em uma rede TCP/IP. UDP nao fornece verificac,ao de
           erros e correc,ao como o TCP.

  V

   VPN

           Ver Virtual Private Network.

   Virtual Private Network

           Um metodo de usar um meio de telecomunicac,ao publica, como a
           Internet, para fornecer acesso remoto a uma rede localizada, como
           uma LAN corporativa.

                                Indice Remissivo

  Simbolos

   -CURRENT, Acompanhando um ramo de desenvolvimento

                compiling, Usando o FreeBSD-CURRENT

                using, Usando o FreeBSD-CURRENT

   -STABLE, Acompanhando um ramo de desenvolvimento

                compiling, Usando o FreeBSD-STABLE

                using, Usando o FreeBSD-STABLE

   .k5login, Configurando um cliente para usar o Kerberos

   .k5users, Configurando um cliente para usar o Kerberos

   .rhosts, Backups do Sistema de Arquivos

   /boot/kernel.old, Criando e Instalando um Kernel Customizado

   /etc, Criando o layout da partic,ao

   /etc/groups, Gerenciando Grupos

   /etc/login.conf, Configurando Classes de Login

   /etc/mail/access, Arquivos de Configurac,ao do Sendmail

   /etc/mail/aliases, Arquivos de Configurac,ao do Sendmail

   /etc/mail/local-host-names, Arquivos de Configurac,ao do Sendmail

   /etc/mail/mailer.conf, Arquivos de Configurac,ao do Sendmail

   /etc/mail/mailertable, Arquivos de Configurac,ao do Sendmail

   /etc/mail/sendmail.cf, Arquivos de Configurac,ao do Sendmail

   /etc/mail/virtusertable, Arquivos de Configurac,ao do Sendmail

   /etc/remote, Usando comandos AT

   /etc/ttys, Configurac,ao de Modem

   /usr, Criando o layout da partic,ao

   /usr/bin/login, Configurac,ao de Modem

   /usr/share/skel, adduser

   /var, Criando o layout da partic,ao

   386BSD, Uma Breve Historia do FreeBSD

   386BSD Patchkit, Uma Breve Historia do FreeBSD

   4.3BSD-Lite, Uma Breve Historia do FreeBSD

   4.4BSD-Lite, Bem vindo ao FreeBSD!

   802.11 (ver wireless networking)

  A

   AbiWord, AbiWord

   accounting

                disk space, Cotas de Disco

   accounts

                adding, adduser

                changing password, passwd

                daemon, Contas do sistema

                groups, Gerenciando Grupos

                limiting, Configurando Classes de Login

                modifying, Gerenciando Contas

                nobody, Contas do sistema

                operator, Contas do sistema

                removing, rmuser

                superuser (root), A conta de superusuario

                system, Contas do sistema

                user, Contas de usuario

   ACL, Listas de Controle de Acesso

   ACPI, Gerenciamento de energia e recursos, Problemas comuns

                ASL, BIOS contem Bytecode com bugs, Substituindo o padrao AML

                debugging, Obtendo e enviando informac,oes de depurac,ao

                problems, Problemas comuns, Obtendo e enviando informac,oes
                de depurac,ao

   adduser, adduser, Utilitarios que Alteram as Classes de Login

   AIX, Sistema de Informac,ao de Rede (NIS)

   anti-aliased fonts, Fontes com Anti-Alias

   Apache, Quem Usa o FreeBSD?, Servidor HTTP Apache

                configuration file, Configurando e Iniciando o Apache

                modules, Modulos Apache

                starting or stopping, Configurando e Iniciando o Apache

   Apache OpenOffice , Apache OpenOffice

   APIC

                disabling, Travamentos do sistema

   APM, Gerenciamento de energia e recursos

   Apple, Quem Usa o FreeBSD?

   ASCII, Usando Localizac,ao

   AT&T, Uma Breve Historia do FreeBSD

   AUDIT, Sinopse

   autofs, Automatizando Montagens com autofs(5)

   automounter subsystem, Automatizando Montagens com autofs(5)

   AutoPPP, Configurando servic,os de discagem

  B

   backup software, Utilitarios de Backup de Terceiros

                cpio, Backups de Diretorio

                dump / restore, Backups do Sistema de Arquivos

                pax, Backups de Diretorio

                tar, Backups de Diretorio

   Basic Input/Output System (ver BIOS)

   BGP, Configurando um roteador com rotas estaticas

   bibliotecas compartilhadas, Instalando Bibliotecas Adicionais Manualmente

   binary compatibility

                Linux, Bem vindo ao FreeBSD!, Sinopse

   BIND, Soluc,ao de problemas

   BIOS, Processo de Inicializac,ao do FreeBSD

   bits-per-second, Terminologia serial e hardware

   Bluetooth, Bluetooth

   Bluetooth audio, Configurando Dispositivos de Som Bluetooth

   Boot Loader, Processo de Inicializac,ao do FreeBSD

   Boot Manager, Processo de Inicializac,ao do FreeBSD, O gerenciador de
   inicializac,ao

   boot-loader, Estagio tres

   booting, Sinopse

   bootstrap, Sinopse

   Bourne shells, Shells

   bridge, Bridging

   browsers

                web, Navegadores

   BSD Copyright, Objetivos do Projeto FreeBSD

   BSD Router, Quem Usa o FreeBSD?

   bsdlabel, Recuperac,ao de Emergencia

  C

   Calligra, Calligra

   CARP, Protocolo Comum de Redundancia de Enderec,os (CARP)

   CD burner

                ATAPI, Criando e Usando Midia em CD

                ATAPI/CAM driver, Dispositivos Suportados

   CD-ROMs

                burning, Gravando um CD

                creating, Criando e Usando Midia em CD

                creating bootable, Escrevendo Dados em um Sistema de Arquivos
                ISO

   CHAP, Autenticac,ao PAP e CHAP

   chpass, chpass

   Chromium, Chromium

   Cisco, Quem Usa o FreeBSD?

   Citrix, Quem Usa o FreeBSD?

   command line, Shells

   committers, O Modelo de Desenvolvimento do FreeBSD

   Common Address Redundancy Protocol, Protocolo Comum de Redundancia de
   Enderec,os (CARP)

   Compiler, O que o FreeBSD Pode Fazer?

   Computer Systems Research Group (CSRG), Bem vindo ao FreeBSD!

   Concurrent Versions System (ver CVS)

   console, Consoles e Terminais Virtuais, Modo Single-User

   console serial, Configurando o Console Serial

   contributors, O Modelo de Desenvolvimento do FreeBSD

   core team, O Modelo de Desenvolvimento do FreeBSD

   country codes, Usando Localizac,ao

   cron

                configuration, Configurando o cron(8)

   cryptography, mod_ssl

   cuau, Configurac,ao de Porta Serial

   CVS, O Modelo de Desenvolvimento do FreeBSD

   CVS Repository, O Modelo de Desenvolvimento do FreeBSD

  D

   dangerously dedicated, Organizac,ao dos Discos

   DCE, Terminologia serial e hardware

   device nodes, Soluc,ao de Problemas de Som

   device.hints, Sugestoes de dispositivos

   DGA, Determinando os Recursos de Video

   DHCP

                configuration files, Configurando um cliente DHCP, Instalando
                e configurando um servidor DHCP

                dhcpd.conf, Instalando e configurando um servidor DHCP

                diskless operation, Configurando o servidor DHCP

                installation, Instalando e configurando um servidor DHCP

                server, Instalando e configurando um servidor DHCP

   dial-in service, Servic,o Dial-in

   dial-out service, Servic,o de Dial-in

   directories, Permissoes

   directory hierarchy, Estrutura de Diretorios

   Disk Labels, Rotulando Dispositivos de Disco

   Disk Mirroring, RAID1 - Espelhamento

   disk quotas, Limites de Recursos, Cotas de Disco

                checking, Habilitando Cotas de Disco, Verificando Limites de
                Cota e Uso de Disco

                limits, Definindo Limites de Cota

   diskless operation, Operac,ao Diskless com PXE

   diskless workstation, Operac,ao Diskless com PXE

   disks

                adding, Adicionando Discos

                detaching a memory disk, Anexando e Desanexando Imagens
                Existentes

                encrypting, Criptografando Partic,oes de Disco

                memory, Anexando e Desanexando Imagens Existentes

                memory file system, Criando um Disco Virtual Baseado em
                Arquivo ou Memoria

                resizing, Redimensionando e Ampliando Discos

   Django, Django

   DNS, Hostnames, Configurac,ao Avanc,ada, Componentes de Email, Email para
   um Dominio, Sistema de Nomes de Dominio (DNS)

   DNS Server, O que o FreeBSD Pode Fazer?

   Documentation (ver Updating and Upgrading)

   documentation package (ver Updating and Upgrading)

   DSP, Soluc,ao de Problemas de Som

   DTE, Terminologia serial e hardware

   DTrace, Sinopse

   DTrace support (ver DTrace)

   dual homed hosts, Configurando um roteador com rotas estaticas

   dump, Backups do Sistema de Arquivos

   DVD

                burning, Criando e Usando Midia de DVD

                DVD+RW, Usando um DVD+RW

                DVD-RAM, Usando um DVD-RAM

                DVD-RW, Usando um DVD-RW

                DVD-Video, Gravando um DVD -Video

   Dynamic Host Configuration Protocol (ver DHCP)

  E

   editors, Editores de Texto

                ee1, Editores de Texto

   ee, Editores de Texto

   electronic mail (ver email)

   ELF, Topicos Avanc,ados

                branding, Topicos Avanc,ados

   emacs, Editores de Texto

   email, O que o FreeBSD Pode Fazer?, Sinopse

                change mta, Alterando o Mail Transfer Agent

                configuration, Configurac,ao basica

                receiving, Componentes de Email

                troubleshooting, Soluc,ao de problemas

   embedded, O que o FreeBSD Pode Fazer?

   encodings, Usando Localizac,ao

   environment variables, Shells

   ePDFView, ePDFView

   execution class loader, Topicos Avanc,ados

  F

   failover, Agregac,ao de links e failover

   FEC, Agregac,ao de links e failover

   fetchmail, Usando o fetchmail

   file permissions, Permissoes

   file server

                UNIX clients, Network File System (NFS)

                Windows clients, Servic,os de arquivos e impressao para
                clientes Microsoft(R) Windows(R) Clients (Samba)

   file systems

                ISO 9660, Criando e Usando Midia em CD, Escrevendo Dados em
                um Sistema de Arquivos ISO

                Joliet, Escrevendo Dados em um Sistema de Arquivos ISO

                mounted with fstab, O arquivo fstab

                mounting, Usando o mount(8)

                snapshots, Snapshots de Sistemas de Arquivos

                unmounting, Usando o umount(8)

   File Systems, Sinopse

   File Systems Support (ver File Systems)

   Firefox, Firefox

   firewall, O que o FreeBSD Pode Fazer?, Firewalls

                IPFILTER, IPFILTER (IPF)

                IPFW, IPFW

                PF, PF

                rulesets, Conceitos de Firewall

   fonts

                anti-aliased, Fontes com Anti-Alias

                spacing, Fontes com Anti-Alias

                TrueType, Fontes TrueType(R)

   Fonts

                LCD screen, Fontes com Anti-Alias

   Free Software Foundation, Uma Breve Historia do FreeBSD, Arquivos GNU Info

   FreeBSD Project

                development model, O Modelo de Desenvolvimento do FreeBSD

                goals, Objetivos do Projeto FreeBSD

                history, Uma Breve Historia do FreeBSD

   FreeBSD Security Advisories, Avisos de Seguranc,a do FreeBSD

   freebsd-update (ver updating-upgrading)

   FreeNAS, Quem Usa o FreeBSD?

   FreshPorts, Encontrando Software

   FTP

                anonymous, Configurac,ao

   FTP servers, O que o FreeBSD Pode Fazer?, Protocolo de Transferencia de
   Arquivos (FTP)

   Fudo Security, Quem Usa o FreeBSD?

   FuryBSD, Quem Usa o FreeBSD?

  G

   gateway, Gateways e Rotas

   Geeqie, Geeqie

   GEOM, Sinopse, RAID0 - Striping, RAID1 - Espelhamento, RAID3 -
   Distribuic,ao em Nivel de Byte com Paridade Dedicada, Dispositivos RAID
   por Software, Rotulando Dispositivos de Disco, Journaling UFS atraves do
   GEOM

   GEOM Disk Framework (ver GEOM)

   getty, Configurac,ao de Modem

   GhostBSD, Quem Usa o FreeBSD?

   GNOME, O que o FreeBSD Pode Fazer?, GNOME

   GNU General Public License (GPL), Objetivos do Projeto FreeBSD

   GNU Lesser General Public License (LGPL), Objetivos do Projeto FreeBSD

   GNU toolchain, Instalando os binarios Linux(R) ELF

   GnuCash, GnuCash

   Gnumeric, Gnumeric

   gpart, Adicionando Discos, Redimensionando e Ampliando Discos

   grace period, Verificando Limites de Cota e Uso de Disco

   Greenman, David, Uma Breve Historia do FreeBSD

   Grimes, Rod, Uma Breve Historia do FreeBSD

   groups, Gerenciando Grupos

   gv, gv

  H

   hard limit, Definindo Limites de Cota

   HAST

                high availability, Alta Disponibilidade de Armazenamento
                (HAST)

   HCI, Encontrando outros dispositivos Bluetooth

   hostname, Hostnames

   hosts, /etc/hosts

   HP-UX, Sistema de Informac,ao de Rede (NIS)

   Hubbard, Jordan, Uma Breve Historia do FreeBSD

   hw.ata.wc, hw.ata.wc

  I

   I/O port, Soluc,ao de Problemas de Som

   IEEE, Backups de Diretorio

   image scanners, Scanners de Imagem

   IMAP, Componentes de Email

   init8, Processo de Inicializac,ao do FreeBSD, Ultimo estagio

   installation, Sinopse

                troubleshooting, Soluc,ao de problemas

   Intel i810 graphic chipset, Configurac,ao com Chipsets graficos Intel(R)
   i810

   internationalization (ver localization)

   Internet Systems Consortium (ISC), Protocolo de configurac,ao dinamica de
   hosts (DHCP)

   interrupt storms, Travamentos do sistema

   IP aliases, Hosts Virtuais

   IP masquerading (ver NAT)

   IP subnet, Bridging

   IPFILTER

                enabling, Ativando o IPF

                kernel options, Ativando o IPF

                logging, Log do IPF

                rule syntax, Sintaxe de Regras IPF

                statistics, Visualizando Estatisticas do IPF

   ipfstat, Visualizando Estatisticas do IPF

   IPFW

                enabling, Ativando o IPFW

                kernel options, Opc,oes do Kerne para o IPFW

                logging, Mensagens de Log do Firewall

                rule processing order, Sintaxe de Regras IPFW

                rule syntax, Sintaxe de Regras IPFW

   ipfw, O Comando IPFW

   ipmon, Log do IPF

   ipnat, Configurando o NAT

   IPsec, VPN Sobre IPsec

                AH, VPN Sobre IPsec

                ESP, VPN Sobre IPsec

   IRQ, Soluc,ao de Problemas de Som

   Isilon, Quem Usa o FreeBSD?

   ISO 9660, Criando e Usando Midia em CD

   iXsystems, Quem Usa o FreeBSD?

  J

   jails, Jails

   Jolitz, Bill, Uma Breve Historia do FreeBSD

   Journaling, Journaling UFS atraves do GEOM

   Juniper, Quem Usa o FreeBSD?

  K

   KDE, O que o FreeBSD Pode Fazer?, KDE

                display manager, KDE

   Kerberos5

                configure clients, Configurando um cliente para usar o
                Kerberos

                enabling services, Configurando um Servidor para Usar o
                Kerberos

                external resources, Recursos e Outras Informac,oes

                Key Distribution Center, Configurando um KDC do Heimdal

                limitations and shortcomings, Atenuando as Limitac,oes do
                Kerberos

   kern.cam.scsi_delay, SCSI_DELAY (kern.cam.scsi_delay)

   kern.ipc.soacceptqueue, kern.ipc.soacceptqueue

   kern.maxfiles, kern.maxfiles

   kernel, Processo de Inicializac,ao do FreeBSD

                boot interaction, Estagio tres

                bootflags, Ultimo estagio

                building / installing, Criando e Instalando um Kernel
                Customizado

                building a custom kernel, Sinopse

                configuration, Configurando a Placa de Som

                configuration file, O Arquivo de Configurac,ao

                NOTES, O Arquivo de Configurac,ao

   kernel options

                COMPAT_LINUX, Configurando a compatibilidade binaria com o
                Linux(R)

                IPFILTER, Ativando o IPF

                IPFILTER_DEFAULT_BLOCK, Ativando o IPF

                IPFILTER_LOG, Ativando o IPF

                IPFIREWALL, Opc,oes do Kerne para o IPFW

                IPFIREWALL_VERBOSE, Opc,oes do Kerne para o IPFW

                IPFIREWALL_VERBOSE_LIMIT, Opc,oes do Kerne para o IPFW

                IPSEC, VPN Sobre IPsec

                IPSEC_DEBUG, VPN Sobre IPsec

                MROUTING, Considerac,oes sobre Multicast

                SCSI DELAY, SCSI_DELAY (kern.cam.scsi_delay)

   keymap, Configurac,ao do Console

   KLD (kernel loadable object), Utilizando os Drivers Windows(R) NDIS

   KMyMoney, KMyMoney

   Konqueror, Konqueror

  L

   L2CAP, Controle de Link Logico e Protocolo de Adaptac,ao (L2CAP)

   LACP, Agregac,ao de links e failover

   lagg, Agregac,ao de links e failover

   language codes, Usando Localizac,ao

   LCD screen, Fontes com Anti-Alias

   LCP, Configurando servic,os de discagem

   LDAP, Protocolo leve de acesso de diretorio ( LDAP ), Configurac,oes de
   Seguranc,a

   LDAP Server, Configurando um servidor LDAP

   LibreOffice, LibreOffice

   limiting users, Configurando Classes de Login

                coredumpsize, Configurando Classes de Login

                cputime, Configurando Classes de Login

                filesize, Configurando Classes de Login

                maxproc, Configurando Classes de Login

                memorylocked, Configurando Classes de Login

                memoryuse, Configurando Classes de Login

                openfiles, Configurando Classes de Login

                quotas, Limites de Recursos

                sbsize, Configurando Classes de Login

                stacksize, Configurando Classes de Login

   links simbolicos, Instalando Bibliotecas Adicionais Manualmente

   Linux, Sistema de Informac,ao de Rede (NIS)

                ELF binaries, Instalando os binarios Linux(R) ELF

   Linux binary compatibility, Sinopse

   livefs CD, Recuperac,ao de Emergencia

   loadbalance, Agregac,ao de links e failover

   loader, Estagio tres

   loader configuration, Estagio tres

   locale, Usando Localizac,ao, Definindo a Localidade para o Login Shell

   localization, Sinopse

                German, Recursos Especificos de Idioma Adicionais

                Greek, Recursos Especificos de Idioma Adicionais

                Japanese, Recursos Especificos de Idioma Adicionais

                Korean, Recursos Especificos de Idioma Adicionais

                Russian, Idioma Russo (Codificac,ao KOI8-R)

                Traditional Chinese, Recursos Especificos de Idioma
                Adicionais

   log files

                FTP, Configurac,ao

   log management, Gerenciamento de log e rotac,ao

   log rotation, Gerenciamento de log e rotac,ao

   login class, Definindo a Localidade para o Login Shell, Utilitarios que
   Alteram as Classes de Login

   ls1, Permissoes

  M

   MAC, Sinopse

                File System Firewall Policy, A Politica Estendida do BSD MAC

   MAC Biba Integrity Policy, O Modulo MAC Biba

   MAC Configuration Testing, Testando a Configurac,ao

   MAC Interface Silencing Policy, A politica de silenciamento da interface
   MAC

   MAC LOMAC, O modulo MAC de marca d'agua baixa

   MAC Multi-Level Security Policy, O modulo de seguranc,a multinivel MAC

   MAC Port Access Control List Policy, A politica de lista de controle de
   acesso da porta MAC

   MAC Process Partition Policy, A Politica de Partic,ao MAC

   MAC See Other UIDs Policy, O MAC ve a Politica de Outros UIDs

   MAC Troubleshooting, Soluc,ao de problemas do framework MAC

   MacOS, Gerando uma Senha de Uso Unico

   mail host, Componentes de Email

   mail server daemons

                Exim, Componentes de Email

                Postfix, Componentes de Email

                qmail, Componentes de Email

                Sendmail, Componentes de Email

   Mail User Agents, Mail User Agents

   Mandatory Access Control (ver MAC)

   manual pages, Paginas de Manual

   Master Boot Record (MBR), Processo de Inicializac,ao do FreeBSD, O
   gerenciador de inicializac,ao

   McAfee, Quem Usa o FreeBSD?

   mencoder, MPlayer e MEncoder

   mfsBSD, Quem Usa o FreeBSD?

   mgetty, Configurando servic,os de discagem

   Microsoft Windows, Servic,os de arquivos e impressao para clientes
   Microsoft(R) Windows(R) Clients (Samba)

   Microsoft Windows

                device drivers, Utilizando os Drivers Windows(R) NDIS

   MidnightBSD, Quem Usa o FreeBSD?

   MIME, Definindo a Localidade para o Login Shell

   modem, Servic,o Dial-in

   mod_perl

                Perl, mod_perl

   mod_php

                PHP, mod_php

   mountd, Network File System (NFS)

   moused, Configurac,ao do Console

   MPlayer, MPlayer e MEncoder

   MS-DOS, Gerando uma Senha de Uso Unico

   multi-user mode, Modo Multi-User

   multicast routing, Considerac,oes sobre Multicast

   MX record, Componentes de Email, Soluc,ao de problemas, Configurac,ao
   basica

  N

   Nagios in a MAC Jail, Nagios em Jail MAC

   NAS4Free, Quem Usa o FreeBSD?

   NAT, O que o FreeBSD Pode Fazer?, Configurando o NAT

                and IPFW, NAT no Kernel

   NDIS, Utilizando os Drivers Windows(R) NDIS

   NDISulator, Utilizando os Drivers Windows(R) NDIS

   net.inet.ip.portrange.*, net.inet.ip.portrange.*

   Net/2, Uma Breve Historia do FreeBSD

   NetApp, Quem Usa o FreeBSD?

   NetBIOS, Configurac,ao Avanc,ada

   NetBSD, Sistema de Informac,ao de Rede (NIS)

   Netflix, Quem Usa o FreeBSD?

   netgroups, Usando Netgroups

   network address translation (ver NAT)

   network cards

                testing, Testando uma placa Ethernet

                troubleshooting, Soluc,ao de problemas

   newsyslog, Gerenciamento de log e rotac,ao

   newsyslog.conf, Gerenciamento de log e rotac,ao

   NFS, Quotas sobre o NFS, Network File System (NFS)

                configuration, Configurando o Servidor

                export examples, Configurando o Servidor

                installing multiple machines, Atualizac,ao de varias maquinas

                mounting, Configurando o Cliente

                server, Network File System (NFS)

   nfsd, Network File System (NFS)

   NIS, Sistema de Informac,ao de Rede (NIS)

                client, Tipos de Maquinas

                client configuration, Configurando um cliente NIS

                domain name, Escolhendo um Nome de Dominio NIS

                domains, Sistema de Informac,ao de Rede (NIS)

                maps, Inicializando os mapas do NIS

                master server, Tipos de Maquinas

                password formats, Formatos de Senha

                server configuration, Configurando o Servidor NIS Master

                slave server, Tipos de Maquinas, Configurando um Servidor NIS
                Slave

   NIS+, Configurac,oes de Seguranc,a

   NOTES, O Arquivo de Configurac,ao

   Novell, Uma Breve Historia do FreeBSD

   NTP, Configurac,ao de NTP

                ntp.conf, O arquivo /etc/ntp.conf

                ntpd, Sincronizac,ao de Relogio com NTP

                rc.conf, Entradas NTP no /etc/rc.conf

   null-modem cable, Cabos Serial e Portas, Configurac,ao do console serial
   em profundidade

  O

   OBEX, OBEX Object Push (OPUSH)

   office suite

                Apache OpenOffice , Apache OpenOffice

                Calligra, Calligra

                LibreOffice, LibreOffice

   Okular, Okular

   one-time passwords, Senhas de Uso Unico

   OpenBSD, Sistema de Informac,ao de Rede (NIS)

   OpenSSH, OpenSSH

                client, Usando os Utilitarios de Cliente SSH

                enabling, Ativando o Servidor SSH

                secure copy, Usando os Utilitarios de Cliente SSH

                tunneling, Tunelamento SSH

   OpenSSL

                certificate generation, Gerando Certificados

   OPNsense, Quem Usa o FreeBSD?

   OSPF, Configurando um roteador com rotas estaticas

  P

   packages, Sinopse

   PAP, Autenticac,ao PAP e CHAP

   partition layout, Criando o layout da partic,ao

   partitions, Organizac,ao dos Discos, Adicionando Discos, Redimensionando e
   Ampliando Discos

   passwd, passwd

   password, Autenticac,ao PAP e CHAP

   pax, Backups de Diretorio

   PCI, Configurando a Placa de Som

   PDF

                viewing, Xpdf, gv, ePDFView, Okular

   permissions, Permissoes

                symbolic, Permissoes simbolicas

   pfSense, Quem Usa o FreeBSD?

   pgp keys, Chaves OpenPGP

   pkg, Monitorando Problemas de Seguranc,a de Terceiros

                search, Encontrando Software

   placas de rede

                configurac,ao, Configurando Placas de Interface de Rede,
                Localizando o Driver Correto, Configurando a placa de rede

   POP, Componentes de Email

   portmap, Termos do NIS e Processos

   portmaster, Atualizando Ports Usando o Portmaster

   ports, Sinopse

                disk-space, Ports e o Espac,o em Disco

                installing, Instalando Ports

                removing, Removendo Ports Instalados

                upgrading, Atualizando os Ports

                upgrading-tools, Ferramentas para atualizar e gerenciar ports

   Ports Collection, Configurando a compatibilidade binaria com o Linux(R)

   portupgrade, Atualizando Ports Usando o Portupgrade

   POSIX, Backups de Diretorio, Definindo a Localidade para o Login Shell

   PostScript

                viewing, gv

   PPP, Sinopse

                configuration, Configurac,ao final do sistema

                Microsoft extensions, Configurac,ao Avanc,ada

                NAT, Usando a funcionalidade de conversao de enderec,os de
                rede (NAT) do PPP

                over ATM, Usando PPP sobre ATM (PPPoA)

                over Ethernet, Sinopse, Usando o PPP sobre Ethernet (PPPoE)

                troubleshooting, Soluc,ao de problemas de conexoes PPP

                with static IP addresses, Configurac,ao basica

   PPPoA, Usando PPP sobre ATM (PPPoA)

   print server

                Windows clients, Servic,os de arquivos e impressao para
                clientes Microsoft(R) Windows(R) Clients (Samba)

   printers, Idioma Russo (Codificac,ao KOI8-R)

   Process Accounting, Auditoria de Processo

   procmail, Usando o procmail

   pw, pw, Utilitarios que Alteram as Classes de Login

   Python, Django

  Q

   Quest KACE, Quem Usa o FreeBSD?

   quotas, Limites de Recursos

  R

   RAID1, RAID1 - Espelhamento

   RAID3, RAID3 - Distribuic,ao em Nivel de Byte com Paridade Dedicada

   rc files, Modo Multi-User

                rc.conf, Gerenciando a configurac,ao especifica do sistema

                rc.serial, Configurac,ao de Porta Serial, Configurac,ao de
                Modem

   resolv.conf, /etc/resolv.conf

   resolver, Sistema de Nomes de Dominio (DNS)

   Resource limits, Limites de Recursos

   restore, Backups do Sistema de Arquivos

   reverse DNS, Sistema de Nomes de Dominio (DNS)

   RIP, Configurando um roteador com rotas estaticas

   rmuser, rmuser

   root file system, Montando e Desmontando Sistemas de Arquivos

   root zone, Sistema de Nomes de Dominio (DNS)

   roundrobin, Agregac,ao de links e failover

   routed, Configurac,ao final do sistema

   router, O que o FreeBSD Pode Fazer?, Configurando um roteador com rotas
   estaticas

   routing, Gateways e Rotas

   rpcbind, Network File System (NFS), Termos do NIS e Processos

   Ruby on Rails, Ruby on Rails

  S

   Samba server, Servic,os de arquivos e impressao para clientes Microsoft(R)
   Windows(R) Clients (Samba)

   Sandvine, Quem Usa o FreeBSD?

   scp1, Usando os Utilitarios de Cliente SSH

   screenmap, Configurac,ao do Console

   SDL, Determinando os Recursos de Video

   SDP, Protocolo de Descoberta de Servic,os (SDP)

   security

                firewalls, Firewalls

                one-time passwords, Senhas de Uso Unico

                OpenSSH, OpenSSH

                OpenSSL, OpenSSL

   Security

                Sudo, Administrac,ao Compartilhada com Sudo

   Security Event Auditing (ver MAC)

   Seguranc,a, Seguranc,a

   sendmail, Configurac,ao final do sistema

   Sendmail, Arquivos de Configurac,ao do Sendmail

   serial communications, Sinopse

   services, Inicializac,ao de Servic,os

   shells, Shells

   shutdown8, Sequencia de Desligamento

   single-user mode, Estagio tres, Modo Single-User

   skeleton directory, adduser

   slices, Organizac,ao dos Discos

   SMTP, Configurac,ao final do sistema, Configurac,ao basica

   soft limit, Definindo Limites de Cota

   Soft Updates, Soft Updates

                details, Mais detalhes sobre soft updates

   Software RAID Devices

                Hardware-assisted RAID, Dispositivos RAID por Software

   Solaris, Topicos Avanc,ados, Sistema de Informac,ao de Rede (NIS)

   Sony, Quem Usa o FreeBSD?

   Sophos, Quem Usa o FreeBSD?

   sound cards, Configurando a Placa de Som

   SourceForge, Encontrando Software

   Spectra Logic, Quem Usa o FreeBSD?

   spreadsheet

                Gnumeric, Gnumeric

                KMyMoney, KMyMoney

   SQL database, Configurac,oes de Seguranc,a

   SSL, mod_ssl

   static IP address, Configurando o PPP

   Stormshield, Quem Usa o FreeBSD?

   Striping, RAID0 - Striping

   subnet, Gateways e Rotas

   Subversion, O Modelo de Desenvolvimento do FreeBSD, Usando o
   FreeBSD-STABLE, Usando o Subversion

   Subversion Repository, O Modelo de Desenvolvimento do FreeBSD

                Mirror Sites, Sites Espelho do Subversion

   SVN (ver Subversion)

   swap

                encrypting, Criptografando Swap

   swap partition, Criando o layout da partic,ao

   swap sizing, Criando o layout da partic,ao

   sysctl, Efetuando ajustes com o sysctl(8), sysctl.conf

   sysctl.conf, sysctl.conf

   syslog, Configurando o log do sistema, Configurac,ao

   syslog.conf, Configurando os logs locais

   syslogd8, Configurando o log do sistema

   system configuration, Sinopse

   system logging, Configurando o log do sistema

   system optimization, Sinopse

  T

   tape media, Usando Fitas de Dados para Backups

   tar, Backups de Diretorio

   TCP Bandwidth Delay Product Limiting

                net.inet.tcp.inflight.enable, Produto de atraso de largura de
                banda TCP

   TCP Wrapper, TCP Wrapper, Seguranc,a NIS

   TCP/IP networking, Bem vindo ao FreeBSD!

   terminals, Consoles e Terminais Virtuais, Terminais

   tether, USB Tethering

   text editors, Editores de Texto

   The GIMP, O GIMP

   The Weather Channel, Quem Usa o FreeBSD?

   traceroute8, Soluc,ao de problemas

   Traditional Chinese

                BIG-5 encoding, Metodo de Classes de Login

   TrueOS, Quem Usa o FreeBSD?

   TrueType Fonts, Fontes TrueType(R)

   ttyu, Configurac,ao de Porta Serial

   tunefs8, Soft Updates

   tuning

                kernel limits, Ajustando os Limites do Kernel

                with sysctl, Efetuando ajustes com o sysctl(8)

   TV cards, Placas de TV

  U

   U.C. Berkeley, Uma Breve Historia do FreeBSD

   UDP, Configurando um cliente DHCP

   UNIX, Permissoes

   Updating and Upgrading, Atualizac,ao do FreeBSD, Atualizando o Conjunto de
   Documentac,ao, Atualizando a documentac,ao a partir do ports

   USB

                disks, Dispositivos de Armazenamento USB

   usuarios

                grandes sites que executam o FreeBSD, Quem Usa o FreeBSD?

  V

   Verisign, Quem Usa o FreeBSD?

   vfs.hirunningspace, vfs.hirunningspace

   vfs.vmiodirenable, vfs.vmiodirenable

   vfs.write_behind, vfs.write_behind

   vi, Editores de Texto

   video packages, Ports e Pacotes Lidando com Video

   video ports, Ports e Pacotes Lidando com Video

   vipw, Utilitarios que Alteram as Classes de Login

   virtual consoles, Consoles e Terminais Virtuais

   virtual hosts, Hosts Virtuais

   Virtual LANs, VLANs

   virtual private network (ver VPN)

   VLANs, VLANs

   vm.swap_idle_enabled, vm.swap_idle_enabled

   Voxer, Quem Usa o FreeBSD?

   VPN, VPN Sobre IPsec

  W

   Walnut Creek CDROM, Uma Breve Historia do FreeBSD

   web servers

                dynamic, Websites Dinamicos

                secure, mod_ssl

                setting up, Servidor HTTP Apache

   widescreen flatpanel configuration, Adicionando um Flatpanel Widescreen ao
   Mix

   Williams, Nate, Uma Breve Historia do FreeBSD

   Windows, Gerando uma Senha de Uso Unico

   Windows drivers, Utilizando os Drivers Windows(R) NDIS

   wireless networking, Rede sem fio

  X

   X Display Manager, O Gerenciador de Display X

   X Input Method (XIM), Configurac,ao do Xorg

   X Window System, O que o FreeBSD Pode Fazer?

   XML, Fontes com Anti-Alias

   Xorg, Configurac,ao do Xorg

   Xorg tuning, Soluc,ao de problemas

   xorg.conf, Soluc,ao de problemas

   Xpdf, Xpdf

   XVideo, Determinando os Recursos de Video

  Y

   yellow pages (ver NIS)

  Z

   zones

                examples, Sistema de Nomes de Dominio (DNS)

   ZRouter, Quem Usa o FreeBSD?

                             Considerac,oes finais

   Este livro e o trabalho combinado de centenas de colaboradores para o
   "Projeto de Documentac,ao do FreeBSD". O texto e criado em XML de acordo
   com o DocBook DTD e e formatado a partir do XML para muitos formatos de
   apresentac,ao diferentes usando o XSLT. A versao impressa deste documento
   nao seria possivel sem a linguagem tipografica TeX de Donald Knuth, o
   LaTeX de Leslie Lamport, ou o pacote de macro JadeTeX de Sebastian Rahtz.
